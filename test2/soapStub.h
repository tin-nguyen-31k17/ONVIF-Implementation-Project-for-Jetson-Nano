/* soapStub.h
   Generated by gSOAP 2.8.127 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2023, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_WSA_2005
#define SOAP_NAMESPACE_OF_wsa5	"http://www.w3.org/2005/08/addressing"
#define SOAP_NAMESPACE_OF_tds	"http://www.onvif.org/ver10/device/wsdl"
#define SOAP_NAMESPACE_OF_tt	"http://www.onvif.org/ver10/schema"
#define SOAP_NAMESPACE_OF_wsnt	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_wsrfbf	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_wstop	"http://docs.oasis-open.org/wsn/t-1"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 208127
# error "GSOAP VERSION 208127 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* wsa5.h:96 */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (19)
/* wsa5:RelationshipType */
enum wsa5__RelationshipType {
	http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0
};
#endif

/* wsa5.h:104 */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (20)
/* wsa5:FaultCodesType */
enum wsa5__FaultCodesType {
	wsa5__InvalidAddressingHeader = 0,
	wsa5__InvalidAddress = 1,
	wsa5__InvalidEPR = 2,
	wsa5__InvalidCardinality = 3,
	wsa5__MissingAddressInEPR = 4,
	wsa5__DuplicateMessageID = 5,
	wsa5__ActionMismatch = 6,
	wsa5__MessageAddressingHeaderRequired = 7,
	wsa5__DestinationUnreachable = 8,
	wsa5__ActionNotSupported = 9,
	wsa5__EndpointUnavailable = 10
};
#endif

/* wsa5.h:254 */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (40)
/* wsa5:IsReferenceParameter */
enum _wsa5__IsReferenceParameter {
	_wsa5__IsReferenceParameter__false = 0,
	_wsa5__IsReferenceParameter__true = 1
};
#endif

/* onvif.h:1898 */
#ifndef SOAP_TYPE_tds__AutoGeoModes
#define SOAP_TYPE_tds__AutoGeoModes (829)
/* tds:AutoGeoModes */
enum tds__AutoGeoModes {
	tds__AutoGeoModes__Location = 0,
	tds__AutoGeoModes__Heading = 1,
	tds__AutoGeoModes__Leveling = 2
};
#endif

/* onvif.h:1928 */
#ifndef SOAP_TYPE_tds__StorageType
#define SOAP_TYPE_tds__StorageType (831)
/* tds:StorageType */
enum tds__StorageType {
	tds__StorageType__NFS = 0,
	tds__StorageType__CIFS = 1,
	tds__StorageType__CDMI = 2,
	tds__StorageType__FTP = 3
};
#endif

/* onvif.h:1988 */
#ifndef SOAP_TYPE_tt__RotateMode
#define SOAP_TYPE_tt__RotateMode (835)
/* tt:RotateMode */
enum tt__RotateMode {
	tt__RotateMode__OFF = 0,
	tt__RotateMode__ON = 1,
	tt__RotateMode__AUTO = 2
};
#endif

/* onvif.h:2018 */
#ifndef SOAP_TYPE_tt__SceneOrientationMode
#define SOAP_TYPE_tt__SceneOrientationMode (837)
/* tt:SceneOrientationMode */
enum tt__SceneOrientationMode {
	tt__SceneOrientationMode__MANUAL = 0,
	tt__SceneOrientationMode__AUTO = 1
};
#endif

/* onvif.h:2039 */
#ifndef SOAP_TYPE_tt__SceneOrientationOption
#define SOAP_TYPE_tt__SceneOrientationOption (839)
/* tt:SceneOrientationOption */
enum tt__SceneOrientationOption {
	tt__SceneOrientationOption__Below = 0,
	tt__SceneOrientationOption__Horizon = 1,
	tt__SceneOrientationOption__Above = 2
};
#endif

/* onvif.h:2061 */
#ifndef SOAP_TYPE_tt__ViewModes
#define SOAP_TYPE_tt__ViewModes (841)
/* tt:ViewModes */
enum tt__ViewModes {
	tt__ViewModes__tt_x003aFisheye = 0,
	tt__ViewModes__tt_x003a360Panorama = 1,
	tt__ViewModes__tt_x003a180Panorama = 2,
	tt__ViewModes__tt_x003aQuad = 3,
	tt__ViewModes__tt_x003aOriginal = 4,
	tt__ViewModes__tt_x003aLeftHalf = 5,
	tt__ViewModes__tt_x003aRightHalf = 6,
	tt__ViewModes__tt_x003aDewarp = 7
};
#endif

/* onvif.h:2116 */
#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (843)
/* tt:VideoEncoding */
enum tt__VideoEncoding {
	tt__VideoEncoding__JPEG = 0,
	tt__VideoEncoding__MPEG4 = 1,
	tt__VideoEncoding__H264 = 2
};
#endif

/* onvif.h:2134 */
#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (845)
/* tt:Mpeg4Profile */
enum tt__Mpeg4Profile {
	tt__Mpeg4Profile__SP = 0,
	tt__Mpeg4Profile__ASP = 1
};
#endif

/* onvif.h:2151 */
#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (847)
/* tt:H264Profile */
enum tt__H264Profile {
	tt__H264Profile__Baseline = 0,
	tt__H264Profile__Main = 1,
	tt__H264Profile__Extended = 2,
	tt__H264Profile__High = 3
};
#endif

/* onvif.h:2174 */
#ifndef SOAP_TYPE_tt__VideoEncodingMimeNames
#define SOAP_TYPE_tt__VideoEncodingMimeNames (849)
/* tt:VideoEncodingMimeNames */
enum tt__VideoEncodingMimeNames {
	tt__VideoEncodingMimeNames__JPEG = 0,
	tt__VideoEncodingMimeNames__MPV4_ES = 1,
	tt__VideoEncodingMimeNames__H264 = 2,
	tt__VideoEncodingMimeNames__H265 = 3
};
#endif

/* onvif.h:2193 */
#ifndef SOAP_TYPE_tt__VideoEncodingProfiles
#define SOAP_TYPE_tt__VideoEncodingProfiles (851)
/* tt:VideoEncodingProfiles */
enum tt__VideoEncodingProfiles {
	tt__VideoEncodingProfiles__Simple = 0,
	tt__VideoEncodingProfiles__AdvancedSimple = 1,
	tt__VideoEncodingProfiles__Baseline = 2,
	tt__VideoEncodingProfiles__Main = 3,
	tt__VideoEncodingProfiles__Main10 = 4,
	tt__VideoEncodingProfiles__Extended = 5,
	tt__VideoEncodingProfiles__High = 6
};
#endif

/* onvif.h:2215 */
#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (853)
/* tt:AudioEncoding */
enum tt__AudioEncoding {
	tt__AudioEncoding__G711 = 0,
	tt__AudioEncoding__G726 = 1,
	tt__AudioEncoding__AAC = 2
};
#endif

/* onvif.h:2237 */
#ifndef SOAP_TYPE_tt__AudioEncodingMimeNames
#define SOAP_TYPE_tt__AudioEncodingMimeNames (855)
/* tt:AudioEncodingMimeNames */
enum tt__AudioEncodingMimeNames {
	tt__AudioEncodingMimeNames__PCMU = 0,
	tt__AudioEncodingMimeNames__G726 = 1,
	tt__AudioEncodingMimeNames__MP4A_LATM = 2,
	tt__AudioEncodingMimeNames__mpeg4_generic = 3
};
#endif

/* onvif.h:2260 */
#ifndef SOAP_TYPE_tt__MetadataCompressionType
#define SOAP_TYPE_tt__MetadataCompressionType (857)
/* tt:MetadataCompressionType */
enum tt__MetadataCompressionType {
	tt__MetadataCompressionType__None = 0,
	tt__MetadataCompressionType__GZIP = 1,
	tt__MetadataCompressionType__EXI = 2
};
#endif

/* onvif.h:2278 */
#ifndef SOAP_TYPE_tt__StreamType
#define SOAP_TYPE_tt__StreamType (859)
/* tt:StreamType */
enum tt__StreamType {
	tt__StreamType__RTP_Unicast = 0,
	tt__StreamType__RTP_Multicast = 1
};
#endif

/* onvif.h:2295 */
#ifndef SOAP_TYPE_tt__TransportProtocol
#define SOAP_TYPE_tt__TransportProtocol (861)
/* tt:TransportProtocol */
enum tt__TransportProtocol {
	tt__TransportProtocol__UDP = 0,
	tt__TransportProtocol__TCP = 1,
	tt__TransportProtocol__RTSP = 2,
	tt__TransportProtocol__HTTP = 3
};
#endif

/* onvif.h:2318 */
#ifndef SOAP_TYPE_tt__ScopeDefinition
#define SOAP_TYPE_tt__ScopeDefinition (863)
/* tt:ScopeDefinition */
enum tt__ScopeDefinition {
	tt__ScopeDefinition__Fixed = 0,
	tt__ScopeDefinition__Configurable = 1
};
#endif

/* onvif.h:2335 */
#ifndef SOAP_TYPE_tt__DiscoveryMode
#define SOAP_TYPE_tt__DiscoveryMode (865)
/* tt:DiscoveryMode */
enum tt__DiscoveryMode {
	tt__DiscoveryMode__Discoverable = 0,
	tt__DiscoveryMode__NonDiscoverable = 1
};
#endif

/* onvif.h:2365 */
#ifndef SOAP_TYPE_tt__Duplex
#define SOAP_TYPE_tt__Duplex (869)
/* tt:Duplex */
enum tt__Duplex {
	tt__Duplex__Full = 0,
	tt__Duplex__Half = 1
};
#endif

/* onvif.h:2398 */
#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration
#define SOAP_TYPE_tt__IPv6DHCPConfiguration (873)
/* tt:IPv6DHCPConfiguration */
enum tt__IPv6DHCPConfiguration {
	tt__IPv6DHCPConfiguration__Auto = 0,
	tt__IPv6DHCPConfiguration__Stateful = 1,
	tt__IPv6DHCPConfiguration__Stateless = 2,
	tt__IPv6DHCPConfiguration__Off = 3
};
#endif

/* onvif.h:2417 */
#ifndef SOAP_TYPE_tt__NetworkProtocolType
#define SOAP_TYPE_tt__NetworkProtocolType (875)
/* tt:NetworkProtocolType */
enum tt__NetworkProtocolType {
	tt__NetworkProtocolType__HTTP = 0,
	tt__NetworkProtocolType__HTTPS = 1,
	tt__NetworkProtocolType__RTSP = 2
};
#endif

/* onvif.h:2435 */
#ifndef SOAP_TYPE_tt__NetworkHostType
#define SOAP_TYPE_tt__NetworkHostType (877)
/* tt:NetworkHostType */
enum tt__NetworkHostType {
	tt__NetworkHostType__IPv4 = 0,
	tt__NetworkHostType__IPv6 = 1,
	tt__NetworkHostType__DNS = 2
};
#endif

/* onvif.h:2489 */
#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (885)
/* tt:IPType */
enum tt__IPType {
	tt__IPType__IPv4 = 0,
	tt__IPType__IPv6 = 1
};
#endif

/* onvif.h:2530 */
#ifndef SOAP_TYPE_tt__IPAddressFilterType
#define SOAP_TYPE_tt__IPAddressFilterType (891)
/* tt:IPAddressFilterType */
enum tt__IPAddressFilterType {
	tt__IPAddressFilterType__Allow = 0,
	tt__IPAddressFilterType__Deny = 1
};
#endif

/* onvif.h:2547 */
#ifndef SOAP_TYPE_tt__DynamicDNSType
#define SOAP_TYPE_tt__DynamicDNSType (893)
/* tt:DynamicDNSType */
enum tt__DynamicDNSType {
	tt__DynamicDNSType__NoUpdate = 0,
	tt__DynamicDNSType__ClientUpdates = 1,
	tt__DynamicDNSType__ServerUpdates = 2
};
#endif

/* onvif.h:2578 */
#ifndef SOAP_TYPE_tt__Dot11StationMode
#define SOAP_TYPE_tt__Dot11StationMode (897)
/* tt:Dot11StationMode */
enum tt__Dot11StationMode {
	tt__Dot11StationMode__Ad_hoc = 0,
	tt__Dot11StationMode__Infrastructure = 1,
	tt__Dot11StationMode__Extended = 2
};
#endif

/* onvif.h:2596 */
#ifndef SOAP_TYPE_tt__Dot11SecurityMode
#define SOAP_TYPE_tt__Dot11SecurityMode (899)
/* tt:Dot11SecurityMode */
enum tt__Dot11SecurityMode {
	tt__Dot11SecurityMode__None = 0,
	tt__Dot11SecurityMode__WEP = 1,
	tt__Dot11SecurityMode__PSK = 2,
	tt__Dot11SecurityMode__Dot1X = 3,
	tt__Dot11SecurityMode__Extended = 4
};
#endif

/* onvif.h:2616 */
#ifndef SOAP_TYPE_tt__Dot11Cipher
#define SOAP_TYPE_tt__Dot11Cipher (901)
/* tt:Dot11Cipher */
enum tt__Dot11Cipher {
	tt__Dot11Cipher__CCMP = 0,
	tt__Dot11Cipher__TKIP = 1,
	tt__Dot11Cipher__Any = 2,
	tt__Dot11Cipher__Extended = 3
};
#endif

/* onvif.h:2661 */
#ifndef SOAP_TYPE_tt__Dot11SignalStrength
#define SOAP_TYPE_tt__Dot11SignalStrength (907)
/* tt:Dot11SignalStrength */
enum tt__Dot11SignalStrength {
	tt__Dot11SignalStrength__None = 0,
	tt__Dot11SignalStrength__Very_x0020Bad = 1,
	tt__Dot11SignalStrength__Bad = 2,
	tt__Dot11SignalStrength__Good = 3,
	tt__Dot11SignalStrength__Very_x0020Good = 4,
	tt__Dot11SignalStrength__Extended = 5
};
#endif

/* onvif.h:2682 */
#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite (909)
/* tt:Dot11AuthAndMangementSuite */
enum tt__Dot11AuthAndMangementSuite {
	tt__Dot11AuthAndMangementSuite__None = 0,
	tt__Dot11AuthAndMangementSuite__Dot1X = 1,
	tt__Dot11AuthAndMangementSuite__PSK = 2,
	tt__Dot11AuthAndMangementSuite__Extended = 3
};
#endif

/* onvif.h:2701 */
#ifndef SOAP_TYPE_tt__CapabilityCategory
#define SOAP_TYPE_tt__CapabilityCategory (911)
/* tt:CapabilityCategory */
enum tt__CapabilityCategory {
	tt__CapabilityCategory__All = 0,
	tt__CapabilityCategory__Analytics = 1,
	tt__CapabilityCategory__Device = 2,
	tt__CapabilityCategory__Events = 3,
	tt__CapabilityCategory__Imaging = 4,
	tt__CapabilityCategory__Media = 5,
	tt__CapabilityCategory__PTZ = 6
};
#endif

/* onvif.h:2727 */
#ifndef SOAP_TYPE_tt__SystemLogType
#define SOAP_TYPE_tt__SystemLogType (913)
/* tt:SystemLogType */
enum tt__SystemLogType {
	tt__SystemLogType__System = 0,
	tt__SystemLogType__Access = 1
};
#endif

/* onvif.h:2756 */
#ifndef SOAP_TYPE_tt__FactoryDefaultType
#define SOAP_TYPE_tt__FactoryDefaultType (915)
/* tt:FactoryDefaultType */
enum tt__FactoryDefaultType {
	tt__FactoryDefaultType__Hard = 0,
	tt__FactoryDefaultType__Soft = 1
};
#endif

/* onvif.h:2781 */
#ifndef SOAP_TYPE_tt__SetDateTimeType
#define SOAP_TYPE_tt__SetDateTimeType (917)
/* tt:SetDateTimeType */
enum tt__SetDateTimeType {
	tt__SetDateTimeType__Manual = 0,
	tt__SetDateTimeType__NTP = 1
};
#endif

/* onvif.h:2806 */
#ifndef SOAP_TYPE_tt__UserLevel
#define SOAP_TYPE_tt__UserLevel (919)
/* tt:UserLevel */
enum tt__UserLevel {
	tt__UserLevel__Administrator = 0,
	tt__UserLevel__Operator = 1,
	tt__UserLevel__User = 2,
	tt__UserLevel__Anonymous = 3,
	tt__UserLevel__Extended = 4
};
#endif

/* onvif.h:2826 */
#ifndef SOAP_TYPE_tt__RelayLogicalState
#define SOAP_TYPE_tt__RelayLogicalState (921)
/* tt:RelayLogicalState */
enum tt__RelayLogicalState {
	tt__RelayLogicalState__active = 0,
	tt__RelayLogicalState__inactive = 1
};
#endif

/* onvif.h:2843 */
#ifndef SOAP_TYPE_tt__RelayIdleState
#define SOAP_TYPE_tt__RelayIdleState (923)
/* tt:RelayIdleState */
enum tt__RelayIdleState {
	tt__RelayIdleState__closed = 0,
	tt__RelayIdleState__open = 1
};
#endif

/* onvif.h:2860 */
#ifndef SOAP_TYPE_tt__RelayMode
#define SOAP_TYPE_tt__RelayMode (925)
/* tt:RelayMode */
enum tt__RelayMode {
	tt__RelayMode__Monostable = 0,
	tt__RelayMode__Bistable = 1
};
#endif

/* onvif.h:2877 */
#ifndef SOAP_TYPE_tt__DigitalIdleState
#define SOAP_TYPE_tt__DigitalIdleState (927)
/* tt:DigitalIdleState */
enum tt__DigitalIdleState {
	tt__DigitalIdleState__closed = 0,
	tt__DigitalIdleState__open = 1
};
#endif

/* onvif.h:2894 */
#ifndef SOAP_TYPE_tt__EFlipMode
#define SOAP_TYPE_tt__EFlipMode (929)
/* tt:EFlipMode */
enum tt__EFlipMode {
	tt__EFlipMode__OFF = 0,
	tt__EFlipMode__ON = 1,
	tt__EFlipMode__Extended = 2
};
#endif

/* onvif.h:2912 */
#ifndef SOAP_TYPE_tt__ReverseMode
#define SOAP_TYPE_tt__ReverseMode (931)
/* tt:ReverseMode */
enum tt__ReverseMode {
	tt__ReverseMode__OFF = 0,
	tt__ReverseMode__ON = 1,
	tt__ReverseMode__AUTO = 2,
	tt__ReverseMode__Extended = 3
};
#endif

/* onvif.h:2944 */
#ifndef SOAP_TYPE_tt__PTZPresetTourState
#define SOAP_TYPE_tt__PTZPresetTourState (935)
/* tt:PTZPresetTourState */
enum tt__PTZPresetTourState {
	tt__PTZPresetTourState__Idle = 0,
	tt__PTZPresetTourState__Touring = 1,
	tt__PTZPresetTourState__Paused = 2,
	tt__PTZPresetTourState__Extended = 3
};
#endif

/* onvif.h:2963 */
#ifndef SOAP_TYPE_tt__PTZPresetTourDirection
#define SOAP_TYPE_tt__PTZPresetTourDirection (937)
/* tt:PTZPresetTourDirection */
enum tt__PTZPresetTourDirection {
	tt__PTZPresetTourDirection__Forward = 0,
	tt__PTZPresetTourDirection__Backward = 1,
	tt__PTZPresetTourDirection__Extended = 2
};
#endif

/* onvif.h:2981 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOperation
#define SOAP_TYPE_tt__PTZPresetTourOperation (939)
/* tt:PTZPresetTourOperation */
enum tt__PTZPresetTourOperation {
	tt__PTZPresetTourOperation__Start = 0,
	tt__PTZPresetTourOperation__Stop = 1,
	tt__PTZPresetTourOperation__Pause = 2,
	tt__PTZPresetTourOperation__Extended = 3
};
#endif

/* onvif.h:3000 */
#ifndef SOAP_TYPE_tt__MoveAndTrackMethod
#define SOAP_TYPE_tt__MoveAndTrackMethod (941)
/* tt:MoveAndTrackMethod */
enum tt__MoveAndTrackMethod {
	tt__MoveAndTrackMethod__PresetToken = 0,
	tt__MoveAndTrackMethod__GeoLocation = 1,
	tt__MoveAndTrackMethod__PTZVector = 2,
	tt__MoveAndTrackMethod__ObjectID = 3
};
#endif

/* onvif.h:3019 */
#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (943)
/* tt:AutoFocusMode */
enum tt__AutoFocusMode {
	tt__AutoFocusMode__AUTO = 0,
	tt__AutoFocusMode__MANUAL = 1
};
#endif

/* onvif.h:3036 */
#ifndef SOAP_TYPE_tt__AFModes
#define SOAP_TYPE_tt__AFModes (945)
/* tt:AFModes */
enum tt__AFModes {
	tt__AFModes__OnceAfterMove = 0
};
#endif

/* onvif.h:3056 */
#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (947)
/* tt:WideDynamicMode */
enum tt__WideDynamicMode {
	tt__WideDynamicMode__OFF = 0,
	tt__WideDynamicMode__ON = 1
};
#endif

/* onvif.h:3077 */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (949)
/* tt:BacklightCompensationMode */
enum tt__BacklightCompensationMode {
	tt__BacklightCompensationMode__OFF = 0,
	tt__BacklightCompensationMode__ON = 1
};
#endif

/* onvif.h:3102 */
#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (951)
/* tt:ExposurePriority */
enum tt__ExposurePriority {
	tt__ExposurePriority__LowNoise = 0,
	tt__ExposurePriority__FrameRate = 1
};
#endif

/* onvif.h:3119 */
#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (953)
/* tt:ExposureMode */
enum tt__ExposureMode {
	tt__ExposureMode__AUTO = 0,
	tt__ExposureMode__MANUAL = 1
};
#endif

/* onvif.h:3136 */
#ifndef SOAP_TYPE_tt__Enabled
#define SOAP_TYPE_tt__Enabled (955)
/* tt:Enabled */
enum tt__Enabled {
	tt__Enabled__ENABLED = 0,
	tt__Enabled__DISABLED = 1
};
#endif

/* onvif.h:3153 */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (957)
/* tt:WhiteBalanceMode */
enum tt__WhiteBalanceMode {
	tt__WhiteBalanceMode__AUTO = 0,
	tt__WhiteBalanceMode__MANUAL = 1
};
#endif

/* onvif.h:3170 */
#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (959)
/* tt:IrCutFilterMode */
enum tt__IrCutFilterMode {
	tt__IrCutFilterMode__ON = 0,
	tt__IrCutFilterMode__OFF = 1,
	tt__IrCutFilterMode__AUTO = 2
};
#endif

/* onvif.h:3188 */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode
#define SOAP_TYPE_tt__ImageStabilizationMode (961)
/* tt:ImageStabilizationMode */
enum tt__ImageStabilizationMode {
	tt__ImageStabilizationMode__OFF = 0,
	tt__ImageStabilizationMode__ON = 1,
	tt__ImageStabilizationMode__AUTO = 2,
	tt__ImageStabilizationMode__Extended = 3
};
#endif

/* onvif.h:3207 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoBoundaryType
#define SOAP_TYPE_tt__IrCutFilterAutoBoundaryType (963)
/* tt:IrCutFilterAutoBoundaryType */
enum tt__IrCutFilterAutoBoundaryType {
	tt__IrCutFilterAutoBoundaryType__Common = 0,
	tt__IrCutFilterAutoBoundaryType__ToOn = 1,
	tt__IrCutFilterAutoBoundaryType__ToOff = 2,
	tt__IrCutFilterAutoBoundaryType__Extended = 3
};
#endif

/* onvif.h:3226 */
#ifndef SOAP_TYPE_tt__ToneCompensationMode
#define SOAP_TYPE_tt__ToneCompensationMode (965)
/* tt:ToneCompensationMode */
enum tt__ToneCompensationMode {
	tt__ToneCompensationMode__OFF = 0,
	tt__ToneCompensationMode__ON = 1,
	tt__ToneCompensationMode__AUTO = 2
};
#endif

/* onvif.h:3244 */
#ifndef SOAP_TYPE_tt__DefoggingMode
#define SOAP_TYPE_tt__DefoggingMode (967)
/* tt:DefoggingMode */
enum tt__DefoggingMode {
	tt__DefoggingMode__OFF = 0,
	tt__DefoggingMode__ON = 1,
	tt__DefoggingMode__AUTO = 2
};
#endif

/* onvif.h:3262 */
#ifndef SOAP_TYPE_tt__ImageSendingType
#define SOAP_TYPE_tt__ImageSendingType (969)
/* tt:ImageSendingType */
enum tt__ImageSendingType {
	tt__ImageSendingType__Embedded = 0,
	tt__ImageSendingType__LocalStorage = 1,
	tt__ImageSendingType__RemoteStorage = 2
};
#endif

/* onvif.h:3280 */
#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (971)
/* tt:PropertyOperation */
enum tt__PropertyOperation {
	tt__PropertyOperation__Initialized = 0,
	tt__PropertyOperation__Deleted = 1,
	tt__PropertyOperation__Changed = 2
};
#endif

/* onvif.h:3298 */
#ifndef SOAP_TYPE_tt__Direction
#define SOAP_TYPE_tt__Direction (973)
/* tt:Direction */
enum tt__Direction {
	tt__Direction__Left = 0,
	tt__Direction__Right = 1,
	tt__Direction__Any = 2
};
#endif

/* onvif.h:3320 */
#ifndef SOAP_TYPE_tt__ReceiverMode
#define SOAP_TYPE_tt__ReceiverMode (975)
/* tt:ReceiverMode */
enum tt__ReceiverMode {
	tt__ReceiverMode__AutoConnect = 0,
	tt__ReceiverMode__AlwaysConnect = 1,
	tt__ReceiverMode__NeverConnect = 2,
	tt__ReceiverMode__Unknown = 3
};
#endif

/* onvif.h:3359 */
#ifndef SOAP_TYPE_tt__ReceiverState
#define SOAP_TYPE_tt__ReceiverState (977)
/* tt:ReceiverState */
enum tt__ReceiverState {
	tt__ReceiverState__NotConnected = 0,
	tt__ReceiverState__Connecting = 1,
	tt__ReceiverState__Connected = 2,
	tt__ReceiverState__Unknown = 3
};
#endif

/* onvif.h:3418 */
#ifndef SOAP_TYPE_tt__SearchState
#define SOAP_TYPE_tt__SearchState (983)
/* tt:SearchState */
enum tt__SearchState {
	tt__SearchState__Queued = 0,
	tt__SearchState__Searching = 1,
	tt__SearchState__Completed = 2,
	tt__SearchState__Unknown = 3
};
#endif

/* onvif.h:3453 */
#ifndef SOAP_TYPE_tt__RecordingStatus
#define SOAP_TYPE_tt__RecordingStatus (985)
/* tt:RecordingStatus */
enum tt__RecordingStatus {
	tt__RecordingStatus__Initiated = 0,
	tt__RecordingStatus__Recording = 1,
	tt__RecordingStatus__Stopped = 2,
	tt__RecordingStatus__Removing = 3,
	tt__RecordingStatus__Removed = 4,
	tt__RecordingStatus__Unknown = 5
};
#endif

/* onvif.h:3478 */
#ifndef SOAP_TYPE_tt__TrackType
#define SOAP_TYPE_tt__TrackType (987)
/* tt:TrackType */
enum tt__TrackType {
	tt__TrackType__Video = 0,
	tt__TrackType__Audio = 1,
	tt__TrackType__Metadata = 2,
	tt__TrackType__Extended = 3
};
#endif

/* onvif.h:3525 */
#ifndef SOAP_TYPE_tt__ModeOfOperation
#define SOAP_TYPE_tt__ModeOfOperation (993)
/* tt:ModeOfOperation */
enum tt__ModeOfOperation {
	tt__ModeOfOperation__Idle = 0,
	tt__ModeOfOperation__Active = 1,
	tt__ModeOfOperation__Unknown = 2
};
#endif

/* onvif.h:3552 */
#ifndef SOAP_TYPE_tt__AudioClassType
#define SOAP_TYPE_tt__AudioClassType (995)
/* tt:AudioClassType */
enum tt__AudioClassType {
	tt__AudioClassType__gun_USCOREshot = 0,
	tt__AudioClassType__scream = 1,
	tt__AudioClassType__glass_USCOREbreaking = 2,
	tt__AudioClassType__tire_USCOREscreech = 3
};
#endif

/* onvif.h:3571 */
#ifndef SOAP_TYPE_tt__OSDType
#define SOAP_TYPE_tt__OSDType (997)
/* tt:OSDType */
enum tt__OSDType {
	tt__OSDType__Text = 0,
	tt__OSDType__Image = 1,
	tt__OSDType__Extended = 2
};
#endif

/* onvif.h:3609 */
#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (1001)
/* tt:MoveStatus */
enum tt__MoveStatus {
	tt__MoveStatus__IDLE = 0,
	tt__MoveStatus__MOVING = 1,
	tt__MoveStatus__UNKNOWN = 2
};
#endif

/* onvif.h:3627 */
#ifndef SOAP_TYPE_tt__Entity
#define SOAP_TYPE_tt__Entity (1003)
/* tt:Entity */
enum tt__Entity {
	tt__Entity__Device = 0,
	tt__Entity__VideoSource = 1,
	tt__Entity__AudioSource = 2
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/* onvif.h:191 */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (62)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

struct _xop__Include;	/* xop.h:59 */
struct wsa5__EndpointReferenceType;	/* wsa5.h:65 */
struct wsa5__ReferenceParametersType;	/* wsa5.h:68 */
struct wsa5__MetadataType;	/* wsa5.h:71 */
struct wsa5__ProblemActionType;	/* wsa5.h:86 */
struct wsa5__RelatesToType;	/* wsa5.h:74 */
struct chan__ChannelInstanceType;	/* wsa5.h:260 */
class xsd__anyType;	/* onvif.h:181 */
struct SOAP_ENV__Envelope;	/* onvif.h:188 */
class xsd__base64Binary;	/* onvif.h:194 */
class xsd__hexBinary;	/* onvif.h:202 */
class wsa5__EndpointReferenceType__;	/* onvif.h:212 */
class SOAP_ENV__Envelope_;	/* onvif.h:219 */
class SOAP_ENV__Fault_;	/* onvif.h:226 */
class xsd__NCName__;	/* onvif.h:236 */
class xsd__QName__;	/* onvif.h:243 */
class xsd__anySimpleType__;	/* onvif.h:253 */
class xsd__anyURI__;	/* onvif.h:263 */
class xsd__base64Binary__;	/* onvif.h:270 */
class xsd__boolean_;	/* onvif.h:277 */
class xsd__dateTime_;	/* onvif.h:284 */
class xsd__double_;	/* onvif.h:291 */
class xsd__duration__;	/* onvif.h:301 */
class xsd__float_;	/* onvif.h:308 */
class xsd__hexBinary__;	/* onvif.h:315 */
class xsd__int_;	/* onvif.h:322 */
class xsd__integer__;	/* onvif.h:332 */
class xsd__nonNegativeInteger__;	/* onvif.h:342 */
class xsd__string_;	/* onvif.h:349 */
class xsd__token__;	/* onvif.h:359 */
class tds__AutoGeoModes_;	/* onvif.h:1919 */
class tds__StorageType_;	/* onvif.h:1954 */
class tt__Name__;	/* onvif.h:1979 */
class tt__RotateMode_;	/* onvif.h:2009 */
class tt__SceneOrientationMode_;	/* onvif.h:2026 */
class tt__SceneOrientationOption_;	/* onvif.h:2048 */
class tt__ViewModes_;	/* onvif.h:2107 */
class tt__VideoEncoding_;	/* onvif.h:2125 */
class tt__Mpeg4Profile_;	/* onvif.h:2142 */
class tt__H264Profile_;	/* onvif.h:2161 */
class tt__VideoEncodingMimeNames_;	/* onvif.h:2184 */
class tt__VideoEncodingProfiles_;	/* onvif.h:2206 */
class tt__AudioEncoding_;	/* onvif.h:2224 */
class tt__AudioEncodingMimeNames_;	/* onvif.h:2251 */
class tt__MetadataCompressionType_;	/* onvif.h:2269 */
class tt__StreamType_;	/* onvif.h:2286 */
class tt__TransportProtocol_;	/* onvif.h:2309 */
class tt__ScopeDefinition_;	/* onvif.h:2326 */
class tt__DiscoveryMode_;	/* onvif.h:2343 */
class tt__NetworkInterfaceConfigPriority__;	/* onvif.h:2356 */
class tt__Duplex_;	/* onvif.h:2373 */
class tt__IANA_IfTypes__;	/* onvif.h:2389 */
class tt__IPv6DHCPConfiguration_;	/* onvif.h:2408 */
class tt__NetworkProtocolType_;	/* onvif.h:2426 */
class tt__NetworkHostType_;	/* onvif.h:2444 */
class tt__IPv4Address__;	/* onvif.h:2456 */
class tt__IPv6Address__;	/* onvif.h:2468 */
class tt__HwAddress__;	/* onvif.h:2480 */
class tt__IPType_;	/* onvif.h:2497 */
class tt__DNSName__;	/* onvif.h:2509 */
class tt__Domain__;	/* onvif.h:2521 */
class tt__IPAddressFilterType_;	/* onvif.h:2538 */
class tt__DynamicDNSType_;	/* onvif.h:2556 */
class tt__Dot11SSIDType__;	/* onvif.h:2569 */
class tt__Dot11StationMode_;	/* onvif.h:2587 */
class tt__Dot11SecurityMode_;	/* onvif.h:2607 */
class tt__Dot11Cipher_;	/* onvif.h:2626 */
class tt__Dot11PSK__;	/* onvif.h:2639 */
class tt__Dot11PSKPassphrase__;	/* onvif.h:2652 */
class tt__Dot11SignalStrength_;	/* onvif.h:2673 */
class tt__Dot11AuthAndMangementSuite_;	/* onvif.h:2692 */
class tt__CapabilityCategory_;	/* onvif.h:2714 */
class tt__SystemLogType_;	/* onvif.h:2743 */
class tt__FactoryDefaultType_;	/* onvif.h:2772 */
class tt__SetDateTimeType_;	/* onvif.h:2797 */
class tt__UserLevel_;	/* onvif.h:2817 */
class tt__RelayLogicalState_;	/* onvif.h:2834 */
class tt__RelayIdleState_;	/* onvif.h:2851 */
class tt__RelayMode_;	/* onvif.h:2868 */
class tt__DigitalIdleState_;	/* onvif.h:2885 */
class tt__EFlipMode_;	/* onvif.h:2903 */
class tt__ReverseMode_;	/* onvif.h:2922 */
class tt__AuxiliaryData__;	/* onvif.h:2935 */
class tt__PTZPresetTourState_;	/* onvif.h:2954 */
class tt__PTZPresetTourDirection_;	/* onvif.h:2972 */
class tt__PTZPresetTourOperation_;	/* onvif.h:2991 */
class tt__MoveAndTrackMethod_;	/* onvif.h:3010 */
class tt__AutoFocusMode_;	/* onvif.h:3027 */
class tt__AFModes_;	/* onvif.h:3047 */
class tt__WideDynamicMode_;	/* onvif.h:3064 */
class tt__BacklightCompensationMode_;	/* onvif.h:3093 */
class tt__ExposurePriority_;	/* onvif.h:3110 */
class tt__ExposureMode_;	/* onvif.h:3127 */
class tt__Enabled_;	/* onvif.h:3144 */
class tt__WhiteBalanceMode_;	/* onvif.h:3161 */
class tt__IrCutFilterMode_;	/* onvif.h:3179 */
class tt__ImageStabilizationMode_;	/* onvif.h:3198 */
class tt__IrCutFilterAutoBoundaryType_;	/* onvif.h:3217 */
class tt__ToneCompensationMode_;	/* onvif.h:3235 */
class tt__DefoggingMode_;	/* onvif.h:3253 */
class tt__ImageSendingType_;	/* onvif.h:3271 */
class tt__PropertyOperation_;	/* onvif.h:3289 */
class tt__Direction_;	/* onvif.h:3307 */
class tt__ReceiverMode_;	/* onvif.h:3346 */
class tt__ReceiverState_;	/* onvif.h:3385 */
class tt__Description__;	/* onvif.h:3397 */
class tt__XPathExpression__;	/* onvif.h:3409 */
class tt__SearchState_;	/* onvif.h:3444 */
class tt__RecordingStatus_;	/* onvif.h:3469 */
class tt__TrackType_;	/* onvif.h:3492 */
class tt__RecordingJobMode__;	/* onvif.h:3504 */
class tt__RecordingJobState__;	/* onvif.h:3516 */
class tt__ModeOfOperation_;	/* onvif.h:3538 */
class tt__AudioClassType_;	/* onvif.h:3562 */
class tt__OSDType_;	/* onvif.h:3580 */
class tt__ReferenceToken__;	/* onvif.h:3600 */
class tt__MoveStatus_;	/* onvif.h:3618 */
class tt__Entity_;	/* onvif.h:3636 */
class wstop__FullTopicExpression__;	/* onvif.h:3677 */
class wstop__ConcreteTopicExpression__;	/* onvif.h:3695 */
class wstop__SimpleTopicExpression__;	/* onvif.h:3712 */
class tt__ReceiverReference__;	/* onvif.h:3724 */
class tt__RecordingReference__;	/* onvif.h:3736 */
class tt__TrackReference__;	/* onvif.h:3748 */
class tt__JobToken__;	/* onvif.h:3760 */
class tt__RecordingJobReference__;	/* onvif.h:3772 */
class _tds__Service_Capabilities;	/* onvif.h:3847 */
class tds__Service;	/* onvif.h:377 */
class tds__DeviceServiceCapabilities;	/* onvif.h:379 */
class tds__NetworkCapabilities;	/* onvif.h:381 */
class tds__SecurityCapabilities;	/* onvif.h:383 */
class tds__SystemCapabilities;	/* onvif.h:385 */
class tds__MiscCapabilities;	/* onvif.h:387 */
class _tds__UserCredential_Extension;	/* onvif.h:4350 */
class tds__UserCredential;	/* onvif.h:389 */
class _tds__StorageConfigurationData_Extension;	/* onvif.h:4407 */
class tds__StorageConfigurationData;	/* onvif.h:391 */
class _tds__GetServices;	/* onvif.h:395 */
class _tds__GetServicesResponse;	/* onvif.h:397 */
class _tds__GetServiceCapabilities;	/* onvif.h:399 */
class _tds__GetServiceCapabilitiesResponse;	/* onvif.h:401 */
class _tds__GetDeviceInformation;	/* onvif.h:403 */
class _tds__GetDeviceInformationResponse;	/* onvif.h:405 */
class _tds__SetSystemDateAndTime;	/* onvif.h:407 */
class _tds__SetSystemDateAndTimeResponse;	/* onvif.h:409 */
class _tds__GetSystemDateAndTime;	/* onvif.h:411 */
class _tds__GetSystemDateAndTimeResponse;	/* onvif.h:413 */
class _tds__SetSystemFactoryDefault;	/* onvif.h:415 */
class _tds__SetSystemFactoryDefaultResponse;	/* onvif.h:417 */
class _tds__UpgradeSystemFirmware;	/* onvif.h:419 */
class _tds__UpgradeSystemFirmwareResponse;	/* onvif.h:421 */
class _tds__SystemReboot;	/* onvif.h:423 */
class _tds__SystemRebootResponse;	/* onvif.h:425 */
class _tds__RestoreSystem;	/* onvif.h:427 */
class _tds__RestoreSystemResponse;	/* onvif.h:429 */
class _tds__GetSystemBackup;	/* onvif.h:431 */
class _tds__GetSystemBackupResponse;	/* onvif.h:433 */
class _tds__GetSystemSupportInformation;	/* onvif.h:435 */
class _tds__GetSystemSupportInformationResponse;	/* onvif.h:437 */
class _tds__GetSystemLog;	/* onvif.h:439 */
class _tds__GetSystemLogResponse;	/* onvif.h:441 */
class _tds__GetScopes;	/* onvif.h:443 */
class _tds__GetScopesResponse;	/* onvif.h:445 */
class _tds__SetScopes;	/* onvif.h:447 */
class _tds__SetScopesResponse;	/* onvif.h:449 */
class _tds__AddScopes;	/* onvif.h:451 */
class _tds__AddScopesResponse;	/* onvif.h:453 */
class _tds__RemoveScopes;	/* onvif.h:455 */
class _tds__RemoveScopesResponse;	/* onvif.h:457 */
class _tds__GetDiscoveryMode;	/* onvif.h:459 */
class _tds__GetDiscoveryModeResponse;	/* onvif.h:461 */
class _tds__SetDiscoveryMode;	/* onvif.h:463 */
class _tds__SetDiscoveryModeResponse;	/* onvif.h:465 */
class _tds__GetRemoteDiscoveryMode;	/* onvif.h:467 */
class _tds__GetRemoteDiscoveryModeResponse;	/* onvif.h:469 */
class _tds__SetRemoteDiscoveryMode;	/* onvif.h:471 */
class _tds__SetRemoteDiscoveryModeResponse;	/* onvif.h:473 */
class _tds__GetDPAddresses;	/* onvif.h:475 */
class _tds__GetDPAddressesResponse;	/* onvif.h:477 */
class _tds__SetDPAddresses;	/* onvif.h:479 */
class _tds__SetDPAddressesResponse;	/* onvif.h:481 */
class _tds__GetEndpointReference;	/* onvif.h:483 */
class _tds__GetEndpointReferenceResponse;	/* onvif.h:485 */
class _tds__GetRemoteUser;	/* onvif.h:487 */
class _tds__GetRemoteUserResponse;	/* onvif.h:489 */
class _tds__SetRemoteUser;	/* onvif.h:491 */
class _tds__SetRemoteUserResponse;	/* onvif.h:493 */
class _tds__GetUsers;	/* onvif.h:495 */
class _tds__GetUsersResponse;	/* onvif.h:497 */
class _tds__CreateUsers;	/* onvif.h:499 */
class _tds__CreateUsersResponse;	/* onvif.h:501 */
class _tds__DeleteUsers;	/* onvif.h:503 */
class _tds__DeleteUsersResponse;	/* onvif.h:505 */
class _tds__SetUser;	/* onvif.h:507 */
class _tds__SetUserResponse;	/* onvif.h:509 */
class _tds__GetWsdlUrl;	/* onvif.h:511 */
class _tds__GetWsdlUrlResponse;	/* onvif.h:513 */
class _tds__GetPasswordComplexityOptions;	/* onvif.h:515 */
class _tds__GetPasswordComplexityOptionsResponse;	/* onvif.h:517 */
class _tds__GetPasswordComplexityConfiguration;	/* onvif.h:519 */
class _tds__GetPasswordComplexityConfigurationResponse;	/* onvif.h:521 */
class _tds__SetPasswordComplexityConfiguration;	/* onvif.h:523 */
class _tds__SetPasswordComplexityConfigurationResponse;	/* onvif.h:525 */
class _tds__GetPasswordHistoryConfiguration;	/* onvif.h:527 */
class _tds__GetPasswordHistoryConfigurationResponse;	/* onvif.h:529 */
class _tds__SetPasswordHistoryConfiguration;	/* onvif.h:531 */
class _tds__SetPasswordHistoryConfigurationResponse;	/* onvif.h:533 */
class _tds__GetAuthFailureWarningOptions;	/* onvif.h:535 */
class _tds__GetAuthFailureWarningOptionsResponse;	/* onvif.h:537 */
class _tds__GetAuthFailureWarningConfiguration;	/* onvif.h:539 */
class _tds__GetAuthFailureWarningConfigurationResponse;	/* onvif.h:541 */
class _tds__SetAuthFailureWarningConfiguration;	/* onvif.h:543 */
class _tds__SetAuthFailureWarningConfigurationResponse;	/* onvif.h:545 */
class _tds__GetCapabilities;	/* onvif.h:547 */
class _tds__GetCapabilitiesResponse;	/* onvif.h:549 */
class _tds__GetHostname;	/* onvif.h:551 */
class _tds__GetHostnameResponse;	/* onvif.h:553 */
class _tds__SetHostname;	/* onvif.h:555 */
class _tds__SetHostnameResponse;	/* onvif.h:557 */
class _tds__SetHostnameFromDHCP;	/* onvif.h:559 */
class _tds__SetHostnameFromDHCPResponse;	/* onvif.h:561 */
class _tds__GetDNS;	/* onvif.h:563 */
class _tds__GetDNSResponse;	/* onvif.h:565 */
class _tds__SetDNS;	/* onvif.h:567 */
class _tds__SetDNSResponse;	/* onvif.h:569 */
class _tds__GetNTP;	/* onvif.h:571 */
class _tds__GetNTPResponse;	/* onvif.h:573 */
class _tds__SetNTP;	/* onvif.h:575 */
class _tds__SetNTPResponse;	/* onvif.h:577 */
class _tds__GetDynamicDNS;	/* onvif.h:579 */
class _tds__GetDynamicDNSResponse;	/* onvif.h:581 */
class _tds__SetDynamicDNS;	/* onvif.h:583 */
class _tds__SetDynamicDNSResponse;	/* onvif.h:585 */
class _tds__GetNetworkInterfaces;	/* onvif.h:587 */
class _tds__GetNetworkInterfacesResponse;	/* onvif.h:589 */
class _tds__SetNetworkInterfaces;	/* onvif.h:591 */
class _tds__SetNetworkInterfacesResponse;	/* onvif.h:593 */
class _tds__GetNetworkProtocols;	/* onvif.h:595 */
class _tds__GetNetworkProtocolsResponse;	/* onvif.h:597 */
class _tds__SetNetworkProtocols;	/* onvif.h:599 */
class _tds__SetNetworkProtocolsResponse;	/* onvif.h:601 */
class _tds__GetNetworkDefaultGateway;	/* onvif.h:603 */
class _tds__GetNetworkDefaultGatewayResponse;	/* onvif.h:605 */
class _tds__SetNetworkDefaultGateway;	/* onvif.h:607 */
class _tds__SetNetworkDefaultGatewayResponse;	/* onvif.h:609 */
class _tds__GetZeroConfiguration;	/* onvif.h:611 */
class _tds__GetZeroConfigurationResponse;	/* onvif.h:613 */
class _tds__SetZeroConfiguration;	/* onvif.h:615 */
class _tds__SetZeroConfigurationResponse;	/* onvif.h:617 */
class _tds__GetIPAddressFilter;	/* onvif.h:619 */
class _tds__GetIPAddressFilterResponse;	/* onvif.h:621 */
class _tds__SetIPAddressFilter;	/* onvif.h:623 */
class _tds__SetIPAddressFilterResponse;	/* onvif.h:625 */
class _tds__AddIPAddressFilter;	/* onvif.h:627 */
class _tds__AddIPAddressFilterResponse;	/* onvif.h:629 */
class _tds__RemoveIPAddressFilter;	/* onvif.h:631 */
class _tds__RemoveIPAddressFilterResponse;	/* onvif.h:633 */
class _tds__GetAccessPolicy;	/* onvif.h:635 */
class _tds__GetAccessPolicyResponse;	/* onvif.h:637 */
class _tds__SetAccessPolicy;	/* onvif.h:639 */
class _tds__SetAccessPolicyResponse;	/* onvif.h:641 */
class _tds__CreateCertificate;	/* onvif.h:643 */
class _tds__CreateCertificateResponse;	/* onvif.h:645 */
class _tds__GetCertificates;	/* onvif.h:647 */
class _tds__GetCertificatesResponse;	/* onvif.h:649 */
class _tds__GetCertificatesStatus;	/* onvif.h:651 */
class _tds__GetCertificatesStatusResponse;	/* onvif.h:653 */
class _tds__SetCertificatesStatus;	/* onvif.h:655 */
class _tds__SetCertificatesStatusResponse;	/* onvif.h:657 */
class _tds__DeleteCertificates;	/* onvif.h:659 */
class _tds__DeleteCertificatesResponse;	/* onvif.h:661 */
class _tds__GetPkcs10Request;	/* onvif.h:663 */
class _tds__GetPkcs10RequestResponse;	/* onvif.h:665 */
class _tds__LoadCertificates;	/* onvif.h:667 */
class _tds__LoadCertificatesResponse;	/* onvif.h:669 */
class _tds__GetClientCertificateMode;	/* onvif.h:671 */
class _tds__GetClientCertificateModeResponse;	/* onvif.h:673 */
class _tds__SetClientCertificateMode;	/* onvif.h:675 */
class _tds__SetClientCertificateModeResponse;	/* onvif.h:677 */
class _tds__GetCACertificates;	/* onvif.h:679 */
class _tds__GetCACertificatesResponse;	/* onvif.h:681 */
class _tds__LoadCertificateWithPrivateKey;	/* onvif.h:683 */
class _tds__LoadCertificateWithPrivateKeyResponse;	/* onvif.h:685 */
class _tds__GetCertificateInformation;	/* onvif.h:687 */
class _tds__GetCertificateInformationResponse;	/* onvif.h:689 */
class _tds__LoadCACertificates;	/* onvif.h:691 */
class _tds__LoadCACertificatesResponse;	/* onvif.h:693 */
class _tds__CreateDot1XConfiguration;	/* onvif.h:695 */
class _tds__CreateDot1XConfigurationResponse;	/* onvif.h:697 */
class _tds__SetDot1XConfiguration;	/* onvif.h:699 */
class _tds__SetDot1XConfigurationResponse;	/* onvif.h:701 */
class _tds__GetDot1XConfiguration;	/* onvif.h:703 */
class _tds__GetDot1XConfigurationResponse;	/* onvif.h:705 */
class _tds__GetDot1XConfigurations;	/* onvif.h:707 */
class _tds__GetDot1XConfigurationsResponse;	/* onvif.h:709 */
class _tds__DeleteDot1XConfiguration;	/* onvif.h:711 */
class _tds__DeleteDot1XConfigurationResponse;	/* onvif.h:713 */
class _tds__GetRelayOutputs;	/* onvif.h:715 */
class _tds__GetRelayOutputsResponse;	/* onvif.h:717 */
class _tds__SetRelayOutputSettings;	/* onvif.h:719 */
class _tds__SetRelayOutputSettingsResponse;	/* onvif.h:721 */
class _tds__SetRelayOutputState;	/* onvif.h:723 */
class _tds__SetRelayOutputStateResponse;	/* onvif.h:725 */
class _tds__SendAuxiliaryCommand;	/* onvif.h:727 */
class _tds__SendAuxiliaryCommandResponse;	/* onvif.h:729 */
class _tds__GetDot11Capabilities;	/* onvif.h:731 */
class _tds__GetDot11CapabilitiesResponse;	/* onvif.h:733 */
class _tds__GetDot11Status;	/* onvif.h:735 */
class _tds__GetDot11StatusResponse;	/* onvif.h:737 */
class _tds__ScanAvailableDot11Networks;	/* onvif.h:739 */
class _tds__ScanAvailableDot11NetworksResponse;	/* onvif.h:741 */
class _tds__GetSystemUris;	/* onvif.h:743 */
class _tds__GetSystemUrisResponse_Extension;	/* onvif.h:8583 */
class _tds__GetSystemUrisResponse;	/* onvif.h:745 */
class _tds__StartFirmwareUpgrade;	/* onvif.h:747 */
class _tds__StartFirmwareUpgradeResponse;	/* onvif.h:749 */
class _tds__StartSystemRestore;	/* onvif.h:751 */
class _tds__StartSystemRestoreResponse;	/* onvif.h:753 */
class _tds__SetHashingAlgorithm;	/* onvif.h:755 */
class _tds__SetHashingAlgorithmResponse;	/* onvif.h:757 */
class _tds__GetStorageConfigurations;	/* onvif.h:759 */
class _tds__GetStorageConfigurationsResponse;	/* onvif.h:761 */
class _tds__CreateStorageConfiguration;	/* onvif.h:763 */
class _tds__CreateStorageConfigurationResponse;	/* onvif.h:765 */
class _tds__GetStorageConfiguration;	/* onvif.h:767 */
class _tds__GetStorageConfigurationResponse;	/* onvif.h:769 */
class _tds__SetStorageConfiguration;	/* onvif.h:771 */
class _tds__SetStorageConfigurationResponse;	/* onvif.h:773 */
class _tds__DeleteStorageConfiguration;	/* onvif.h:775 */
class _tds__DeleteStorageConfigurationResponse;	/* onvif.h:777 */
class _tds__GetGeoLocation;	/* onvif.h:779 */
class _tds__GetGeoLocationResponse;	/* onvif.h:781 */
class _tds__SetGeoLocation;	/* onvif.h:783 */
class _tds__SetGeoLocationResponse;	/* onvif.h:785 */
class _tds__DeleteGeoLocation;	/* onvif.h:787 */
class _tds__DeleteGeoLocationResponse;	/* onvif.h:789 */
class tt__DeviceEntity;	/* onvif.h:791 */
class tt__IntRectangle;	/* onvif.h:793 */
class tt__IntRectangleRange;	/* onvif.h:795 */
class tt__FloatRange;	/* onvif.h:797 */
class tt__DurationRange;	/* onvif.h:799 */
class tt__IntItems;	/* onvif.h:801 */
class tt__FloatItems;	/* onvif.h:803 */
class tt__AnyHolder;	/* onvif.h:805 */
class tt__VideoSourceExtension;	/* onvif.h:809 */
class tt__VideoSourceExtension2;	/* onvif.h:811 */
class tt__Profile;	/* onvif.h:815 */
class tt__ProfileExtension;	/* onvif.h:817 */
class tt__ProfileExtension2;	/* onvif.h:819 */
class tt__ConfigurationEntity;	/* onvif.h:821 */
class tt__VideoSourceConfigurationExtension;	/* onvif.h:825 */
class tt__VideoSourceConfigurationExtension2;	/* onvif.h:827 */
class tt__Rotate;	/* onvif.h:829 */
class tt__RotateExtension;	/* onvif.h:831 */
class tt__LensProjection;	/* onvif.h:833 */
class tt__LensOffset;	/* onvif.h:835 */
class tt__LensDescription;	/* onvif.h:837 */
class tt__VideoSourceConfigurationOptions;	/* onvif.h:839 */
class tt__VideoSourceConfigurationOptionsExtension;	/* onvif.h:841 */
class tt__VideoSourceConfigurationOptionsExtension2;	/* onvif.h:843 */
class tt__RotateOptions;	/* onvif.h:845 */
class tt__RotateOptionsExtension;	/* onvif.h:847 */
class tt__SceneOrientation;	/* onvif.h:849 */
class tt__VideoResolution;	/* onvif.h:853 */
class tt__VideoRateControl;	/* onvif.h:855 */
class tt__Mpeg4Configuration;	/* onvif.h:857 */
class tt__H264Configuration;	/* onvif.h:859 */
class tt__VideoEncoderConfigurationOptions;	/* onvif.h:861 */
class tt__VideoEncoderOptionsExtension;	/* onvif.h:863 */
class tt__VideoEncoderOptionsExtension2;	/* onvif.h:865 */
class tt__JpegOptions;	/* onvif.h:867 */
class tt__Mpeg4Options;	/* onvif.h:871 */
class tt__H264Options;	/* onvif.h:875 */
class tt__VideoResolution2;	/* onvif.h:881 */
class tt__VideoRateControl2;	/* onvif.h:883 */
class tt__VideoEncoder2ConfigurationOptions;	/* onvif.h:885 */
class tt__AudioSourceConfigurationOptions;	/* onvif.h:889 */
class tt__AudioSourceOptionsExtension;	/* onvif.h:891 */
class tt__AudioEncoderConfigurationOptions;	/* onvif.h:895 */
class tt__AudioEncoderConfigurationOption;	/* onvif.h:897 */
class tt__AudioEncoder2ConfigurationOptions;	/* onvif.h:901 */
class tt__MetadataConfigurationExtension;	/* onvif.h:907 */
class tt__PTZFilter;	/* onvif.h:909 */
class _tt__EventSubscription_SubscriptionPolicy;	/* onvif.h:10912 */
class tt__EventSubscription;	/* onvif.h:911 */
class tt__MetadataConfigurationOptions;	/* onvif.h:913 */
class tt__MetadataConfigurationOptionsExtension;	/* onvif.h:915 */
class tt__MetadataConfigurationOptionsExtension2;	/* onvif.h:917 */
class tt__PTZStatusFilterOptions;	/* onvif.h:919 */
class tt__PTZStatusFilterOptionsExtension;	/* onvif.h:921 */
class tt__VideoOutputExtension;	/* onvif.h:925 */
class tt__VideoOutputConfigurationOptions;	/* onvif.h:929 */
class tt__VideoDecoderConfigurationOptions;	/* onvif.h:931 */
class tt__H264DecOptions;	/* onvif.h:933 */
class tt__JpegDecOptions;	/* onvif.h:935 */
class tt__Mpeg4DecOptions;	/* onvif.h:937 */
class tt__VideoDecoderConfigurationOptionsExtension;	/* onvif.h:939 */
class tt__AudioOutputConfigurationOptions;	/* onvif.h:945 */
class tt__AudioDecoderConfigurationOptions;	/* onvif.h:949 */
class tt__G711DecOptions;	/* onvif.h:951 */
class tt__AACDecOptions;	/* onvif.h:953 */
class tt__G726DecOptions;	/* onvif.h:955 */
class tt__AudioDecoderConfigurationOptionsExtension;	/* onvif.h:957 */
class tt__MulticastConfiguration;	/* onvif.h:959 */
class tt__StreamSetup;	/* onvif.h:961 */
class tt__Transport;	/* onvif.h:963 */
class tt__MediaUri;	/* onvif.h:965 */
class tt__Scope;	/* onvif.h:967 */
class tt__NetworkInterfaceExtension;	/* onvif.h:971 */
class tt__Dot3Configuration;	/* onvif.h:973 */
class tt__NetworkInterfaceExtension2;	/* onvif.h:975 */
class tt__NetworkInterfaceLink;	/* onvif.h:977 */
class tt__NetworkInterfaceConnectionSetting;	/* onvif.h:979 */
class tt__NetworkInterfaceInfo;	/* onvif.h:981 */
class tt__IPv6NetworkInterface;	/* onvif.h:983 */
class tt__IPv4NetworkInterface;	/* onvif.h:985 */
class tt__IPv4Configuration;	/* onvif.h:987 */
class tt__IPv6Configuration;	/* onvif.h:989 */
class tt__IPv6ConfigurationExtension;	/* onvif.h:991 */
class tt__NetworkProtocol;	/* onvif.h:993 */
class tt__NetworkProtocolExtension;	/* onvif.h:995 */
class tt__NetworkHost;	/* onvif.h:997 */
class tt__NetworkHostExtension;	/* onvif.h:999 */
class tt__IPAddress;	/* onvif.h:1001 */
class tt__PrefixedIPv4Address;	/* onvif.h:1003 */
class tt__PrefixedIPv6Address;	/* onvif.h:1005 */
class tt__HostnameInformation;	/* onvif.h:1007 */
class tt__HostnameInformationExtension;	/* onvif.h:1009 */
class tt__DNSInformation;	/* onvif.h:1011 */
class tt__DNSInformationExtension;	/* onvif.h:1013 */
class tt__NTPInformation;	/* onvif.h:1015 */
class tt__NTPInformationExtension;	/* onvif.h:1017 */
class tt__DynamicDNSInformation;	/* onvif.h:1019 */
class tt__DynamicDNSInformationExtension;	/* onvif.h:1021 */
class tt__NetworkInterfaceSetConfiguration;	/* onvif.h:1023 */
class tt__NetworkInterfaceSetConfigurationExtension;	/* onvif.h:1025 */
class tt__IPv6NetworkInterfaceSetConfiguration;	/* onvif.h:1027 */
class tt__IPv4NetworkInterfaceSetConfiguration;	/* onvif.h:1029 */
class tt__NetworkGateway;	/* onvif.h:1031 */
class tt__NetworkZeroConfiguration;	/* onvif.h:1033 */
class tt__NetworkZeroConfigurationExtension;	/* onvif.h:1035 */
class tt__NetworkZeroConfigurationExtension2;	/* onvif.h:1037 */
class tt__IPAddressFilter;	/* onvif.h:1039 */
class tt__IPAddressFilterExtension;	/* onvif.h:1041 */
class tt__Dot11Configuration;	/* onvif.h:1043 */
class tt__Dot11SecurityConfiguration;	/* onvif.h:1045 */
class tt__Dot11SecurityConfigurationExtension;	/* onvif.h:1047 */
class tt__Dot11PSKSet;	/* onvif.h:1049 */
class tt__Dot11PSKSetExtension;	/* onvif.h:1051 */
class tt__NetworkInterfaceSetConfigurationExtension2;	/* onvif.h:1053 */
class tt__Dot11Capabilities;	/* onvif.h:1055 */
class tt__Dot11Status;	/* onvif.h:1057 */
class tt__Dot11AvailableNetworks;	/* onvif.h:1059 */
class tt__Dot11AvailableNetworksExtension;	/* onvif.h:1061 */
class tt__Capabilities;	/* onvif.h:1063 */
class tt__CapabilitiesExtension;	/* onvif.h:1065 */
class tt__CapabilitiesExtension2;	/* onvif.h:1067 */
class tt__AnalyticsCapabilities;	/* onvif.h:1069 */
class tt__DeviceCapabilities;	/* onvif.h:1071 */
class tt__DeviceCapabilitiesExtension;	/* onvif.h:1073 */
class tt__EventCapabilities;	/* onvif.h:1075 */
class tt__IOCapabilities;	/* onvif.h:1077 */
class tt__IOCapabilitiesExtension;	/* onvif.h:1079 */
class tt__IOCapabilitiesExtension2;	/* onvif.h:1081 */
class tt__MediaCapabilities;	/* onvif.h:1083 */
class tt__MediaCapabilitiesExtension;	/* onvif.h:1085 */
class tt__RealTimeStreamingCapabilities;	/* onvif.h:1087 */
class tt__RealTimeStreamingCapabilitiesExtension;	/* onvif.h:1089 */
class tt__ProfileCapabilities;	/* onvif.h:1091 */
class tt__NetworkCapabilities;	/* onvif.h:1093 */
class tt__NetworkCapabilitiesExtension;	/* onvif.h:1095 */
class tt__NetworkCapabilitiesExtension2;	/* onvif.h:1097 */
class tt__SecurityCapabilities;	/* onvif.h:1099 */
class tt__SecurityCapabilitiesExtension;	/* onvif.h:1101 */
class tt__SecurityCapabilitiesExtension2;	/* onvif.h:1103 */
class tt__SystemCapabilities;	/* onvif.h:1105 */
class tt__SystemCapabilitiesExtension;	/* onvif.h:1107 */
class tt__SystemCapabilitiesExtension2;	/* onvif.h:1109 */
class tt__OnvifVersion;	/* onvif.h:1111 */
class tt__ImagingCapabilities;	/* onvif.h:1113 */
class tt__PTZCapabilities;	/* onvif.h:1115 */
class tt__DeviceIOCapabilities;	/* onvif.h:1117 */
class tt__DisplayCapabilities;	/* onvif.h:1119 */
class tt__RecordingCapabilities;	/* onvif.h:1121 */
class tt__SearchCapabilities;	/* onvif.h:1123 */
class tt__ReplayCapabilities;	/* onvif.h:1125 */
class tt__ReceiverCapabilities;	/* onvif.h:1127 */
class tt__AnalyticsDeviceCapabilities;	/* onvif.h:1129 */
class tt__AnalyticsDeviceExtension;	/* onvif.h:1131 */
class tt__SystemLog;	/* onvif.h:1133 */
class tt__SupportInformation;	/* onvif.h:1135 */
class tt__BinaryData;	/* onvif.h:1137 */
class tt__AttachmentData;	/* onvif.h:1139 */
class tt__BackupFile;	/* onvif.h:1141 */
class tt__SystemLogUriList;	/* onvif.h:1143 */
class tt__SystemLogUri;	/* onvif.h:1145 */
class tt__SystemDateTime;	/* onvif.h:1147 */
class tt__SystemDateTimeExtension;	/* onvif.h:1149 */
class tt__DateTime;	/* onvif.h:1151 */
class tt__Date;	/* onvif.h:1153 */
class tt__Time;	/* onvif.h:1155 */
class tt__TimeZone;	/* onvif.h:1157 */
class tt__RemoteUser;	/* onvif.h:1159 */
class tt__User;	/* onvif.h:1161 */
class tt__UserExtension;	/* onvif.h:1163 */
class tt__CertificateGenerationParameters;	/* onvif.h:1165 */
class tt__CertificateGenerationParametersExtension;	/* onvif.h:1167 */
class tt__Certificate;	/* onvif.h:1169 */
class tt__CertificateStatus;	/* onvif.h:1171 */
class tt__CertificateWithPrivateKey;	/* onvif.h:1173 */
class tt__CertificateInformation;	/* onvif.h:1175 */
class tt__CertificateInformationExtension;	/* onvif.h:1179 */
class tt__Dot1XConfiguration;	/* onvif.h:1181 */
class tt__Dot1XConfigurationExtension;	/* onvif.h:1183 */
class tt__EAPMethodConfiguration;	/* onvif.h:1185 */
class tt__EapMethodExtension;	/* onvif.h:1187 */
class tt__TLSConfiguration;	/* onvif.h:1189 */
class tt__GenericEapPwdConfigurationExtension;	/* onvif.h:1191 */
class tt__RelayOutputSettings;	/* onvif.h:1193 */
class tt__PTZNodeExtension;	/* onvif.h:1201 */
class tt__PTZNodeExtension2;	/* onvif.h:1203 */
class tt__PTZPresetTourSupported;	/* onvif.h:1205 */
class tt__PTZPresetTourSupportedExtension;	/* onvif.h:1207 */
class tt__PTZConfigurationExtension;	/* onvif.h:1211 */
class tt__PTZConfigurationExtension2;	/* onvif.h:1213 */
class tt__PTControlDirection;	/* onvif.h:1215 */
class tt__PTControlDirectionExtension;	/* onvif.h:1217 */
class tt__EFlip;	/* onvif.h:1219 */
class tt__Reverse;	/* onvif.h:1221 */
class tt__PTZConfigurationOptions;	/* onvif.h:1223 */
class tt__PTZConfigurationOptions2;	/* onvif.h:1225 */
class tt__PTControlDirectionOptions;	/* onvif.h:1227 */
class tt__PTControlDirectionOptionsExtension;	/* onvif.h:1229 */
class tt__EFlipOptions;	/* onvif.h:1231 */
class tt__EFlipOptionsExtension;	/* onvif.h:1233 */
class tt__ReverseOptions;	/* onvif.h:1235 */
class tt__ReverseOptionsExtension;	/* onvif.h:1237 */
class tt__PanTiltLimits;	/* onvif.h:1239 */
class tt__ZoomLimits;	/* onvif.h:1241 */
class tt__PTZSpaces;	/* onvif.h:1243 */
class tt__PTZSpacesExtension;	/* onvif.h:1245 */
class tt__Space2DDescription;	/* onvif.h:1247 */
class tt__Space1DDescription;	/* onvif.h:1249 */
class tt__PTZSpeed;	/* onvif.h:1251 */
class tt__PTZPreset;	/* onvif.h:1253 */
class tt__PresetTour;	/* onvif.h:1255 */
class tt__PTZPresetTourExtension;	/* onvif.h:1257 */
class tt__PTZPresetTourSpot;	/* onvif.h:1259 */
class tt__PTZPresetTourSpotExtension;	/* onvif.h:1261 */
union _tt__union_PTZPresetTourPresetDetail;	/* onvif.h:16834 */
class tt__PTZPresetTourPresetDetail;	/* onvif.h:1263 */
class tt__PTZPresetTourTypeExtension;	/* onvif.h:1265 */
class tt__PTZPresetTourStatus;	/* onvif.h:1267 */
class tt__PTZPresetTourStatusExtension;	/* onvif.h:1269 */
class tt__PTZPresetTourStartingCondition;	/* onvif.h:1271 */
class tt__PTZPresetTourStartingConditionExtension;	/* onvif.h:1273 */
class tt__PTZPresetTourOptions;	/* onvif.h:1275 */
class tt__PTZPresetTourSpotOptions;	/* onvif.h:1277 */
class tt__PTZPresetTourPresetDetailOptions;	/* onvif.h:1279 */
class tt__PTZPresetTourPresetDetailOptionsExtension;	/* onvif.h:1281 */
class tt__PTZPresetTourStartingConditionOptions;	/* onvif.h:1283 */
class tt__PTZPresetTourStartingConditionOptionsExtension;	/* onvif.h:1285 */
class tt__ImagingStatus;	/* onvif.h:1287 */
class tt__FocusStatus;	/* onvif.h:1289 */
class tt__FocusConfiguration;	/* onvif.h:1291 */
class tt__ImagingSettings;	/* onvif.h:1293 */
class tt__ImagingSettingsExtension;	/* onvif.h:1295 */
class tt__Exposure;	/* onvif.h:1297 */
class tt__WideDynamicRange;	/* onvif.h:1299 */
class tt__BacklightCompensation;	/* onvif.h:1301 */
class tt__ImagingOptions;	/* onvif.h:1303 */
class tt__WideDynamicRangeOptions;	/* onvif.h:1305 */
class tt__BacklightCompensationOptions;	/* onvif.h:1307 */
class tt__FocusOptions;	/* onvif.h:1309 */
class tt__ExposureOptions;	/* onvif.h:1311 */
class tt__WhiteBalanceOptions;	/* onvif.h:1313 */
class tt__FocusMove;	/* onvif.h:1315 */
class tt__AbsoluteFocus;	/* onvif.h:1317 */
class tt__RelativeFocus;	/* onvif.h:1319 */
class tt__ContinuousFocus;	/* onvif.h:1321 */
class tt__MoveOptions;	/* onvif.h:1323 */
class tt__AbsoluteFocusOptions;	/* onvif.h:1325 */
class tt__RelativeFocusOptions;	/* onvif.h:1327 */
class tt__ContinuousFocusOptions;	/* onvif.h:1329 */
class tt__WhiteBalance;	/* onvif.h:1331 */
class tt__ImagingStatus20;	/* onvif.h:1333 */
class tt__ImagingStatus20Extension;	/* onvif.h:1335 */
class tt__FocusStatus20;	/* onvif.h:1337 */
class tt__FocusStatus20Extension;	/* onvif.h:1339 */
class tt__ImagingSettings20;	/* onvif.h:1341 */
class tt__ImagingSettingsExtension20;	/* onvif.h:1343 */
class tt__ImagingSettingsExtension202;	/* onvif.h:1345 */
class tt__ImagingSettingsExtension203;	/* onvif.h:1347 */
class tt__ImagingSettingsExtension204;	/* onvif.h:1349 */
class tt__ImageStabilization;	/* onvif.h:1351 */
class tt__ImageStabilizationExtension;	/* onvif.h:1353 */
class tt__IrCutFilterAutoAdjustment;	/* onvif.h:1355 */
class tt__IrCutFilterAutoAdjustmentExtension;	/* onvif.h:1357 */
class tt__WideDynamicRange20;	/* onvif.h:1359 */
class tt__BacklightCompensation20;	/* onvif.h:1361 */
class tt__Exposure20;	/* onvif.h:1363 */
class tt__ToneCompensation;	/* onvif.h:1365 */
class tt__ToneCompensationExtension;	/* onvif.h:1367 */
class tt__Defogging;	/* onvif.h:1369 */
class tt__DefoggingExtension;	/* onvif.h:1371 */
class tt__NoiseReduction;	/* onvif.h:1373 */
class tt__ImagingOptions20;	/* onvif.h:1375 */
class tt__ImagingOptions20Extension;	/* onvif.h:1377 */
class tt__ImagingOptions20Extension2;	/* onvif.h:1379 */
class tt__ImagingOptions20Extension3;	/* onvif.h:1381 */
class tt__ImagingOptions20Extension4;	/* onvif.h:1383 */
class tt__ImageStabilizationOptions;	/* onvif.h:1385 */
class tt__ImageStabilizationOptionsExtension;	/* onvif.h:1387 */
class tt__IrCutFilterAutoAdjustmentOptions;	/* onvif.h:1389 */
class tt__IrCutFilterAutoAdjustmentOptionsExtension;	/* onvif.h:1391 */
class tt__WideDynamicRangeOptions20;	/* onvif.h:1393 */
class tt__BacklightCompensationOptions20;	/* onvif.h:1395 */
class tt__ExposureOptions20;	/* onvif.h:1397 */
class tt__MoveOptions20;	/* onvif.h:1399 */
class tt__RelativeFocusOptions20;	/* onvif.h:1401 */
class tt__WhiteBalance20;	/* onvif.h:1403 */
class tt__WhiteBalance20Extension;	/* onvif.h:1405 */
class tt__FocusConfiguration20;	/* onvif.h:1407 */
class tt__FocusConfiguration20Extension;	/* onvif.h:1409 */
class tt__WhiteBalanceOptions20;	/* onvif.h:1411 */
class tt__WhiteBalanceOptions20Extension;	/* onvif.h:1413 */
class tt__FocusOptions20;	/* onvif.h:1415 */
class tt__FocusOptions20Extension;	/* onvif.h:1417 */
class tt__ToneCompensationOptions;	/* onvif.h:1419 */
class tt__DefoggingOptions;	/* onvif.h:1421 */
class tt__NoiseReductionOptions;	/* onvif.h:1423 */
class tt__MessageExtension;	/* onvif.h:1425 */
class _tt__ItemList_SimpleItem;	/* onvif.h:19896 */
class _tt__ItemList_ElementItem;	/* onvif.h:19928 */
class tt__ItemList;	/* onvif.h:1427 */
class tt__ItemListExtension;	/* onvif.h:1429 */
class tt__MessageDescription;	/* onvif.h:1431 */
class tt__MessageDescriptionExtension;	/* onvif.h:1433 */
class _tt__ItemListDescription_SimpleItemDescription;	/* onvif.h:20094 */
class _tt__ItemListDescription_ElementItemDescription;	/* onvif.h:20122 */
class tt__ItemListDescription;	/* onvif.h:1435 */
class tt__ItemListDescriptionExtension;	/* onvif.h:1437 */
class tt__Polyline;	/* onvif.h:1439 */
class tt__AnalyticsEngineConfiguration;	/* onvif.h:1441 */
class tt__AnalyticsEngineConfigurationExtension;	/* onvif.h:1443 */
class tt__RuleEngineConfiguration;	/* onvif.h:1445 */
class tt__RuleEngineConfigurationExtension;	/* onvif.h:1447 */
class tt__Config;	/* onvif.h:1449 */
class _tt__ConfigDescription_Messages;	/* onvif.h:20373 */
class tt__ConfigDescription;	/* onvif.h:1451 */
class tt__ConfigDescriptionExtension;	/* onvif.h:1453 */
class tt__SupportedRules;	/* onvif.h:1455 */
class tt__SupportedRulesExtension;	/* onvif.h:1457 */
class tt__SupportedAnalyticsModules;	/* onvif.h:1459 */
class tt__SupportedAnalyticsModulesExtension;	/* onvif.h:1461 */
class tt__PolylineArray;	/* onvif.h:1463 */
class tt__PolylineArrayExtension;	/* onvif.h:1465 */
class tt__PolylineArrayConfiguration;	/* onvif.h:1467 */
class tt__MotionExpression;	/* onvif.h:1469 */
class tt__MotionExpressionConfiguration;	/* onvif.h:1471 */
class tt__CellLayout;	/* onvif.h:1473 */
class tt__PaneConfiguration;	/* onvif.h:1475 */
class tt__PaneLayout;	/* onvif.h:1477 */
class tt__Layout;	/* onvif.h:1479 */
class tt__LayoutExtension;	/* onvif.h:1481 */
class tt__CodingCapabilities;	/* onvif.h:1483 */
class tt__LayoutOptions;	/* onvif.h:1485 */
class tt__LayoutOptionsExtension;	/* onvif.h:1487 */
class tt__PaneLayoutOptions;	/* onvif.h:1489 */
class tt__PaneOptionExtension;	/* onvif.h:1491 */
class tt__Receiver;	/* onvif.h:1493 */
class tt__ReceiverConfiguration;	/* onvif.h:1495 */
class tt__ReceiverStateInformation;	/* onvif.h:1497 */
class tt__SourceReference;	/* onvif.h:1499 */
class tt__DateTimeRange;	/* onvif.h:1501 */
class tt__RecordingSummary;	/* onvif.h:1503 */
class tt__SearchScope;	/* onvif.h:1505 */
class tt__SearchScopeExtension;	/* onvif.h:1507 */
class tt__PTZPositionFilter;	/* onvif.h:1511 */
class tt__MetadataFilter;	/* onvif.h:1513 */
class tt__FindRecordingResultList;	/* onvif.h:1515 */
class tt__FindEventResultList;	/* onvif.h:1517 */
class tt__FindEventResult;	/* onvif.h:1519 */
class tt__FindPTZPositionResultList;	/* onvif.h:1521 */
class tt__FindPTZPositionResult;	/* onvif.h:1523 */
class tt__FindMetadataResultList;	/* onvif.h:1525 */
class tt__FindMetadataResult;	/* onvif.h:1527 */
class tt__RecordingInformation;	/* onvif.h:1529 */
class tt__RecordingSourceInformation;	/* onvif.h:1531 */
class tt__TrackInformation;	/* onvif.h:1533 */
class tt__MediaAttributes;	/* onvif.h:1535 */
class tt__TrackAttributes;	/* onvif.h:1537 */
class tt__TrackAttributesExtension;	/* onvif.h:1539 */
class tt__VideoAttributes;	/* onvif.h:1541 */
class tt__AudioAttributes;	/* onvif.h:1543 */
class tt__MetadataAttributes;	/* onvif.h:1545 */
class tt__RecordingConfiguration;	/* onvif.h:1547 */
class tt__TrackConfiguration;	/* onvif.h:1549 */
class tt__GetRecordingsResponseItem;	/* onvif.h:1551 */
class tt__GetTracksResponseList;	/* onvif.h:1553 */
class tt__GetTracksResponseItem;	/* onvif.h:1555 */
class tt__RecordingJobConfiguration;	/* onvif.h:1557 */
class _tt__RecordingEventFilter_Filter;	/* onvif.h:22689 */
class tt__RecordingEventFilter;	/* onvif.h:1559 */
class tt__RecordingJobConfigurationExtension;	/* onvif.h:1561 */
class tt__RecordingJobSource;	/* onvif.h:1563 */
class tt__RecordingJobSourceExtension;	/* onvif.h:1565 */
class tt__RecordingJobTrack;	/* onvif.h:1567 */
class tt__RecordingJobStateInformation;	/* onvif.h:1569 */
class tt__RecordingJobStateInformationExtension;	/* onvif.h:1571 */
class tt__RecordingJobStateSource;	/* onvif.h:1573 */
class tt__RecordingJobStateTracks;	/* onvif.h:1575 */
class tt__RecordingJobStateTrack;	/* onvif.h:1577 */
class tt__GetRecordingJobsResponseItem;	/* onvif.h:1579 */
class tt__ReplayConfiguration;	/* onvif.h:1581 */
class tt__AnalyticsDeviceEngineConfiguration;	/* onvif.h:1585 */
class tt__AnalyticsDeviceEngineConfigurationExtension;	/* onvif.h:1587 */
class tt__EngineConfiguration;	/* onvif.h:1589 */
class tt__AnalyticsEngineInputInfo;	/* onvif.h:1591 */
class tt__AnalyticsEngineInputInfoExtension;	/* onvif.h:1593 */
class tt__SourceIdentification;	/* onvif.h:1597 */
class tt__SourceIdentificationExtension;	/* onvif.h:1599 */
class tt__MetadataInput;	/* onvif.h:1601 */
class tt__MetadataInputExtension;	/* onvif.h:1603 */
class tt__AnalyticsStateInformation;	/* onvif.h:1607 */
class tt__AnalyticsState;	/* onvif.h:1609 */
class tt__ActionEngineEventPayload;	/* onvif.h:1611 */
class tt__ActionEngineEventPayloadExtension;	/* onvif.h:1613 */
class tt__AudioClassCandidate;	/* onvif.h:1615 */
class tt__AudioClassDescriptor;	/* onvif.h:1617 */
class tt__AudioClassDescriptorExtension;	/* onvif.h:1619 */
class tt__ActiveConnection;	/* onvif.h:1621 */
class tt__ProfileStatus;	/* onvif.h:1623 */
class tt__ProfileStatusExtension;	/* onvif.h:1625 */
class tt__OSDPosConfiguration;	/* onvif.h:1629 */
class tt__OSDPosConfigurationExtension;	/* onvif.h:1631 */
class tt__OSDColor;	/* onvif.h:1633 */
class tt__OSDTextConfiguration;	/* onvif.h:1635 */
class tt__OSDTextConfigurationExtension;	/* onvif.h:1637 */
class tt__OSDImgConfiguration;	/* onvif.h:1639 */
class tt__OSDImgConfigurationExtension;	/* onvif.h:1641 */
class tt__ColorspaceRange;	/* onvif.h:1643 */
union _tt__union_ColorOptions;	/* onvif.h:24098 */
class tt__ColorOptions;	/* onvif.h:1645 */
class tt__OSDColorOptions;	/* onvif.h:1647 */
class tt__OSDColorOptionsExtension;	/* onvif.h:1649 */
class tt__OSDTextOptions;	/* onvif.h:1651 */
class tt__OSDTextOptionsExtension;	/* onvif.h:1653 */
class tt__OSDImgOptions;	/* onvif.h:1655 */
class tt__OSDImgOptionsExtension;	/* onvif.h:1657 */
class tt__OSDConfigurationExtension;	/* onvif.h:1661 */
class tt__MaximumNumberOfOSDs;	/* onvif.h:1663 */
class tt__OSDConfigurationOptions;	/* onvif.h:1665 */
class tt__OSDConfigurationOptionsExtension;	/* onvif.h:1667 */
class tt__FileProgress;	/* onvif.h:1669 */
class tt__ArrayOfFileProgress;	/* onvif.h:1671 */
class tt__ArrayOfFileProgressExtension;	/* onvif.h:1673 */
class tt__StorageReferencePath;	/* onvif.h:1675 */
class tt__StorageReferencePathExtension;	/* onvif.h:1677 */
class tt__PolygonOptions;	/* onvif.h:1679 */
class tt__IntRange;	/* onvif.h:1681 */
class tt__Vector2D;	/* onvif.h:1683 */
class tt__Vector1D;	/* onvif.h:1685 */
class tt__PTZVector;	/* onvif.h:1687 */
class tt__PTZStatus;	/* onvif.h:1689 */
class tt__PTZMoveStatus;	/* onvif.h:1691 */
class tt__Vector;	/* onvif.h:1693 */
class tt__Rectangle;	/* onvif.h:1695 */
class tt__Polygon;	/* onvif.h:1697 */
class tt__Color;	/* onvif.h:1699 */
class tt__ColorCovariance;	/* onvif.h:1701 */
class _tt__ColorDescriptor_ColorCluster;	/* onvif.h:25137 */
class tt__ColorDescriptor;	/* onvif.h:1703 */
class tt__Transformation;	/* onvif.h:1705 */
class tt__TransformationExtension;	/* onvif.h:1707 */
class tt__GeoLocation;	/* onvif.h:1709 */
class tt__GeoOrientation;	/* onvif.h:1711 */
class tt__LocalLocation;	/* onvif.h:1713 */
class tt__LocalOrientation;	/* onvif.h:1715 */
class tt__LocationEntity;	/* onvif.h:1717 */
class _tt__StringItems;	/* onvif.h:1719 */
class _tt__Message;	/* onvif.h:1721 */
class wsnt__QueryExpressionType;	/* onvif.h:1723 */
class wsnt__TopicExpressionType;	/* onvif.h:1725 */
class wsnt__FilterType;	/* onvif.h:1727 */
class wsnt__SubscriptionPolicyType;	/* onvif.h:1729 */
class _wsnt__NotificationMessageHolderType_Message;	/* onvif.h:25724 */
class wsnt__NotificationMessageHolderType;	/* onvif.h:1731 */
class _wsnt__NotificationProducerRP;	/* onvif.h:1773 */
class _wsnt__SubscriptionManagerRP;	/* onvif.h:1775 */
class _wsnt__Notify;	/* onvif.h:1777 */
class _wsnt__UseRaw;	/* onvif.h:1779 */
class _wsnt__Subscribe_SubscriptionPolicy;	/* onvif.h:25875 */
class _wsnt__Subscribe;	/* onvif.h:1781 */
class _wsnt__SubscribeResponse;	/* onvif.h:1783 */
class _wsnt__GetCurrentMessage;	/* onvif.h:1785 */
class _wsnt__GetCurrentMessageResponse;	/* onvif.h:1787 */
class _wsnt__GetMessages;	/* onvif.h:1789 */
class _wsnt__GetMessagesResponse;	/* onvif.h:1791 */
class _wsnt__DestroyPullPoint;	/* onvif.h:1793 */
class _wsnt__DestroyPullPointResponse;	/* onvif.h:1795 */
class _wsnt__CreatePullPoint;	/* onvif.h:1797 */
class _wsnt__CreatePullPointResponse;	/* onvif.h:1799 */
class _wsnt__Renew;	/* onvif.h:1801 */
class _wsnt__RenewResponse;	/* onvif.h:1803 */
class _wsnt__Unsubscribe;	/* onvif.h:1805 */
class _wsnt__UnsubscribeResponse;	/* onvif.h:1807 */
class _wsnt__PauseSubscription;	/* onvif.h:1809 */
class _wsnt__PauseSubscriptionResponse;	/* onvif.h:1811 */
class _wsnt__ResumeSubscription;	/* onvif.h:1813 */
class _wsnt__ResumeSubscriptionResponse;	/* onvif.h:1815 */
class _wsrfbf__BaseFaultType_ErrorCode;	/* onvif.h:26498 */
class _wsrfbf__BaseFaultType_Description;	/* onvif.h:26521 */
class _wsrfbf__BaseFaultType_FaultCause;	/* onvif.h:26539 */
class wsrfbf__BaseFaultType;	/* onvif.h:1817 */
class wstop__Documentation;	/* onvif.h:1819 */
class wstop__ExtensibleDocumented;	/* onvif.h:1821 */
class wstop__QueryExpressionType;	/* onvif.h:1823 */
class tds__StorageConfiguration;	/* onvif.h:393 */
class tt__VideoSource;	/* onvif.h:807 */
class tt__AudioSource;	/* onvif.h:813 */
class tt__VideoSourceConfiguration;	/* onvif.h:823 */
class tt__VideoEncoderConfiguration;	/* onvif.h:851 */
class tt__JpegOptions2;	/* onvif.h:869 */
class tt__Mpeg4Options2;	/* onvif.h:873 */
class tt__H264Options2;	/* onvif.h:877 */
class tt__VideoEncoder2Configuration;	/* onvif.h:879 */
class tt__AudioSourceConfiguration;	/* onvif.h:887 */
class tt__AudioEncoderConfiguration;	/* onvif.h:893 */
class tt__AudioEncoder2Configuration;	/* onvif.h:899 */
class tt__VideoAnalyticsConfiguration;	/* onvif.h:903 */
class tt__MetadataConfiguration;	/* onvif.h:905 */
class tt__VideoOutput;	/* onvif.h:923 */
class tt__VideoOutputConfiguration;	/* onvif.h:927 */
class tt__AudioOutput;	/* onvif.h:941 */
class tt__AudioOutputConfiguration;	/* onvif.h:943 */
class tt__AudioDecoderConfiguration;	/* onvif.h:947 */
class tt__NetworkInterface;	/* onvif.h:969 */
class tt__CertificateUsage;	/* onvif.h:1177 */
class tt__RelayOutput;	/* onvif.h:1195 */
class tt__DigitalInput;	/* onvif.h:1197 */
class tt__PTZNode;	/* onvif.h:1199 */
class tt__PTZConfiguration;	/* onvif.h:1209 */
class tt__EventFilter;	/* onvif.h:1509 */
class tt__AnalyticsEngine;	/* onvif.h:1583 */
class tt__AnalyticsEngineInput;	/* onvif.h:1595 */
class tt__AnalyticsEngineControl;	/* onvif.h:1605 */
class tt__OSDConfiguration;	/* onvif.h:1659 */
class wsnt__SubscribeCreationFailedFaultType;	/* onvif.h:1733 */
class wsnt__InvalidFilterFaultType;	/* onvif.h:1735 */
class wsnt__TopicExpressionDialectUnknownFaultType;	/* onvif.h:1737 */
class wsnt__InvalidTopicExpressionFaultType;	/* onvif.h:1739 */
class wsnt__TopicNotSupportedFaultType;	/* onvif.h:1741 */
class wsnt__MultipleTopicsSpecifiedFaultType;	/* onvif.h:1743 */
class wsnt__InvalidProducerPropertiesExpressionFaultType;	/* onvif.h:1745 */
class wsnt__InvalidMessageContentExpressionFaultType;	/* onvif.h:1747 */
class wsnt__UnrecognizedPolicyRequestFaultType;	/* onvif.h:1749 */
class wsnt__UnsupportedPolicyRequestFaultType;	/* onvif.h:1751 */
class wsnt__NotifyMessageNotSupportedFaultType;	/* onvif.h:1753 */
class wsnt__UnacceptableInitialTerminationTimeFaultType;	/* onvif.h:1755 */
class wsnt__NoCurrentMessageOnTopicFaultType;	/* onvif.h:1757 */
class wsnt__UnableToGetMessagesFaultType;	/* onvif.h:1759 */
class wsnt__UnableToDestroyPullPointFaultType;	/* onvif.h:1761 */
class wsnt__UnableToCreatePullPointFaultType;	/* onvif.h:1763 */
class wsnt__UnacceptableTerminationTimeFaultType;	/* onvif.h:1765 */
class wsnt__UnableToDestroySubscriptionFaultType;	/* onvif.h:1767 */
class wsnt__PauseFailedFaultType;	/* onvif.h:1769 */
class wsnt__ResumeFailedFaultType;	/* onvif.h:1771 */
class _wstop__TopicNamespaceType_Topic;	/* onvif.h:30635 */
class wstop__TopicNamespaceType;	/* onvif.h:1825 */
class wstop__TopicType;	/* onvif.h:1827 */
class wstop__TopicSetType;	/* onvif.h:1829 */
class tt__OSDReference;	/* onvif.h:1627 */
struct __tds__GetServices;	/* onvif.h:31370 */
struct __tds__GetServiceCapabilities;	/* onvif.h:31439 */
struct __tds__GetDeviceInformation;	/* onvif.h:31507 */
struct __tds__SetSystemDateAndTime;	/* onvif.h:31589 */
struct __tds__GetSystemDateAndTime;	/* onvif.h:31663 */
struct __tds__SetSystemFactoryDefault;	/* onvif.h:31731 */
struct __tds__UpgradeSystemFirmware;	/* onvif.h:31805 */
struct __tds__SystemReboot;	/* onvif.h:31873 */
struct __tds__RestoreSystem;	/* onvif.h:31949 */
struct __tds__GetSystemBackup;	/* onvif.h:32024 */
struct __tds__GetSystemLog;	/* onvif.h:32093 */
struct __tds__GetSystemSupportInformation;	/* onvif.h:32161 */
struct __tds__GetScopes;	/* onvif.h:32244 */
struct __tds__SetScopes;	/* onvif.h:32320 */
struct __tds__AddScopes;	/* onvif.h:32392 */
struct __tds__RemoveScopes;	/* onvif.h:32466 */
struct __tds__GetDiscoveryMode;	/* onvif.h:32538 */
struct __tds__SetDiscoveryMode;	/* onvif.h:32611 */
struct __tds__GetRemoteDiscoveryMode;	/* onvif.h:32685 */
struct __tds__SetRemoteDiscoveryMode;	/* onvif.h:32759 */
struct __tds__GetDPAddresses;	/* onvif.h:32831 */
struct __tds__GetEndpointReference;	/* onvif.h:32905 */
struct __tds__GetRemoteUser;	/* onvif.h:32979 */
struct __tds__SetRemoteUser;	/* onvif.h:33058 */
struct __tds__GetUsers;	/* onvif.h:33130 */
struct __tds__CreateUsers;	/* onvif.h:33210 */
struct __tds__DeleteUsers;	/* onvif.h:33285 */
struct __tds__SetUser;	/* onvif.h:33358 */
struct __tds__GetWsdlUrl;	/* onvif.h:33427 */
struct __tds__GetPasswordComplexityOptions;	/* onvif.h:33496 */
struct __tds__GetPasswordComplexityConfiguration;	/* onvif.h:33564 */
struct __tds__SetPasswordComplexityConfiguration;	/* onvif.h:33632 */
struct __tds__GetPasswordHistoryConfiguration;	/* onvif.h:33700 */
struct __tds__SetPasswordHistoryConfiguration;	/* onvif.h:33768 */
struct __tds__GetAuthFailureWarningOptions;	/* onvif.h:33837 */
struct __tds__GetAuthFailureWarningConfiguration;	/* onvif.h:33906 */
struct __tds__SetAuthFailureWarningConfiguration;	/* onvif.h:33974 */
struct __tds__GetCapabilities;	/* onvif.h:34044 */
struct __tds__SetDPAddresses;	/* onvif.h:34117 */
struct __tds__GetHostname;	/* onvif.h:34188 */
struct __tds__SetHostname;	/* onvif.h:34263 */
struct __tds__SetHostnameFromDHCP;	/* onvif.h:34331 */
struct __tds__GetDNS;	/* onvif.h:34401 */
struct __tds__SetDNS;	/* onvif.h:34471 */
struct __tds__GetNTP;	/* onvif.h:34542 */
struct __tds__SetNTP;	/* onvif.h:34620 */
struct __tds__GetDynamicDNS;	/* onvif.h:34692 */
struct __tds__SetDynamicDNS;	/* onvif.h:34764 */
struct __tds__GetNetworkInterfaces;	/* onvif.h:34836 */
struct __tds__SetNetworkInterfaces;	/* onvif.h:34913 */
struct __tds__GetNetworkProtocols;	/* onvif.h:34984 */
struct __tds__SetNetworkProtocols;	/* onvif.h:35055 */
struct __tds__GetNetworkDefaultGateway;	/* onvif.h:35126 */
struct __tds__SetNetworkDefaultGateway;	/* onvif.h:35196 */
struct __tds__GetZeroConfiguration;	/* onvif.h:35271 */
struct __tds__SetZeroConfiguration;	/* onvif.h:35340 */
struct __tds__GetIPAddressFilter;	/* onvif.h:35412 */
struct __tds__SetIPAddressFilter;	/* onvif.h:35486 */
struct __tds__AddIPAddressFilter;	/* onvif.h:35559 */
struct __tds__RemoveIPAddressFilter;	/* onvif.h:35632 */
struct __tds__GetAccessPolicy;	/* onvif.h:35714 */
struct __tds__SetAccessPolicy;	/* onvif.h:35787 */
struct __tds__CreateCertificate;	/* onvif.h:35854 */
struct __tds__GetCertificates;	/* onvif.h:35921 */
struct __tds__GetCertificatesStatus;	/* onvif.h:35988 */
struct __tds__SetCertificatesStatus;	/* onvif.h:36055 */
struct __tds__DeleteCertificates;	/* onvif.h:36122 */
struct __tds__GetPkcs10Request;	/* onvif.h:36189 */
struct __tds__LoadCertificates;	/* onvif.h:36256 */
struct __tds__GetClientCertificateMode;	/* onvif.h:36323 */
struct __tds__SetClientCertificateMode;	/* onvif.h:36390 */
struct __tds__GetRelayOutputs;	/* onvif.h:36460 */
struct __tds__SetRelayOutputSettings;	/* onvif.h:36530 */
struct __tds__SetRelayOutputState;	/* onvif.h:36600 */
struct __tds__SendAuxiliaryCommand;	/* onvif.h:36699 */
struct __tds__GetCACertificates;	/* onvif.h:36766 */
struct __tds__LoadCertificateWithPrivateKey;	/* onvif.h:36833 */
struct __tds__GetCertificateInformation;	/* onvif.h:36900 */
struct __tds__LoadCACertificates;	/* onvif.h:36967 */
struct __tds__CreateDot1XConfiguration;	/* onvif.h:37034 */
struct __tds__SetDot1XConfiguration;	/* onvif.h:37101 */
struct __tds__GetDot1XConfiguration;	/* onvif.h:37168 */
struct __tds__GetDot1XConfigurations;	/* onvif.h:37235 */
struct __tds__DeleteDot1XConfiguration;	/* onvif.h:37302 */
struct __tds__GetDot11Capabilities;	/* onvif.h:37371 */
struct __tds__GetDot11Status;	/* onvif.h:37441 */
struct __tds__ScanAvailableDot11Networks;	/* onvif.h:37511 */
struct __tds__GetSystemUris;	/* onvif.h:37598 */
struct __tds__StartFirmwareUpgrade;	/* onvif.h:37694 */
struct __tds__StartSystemRestore;	/* onvif.h:37789 */
struct __tds__GetStorageConfigurations;	/* onvif.h:37859 */
struct __tds__CreateStorageConfiguration;	/* onvif.h:37930 */
struct __tds__GetStorageConfiguration;	/* onvif.h:38000 */
struct __tds__SetStorageConfiguration;	/* onvif.h:38069 */
struct __tds__DeleteStorageConfiguration;	/* onvif.h:38139 */
struct __tds__GetGeoLocation;	/* onvif.h:38209 */
struct __tds__SetGeoLocation;	/* onvif.h:38279 */
struct __tds__DeleteGeoLocation;	/* onvif.h:38348 */
struct __tds__SetHashingAlgorithm;	/* onvif.h:38418 */

/* xop.h:59 */
#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (8)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
struct SOAP_CMAC _xop__Include {
      public:
        unsigned char *__ptr;
        int __size;
        /** Optional element 'id' of XML schema type 'xsd:string' */
        char *id;
        /** Optional element 'type' of XML schema type 'xsd:string' */
        char *type;
        /** Optional element 'options' of XML schema type 'xsd:string' */
        char *options;
      public:
        /** Return unique type id SOAP_TYPE__xop__Include */
        long soap_type() const { return SOAP_TYPE__xop__Include; }
        /** Constructor with member initializations */
        _xop__Include() : __ptr(), __size(), id(), type(), options() { }
        /** Friend allocator */
        friend SOAP_FMAC1 _xop__Include * SOAP_FMAC2 soap_instantiate__xop__Include(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:65 */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (12)
/* complex XML schema type 'wsa5:EndpointReferenceType': */
struct SOAP_CMAC wsa5__EndpointReferenceType {
      public:
        /** Required element 'wsa5:Address' of XML schema type 'xsd:string' */
        char *Address;
        /** Optional element 'wsa5:ReferenceParameters' of XML schema type 'wsa5:ReferenceParametersType' */
        struct wsa5__ReferenceParametersType *ReferenceParameters;
        /** Optional element 'wsa5:Metadata' of XML schema type 'wsa5:MetadataType' */
        struct wsa5__MetadataType *Metadata;
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__EndpointReferenceType */
        long soap_type() const { return SOAP_TYPE_wsa5__EndpointReferenceType; }
        /** Constructor with member initializations */
        wsa5__EndpointReferenceType() : Address(), ReferenceParameters(), Metadata(), __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:68 */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (13)
/* complex XML schema type 'wsa5:ReferenceParametersType': */
struct SOAP_CMAC wsa5__ReferenceParametersType {
      public:
        /** Optional element 'chan:ChannelInstance' of XML schema type 'xsd:int' */
        int *chan__ChannelInstance;
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__ReferenceParametersType */
        long soap_type() const { return SOAP_TYPE_wsa5__ReferenceParametersType; }
        /** Constructor with member initializations */
        wsa5__ReferenceParametersType() : chan__ChannelInstance(), __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:71 */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (14)
/* complex XML schema type 'wsa5:MetadataType': */
struct SOAP_CMAC wsa5__MetadataType {
      public:
        /** Sequence of elements '-any' of XML schema type 'xsd:anyType' stored in dynamic array __any of length __size */
        int __size;
        char **__any;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__MetadataType */
        long soap_type() const { return SOAP_TYPE_wsa5__MetadataType; }
        /** Constructor with member initializations */
        wsa5__MetadataType() : __size(), __any(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:86 */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (16)
/* complex XML schema type 'wsa5:ProblemActionType': */
struct SOAP_CMAC wsa5__ProblemActionType {
      public:
        /** Optional element 'wsa5:Action' of XML schema type 'xsd:string' */
        char *Action;
        /** Optional element 'wsa5:SoapAction' of XML schema type 'xsd:string' */
        char *SoapAction;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__ProblemActionType */
        long soap_type() const { return SOAP_TYPE_wsa5__ProblemActionType; }
        /** Constructor with member initializations */
        wsa5__ProblemActionType() : Action(), SoapAction(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:74 */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (15)
/* simple XML schema type 'wsa5:RelatesToType': */
struct SOAP_CMAC wsa5__RelatesToType {
      public:
        /** Simple content of XML schema type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'RelationshipType' of XML schema type 'wsa5:RelationshipTypeOpenEnum' */
        char *RelationshipType;
        /** Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType' */
        char *__anyAttribute;
      public:
        /** Return unique type id SOAP_TYPE_wsa5__RelatesToType */
        long soap_type() const { return SOAP_TYPE_wsa5__RelatesToType; }
        /** Constructor with member initializations */
        wsa5__RelatesToType() : __item(), RelationshipType(), __anyAttribute() { }
        /** Friend allocator */
        friend SOAP_FMAC1 wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:260 */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (41)
/* simple XML schema type 'chan:ChannelInstanceType': */
struct SOAP_CMAC chan__ChannelInstanceType {
      public:
        /** Simple content of XML schema type 'xsd:int' wrapped by this struct */
        int __item;
        /** Optional attribute 'wsa5:IsReferenceParameter' of XML schema type 'wsa5:IsReferenceParameter' */
        enum _wsa5__IsReferenceParameter wsa5__IsReferenceParameter;	/**< initialized with default value = (enum _wsa5__IsReferenceParameter)0 */
      public:
        /** Return unique type id SOAP_TYPE_chan__ChannelInstanceType */
        long soap_type() const { return SOAP_TYPE_chan__ChannelInstanceType; }
        /** Constructor with member initializations */
        chan__ChannelInstanceType() : __item(), wsa5__IsReferenceParameter((enum _wsa5__IsReferenceParameter)0) { }
        /** Friend allocator */
        friend SOAP_FMAC1 chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa5.h:266 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (42)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Optional element 'wsa5:MessageID' of XML schema type 'wsa5:MessageID' */
        char *wsa5__MessageID;
        /** Optional element 'wsa5:RelatesTo' of XML schema type 'wsa5:RelatesTo' */
        struct wsa5__RelatesToType *wsa5__RelatesTo;
        /** Optional element 'wsa5:From' of XML schema type 'wsa5:From' */
        struct wsa5__EndpointReferenceType *wsa5__From;
        /** MustUnderstand */
        struct wsa5__EndpointReferenceType *wsa5__ReplyTo;
        /** MustUnderstand */
        struct wsa5__EndpointReferenceType *wsa5__FaultTo;
        /** MustUnderstand */
        char *wsa5__To;
        /** MustUnderstand */
        char *wsa5__Action;
        /** Optional element 'chan:ChannelInstance' of XML schema type 'chan:ChannelInstanceType' */
        struct chan__ChannelInstanceType *chan__ChannelInstance;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : wsa5__MessageID(), wsa5__RelatesTo(), wsa5__From(), wsa5__ReplyTo(), wsa5__FaultTo(), wsa5__To(), wsa5__Action(), chan__ChannelInstance() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:283 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (48)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:284 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (50)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:285 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (52)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa5.h:290 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (56)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* onvif.h:181 */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (57)
/* Type xsd__anyType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:anyType': */
class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyType); }
      public:
        /// Constructor with default initializations
        xsd__anyType() : __item(), soap() { }
        /// Destructor
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:188 */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (59)
/* complex XML schema type 'SOAP-ENV:Envelope': */
struct SOAP_CMAC SOAP_ENV__Envelope {
      public:
        /** Optional element 'SOAP-ENV:Header' of XML schema type 'SOAP-ENV:Header' */
        struct SOAP_ENV__Header *SOAP_ENV__Header;
        /** Optional element 'SOAP-ENV:Body' of XML schema type 'xsd:anyType' */
        char *SOAP_ENV__Body;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Envelope */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Envelope; }
        /** Constructor with member initializations */
        SOAP_ENV__Envelope() : SOAP_ENV__Header(), SOAP_ENV__Body() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Envelope * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Envelope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:194 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (63)
/* binary data attached as MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64: */
class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        /// Destructor
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:202 */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (64)
/* hexBinary XML schema type: */
class SOAP_CMAC xsd__hexBinary {
      public:
        unsigned char *__ptr;
        int __size;
      public:
        /// Return unique type id SOAP_TYPE_xsd__hexBinary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__hexBinary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__hexBinary, default initialized and not managed by a soap context
        virtual xsd__hexBinary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__hexBinary); }
      public:
        /// Constructor with default initializations
        xsd__hexBinary() : __ptr(), __size() { }
        /// Destructor
        virtual ~xsd__hexBinary() { }
        /// Friend allocator used by soap_new_xsd__hexBinary(struct soap*, int)
        friend SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:212 */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType__
#define SOAP_TYPE_wsa5__EndpointReferenceType__ (65)
/* Type wsa5__EndpointReferenceType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'wsa5:EndpointReferenceType': */
class SOAP_CMAC wsa5__EndpointReferenceType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'wsa5:EndpointReferenceType' wrapped by this struct
        struct wsa5__EndpointReferenceType __item;
      public:
        /// Return unique type id SOAP_TYPE_wsa5__EndpointReferenceType__
        virtual long soap_type(void) const { return SOAP_TYPE_wsa5__EndpointReferenceType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsa5__EndpointReferenceType__, default initialized and not managed by a soap context
        virtual wsa5__EndpointReferenceType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsa5__EndpointReferenceType__); }
      public:
        /// Constructor with default initializations
        wsa5__EndpointReferenceType__() : __item() { }
        /// Destructor
        virtual ~wsa5__EndpointReferenceType__() { }
        /// Friend allocator used by soap_new_wsa5__EndpointReferenceType__(struct soap*, int)
        friend SOAP_FMAC1 wsa5__EndpointReferenceType__ * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:219 */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope_
#define SOAP_TYPE_SOAP_ENV__Envelope_ (66)
/* Type SOAP_ENV__Envelope_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'SOAP-ENV:Envelope': */
class SOAP_CMAC SOAP_ENV__Envelope_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'SOAP-ENV:Envelope' wrapped by this struct
        struct SOAP_ENV__Envelope __item;
      public:
        /// Return unique type id SOAP_TYPE_SOAP_ENV__Envelope_
        virtual long soap_type(void) const { return SOAP_TYPE_SOAP_ENV__Envelope_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type SOAP_ENV__Envelope_, default initialized and not managed by a soap context
        virtual SOAP_ENV__Envelope_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(SOAP_ENV__Envelope_); }
      public:
        /// Constructor with default initializations
        SOAP_ENV__Envelope_() : __item() { }
        /// Destructor
        virtual ~SOAP_ENV__Envelope_() { }
        /// Friend allocator used by soap_new_SOAP_ENV__Envelope_(struct soap*, int)
        friend SOAP_FMAC1 SOAP_ENV__Envelope_ * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Envelope_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:226 */
#ifndef SOAP_TYPE_SOAP_ENV__Fault_
#define SOAP_TYPE_SOAP_ENV__Fault_ (67)
/* Type SOAP_ENV__Fault_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'SOAP-ENV:Fault': */
class SOAP_CMAC SOAP_ENV__Fault_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'SOAP-ENV:Fault' wrapped by this struct
        struct SOAP_ENV__Fault __item;
      public:
        /// Return unique type id SOAP_TYPE_SOAP_ENV__Fault_
        virtual long soap_type(void) const { return SOAP_TYPE_SOAP_ENV__Fault_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type SOAP_ENV__Fault_, default initialized and not managed by a soap context
        virtual SOAP_ENV__Fault_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(SOAP_ENV__Fault_); }
      public:
        /// Constructor with default initializations
        SOAP_ENV__Fault_() : __item() { }
        /// Destructor
        virtual ~SOAP_ENV__Fault_() { }
        /// Friend allocator used by soap_new_SOAP_ENV__Fault_(struct soap*, int)
        friend SOAP_FMAC1 SOAP_ENV__Fault_ * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:236 */
#ifndef SOAP_TYPE_xsd__NCName__
#define SOAP_TYPE_xsd__NCName__ (69)
/* Type xsd__NCName__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:NCName': */
class SOAP_CMAC xsd__NCName__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:NCName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__NCName__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__NCName__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__NCName__, default initialized and not managed by a soap context
        virtual xsd__NCName__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__NCName__); }
      public:
        /// Constructor with default initializations
        xsd__NCName__() : __item() { }
        /// Destructor
        virtual ~xsd__NCName__() { }
        /// Friend allocator used by soap_new_xsd__NCName__(struct soap*, int)
        friend SOAP_FMAC1 xsd__NCName__ * SOAP_FMAC2 soap_instantiate_xsd__NCName__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:243 */
#ifndef SOAP_TYPE_xsd__QName__
#define SOAP_TYPE_xsd__QName__ (70)
/* Type xsd__QName__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:QName': */
class SOAP_CMAC xsd__QName__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:QName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__QName__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__QName__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__QName__, default initialized and not managed by a soap context
        virtual xsd__QName__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__QName__); }
      public:
        /// Constructor with default initializations
        xsd__QName__() : __item() { }
        /// Destructor
        virtual ~xsd__QName__() { }
        /// Friend allocator used by soap_new_xsd__QName__(struct soap*, int)
        friend SOAP_FMAC1 xsd__QName__ * SOAP_FMAC2 soap_instantiate_xsd__QName__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:253 */
#ifndef SOAP_TYPE_xsd__anySimpleType__
#define SOAP_TYPE_xsd__anySimpleType__ (72)
/* Type xsd__anySimpleType__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:anySimpleType': */
class SOAP_CMAC xsd__anySimpleType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anySimpleType' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anySimpleType__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anySimpleType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anySimpleType__, default initialized and not managed by a soap context
        virtual xsd__anySimpleType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anySimpleType__); }
      public:
        /// Constructor with default initializations
        xsd__anySimpleType__() : __item() { }
        /// Destructor
        virtual ~xsd__anySimpleType__() { }
        /// Friend allocator used by soap_new_xsd__anySimpleType__(struct soap*, int)
        friend SOAP_FMAC1 xsd__anySimpleType__ * SOAP_FMAC2 soap_instantiate_xsd__anySimpleType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:263 */
#ifndef SOAP_TYPE_xsd__anyURI__
#define SOAP_TYPE_xsd__anyURI__ (74)
/* Type xsd__anyURI__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:anyURI': */
class SOAP_CMAC xsd__anyURI__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyURI' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyURI__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyURI__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyURI__, default initialized and not managed by a soap context
        virtual xsd__anyURI__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyURI__); }
      public:
        /// Constructor with default initializations
        xsd__anyURI__() : __item() { }
        /// Destructor
        virtual ~xsd__anyURI__() { }
        /// Friend allocator used by soap_new_xsd__anyURI__(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyURI__ * SOAP_FMAC2 soap_instantiate_xsd__anyURI__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:270 */
#ifndef SOAP_TYPE_xsd__base64Binary__
#define SOAP_TYPE_xsd__base64Binary__ (75)
/* Type xsd__base64Binary__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:base64Binary': */
class SOAP_CMAC xsd__base64Binary__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary__, default initialized and not managed by a soap context
        virtual xsd__base64Binary__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary__); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary__() : __item() { }
        /// Destructor
        virtual ~xsd__base64Binary__() { }
        /// Friend allocator used by soap_new_xsd__base64Binary__(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary__ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:277 */
#ifndef SOAP_TYPE_xsd__boolean_
#define SOAP_TYPE_xsd__boolean_ (76)
/* Type xsd__boolean_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:boolean': */
class SOAP_CMAC xsd__boolean_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__boolean_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean_, default initialized and not managed by a soap context
        virtual xsd__boolean_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__boolean_); }
      public:
        /// Constructor with default initializations
        xsd__boolean_() : __item() { }
        /// Destructor
        virtual ~xsd__boolean_() { }
        /// Friend allocator used by soap_new_xsd__boolean_(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean_ * SOAP_FMAC2 soap_instantiate_xsd__boolean_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:284 */
#ifndef SOAP_TYPE_xsd__dateTime_
#define SOAP_TYPE_xsd__dateTime_ (78)
/* Type xsd__dateTime_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:dateTime': */
class SOAP_CMAC xsd__dateTime_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__dateTime_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__dateTime_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime_, default initialized and not managed by a soap context
        virtual xsd__dateTime_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__dateTime_); }
      public:
        /// Constructor with default initializations
        xsd__dateTime_() : __item() { }
        /// Destructor
        virtual ~xsd__dateTime_() { }
        /// Friend allocator used by soap_new_xsd__dateTime_(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime_ * SOAP_FMAC2 soap_instantiate_xsd__dateTime_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:291 */
#ifndef SOAP_TYPE_xsd__double_
#define SOAP_TYPE_xsd__double_ (80)
/* Type xsd__double_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:double': */
class SOAP_CMAC xsd__double_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:double' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__double_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__double_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__double_, default initialized and not managed by a soap context
        virtual xsd__double_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__double_); }
      public:
        /// Constructor with default initializations
        xsd__double_() : __item() { }
        /// Destructor
        virtual ~xsd__double_() { }
        /// Friend allocator used by soap_new_xsd__double_(struct soap*, int)
        friend SOAP_FMAC1 xsd__double_ * SOAP_FMAC2 soap_instantiate_xsd__double_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:301 */
#ifndef SOAP_TYPE_xsd__duration__
#define SOAP_TYPE_xsd__duration__ (83)
/* Type xsd__duration__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:duration': */
class SOAP_CMAC xsd__duration__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:duration' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__duration__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__duration__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__duration__, default initialized and not managed by a soap context
        virtual xsd__duration__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__duration__); }
      public:
        /// Constructor with default initializations
        xsd__duration__() : __item() { }
        /// Destructor
        virtual ~xsd__duration__() { }
        /// Friend allocator used by soap_new_xsd__duration__(struct soap*, int)
        friend SOAP_FMAC1 xsd__duration__ * SOAP_FMAC2 soap_instantiate_xsd__duration__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:308 */
#ifndef SOAP_TYPE_xsd__float_
#define SOAP_TYPE_xsd__float_ (84)
/* Type xsd__float_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:float': */
class SOAP_CMAC xsd__float_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:float' wrapped by this struct
        float __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__float_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__float_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__float_, default initialized and not managed by a soap context
        virtual xsd__float_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__float_); }
      public:
        /// Constructor with default initializations
        xsd__float_() : __item() { }
        /// Destructor
        virtual ~xsd__float_() { }
        /// Friend allocator used by soap_new_xsd__float_(struct soap*, int)
        friend SOAP_FMAC1 xsd__float_ * SOAP_FMAC2 soap_instantiate_xsd__float_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:315 */
#ifndef SOAP_TYPE_xsd__hexBinary__
#define SOAP_TYPE_xsd__hexBinary__ (86)
/* Type xsd__hexBinary__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:hexBinary': */
class SOAP_CMAC xsd__hexBinary__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:hexBinary' wrapped by this struct
        xsd__hexBinary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__hexBinary__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__hexBinary__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__hexBinary__, default initialized and not managed by a soap context
        virtual xsd__hexBinary__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__hexBinary__); }
      public:
        /// Constructor with default initializations
        xsd__hexBinary__() : __item() { }
        /// Destructor
        virtual ~xsd__hexBinary__() { }
        /// Friend allocator used by soap_new_xsd__hexBinary__(struct soap*, int)
        friend SOAP_FMAC1 xsd__hexBinary__ * SOAP_FMAC2 soap_instantiate_xsd__hexBinary__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:322 */
#ifndef SOAP_TYPE_xsd__int_
#define SOAP_TYPE_xsd__int_ (87)
/* Type xsd__int_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:int': */
class SOAP_CMAC xsd__int_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__int_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__int_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int_, default initialized and not managed by a soap context
        virtual xsd__int_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__int_); }
      public:
        /// Constructor with default initializations
        xsd__int_() : __item() { }
        /// Destructor
        virtual ~xsd__int_() { }
        /// Friend allocator used by soap_new_xsd__int_(struct soap*, int)
        friend SOAP_FMAC1 xsd__int_ * SOAP_FMAC2 soap_instantiate_xsd__int_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:332 */
#ifndef SOAP_TYPE_xsd__integer__
#define SOAP_TYPE_xsd__integer__ (89)
/* Type xsd__integer__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:integer': */
class SOAP_CMAC xsd__integer__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:integer' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__integer__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__integer__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__integer__, default initialized and not managed by a soap context
        virtual xsd__integer__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__integer__); }
      public:
        /// Constructor with default initializations
        xsd__integer__() : __item() { }
        /// Destructor
        virtual ~xsd__integer__() { }
        /// Friend allocator used by soap_new_xsd__integer__(struct soap*, int)
        friend SOAP_FMAC1 xsd__integer__ * SOAP_FMAC2 soap_instantiate_xsd__integer__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:342 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger__
#define SOAP_TYPE_xsd__nonNegativeInteger__ (91)
/* Type xsd__nonNegativeInteger__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:nonNegativeInteger': */
class SOAP_CMAC xsd__nonNegativeInteger__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:nonNegativeInteger' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__nonNegativeInteger__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__nonNegativeInteger__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__nonNegativeInteger__, default initialized and not managed by a soap context
        virtual xsd__nonNegativeInteger__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__nonNegativeInteger__); }
      public:
        /// Constructor with default initializations
        xsd__nonNegativeInteger__() : __item() { }
        /// Destructor
        virtual ~xsd__nonNegativeInteger__() { }
        /// Friend allocator used by soap_new_xsd__nonNegativeInteger__(struct soap*, int)
        friend SOAP_FMAC1 xsd__nonNegativeInteger__ * SOAP_FMAC2 soap_instantiate_xsd__nonNegativeInteger__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:349 */
#ifndef SOAP_TYPE_xsd__string_
#define SOAP_TYPE_xsd__string_ (92)
/* Type xsd__string_ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:string': */
class SOAP_CMAC xsd__string_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__string_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string_, default initialized and not managed by a soap context
        virtual xsd__string_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__string_); }
      public:
        /// Constructor with default initializations
        xsd__string_() : __item() { }
        /// Destructor
        virtual ~xsd__string_() { }
        /// Friend allocator used by soap_new_xsd__string_(struct soap*, int)
        friend SOAP_FMAC1 xsd__string_ * SOAP_FMAC2 soap_instantiate_xsd__string_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:359 */
#ifndef SOAP_TYPE_xsd__token__
#define SOAP_TYPE_xsd__token__ (94)
/* Type xsd__token__ is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'xsd:token': */
class SOAP_CMAC xsd__token__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:token' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__token__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__token__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__token__, default initialized and not managed by a soap context
        virtual xsd__token__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__token__); }
      public:
        /// Constructor with default initializations
        xsd__token__() : __item() { }
        /// Destructor
        virtual ~xsd__token__() { }
        /// Friend allocator used by soap_new_xsd__token__(struct soap*, int)
        friend SOAP_FMAC1 xsd__token__ * SOAP_FMAC2 soap_instantiate_xsd__token__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1919 */
#ifndef SOAP_TYPE_tds__AutoGeoModes_
#define SOAP_TYPE_tds__AutoGeoModes_ (830)
/* simple XML schema type 'tds:AutoGeoModes': */
class SOAP_CMAC tds__AutoGeoModes_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tds:AutoGeoModes' wrapped by this struct
        enum tds__AutoGeoModes __item;
      public:
        /// Return unique type id SOAP_TYPE_tds__AutoGeoModes_
        virtual long soap_type(void) const { return SOAP_TYPE_tds__AutoGeoModes_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__AutoGeoModes_, default initialized and not managed by a soap context
        virtual tds__AutoGeoModes_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__AutoGeoModes_); }
      public:
        /// Constructor with default initializations
        tds__AutoGeoModes_() : __item() { }
        /// Destructor
        virtual ~tds__AutoGeoModes_() { }
        /// Friend allocator used by soap_new_tds__AutoGeoModes_(struct soap*, int)
        friend SOAP_FMAC1 tds__AutoGeoModes_ * SOAP_FMAC2 soap_instantiate_tds__AutoGeoModes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1954 */
#ifndef SOAP_TYPE_tds__StorageType_
#define SOAP_TYPE_tds__StorageType_ (832)
/* simple XML schema type 'tds:StorageType': */
class SOAP_CMAC tds__StorageType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tds:StorageType' wrapped by this struct
        enum tds__StorageType __item;
      public:
        /// Return unique type id SOAP_TYPE_tds__StorageType_
        virtual long soap_type(void) const { return SOAP_TYPE_tds__StorageType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__StorageType_, default initialized and not managed by a soap context
        virtual tds__StorageType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__StorageType_); }
      public:
        /// Constructor with default initializations
        tds__StorageType_() : __item() { }
        /// Destructor
        virtual ~tds__StorageType_() { }
        /// Friend allocator used by soap_new_tds__StorageType_(struct soap*, int)
        friend SOAP_FMAC1 tds__StorageType_ * SOAP_FMAC2 soap_instantiate_tds__StorageType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1979 */
#ifndef SOAP_TYPE_tt__Name__
#define SOAP_TYPE_tt__Name__ (834)
/* simple XML schema type 'tt:Name': */
class SOAP_CMAC tt__Name__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Name' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Name__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Name__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Name__, default initialized and not managed by a soap context
        virtual tt__Name__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Name__); }
      public:
        /// Constructor with default initializations
        tt__Name__() : __item() { }
        /// Destructor
        virtual ~tt__Name__() { }
        /// Friend allocator used by soap_new_tt__Name__(struct soap*, int)
        friend SOAP_FMAC1 tt__Name__ * SOAP_FMAC2 soap_instantiate_tt__Name__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2009 */
#ifndef SOAP_TYPE_tt__RotateMode_
#define SOAP_TYPE_tt__RotateMode_ (836)
/* simple XML schema type 'tt:RotateMode': */
class SOAP_CMAC tt__RotateMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:RotateMode' wrapped by this struct
        enum tt__RotateMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__RotateMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RotateMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RotateMode_, default initialized and not managed by a soap context
        virtual tt__RotateMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RotateMode_); }
      public:
        /// Constructor with default initializations
        tt__RotateMode_() : __item() { }
        /// Destructor
        virtual ~tt__RotateMode_() { }
        /// Friend allocator used by soap_new_tt__RotateMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__RotateMode_ * SOAP_FMAC2 soap_instantiate_tt__RotateMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2026 */
#ifndef SOAP_TYPE_tt__SceneOrientationMode_
#define SOAP_TYPE_tt__SceneOrientationMode_ (838)
/* simple XML schema type 'tt:SceneOrientationMode': */
class SOAP_CMAC tt__SceneOrientationMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:SceneOrientationMode' wrapped by this struct
        enum tt__SceneOrientationMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__SceneOrientationMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SceneOrientationMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SceneOrientationMode_, default initialized and not managed by a soap context
        virtual tt__SceneOrientationMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SceneOrientationMode_); }
      public:
        /// Constructor with default initializations
        tt__SceneOrientationMode_() : __item() { }
        /// Destructor
        virtual ~tt__SceneOrientationMode_() { }
        /// Friend allocator used by soap_new_tt__SceneOrientationMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__SceneOrientationMode_ * SOAP_FMAC2 soap_instantiate_tt__SceneOrientationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2048 */
#ifndef SOAP_TYPE_tt__SceneOrientationOption_
#define SOAP_TYPE_tt__SceneOrientationOption_ (840)
/* simple XML schema type 'tt:SceneOrientationOption': */
class SOAP_CMAC tt__SceneOrientationOption_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:SceneOrientationOption' wrapped by this struct
        enum tt__SceneOrientationOption __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__SceneOrientationOption_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SceneOrientationOption_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SceneOrientationOption_, default initialized and not managed by a soap context
        virtual tt__SceneOrientationOption_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SceneOrientationOption_); }
      public:
        /// Constructor with default initializations
        tt__SceneOrientationOption_() : __item() { }
        /// Destructor
        virtual ~tt__SceneOrientationOption_() { }
        /// Friend allocator used by soap_new_tt__SceneOrientationOption_(struct soap*, int)
        friend SOAP_FMAC1 tt__SceneOrientationOption_ * SOAP_FMAC2 soap_instantiate_tt__SceneOrientationOption_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2107 */
#ifndef SOAP_TYPE_tt__ViewModes_
#define SOAP_TYPE_tt__ViewModes_ (842)
/* simple XML schema type 'tt:ViewModes': */
class SOAP_CMAC tt__ViewModes_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ViewModes' wrapped by this struct
        enum tt__ViewModes __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ViewModes_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ViewModes_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ViewModes_, default initialized and not managed by a soap context
        virtual tt__ViewModes_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ViewModes_); }
      public:
        /// Constructor with default initializations
        tt__ViewModes_() : __item() { }
        /// Destructor
        virtual ~tt__ViewModes_() { }
        /// Friend allocator used by soap_new_tt__ViewModes_(struct soap*, int)
        friend SOAP_FMAC1 tt__ViewModes_ * SOAP_FMAC2 soap_instantiate_tt__ViewModes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2125 */
#ifndef SOAP_TYPE_tt__VideoEncoding_
#define SOAP_TYPE_tt__VideoEncoding_ (844)
/* simple XML schema type 'tt:VideoEncoding': */
class SOAP_CMAC tt__VideoEncoding_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:VideoEncoding' wrapped by this struct
        enum tt__VideoEncoding __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoding_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoding_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoding_, default initialized and not managed by a soap context
        virtual tt__VideoEncoding_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoding_); }
      public:
        /// Constructor with default initializations
        tt__VideoEncoding_() : __item() { }
        /// Destructor
        virtual ~tt__VideoEncoding_() { }
        /// Friend allocator used by soap_new_tt__VideoEncoding_(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoding_ * SOAP_FMAC2 soap_instantiate_tt__VideoEncoding_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2142 */
#ifndef SOAP_TYPE_tt__Mpeg4Profile_
#define SOAP_TYPE_tt__Mpeg4Profile_ (846)
/* simple XML schema type 'tt:Mpeg4Profile': */
class SOAP_CMAC tt__Mpeg4Profile_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Mpeg4Profile' wrapped by this struct
        enum tt__Mpeg4Profile __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Mpeg4Profile_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Mpeg4Profile_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Mpeg4Profile_, default initialized and not managed by a soap context
        virtual tt__Mpeg4Profile_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Mpeg4Profile_); }
      public:
        /// Constructor with default initializations
        tt__Mpeg4Profile_() : __item() { }
        /// Destructor
        virtual ~tt__Mpeg4Profile_() { }
        /// Friend allocator used by soap_new_tt__Mpeg4Profile_(struct soap*, int)
        friend SOAP_FMAC1 tt__Mpeg4Profile_ * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Profile_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2161 */
#ifndef SOAP_TYPE_tt__H264Profile_
#define SOAP_TYPE_tt__H264Profile_ (848)
/* simple XML schema type 'tt:H264Profile': */
class SOAP_CMAC tt__H264Profile_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:H264Profile' wrapped by this struct
        enum tt__H264Profile __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__H264Profile_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__H264Profile_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__H264Profile_, default initialized and not managed by a soap context
        virtual tt__H264Profile_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__H264Profile_); }
      public:
        /// Constructor with default initializations
        tt__H264Profile_() : __item() { }
        /// Destructor
        virtual ~tt__H264Profile_() { }
        /// Friend allocator used by soap_new_tt__H264Profile_(struct soap*, int)
        friend SOAP_FMAC1 tt__H264Profile_ * SOAP_FMAC2 soap_instantiate_tt__H264Profile_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2184 */
#ifndef SOAP_TYPE_tt__VideoEncodingMimeNames_
#define SOAP_TYPE_tt__VideoEncodingMimeNames_ (850)
/* simple XML schema type 'tt:VideoEncodingMimeNames': */
class SOAP_CMAC tt__VideoEncodingMimeNames_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:VideoEncodingMimeNames' wrapped by this struct
        enum tt__VideoEncodingMimeNames __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncodingMimeNames_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncodingMimeNames_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncodingMimeNames_, default initialized and not managed by a soap context
        virtual tt__VideoEncodingMimeNames_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncodingMimeNames_); }
      public:
        /// Constructor with default initializations
        tt__VideoEncodingMimeNames_() : __item() { }
        /// Destructor
        virtual ~tt__VideoEncodingMimeNames_() { }
        /// Friend allocator used by soap_new_tt__VideoEncodingMimeNames_(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncodingMimeNames_ * SOAP_FMAC2 soap_instantiate_tt__VideoEncodingMimeNames_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2206 */
#ifndef SOAP_TYPE_tt__VideoEncodingProfiles_
#define SOAP_TYPE_tt__VideoEncodingProfiles_ (852)
/* simple XML schema type 'tt:VideoEncodingProfiles': */
class SOAP_CMAC tt__VideoEncodingProfiles_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:VideoEncodingProfiles' wrapped by this struct
        enum tt__VideoEncodingProfiles __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncodingProfiles_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncodingProfiles_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncodingProfiles_, default initialized and not managed by a soap context
        virtual tt__VideoEncodingProfiles_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncodingProfiles_); }
      public:
        /// Constructor with default initializations
        tt__VideoEncodingProfiles_() : __item() { }
        /// Destructor
        virtual ~tt__VideoEncodingProfiles_() { }
        /// Friend allocator used by soap_new_tt__VideoEncodingProfiles_(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncodingProfiles_ * SOAP_FMAC2 soap_instantiate_tt__VideoEncodingProfiles_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2224 */
#ifndef SOAP_TYPE_tt__AudioEncoding_
#define SOAP_TYPE_tt__AudioEncoding_ (854)
/* simple XML schema type 'tt:AudioEncoding': */
class SOAP_CMAC tt__AudioEncoding_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:AudioEncoding' wrapped by this struct
        enum tt__AudioEncoding __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioEncoding_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioEncoding_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioEncoding_, default initialized and not managed by a soap context
        virtual tt__AudioEncoding_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioEncoding_); }
      public:
        /// Constructor with default initializations
        tt__AudioEncoding_() : __item() { }
        /// Destructor
        virtual ~tt__AudioEncoding_() { }
        /// Friend allocator used by soap_new_tt__AudioEncoding_(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioEncoding_ * SOAP_FMAC2 soap_instantiate_tt__AudioEncoding_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2251 */
#ifndef SOAP_TYPE_tt__AudioEncodingMimeNames_
#define SOAP_TYPE_tt__AudioEncodingMimeNames_ (856)
/* simple XML schema type 'tt:AudioEncodingMimeNames': */
class SOAP_CMAC tt__AudioEncodingMimeNames_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:AudioEncodingMimeNames' wrapped by this struct
        enum tt__AudioEncodingMimeNames __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioEncodingMimeNames_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioEncodingMimeNames_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioEncodingMimeNames_, default initialized and not managed by a soap context
        virtual tt__AudioEncodingMimeNames_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioEncodingMimeNames_); }
      public:
        /// Constructor with default initializations
        tt__AudioEncodingMimeNames_() : __item() { }
        /// Destructor
        virtual ~tt__AudioEncodingMimeNames_() { }
        /// Friend allocator used by soap_new_tt__AudioEncodingMimeNames_(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioEncodingMimeNames_ * SOAP_FMAC2 soap_instantiate_tt__AudioEncodingMimeNames_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2269 */
#ifndef SOAP_TYPE_tt__MetadataCompressionType_
#define SOAP_TYPE_tt__MetadataCompressionType_ (858)
/* simple XML schema type 'tt:MetadataCompressionType': */
class SOAP_CMAC tt__MetadataCompressionType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:MetadataCompressionType' wrapped by this struct
        enum tt__MetadataCompressionType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataCompressionType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataCompressionType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataCompressionType_, default initialized and not managed by a soap context
        virtual tt__MetadataCompressionType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataCompressionType_); }
      public:
        /// Constructor with default initializations
        tt__MetadataCompressionType_() : __item() { }
        /// Destructor
        virtual ~tt__MetadataCompressionType_() { }
        /// Friend allocator used by soap_new_tt__MetadataCompressionType_(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataCompressionType_ * SOAP_FMAC2 soap_instantiate_tt__MetadataCompressionType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2286 */
#ifndef SOAP_TYPE_tt__StreamType_
#define SOAP_TYPE_tt__StreamType_ (860)
/* simple XML schema type 'tt:StreamType': */
class SOAP_CMAC tt__StreamType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:StreamType' wrapped by this struct
        enum tt__StreamType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__StreamType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__StreamType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__StreamType_, default initialized and not managed by a soap context
        virtual tt__StreamType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__StreamType_); }
      public:
        /// Constructor with default initializations
        tt__StreamType_() : __item() { }
        /// Destructor
        virtual ~tt__StreamType_() { }
        /// Friend allocator used by soap_new_tt__StreamType_(struct soap*, int)
        friend SOAP_FMAC1 tt__StreamType_ * SOAP_FMAC2 soap_instantiate_tt__StreamType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2309 */
#ifndef SOAP_TYPE_tt__TransportProtocol_
#define SOAP_TYPE_tt__TransportProtocol_ (862)
/* simple XML schema type 'tt:TransportProtocol': */
class SOAP_CMAC tt__TransportProtocol_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:TransportProtocol' wrapped by this struct
        enum tt__TransportProtocol __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__TransportProtocol_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__TransportProtocol_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__TransportProtocol_, default initialized and not managed by a soap context
        virtual tt__TransportProtocol_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__TransportProtocol_); }
      public:
        /// Constructor with default initializations
        tt__TransportProtocol_() : __item() { }
        /// Destructor
        virtual ~tt__TransportProtocol_() { }
        /// Friend allocator used by soap_new_tt__TransportProtocol_(struct soap*, int)
        friend SOAP_FMAC1 tt__TransportProtocol_ * SOAP_FMAC2 soap_instantiate_tt__TransportProtocol_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2326 */
#ifndef SOAP_TYPE_tt__ScopeDefinition_
#define SOAP_TYPE_tt__ScopeDefinition_ (864)
/* simple XML schema type 'tt:ScopeDefinition': */
class SOAP_CMAC tt__ScopeDefinition_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ScopeDefinition' wrapped by this struct
        enum tt__ScopeDefinition __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ScopeDefinition_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ScopeDefinition_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ScopeDefinition_, default initialized and not managed by a soap context
        virtual tt__ScopeDefinition_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ScopeDefinition_); }
      public:
        /// Constructor with default initializations
        tt__ScopeDefinition_() : __item() { }
        /// Destructor
        virtual ~tt__ScopeDefinition_() { }
        /// Friend allocator used by soap_new_tt__ScopeDefinition_(struct soap*, int)
        friend SOAP_FMAC1 tt__ScopeDefinition_ * SOAP_FMAC2 soap_instantiate_tt__ScopeDefinition_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2343 */
#ifndef SOAP_TYPE_tt__DiscoveryMode_
#define SOAP_TYPE_tt__DiscoveryMode_ (866)
/* simple XML schema type 'tt:DiscoveryMode': */
class SOAP_CMAC tt__DiscoveryMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:DiscoveryMode' wrapped by this struct
        enum tt__DiscoveryMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__DiscoveryMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DiscoveryMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DiscoveryMode_, default initialized and not managed by a soap context
        virtual tt__DiscoveryMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DiscoveryMode_); }
      public:
        /// Constructor with default initializations
        tt__DiscoveryMode_() : __item() { }
        /// Destructor
        virtual ~tt__DiscoveryMode_() { }
        /// Friend allocator used by soap_new_tt__DiscoveryMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__DiscoveryMode_ * SOAP_FMAC2 soap_instantiate_tt__DiscoveryMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2356 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority__
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority__ (868)
/* simple XML schema type 'tt:NetworkInterfaceConfigPriority': */
class SOAP_CMAC tt__NetworkInterfaceConfigPriority__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:NetworkInterfaceConfigPriority' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceConfigPriority__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceConfigPriority__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceConfigPriority__, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceConfigPriority__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceConfigPriority__); }
      public:
        /// Constructor with default initializations
        tt__NetworkInterfaceConfigPriority__() : __item() { }
        /// Destructor
        virtual ~tt__NetworkInterfaceConfigPriority__() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceConfigPriority__(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceConfigPriority__ * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceConfigPriority__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2373 */
#ifndef SOAP_TYPE_tt__Duplex_
#define SOAP_TYPE_tt__Duplex_ (870)
/* simple XML schema type 'tt:Duplex': */
class SOAP_CMAC tt__Duplex_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Duplex' wrapped by this struct
        enum tt__Duplex __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Duplex_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Duplex_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Duplex_, default initialized and not managed by a soap context
        virtual tt__Duplex_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Duplex_); }
      public:
        /// Constructor with default initializations
        tt__Duplex_() : __item() { }
        /// Destructor
        virtual ~tt__Duplex_() { }
        /// Friend allocator used by soap_new_tt__Duplex_(struct soap*, int)
        friend SOAP_FMAC1 tt__Duplex_ * SOAP_FMAC2 soap_instantiate_tt__Duplex_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2389 */
#ifndef SOAP_TYPE_tt__IANA_IfTypes__
#define SOAP_TYPE_tt__IANA_IfTypes__ (872)
/* simple XML schema type 'tt:IANA-IfTypes': */
class SOAP_CMAC tt__IANA_IfTypes__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:IANA-IfTypes' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__IANA_IfTypes__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IANA_IfTypes__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IANA_IfTypes__, default initialized and not managed by a soap context
        virtual tt__IANA_IfTypes__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IANA_IfTypes__); }
      public:
        /// Constructor with default initializations
        tt__IANA_IfTypes__() : __item() { }
        /// Destructor
        virtual ~tt__IANA_IfTypes__() { }
        /// Friend allocator used by soap_new_tt__IANA_IfTypes__(struct soap*, int)
        friend SOAP_FMAC1 tt__IANA_IfTypes__ * SOAP_FMAC2 soap_instantiate_tt__IANA_IfTypes__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2408 */
#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration_
#define SOAP_TYPE_tt__IPv6DHCPConfiguration_ (874)
/* simple XML schema type 'tt:IPv6DHCPConfiguration': */
class SOAP_CMAC tt__IPv6DHCPConfiguration_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:IPv6DHCPConfiguration' wrapped by this struct
        enum tt__IPv6DHCPConfiguration __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv6DHCPConfiguration_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv6DHCPConfiguration_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv6DHCPConfiguration_, default initialized and not managed by a soap context
        virtual tt__IPv6DHCPConfiguration_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv6DHCPConfiguration_); }
      public:
        /// Constructor with default initializations
        tt__IPv6DHCPConfiguration_() : __item() { }
        /// Destructor
        virtual ~tt__IPv6DHCPConfiguration_() { }
        /// Friend allocator used by soap_new_tt__IPv6DHCPConfiguration_(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv6DHCPConfiguration_ * SOAP_FMAC2 soap_instantiate_tt__IPv6DHCPConfiguration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2426 */
#ifndef SOAP_TYPE_tt__NetworkProtocolType_
#define SOAP_TYPE_tt__NetworkProtocolType_ (876)
/* simple XML schema type 'tt:NetworkProtocolType': */
class SOAP_CMAC tt__NetworkProtocolType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:NetworkProtocolType' wrapped by this struct
        enum tt__NetworkProtocolType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkProtocolType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkProtocolType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkProtocolType_, default initialized and not managed by a soap context
        virtual tt__NetworkProtocolType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkProtocolType_); }
      public:
        /// Constructor with default initializations
        tt__NetworkProtocolType_() : __item() { }
        /// Destructor
        virtual ~tt__NetworkProtocolType_() { }
        /// Friend allocator used by soap_new_tt__NetworkProtocolType_(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkProtocolType_ * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocolType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2444 */
#ifndef SOAP_TYPE_tt__NetworkHostType_
#define SOAP_TYPE_tt__NetworkHostType_ (878)
/* simple XML schema type 'tt:NetworkHostType': */
class SOAP_CMAC tt__NetworkHostType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:NetworkHostType' wrapped by this struct
        enum tt__NetworkHostType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkHostType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkHostType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkHostType_, default initialized and not managed by a soap context
        virtual tt__NetworkHostType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkHostType_); }
      public:
        /// Constructor with default initializations
        tt__NetworkHostType_() : __item() { }
        /// Destructor
        virtual ~tt__NetworkHostType_() { }
        /// Friend allocator used by soap_new_tt__NetworkHostType_(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkHostType_ * SOAP_FMAC2 soap_instantiate_tt__NetworkHostType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2456 */
#ifndef SOAP_TYPE_tt__IPv4Address__
#define SOAP_TYPE_tt__IPv4Address__ (880)
/* simple XML schema type 'tt:IPv4Address': */
class SOAP_CMAC tt__IPv4Address__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:IPv4Address' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv4Address__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv4Address__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv4Address__, default initialized and not managed by a soap context
        virtual tt__IPv4Address__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv4Address__); }
      public:
        /// Constructor with default initializations
        tt__IPv4Address__() : __item() { }
        /// Destructor
        virtual ~tt__IPv4Address__() { }
        /// Friend allocator used by soap_new_tt__IPv4Address__(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv4Address__ * SOAP_FMAC2 soap_instantiate_tt__IPv4Address__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2468 */
#ifndef SOAP_TYPE_tt__IPv6Address__
#define SOAP_TYPE_tt__IPv6Address__ (882)
/* simple XML schema type 'tt:IPv6Address': */
class SOAP_CMAC tt__IPv6Address__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:IPv6Address' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv6Address__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv6Address__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv6Address__, default initialized and not managed by a soap context
        virtual tt__IPv6Address__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv6Address__); }
      public:
        /// Constructor with default initializations
        tt__IPv6Address__() : __item() { }
        /// Destructor
        virtual ~tt__IPv6Address__() { }
        /// Friend allocator used by soap_new_tt__IPv6Address__(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv6Address__ * SOAP_FMAC2 soap_instantiate_tt__IPv6Address__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2480 */
#ifndef SOAP_TYPE_tt__HwAddress__
#define SOAP_TYPE_tt__HwAddress__ (884)
/* simple XML schema type 'tt:HwAddress': */
class SOAP_CMAC tt__HwAddress__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:HwAddress' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__HwAddress__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__HwAddress__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__HwAddress__, default initialized and not managed by a soap context
        virtual tt__HwAddress__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__HwAddress__); }
      public:
        /// Constructor with default initializations
        tt__HwAddress__() : __item() { }
        /// Destructor
        virtual ~tt__HwAddress__() { }
        /// Friend allocator used by soap_new_tt__HwAddress__(struct soap*, int)
        friend SOAP_FMAC1 tt__HwAddress__ * SOAP_FMAC2 soap_instantiate_tt__HwAddress__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2497 */
#ifndef SOAP_TYPE_tt__IPType_
#define SOAP_TYPE_tt__IPType_ (886)
/* simple XML schema type 'tt:IPType': */
class SOAP_CMAC tt__IPType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:IPType' wrapped by this struct
        enum tt__IPType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPType_, default initialized and not managed by a soap context
        virtual tt__IPType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPType_); }
      public:
        /// Constructor with default initializations
        tt__IPType_() : __item() { }
        /// Destructor
        virtual ~tt__IPType_() { }
        /// Friend allocator used by soap_new_tt__IPType_(struct soap*, int)
        friend SOAP_FMAC1 tt__IPType_ * SOAP_FMAC2 soap_instantiate_tt__IPType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2509 */
#ifndef SOAP_TYPE_tt__DNSName__
#define SOAP_TYPE_tt__DNSName__ (888)
/* simple XML schema type 'tt:DNSName': */
class SOAP_CMAC tt__DNSName__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:DNSName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__DNSName__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DNSName__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DNSName__, default initialized and not managed by a soap context
        virtual tt__DNSName__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DNSName__); }
      public:
        /// Constructor with default initializations
        tt__DNSName__() : __item() { }
        /// Destructor
        virtual ~tt__DNSName__() { }
        /// Friend allocator used by soap_new_tt__DNSName__(struct soap*, int)
        friend SOAP_FMAC1 tt__DNSName__ * SOAP_FMAC2 soap_instantiate_tt__DNSName__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2521 */
#ifndef SOAP_TYPE_tt__Domain__
#define SOAP_TYPE_tt__Domain__ (890)
/* simple XML schema type 'tt:Domain': */
class SOAP_CMAC tt__Domain__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Domain' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Domain__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Domain__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Domain__, default initialized and not managed by a soap context
        virtual tt__Domain__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Domain__); }
      public:
        /// Constructor with default initializations
        tt__Domain__() : __item() { }
        /// Destructor
        virtual ~tt__Domain__() { }
        /// Friend allocator used by soap_new_tt__Domain__(struct soap*, int)
        friend SOAP_FMAC1 tt__Domain__ * SOAP_FMAC2 soap_instantiate_tt__Domain__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2538 */
#ifndef SOAP_TYPE_tt__IPAddressFilterType_
#define SOAP_TYPE_tt__IPAddressFilterType_ (892)
/* simple XML schema type 'tt:IPAddressFilterType': */
class SOAP_CMAC tt__IPAddressFilterType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:IPAddressFilterType' wrapped by this struct
        enum tt__IPAddressFilterType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPAddressFilterType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPAddressFilterType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPAddressFilterType_, default initialized and not managed by a soap context
        virtual tt__IPAddressFilterType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPAddressFilterType_); }
      public:
        /// Constructor with default initializations
        tt__IPAddressFilterType_() : __item() { }
        /// Destructor
        virtual ~tt__IPAddressFilterType_() { }
        /// Friend allocator used by soap_new_tt__IPAddressFilterType_(struct soap*, int)
        friend SOAP_FMAC1 tt__IPAddressFilterType_ * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilterType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2556 */
#ifndef SOAP_TYPE_tt__DynamicDNSType_
#define SOAP_TYPE_tt__DynamicDNSType_ (894)
/* simple XML schema type 'tt:DynamicDNSType': */
class SOAP_CMAC tt__DynamicDNSType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:DynamicDNSType' wrapped by this struct
        enum tt__DynamicDNSType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__DynamicDNSType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DynamicDNSType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DynamicDNSType_, default initialized and not managed by a soap context
        virtual tt__DynamicDNSType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DynamicDNSType_); }
      public:
        /// Constructor with default initializations
        tt__DynamicDNSType_() : __item() { }
        /// Destructor
        virtual ~tt__DynamicDNSType_() { }
        /// Friend allocator used by soap_new_tt__DynamicDNSType_(struct soap*, int)
        friend SOAP_FMAC1 tt__DynamicDNSType_ * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2569 */
#ifndef SOAP_TYPE_tt__Dot11SSIDType__
#define SOAP_TYPE_tt__Dot11SSIDType__ (896)
/* simple XML schema type 'tt:Dot11SSIDType': */
class SOAP_CMAC tt__Dot11SSIDType__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Dot11SSIDType' wrapped by this struct
        xsd__hexBinary __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11SSIDType__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11SSIDType__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11SSIDType__, default initialized and not managed by a soap context
        virtual tt__Dot11SSIDType__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11SSIDType__); }
      public:
        /// Constructor with default initializations
        tt__Dot11SSIDType__() : __item() { }
        /// Destructor
        virtual ~tt__Dot11SSIDType__() { }
        /// Friend allocator used by soap_new_tt__Dot11SSIDType__(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11SSIDType__ * SOAP_FMAC2 soap_instantiate_tt__Dot11SSIDType__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2587 */
#ifndef SOAP_TYPE_tt__Dot11StationMode_
#define SOAP_TYPE_tt__Dot11StationMode_ (898)
/* simple XML schema type 'tt:Dot11StationMode': */
class SOAP_CMAC tt__Dot11StationMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Dot11StationMode' wrapped by this struct
        enum tt__Dot11StationMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11StationMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11StationMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11StationMode_, default initialized and not managed by a soap context
        virtual tt__Dot11StationMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11StationMode_); }
      public:
        /// Constructor with default initializations
        tt__Dot11StationMode_() : __item() { }
        /// Destructor
        virtual ~tt__Dot11StationMode_() { }
        /// Friend allocator used by soap_new_tt__Dot11StationMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11StationMode_ * SOAP_FMAC2 soap_instantiate_tt__Dot11StationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2607 */
#ifndef SOAP_TYPE_tt__Dot11SecurityMode_
#define SOAP_TYPE_tt__Dot11SecurityMode_ (900)
/* simple XML schema type 'tt:Dot11SecurityMode': */
class SOAP_CMAC tt__Dot11SecurityMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Dot11SecurityMode' wrapped by this struct
        enum tt__Dot11SecurityMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11SecurityMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11SecurityMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11SecurityMode_, default initialized and not managed by a soap context
        virtual tt__Dot11SecurityMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11SecurityMode_); }
      public:
        /// Constructor with default initializations
        tt__Dot11SecurityMode_() : __item() { }
        /// Destructor
        virtual ~tt__Dot11SecurityMode_() { }
        /// Friend allocator used by soap_new_tt__Dot11SecurityMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11SecurityMode_ * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2626 */
#ifndef SOAP_TYPE_tt__Dot11Cipher_
#define SOAP_TYPE_tt__Dot11Cipher_ (902)
/* simple XML schema type 'tt:Dot11Cipher': */
class SOAP_CMAC tt__Dot11Cipher_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Dot11Cipher' wrapped by this struct
        enum tt__Dot11Cipher __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11Cipher_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11Cipher_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11Cipher_, default initialized and not managed by a soap context
        virtual tt__Dot11Cipher_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11Cipher_); }
      public:
        /// Constructor with default initializations
        tt__Dot11Cipher_() : __item() { }
        /// Destructor
        virtual ~tt__Dot11Cipher_() { }
        /// Friend allocator used by soap_new_tt__Dot11Cipher_(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11Cipher_ * SOAP_FMAC2 soap_instantiate_tt__Dot11Cipher_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2639 */
#ifndef SOAP_TYPE_tt__Dot11PSK__
#define SOAP_TYPE_tt__Dot11PSK__ (904)
/* simple XML schema type 'tt:Dot11PSK': */
class SOAP_CMAC tt__Dot11PSK__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Dot11PSK' wrapped by this struct
        xsd__hexBinary __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11PSK__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11PSK__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11PSK__, default initialized and not managed by a soap context
        virtual tt__Dot11PSK__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11PSK__); }
      public:
        /// Constructor with default initializations
        tt__Dot11PSK__() : __item() { }
        /// Destructor
        virtual ~tt__Dot11PSK__() { }
        /// Friend allocator used by soap_new_tt__Dot11PSK__(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11PSK__ * SOAP_FMAC2 soap_instantiate_tt__Dot11PSK__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2652 */
#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase__
#define SOAP_TYPE_tt__Dot11PSKPassphrase__ (906)
/* simple XML schema type 'tt:Dot11PSKPassphrase': */
class SOAP_CMAC tt__Dot11PSKPassphrase__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Dot11PSKPassphrase' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11PSKPassphrase__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11PSKPassphrase__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11PSKPassphrase__, default initialized and not managed by a soap context
        virtual tt__Dot11PSKPassphrase__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11PSKPassphrase__); }
      public:
        /// Constructor with default initializations
        tt__Dot11PSKPassphrase__() : __item() { }
        /// Destructor
        virtual ~tt__Dot11PSKPassphrase__() { }
        /// Friend allocator used by soap_new_tt__Dot11PSKPassphrase__(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11PSKPassphrase__ * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKPassphrase__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2673 */
#ifndef SOAP_TYPE_tt__Dot11SignalStrength_
#define SOAP_TYPE_tt__Dot11SignalStrength_ (908)
/* simple XML schema type 'tt:Dot11SignalStrength': */
class SOAP_CMAC tt__Dot11SignalStrength_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Dot11SignalStrength' wrapped by this struct
        enum tt__Dot11SignalStrength __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11SignalStrength_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11SignalStrength_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11SignalStrength_, default initialized and not managed by a soap context
        virtual tt__Dot11SignalStrength_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11SignalStrength_); }
      public:
        /// Constructor with default initializations
        tt__Dot11SignalStrength_() : __item() { }
        /// Destructor
        virtual ~tt__Dot11SignalStrength_() { }
        /// Friend allocator used by soap_new_tt__Dot11SignalStrength_(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11SignalStrength_ * SOAP_FMAC2 soap_instantiate_tt__Dot11SignalStrength_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2692 */
#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite_
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite_ (910)
/* simple XML schema type 'tt:Dot11AuthAndMangementSuite': */
class SOAP_CMAC tt__Dot11AuthAndMangementSuite_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Dot11AuthAndMangementSuite' wrapped by this struct
        enum tt__Dot11AuthAndMangementSuite __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11AuthAndMangementSuite_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11AuthAndMangementSuite_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11AuthAndMangementSuite_, default initialized and not managed by a soap context
        virtual tt__Dot11AuthAndMangementSuite_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11AuthAndMangementSuite_); }
      public:
        /// Constructor with default initializations
        tt__Dot11AuthAndMangementSuite_() : __item() { }
        /// Destructor
        virtual ~tt__Dot11AuthAndMangementSuite_() { }
        /// Friend allocator used by soap_new_tt__Dot11AuthAndMangementSuite_(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11AuthAndMangementSuite_ * SOAP_FMAC2 soap_instantiate_tt__Dot11AuthAndMangementSuite_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2714 */
#ifndef SOAP_TYPE_tt__CapabilityCategory_
#define SOAP_TYPE_tt__CapabilityCategory_ (912)
/* simple XML schema type 'tt:CapabilityCategory': */
class SOAP_CMAC tt__CapabilityCategory_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:CapabilityCategory' wrapped by this struct
        enum tt__CapabilityCategory __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__CapabilityCategory_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CapabilityCategory_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CapabilityCategory_, default initialized and not managed by a soap context
        virtual tt__CapabilityCategory_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CapabilityCategory_); }
      public:
        /// Constructor with default initializations
        tt__CapabilityCategory_() : __item() { }
        /// Destructor
        virtual ~tt__CapabilityCategory_() { }
        /// Friend allocator used by soap_new_tt__CapabilityCategory_(struct soap*, int)
        friend SOAP_FMAC1 tt__CapabilityCategory_ * SOAP_FMAC2 soap_instantiate_tt__CapabilityCategory_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2743 */
#ifndef SOAP_TYPE_tt__SystemLogType_
#define SOAP_TYPE_tt__SystemLogType_ (914)
/* simple XML schema type 'tt:SystemLogType': */
class SOAP_CMAC tt__SystemLogType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:SystemLogType' wrapped by this struct
        enum tt__SystemLogType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemLogType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemLogType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemLogType_, default initialized and not managed by a soap context
        virtual tt__SystemLogType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemLogType_); }
      public:
        /// Constructor with default initializations
        tt__SystemLogType_() : __item() { }
        /// Destructor
        virtual ~tt__SystemLogType_() { }
        /// Friend allocator used by soap_new_tt__SystemLogType_(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemLogType_ * SOAP_FMAC2 soap_instantiate_tt__SystemLogType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2772 */
#ifndef SOAP_TYPE_tt__FactoryDefaultType_
#define SOAP_TYPE_tt__FactoryDefaultType_ (916)
/* simple XML schema type 'tt:FactoryDefaultType': */
class SOAP_CMAC tt__FactoryDefaultType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:FactoryDefaultType' wrapped by this struct
        enum tt__FactoryDefaultType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__FactoryDefaultType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FactoryDefaultType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FactoryDefaultType_, default initialized and not managed by a soap context
        virtual tt__FactoryDefaultType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FactoryDefaultType_); }
      public:
        /// Constructor with default initializations
        tt__FactoryDefaultType_() : __item() { }
        /// Destructor
        virtual ~tt__FactoryDefaultType_() { }
        /// Friend allocator used by soap_new_tt__FactoryDefaultType_(struct soap*, int)
        friend SOAP_FMAC1 tt__FactoryDefaultType_ * SOAP_FMAC2 soap_instantiate_tt__FactoryDefaultType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2797 */
#ifndef SOAP_TYPE_tt__SetDateTimeType_
#define SOAP_TYPE_tt__SetDateTimeType_ (918)
/* simple XML schema type 'tt:SetDateTimeType': */
class SOAP_CMAC tt__SetDateTimeType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:SetDateTimeType' wrapped by this struct
        enum tt__SetDateTimeType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__SetDateTimeType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SetDateTimeType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SetDateTimeType_, default initialized and not managed by a soap context
        virtual tt__SetDateTimeType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SetDateTimeType_); }
      public:
        /// Constructor with default initializations
        tt__SetDateTimeType_() : __item() { }
        /// Destructor
        virtual ~tt__SetDateTimeType_() { }
        /// Friend allocator used by soap_new_tt__SetDateTimeType_(struct soap*, int)
        friend SOAP_FMAC1 tt__SetDateTimeType_ * SOAP_FMAC2 soap_instantiate_tt__SetDateTimeType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2817 */
#ifndef SOAP_TYPE_tt__UserLevel_
#define SOAP_TYPE_tt__UserLevel_ (920)
/* simple XML schema type 'tt:UserLevel': */
class SOAP_CMAC tt__UserLevel_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:UserLevel' wrapped by this struct
        enum tt__UserLevel __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__UserLevel_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__UserLevel_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__UserLevel_, default initialized and not managed by a soap context
        virtual tt__UserLevel_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__UserLevel_); }
      public:
        /// Constructor with default initializations
        tt__UserLevel_() : __item() { }
        /// Destructor
        virtual ~tt__UserLevel_() { }
        /// Friend allocator used by soap_new_tt__UserLevel_(struct soap*, int)
        friend SOAP_FMAC1 tt__UserLevel_ * SOAP_FMAC2 soap_instantiate_tt__UserLevel_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2834 */
#ifndef SOAP_TYPE_tt__RelayLogicalState_
#define SOAP_TYPE_tt__RelayLogicalState_ (922)
/* simple XML schema type 'tt:RelayLogicalState': */
class SOAP_CMAC tt__RelayLogicalState_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:RelayLogicalState' wrapped by this struct
        enum tt__RelayLogicalState __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelayLogicalState_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelayLogicalState_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelayLogicalState_, default initialized and not managed by a soap context
        virtual tt__RelayLogicalState_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelayLogicalState_); }
      public:
        /// Constructor with default initializations
        tt__RelayLogicalState_() : __item() { }
        /// Destructor
        virtual ~tt__RelayLogicalState_() { }
        /// Friend allocator used by soap_new_tt__RelayLogicalState_(struct soap*, int)
        friend SOAP_FMAC1 tt__RelayLogicalState_ * SOAP_FMAC2 soap_instantiate_tt__RelayLogicalState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2851 */
#ifndef SOAP_TYPE_tt__RelayIdleState_
#define SOAP_TYPE_tt__RelayIdleState_ (924)
/* simple XML schema type 'tt:RelayIdleState': */
class SOAP_CMAC tt__RelayIdleState_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:RelayIdleState' wrapped by this struct
        enum tt__RelayIdleState __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelayIdleState_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelayIdleState_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelayIdleState_, default initialized and not managed by a soap context
        virtual tt__RelayIdleState_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelayIdleState_); }
      public:
        /// Constructor with default initializations
        tt__RelayIdleState_() : __item() { }
        /// Destructor
        virtual ~tt__RelayIdleState_() { }
        /// Friend allocator used by soap_new_tt__RelayIdleState_(struct soap*, int)
        friend SOAP_FMAC1 tt__RelayIdleState_ * SOAP_FMAC2 soap_instantiate_tt__RelayIdleState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2868 */
#ifndef SOAP_TYPE_tt__RelayMode_
#define SOAP_TYPE_tt__RelayMode_ (926)
/* simple XML schema type 'tt:RelayMode': */
class SOAP_CMAC tt__RelayMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:RelayMode' wrapped by this struct
        enum tt__RelayMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelayMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelayMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelayMode_, default initialized and not managed by a soap context
        virtual tt__RelayMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelayMode_); }
      public:
        /// Constructor with default initializations
        tt__RelayMode_() : __item() { }
        /// Destructor
        virtual ~tt__RelayMode_() { }
        /// Friend allocator used by soap_new_tt__RelayMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__RelayMode_ * SOAP_FMAC2 soap_instantiate_tt__RelayMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2885 */
#ifndef SOAP_TYPE_tt__DigitalIdleState_
#define SOAP_TYPE_tt__DigitalIdleState_ (928)
/* simple XML schema type 'tt:DigitalIdleState': */
class SOAP_CMAC tt__DigitalIdleState_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:DigitalIdleState' wrapped by this struct
        enum tt__DigitalIdleState __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__DigitalIdleState_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DigitalIdleState_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DigitalIdleState_, default initialized and not managed by a soap context
        virtual tt__DigitalIdleState_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DigitalIdleState_); }
      public:
        /// Constructor with default initializations
        tt__DigitalIdleState_() : __item() { }
        /// Destructor
        virtual ~tt__DigitalIdleState_() { }
        /// Friend allocator used by soap_new_tt__DigitalIdleState_(struct soap*, int)
        friend SOAP_FMAC1 tt__DigitalIdleState_ * SOAP_FMAC2 soap_instantiate_tt__DigitalIdleState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2903 */
#ifndef SOAP_TYPE_tt__EFlipMode_
#define SOAP_TYPE_tt__EFlipMode_ (930)
/* simple XML schema type 'tt:EFlipMode': */
class SOAP_CMAC tt__EFlipMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:EFlipMode' wrapped by this struct
        enum tt__EFlipMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__EFlipMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EFlipMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EFlipMode_, default initialized and not managed by a soap context
        virtual tt__EFlipMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EFlipMode_); }
      public:
        /// Constructor with default initializations
        tt__EFlipMode_() : __item() { }
        /// Destructor
        virtual ~tt__EFlipMode_() { }
        /// Friend allocator used by soap_new_tt__EFlipMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__EFlipMode_ * SOAP_FMAC2 soap_instantiate_tt__EFlipMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2922 */
#ifndef SOAP_TYPE_tt__ReverseMode_
#define SOAP_TYPE_tt__ReverseMode_ (932)
/* simple XML schema type 'tt:ReverseMode': */
class SOAP_CMAC tt__ReverseMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ReverseMode' wrapped by this struct
        enum tt__ReverseMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReverseMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReverseMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReverseMode_, default initialized and not managed by a soap context
        virtual tt__ReverseMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReverseMode_); }
      public:
        /// Constructor with default initializations
        tt__ReverseMode_() : __item() { }
        /// Destructor
        virtual ~tt__ReverseMode_() { }
        /// Friend allocator used by soap_new_tt__ReverseMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__ReverseMode_ * SOAP_FMAC2 soap_instantiate_tt__ReverseMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2935 */
#ifndef SOAP_TYPE_tt__AuxiliaryData__
#define SOAP_TYPE_tt__AuxiliaryData__ (934)
/* simple XML schema type 'tt:AuxiliaryData': */
class SOAP_CMAC tt__AuxiliaryData__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:AuxiliaryData' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__AuxiliaryData__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AuxiliaryData__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AuxiliaryData__, default initialized and not managed by a soap context
        virtual tt__AuxiliaryData__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AuxiliaryData__); }
      public:
        /// Constructor with default initializations
        tt__AuxiliaryData__() : __item() { }
        /// Destructor
        virtual ~tt__AuxiliaryData__() { }
        /// Friend allocator used by soap_new_tt__AuxiliaryData__(struct soap*, int)
        friend SOAP_FMAC1 tt__AuxiliaryData__ * SOAP_FMAC2 soap_instantiate_tt__AuxiliaryData__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2954 */
#ifndef SOAP_TYPE_tt__PTZPresetTourState_
#define SOAP_TYPE_tt__PTZPresetTourState_ (936)
/* simple XML schema type 'tt:PTZPresetTourState': */
class SOAP_CMAC tt__PTZPresetTourState_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:PTZPresetTourState' wrapped by this struct
        enum tt__PTZPresetTourState __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourState_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourState_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourState_, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourState_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourState_); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourState_() : __item() { }
        /// Destructor
        virtual ~tt__PTZPresetTourState_() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourState_(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourState_ * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2972 */
#ifndef SOAP_TYPE_tt__PTZPresetTourDirection_
#define SOAP_TYPE_tt__PTZPresetTourDirection_ (938)
/* simple XML schema type 'tt:PTZPresetTourDirection': */
class SOAP_CMAC tt__PTZPresetTourDirection_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:PTZPresetTourDirection' wrapped by this struct
        enum tt__PTZPresetTourDirection __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourDirection_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourDirection_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourDirection_, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourDirection_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourDirection_); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourDirection_() : __item() { }
        /// Destructor
        virtual ~tt__PTZPresetTourDirection_() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourDirection_(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourDirection_ * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourDirection_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:2991 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOperation_
#define SOAP_TYPE_tt__PTZPresetTourOperation_ (940)
/* simple XML schema type 'tt:PTZPresetTourOperation': */
class SOAP_CMAC tt__PTZPresetTourOperation_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:PTZPresetTourOperation' wrapped by this struct
        enum tt__PTZPresetTourOperation __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourOperation_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourOperation_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourOperation_, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourOperation_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourOperation_); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourOperation_() : __item() { }
        /// Destructor
        virtual ~tt__PTZPresetTourOperation_() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourOperation_(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourOperation_ * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourOperation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3010 */
#ifndef SOAP_TYPE_tt__MoveAndTrackMethod_
#define SOAP_TYPE_tt__MoveAndTrackMethod_ (942)
/* simple XML schema type 'tt:MoveAndTrackMethod': */
class SOAP_CMAC tt__MoveAndTrackMethod_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:MoveAndTrackMethod' wrapped by this struct
        enum tt__MoveAndTrackMethod __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__MoveAndTrackMethod_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MoveAndTrackMethod_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MoveAndTrackMethod_, default initialized and not managed by a soap context
        virtual tt__MoveAndTrackMethod_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MoveAndTrackMethod_); }
      public:
        /// Constructor with default initializations
        tt__MoveAndTrackMethod_() : __item() { }
        /// Destructor
        virtual ~tt__MoveAndTrackMethod_() { }
        /// Friend allocator used by soap_new_tt__MoveAndTrackMethod_(struct soap*, int)
        friend SOAP_FMAC1 tt__MoveAndTrackMethod_ * SOAP_FMAC2 soap_instantiate_tt__MoveAndTrackMethod_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3027 */
#ifndef SOAP_TYPE_tt__AutoFocusMode_
#define SOAP_TYPE_tt__AutoFocusMode_ (944)
/* simple XML schema type 'tt:AutoFocusMode': */
class SOAP_CMAC tt__AutoFocusMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:AutoFocusMode' wrapped by this struct
        enum tt__AutoFocusMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__AutoFocusMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AutoFocusMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AutoFocusMode_, default initialized and not managed by a soap context
        virtual tt__AutoFocusMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AutoFocusMode_); }
      public:
        /// Constructor with default initializations
        tt__AutoFocusMode_() : __item() { }
        /// Destructor
        virtual ~tt__AutoFocusMode_() { }
        /// Friend allocator used by soap_new_tt__AutoFocusMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__AutoFocusMode_ * SOAP_FMAC2 soap_instantiate_tt__AutoFocusMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3047 */
#ifndef SOAP_TYPE_tt__AFModes_
#define SOAP_TYPE_tt__AFModes_ (946)
/* simple XML schema type 'tt:AFModes': */
class SOAP_CMAC tt__AFModes_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:AFModes' wrapped by this struct
        enum tt__AFModes __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__AFModes_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AFModes_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AFModes_, default initialized and not managed by a soap context
        virtual tt__AFModes_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AFModes_); }
      public:
        /// Constructor with default initializations
        tt__AFModes_() : __item() { }
        /// Destructor
        virtual ~tt__AFModes_() { }
        /// Friend allocator used by soap_new_tt__AFModes_(struct soap*, int)
        friend SOAP_FMAC1 tt__AFModes_ * SOAP_FMAC2 soap_instantiate_tt__AFModes_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3064 */
#ifndef SOAP_TYPE_tt__WideDynamicMode_
#define SOAP_TYPE_tt__WideDynamicMode_ (948)
/* simple XML schema type 'tt:WideDynamicMode': */
class SOAP_CMAC tt__WideDynamicMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:WideDynamicMode' wrapped by this struct
        enum tt__WideDynamicMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__WideDynamicMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WideDynamicMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WideDynamicMode_, default initialized and not managed by a soap context
        virtual tt__WideDynamicMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WideDynamicMode_); }
      public:
        /// Constructor with default initializations
        tt__WideDynamicMode_() : __item() { }
        /// Destructor
        virtual ~tt__WideDynamicMode_() { }
        /// Friend allocator used by soap_new_tt__WideDynamicMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__WideDynamicMode_ * SOAP_FMAC2 soap_instantiate_tt__WideDynamicMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3093 */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode_
#define SOAP_TYPE_tt__BacklightCompensationMode_ (950)
/* simple XML schema type 'tt:BacklightCompensationMode': */
class SOAP_CMAC tt__BacklightCompensationMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:BacklightCompensationMode' wrapped by this struct
        enum tt__BacklightCompensationMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__BacklightCompensationMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BacklightCompensationMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BacklightCompensationMode_, default initialized and not managed by a soap context
        virtual tt__BacklightCompensationMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BacklightCompensationMode_); }
      public:
        /// Constructor with default initializations
        tt__BacklightCompensationMode_() : __item() { }
        /// Destructor
        virtual ~tt__BacklightCompensationMode_() { }
        /// Friend allocator used by soap_new_tt__BacklightCompensationMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__BacklightCompensationMode_ * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3110 */
#ifndef SOAP_TYPE_tt__ExposurePriority_
#define SOAP_TYPE_tt__ExposurePriority_ (952)
/* simple XML schema type 'tt:ExposurePriority': */
class SOAP_CMAC tt__ExposurePriority_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ExposurePriority' wrapped by this struct
        enum tt__ExposurePriority __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ExposurePriority_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ExposurePriority_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ExposurePriority_, default initialized and not managed by a soap context
        virtual tt__ExposurePriority_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ExposurePriority_); }
      public:
        /// Constructor with default initializations
        tt__ExposurePriority_() : __item() { }
        /// Destructor
        virtual ~tt__ExposurePriority_() { }
        /// Friend allocator used by soap_new_tt__ExposurePriority_(struct soap*, int)
        friend SOAP_FMAC1 tt__ExposurePriority_ * SOAP_FMAC2 soap_instantiate_tt__ExposurePriority_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3127 */
#ifndef SOAP_TYPE_tt__ExposureMode_
#define SOAP_TYPE_tt__ExposureMode_ (954)
/* simple XML schema type 'tt:ExposureMode': */
class SOAP_CMAC tt__ExposureMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ExposureMode' wrapped by this struct
        enum tt__ExposureMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ExposureMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ExposureMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ExposureMode_, default initialized and not managed by a soap context
        virtual tt__ExposureMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ExposureMode_); }
      public:
        /// Constructor with default initializations
        tt__ExposureMode_() : __item() { }
        /// Destructor
        virtual ~tt__ExposureMode_() { }
        /// Friend allocator used by soap_new_tt__ExposureMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__ExposureMode_ * SOAP_FMAC2 soap_instantiate_tt__ExposureMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3144 */
#ifndef SOAP_TYPE_tt__Enabled_
#define SOAP_TYPE_tt__Enabled_ (956)
/* simple XML schema type 'tt:Enabled': */
class SOAP_CMAC tt__Enabled_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Enabled' wrapped by this struct
        enum tt__Enabled __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Enabled_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Enabled_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Enabled_, default initialized and not managed by a soap context
        virtual tt__Enabled_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Enabled_); }
      public:
        /// Constructor with default initializations
        tt__Enabled_() : __item() { }
        /// Destructor
        virtual ~tt__Enabled_() { }
        /// Friend allocator used by soap_new_tt__Enabled_(struct soap*, int)
        friend SOAP_FMAC1 tt__Enabled_ * SOAP_FMAC2 soap_instantiate_tt__Enabled_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3161 */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode_
#define SOAP_TYPE_tt__WhiteBalanceMode_ (958)
/* simple XML schema type 'tt:WhiteBalanceMode': */
class SOAP_CMAC tt__WhiteBalanceMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:WhiteBalanceMode' wrapped by this struct
        enum tt__WhiteBalanceMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalanceMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalanceMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalanceMode_, default initialized and not managed by a soap context
        virtual tt__WhiteBalanceMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalanceMode_); }
      public:
        /// Constructor with default initializations
        tt__WhiteBalanceMode_() : __item() { }
        /// Destructor
        virtual ~tt__WhiteBalanceMode_() { }
        /// Friend allocator used by soap_new_tt__WhiteBalanceMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalanceMode_ * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3179 */
#ifndef SOAP_TYPE_tt__IrCutFilterMode_
#define SOAP_TYPE_tt__IrCutFilterMode_ (960)
/* simple XML schema type 'tt:IrCutFilterMode': */
class SOAP_CMAC tt__IrCutFilterMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:IrCutFilterMode' wrapped by this struct
        enum tt__IrCutFilterMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterMode_, default initialized and not managed by a soap context
        virtual tt__IrCutFilterMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterMode_); }
      public:
        /// Constructor with default initializations
        tt__IrCutFilterMode_() : __item() { }
        /// Destructor
        virtual ~tt__IrCutFilterMode_() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterMode_ * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3198 */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode_
#define SOAP_TYPE_tt__ImageStabilizationMode_ (962)
/* simple XML schema type 'tt:ImageStabilizationMode': */
class SOAP_CMAC tt__ImageStabilizationMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ImageStabilizationMode' wrapped by this struct
        enum tt__ImageStabilizationMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilizationMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilizationMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilizationMode_, default initialized and not managed by a soap context
        virtual tt__ImageStabilizationMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilizationMode_); }
      public:
        /// Constructor with default initializations
        tt__ImageStabilizationMode_() : __item() { }
        /// Destructor
        virtual ~tt__ImageStabilizationMode_() { }
        /// Friend allocator used by soap_new_tt__ImageStabilizationMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilizationMode_ * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3217 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoBoundaryType_
#define SOAP_TYPE_tt__IrCutFilterAutoBoundaryType_ (964)
/* simple XML schema type 'tt:IrCutFilterAutoBoundaryType': */
class SOAP_CMAC tt__IrCutFilterAutoBoundaryType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:IrCutFilterAutoBoundaryType' wrapped by this struct
        enum tt__IrCutFilterAutoBoundaryType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoBoundaryType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoBoundaryType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoBoundaryType_, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoBoundaryType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoBoundaryType_); }
      public:
        /// Constructor with default initializations
        tt__IrCutFilterAutoBoundaryType_() : __item() { }
        /// Destructor
        virtual ~tt__IrCutFilterAutoBoundaryType_() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoBoundaryType_(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoBoundaryType_ * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoBoundaryType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3235 */
#ifndef SOAP_TYPE_tt__ToneCompensationMode_
#define SOAP_TYPE_tt__ToneCompensationMode_ (966)
/* simple XML schema type 'tt:ToneCompensationMode': */
class SOAP_CMAC tt__ToneCompensationMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ToneCompensationMode' wrapped by this struct
        enum tt__ToneCompensationMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ToneCompensationMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ToneCompensationMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ToneCompensationMode_, default initialized and not managed by a soap context
        virtual tt__ToneCompensationMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ToneCompensationMode_); }
      public:
        /// Constructor with default initializations
        tt__ToneCompensationMode_() : __item() { }
        /// Destructor
        virtual ~tt__ToneCompensationMode_() { }
        /// Friend allocator used by soap_new_tt__ToneCompensationMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__ToneCompensationMode_ * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3253 */
#ifndef SOAP_TYPE_tt__DefoggingMode_
#define SOAP_TYPE_tt__DefoggingMode_ (968)
/* simple XML schema type 'tt:DefoggingMode': */
class SOAP_CMAC tt__DefoggingMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:DefoggingMode' wrapped by this struct
        enum tt__DefoggingMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__DefoggingMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DefoggingMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DefoggingMode_, default initialized and not managed by a soap context
        virtual tt__DefoggingMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DefoggingMode_); }
      public:
        /// Constructor with default initializations
        tt__DefoggingMode_() : __item() { }
        /// Destructor
        virtual ~tt__DefoggingMode_() { }
        /// Friend allocator used by soap_new_tt__DefoggingMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__DefoggingMode_ * SOAP_FMAC2 soap_instantiate_tt__DefoggingMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3271 */
#ifndef SOAP_TYPE_tt__ImageSendingType_
#define SOAP_TYPE_tt__ImageSendingType_ (970)
/* simple XML schema type 'tt:ImageSendingType': */
class SOAP_CMAC tt__ImageSendingType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ImageSendingType' wrapped by this struct
        enum tt__ImageSendingType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageSendingType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageSendingType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageSendingType_, default initialized and not managed by a soap context
        virtual tt__ImageSendingType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageSendingType_); }
      public:
        /// Constructor with default initializations
        tt__ImageSendingType_() : __item() { }
        /// Destructor
        virtual ~tt__ImageSendingType_() { }
        /// Friend allocator used by soap_new_tt__ImageSendingType_(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageSendingType_ * SOAP_FMAC2 soap_instantiate_tt__ImageSendingType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3289 */
#ifndef SOAP_TYPE_tt__PropertyOperation_
#define SOAP_TYPE_tt__PropertyOperation_ (972)
/* simple XML schema type 'tt:PropertyOperation': */
class SOAP_CMAC tt__PropertyOperation_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:PropertyOperation' wrapped by this struct
        enum tt__PropertyOperation __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__PropertyOperation_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PropertyOperation_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PropertyOperation_, default initialized and not managed by a soap context
        virtual tt__PropertyOperation_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PropertyOperation_); }
      public:
        /// Constructor with default initializations
        tt__PropertyOperation_() : __item() { }
        /// Destructor
        virtual ~tt__PropertyOperation_() { }
        /// Friend allocator used by soap_new_tt__PropertyOperation_(struct soap*, int)
        friend SOAP_FMAC1 tt__PropertyOperation_ * SOAP_FMAC2 soap_instantiate_tt__PropertyOperation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3307 */
#ifndef SOAP_TYPE_tt__Direction_
#define SOAP_TYPE_tt__Direction_ (974)
/* simple XML schema type 'tt:Direction': */
class SOAP_CMAC tt__Direction_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Direction' wrapped by this struct
        enum tt__Direction __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Direction_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Direction_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Direction_, default initialized and not managed by a soap context
        virtual tt__Direction_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Direction_); }
      public:
        /// Constructor with default initializations
        tt__Direction_() : __item() { }
        /// Destructor
        virtual ~tt__Direction_() { }
        /// Friend allocator used by soap_new_tt__Direction_(struct soap*, int)
        friend SOAP_FMAC1 tt__Direction_ * SOAP_FMAC2 soap_instantiate_tt__Direction_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3346 */
#ifndef SOAP_TYPE_tt__ReceiverMode_
#define SOAP_TYPE_tt__ReceiverMode_ (976)
/* simple XML schema type 'tt:ReceiverMode': */
class SOAP_CMAC tt__ReceiverMode_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ReceiverMode' wrapped by this struct
        enum tt__ReceiverMode __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReceiverMode_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReceiverMode_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReceiverMode_, default initialized and not managed by a soap context
        virtual tt__ReceiverMode_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReceiverMode_); }
      public:
        /// Constructor with default initializations
        tt__ReceiverMode_() : __item() { }
        /// Destructor
        virtual ~tt__ReceiverMode_() { }
        /// Friend allocator used by soap_new_tt__ReceiverMode_(struct soap*, int)
        friend SOAP_FMAC1 tt__ReceiverMode_ * SOAP_FMAC2 soap_instantiate_tt__ReceiverMode_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3385 */
#ifndef SOAP_TYPE_tt__ReceiverState_
#define SOAP_TYPE_tt__ReceiverState_ (978)
/* simple XML schema type 'tt:ReceiverState': */
class SOAP_CMAC tt__ReceiverState_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ReceiverState' wrapped by this struct
        enum tt__ReceiverState __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReceiverState_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReceiverState_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReceiverState_, default initialized and not managed by a soap context
        virtual tt__ReceiverState_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReceiverState_); }
      public:
        /// Constructor with default initializations
        tt__ReceiverState_() : __item() { }
        /// Destructor
        virtual ~tt__ReceiverState_() { }
        /// Friend allocator used by soap_new_tt__ReceiverState_(struct soap*, int)
        friend SOAP_FMAC1 tt__ReceiverState_ * SOAP_FMAC2 soap_instantiate_tt__ReceiverState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3397 */
#ifndef SOAP_TYPE_tt__Description__
#define SOAP_TYPE_tt__Description__ (980)
/* simple XML schema type 'tt:Description': */
class SOAP_CMAC tt__Description__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Description' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Description__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Description__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Description__, default initialized and not managed by a soap context
        virtual tt__Description__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Description__); }
      public:
        /// Constructor with default initializations
        tt__Description__() : __item() { }
        /// Destructor
        virtual ~tt__Description__() { }
        /// Friend allocator used by soap_new_tt__Description__(struct soap*, int)
        friend SOAP_FMAC1 tt__Description__ * SOAP_FMAC2 soap_instantiate_tt__Description__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3409 */
#ifndef SOAP_TYPE_tt__XPathExpression__
#define SOAP_TYPE_tt__XPathExpression__ (982)
/* simple XML schema type 'tt:XPathExpression': */
class SOAP_CMAC tt__XPathExpression__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:XPathExpression' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__XPathExpression__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__XPathExpression__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__XPathExpression__, default initialized and not managed by a soap context
        virtual tt__XPathExpression__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__XPathExpression__); }
      public:
        /// Constructor with default initializations
        tt__XPathExpression__() : __item() { }
        /// Destructor
        virtual ~tt__XPathExpression__() { }
        /// Friend allocator used by soap_new_tt__XPathExpression__(struct soap*, int)
        friend SOAP_FMAC1 tt__XPathExpression__ * SOAP_FMAC2 soap_instantiate_tt__XPathExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3444 */
#ifndef SOAP_TYPE_tt__SearchState_
#define SOAP_TYPE_tt__SearchState_ (984)
/* simple XML schema type 'tt:SearchState': */
class SOAP_CMAC tt__SearchState_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:SearchState' wrapped by this struct
        enum tt__SearchState __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__SearchState_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SearchState_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SearchState_, default initialized and not managed by a soap context
        virtual tt__SearchState_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SearchState_); }
      public:
        /// Constructor with default initializations
        tt__SearchState_() : __item() { }
        /// Destructor
        virtual ~tt__SearchState_() { }
        /// Friend allocator used by soap_new_tt__SearchState_(struct soap*, int)
        friend SOAP_FMAC1 tt__SearchState_ * SOAP_FMAC2 soap_instantiate_tt__SearchState_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3469 */
#ifndef SOAP_TYPE_tt__RecordingStatus_
#define SOAP_TYPE_tt__RecordingStatus_ (986)
/* simple XML schema type 'tt:RecordingStatus': */
class SOAP_CMAC tt__RecordingStatus_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:RecordingStatus' wrapped by this struct
        enum tt__RecordingStatus __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingStatus_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingStatus_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingStatus_, default initialized and not managed by a soap context
        virtual tt__RecordingStatus_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingStatus_); }
      public:
        /// Constructor with default initializations
        tt__RecordingStatus_() : __item() { }
        /// Destructor
        virtual ~tt__RecordingStatus_() { }
        /// Friend allocator used by soap_new_tt__RecordingStatus_(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingStatus_ * SOAP_FMAC2 soap_instantiate_tt__RecordingStatus_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3492 */
#ifndef SOAP_TYPE_tt__TrackType_
#define SOAP_TYPE_tt__TrackType_ (988)
/* simple XML schema type 'tt:TrackType': */
class SOAP_CMAC tt__TrackType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:TrackType' wrapped by this struct
        enum tt__TrackType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__TrackType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__TrackType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__TrackType_, default initialized and not managed by a soap context
        virtual tt__TrackType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__TrackType_); }
      public:
        /// Constructor with default initializations
        tt__TrackType_() : __item() { }
        /// Destructor
        virtual ~tt__TrackType_() { }
        /// Friend allocator used by soap_new_tt__TrackType_(struct soap*, int)
        friend SOAP_FMAC1 tt__TrackType_ * SOAP_FMAC2 soap_instantiate_tt__TrackType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3504 */
#ifndef SOAP_TYPE_tt__RecordingJobMode__
#define SOAP_TYPE_tt__RecordingJobMode__ (990)
/* simple XML schema type 'tt:RecordingJobMode': */
class SOAP_CMAC tt__RecordingJobMode__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:RecordingJobMode' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobMode__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobMode__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobMode__, default initialized and not managed by a soap context
        virtual tt__RecordingJobMode__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobMode__); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobMode__() : __item() { }
        /// Destructor
        virtual ~tt__RecordingJobMode__() { }
        /// Friend allocator used by soap_new_tt__RecordingJobMode__(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobMode__ * SOAP_FMAC2 soap_instantiate_tt__RecordingJobMode__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3516 */
#ifndef SOAP_TYPE_tt__RecordingJobState__
#define SOAP_TYPE_tt__RecordingJobState__ (992)
/* simple XML schema type 'tt:RecordingJobState': */
class SOAP_CMAC tt__RecordingJobState__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:RecordingJobState' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobState__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobState__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobState__, default initialized and not managed by a soap context
        virtual tt__RecordingJobState__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobState__); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobState__() : __item() { }
        /// Destructor
        virtual ~tt__RecordingJobState__() { }
        /// Friend allocator used by soap_new_tt__RecordingJobState__(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobState__ * SOAP_FMAC2 soap_instantiate_tt__RecordingJobState__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3538 */
#ifndef SOAP_TYPE_tt__ModeOfOperation_
#define SOAP_TYPE_tt__ModeOfOperation_ (994)
/* simple XML schema type 'tt:ModeOfOperation': */
class SOAP_CMAC tt__ModeOfOperation_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ModeOfOperation' wrapped by this struct
        enum tt__ModeOfOperation __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ModeOfOperation_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ModeOfOperation_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ModeOfOperation_, default initialized and not managed by a soap context
        virtual tt__ModeOfOperation_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ModeOfOperation_); }
      public:
        /// Constructor with default initializations
        tt__ModeOfOperation_() : __item() { }
        /// Destructor
        virtual ~tt__ModeOfOperation_() { }
        /// Friend allocator used by soap_new_tt__ModeOfOperation_(struct soap*, int)
        friend SOAP_FMAC1 tt__ModeOfOperation_ * SOAP_FMAC2 soap_instantiate_tt__ModeOfOperation_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3562 */
#ifndef SOAP_TYPE_tt__AudioClassType_
#define SOAP_TYPE_tt__AudioClassType_ (996)
/* simple XML schema type 'tt:AudioClassType': */
class SOAP_CMAC tt__AudioClassType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:AudioClassType' wrapped by this struct
        enum tt__AudioClassType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioClassType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioClassType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioClassType_, default initialized and not managed by a soap context
        virtual tt__AudioClassType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioClassType_); }
      public:
        /// Constructor with default initializations
        tt__AudioClassType_() : __item() { }
        /// Destructor
        virtual ~tt__AudioClassType_() { }
        /// Friend allocator used by soap_new_tt__AudioClassType_(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioClassType_ * SOAP_FMAC2 soap_instantiate_tt__AudioClassType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3580 */
#ifndef SOAP_TYPE_tt__OSDType_
#define SOAP_TYPE_tt__OSDType_ (998)
/* simple XML schema type 'tt:OSDType': */
class SOAP_CMAC tt__OSDType_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:OSDType' wrapped by this struct
        enum tt__OSDType __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDType_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDType_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDType_, default initialized and not managed by a soap context
        virtual tt__OSDType_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDType_); }
      public:
        /// Constructor with default initializations
        tt__OSDType_() : __item() { }
        /// Destructor
        virtual ~tt__OSDType_() { }
        /// Friend allocator used by soap_new_tt__OSDType_(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDType_ * SOAP_FMAC2 soap_instantiate_tt__OSDType_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3600 */
#ifndef SOAP_TYPE_tt__ReferenceToken__
#define SOAP_TYPE_tt__ReferenceToken__ (1000)
/* simple XML schema type 'tt:ReferenceToken': */
class SOAP_CMAC tt__ReferenceToken__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ReferenceToken' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReferenceToken__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReferenceToken__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReferenceToken__, default initialized and not managed by a soap context
        virtual tt__ReferenceToken__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReferenceToken__); }
      public:
        /// Constructor with default initializations
        tt__ReferenceToken__() : __item() { }
        /// Destructor
        virtual ~tt__ReferenceToken__() { }
        /// Friend allocator used by soap_new_tt__ReferenceToken__(struct soap*, int)
        friend SOAP_FMAC1 tt__ReferenceToken__ * SOAP_FMAC2 soap_instantiate_tt__ReferenceToken__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3618 */
#ifndef SOAP_TYPE_tt__MoveStatus_
#define SOAP_TYPE_tt__MoveStatus_ (1002)
/* simple XML schema type 'tt:MoveStatus': */
class SOAP_CMAC tt__MoveStatus_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:MoveStatus' wrapped by this struct
        enum tt__MoveStatus __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__MoveStatus_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MoveStatus_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MoveStatus_, default initialized and not managed by a soap context
        virtual tt__MoveStatus_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MoveStatus_); }
      public:
        /// Constructor with default initializations
        tt__MoveStatus_() : __item() { }
        /// Destructor
        virtual ~tt__MoveStatus_() { }
        /// Friend allocator used by soap_new_tt__MoveStatus_(struct soap*, int)
        friend SOAP_FMAC1 tt__MoveStatus_ * SOAP_FMAC2 soap_instantiate_tt__MoveStatus_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3636 */
#ifndef SOAP_TYPE_tt__Entity_
#define SOAP_TYPE_tt__Entity_ (1004)
/* simple XML schema type 'tt:Entity': */
class SOAP_CMAC tt__Entity_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:Entity' wrapped by this struct
        enum tt__Entity __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__Entity_
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Entity_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Entity_, default initialized and not managed by a soap context
        virtual tt__Entity_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Entity_); }
      public:
        /// Constructor with default initializations
        tt__Entity_() : __item() { }
        /// Destructor
        virtual ~tt__Entity_() { }
        /// Friend allocator used by soap_new_tt__Entity_(struct soap*, int)
        friend SOAP_FMAC1 tt__Entity_ * SOAP_FMAC2 soap_instantiate_tt__Entity_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3677 */
#ifndef SOAP_TYPE_wstop__FullTopicExpression__
#define SOAP_TYPE_wstop__FullTopicExpression__ (1006)
/* simple XML schema type 'wstop:FullTopicExpression': */
class SOAP_CMAC wstop__FullTopicExpression__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'wstop:FullTopicExpression' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_wstop__FullTopicExpression__
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__FullTopicExpression__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__FullTopicExpression__, default initialized and not managed by a soap context
        virtual wstop__FullTopicExpression__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__FullTopicExpression__); }
      public:
        /// Constructor with default initializations
        wstop__FullTopicExpression__() : __item() { }
        /// Destructor
        virtual ~wstop__FullTopicExpression__() { }
        /// Friend allocator used by soap_new_wstop__FullTopicExpression__(struct soap*, int)
        friend SOAP_FMAC1 wstop__FullTopicExpression__ * SOAP_FMAC2 soap_instantiate_wstop__FullTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3695 */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression__
#define SOAP_TYPE_wstop__ConcreteTopicExpression__ (1008)
/* simple XML schema type 'wstop:ConcreteTopicExpression': */
class SOAP_CMAC wstop__ConcreteTopicExpression__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'wstop:ConcreteTopicExpression' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_wstop__ConcreteTopicExpression__
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__ConcreteTopicExpression__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__ConcreteTopicExpression__, default initialized and not managed by a soap context
        virtual wstop__ConcreteTopicExpression__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__ConcreteTopicExpression__); }
      public:
        /// Constructor with default initializations
        wstop__ConcreteTopicExpression__() : __item() { }
        /// Destructor
        virtual ~wstop__ConcreteTopicExpression__() { }
        /// Friend allocator used by soap_new_wstop__ConcreteTopicExpression__(struct soap*, int)
        friend SOAP_FMAC1 wstop__ConcreteTopicExpression__ * SOAP_FMAC2 soap_instantiate_wstop__ConcreteTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3712 */
#ifndef SOAP_TYPE_wstop__SimpleTopicExpression__
#define SOAP_TYPE_wstop__SimpleTopicExpression__ (1010)
/* simple XML schema type 'wstop:SimpleTopicExpression': */
class SOAP_CMAC wstop__SimpleTopicExpression__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:QName' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_wstop__SimpleTopicExpression__
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__SimpleTopicExpression__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__SimpleTopicExpression__, default initialized and not managed by a soap context
        virtual wstop__SimpleTopicExpression__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__SimpleTopicExpression__); }
      public:
        /// Constructor with default initializations
        wstop__SimpleTopicExpression__() : __item() { }
        /// Destructor
        virtual ~wstop__SimpleTopicExpression__() { }
        /// Friend allocator used by soap_new_wstop__SimpleTopicExpression__(struct soap*, int)
        friend SOAP_FMAC1 wstop__SimpleTopicExpression__ * SOAP_FMAC2 soap_instantiate_wstop__SimpleTopicExpression__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3724 */
#ifndef SOAP_TYPE_tt__ReceiverReference__
#define SOAP_TYPE_tt__ReceiverReference__ (1012)
/* simple XML schema type 'tt:ReceiverReference': */
class SOAP_CMAC tt__ReceiverReference__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ReceiverReference' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReceiverReference__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReceiverReference__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReceiverReference__, default initialized and not managed by a soap context
        virtual tt__ReceiverReference__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReceiverReference__); }
      public:
        /// Constructor with default initializations
        tt__ReceiverReference__() : __item() { }
        /// Destructor
        virtual ~tt__ReceiverReference__() { }
        /// Friend allocator used by soap_new_tt__ReceiverReference__(struct soap*, int)
        friend SOAP_FMAC1 tt__ReceiverReference__ * SOAP_FMAC2 soap_instantiate_tt__ReceiverReference__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3736 */
#ifndef SOAP_TYPE_tt__RecordingReference__
#define SOAP_TYPE_tt__RecordingReference__ (1014)
/* simple XML schema type 'tt:RecordingReference': */
class SOAP_CMAC tt__RecordingReference__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:RecordingReference' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingReference__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingReference__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingReference__, default initialized and not managed by a soap context
        virtual tt__RecordingReference__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingReference__); }
      public:
        /// Constructor with default initializations
        tt__RecordingReference__() : __item() { }
        /// Destructor
        virtual ~tt__RecordingReference__() { }
        /// Friend allocator used by soap_new_tt__RecordingReference__(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingReference__ * SOAP_FMAC2 soap_instantiate_tt__RecordingReference__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3748 */
#ifndef SOAP_TYPE_tt__TrackReference__
#define SOAP_TYPE_tt__TrackReference__ (1016)
/* simple XML schema type 'tt:TrackReference': */
class SOAP_CMAC tt__TrackReference__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:TrackReference' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__TrackReference__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__TrackReference__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__TrackReference__, default initialized and not managed by a soap context
        virtual tt__TrackReference__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__TrackReference__); }
      public:
        /// Constructor with default initializations
        tt__TrackReference__() : __item() { }
        /// Destructor
        virtual ~tt__TrackReference__() { }
        /// Friend allocator used by soap_new_tt__TrackReference__(struct soap*, int)
        friend SOAP_FMAC1 tt__TrackReference__ * SOAP_FMAC2 soap_instantiate_tt__TrackReference__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3760 */
#ifndef SOAP_TYPE_tt__JobToken__
#define SOAP_TYPE_tt__JobToken__ (1018)
/* simple XML schema type 'tt:JobToken': */
class SOAP_CMAC tt__JobToken__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:JobToken' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__JobToken__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__JobToken__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__JobToken__, default initialized and not managed by a soap context
        virtual tt__JobToken__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__JobToken__); }
      public:
        /// Constructor with default initializations
        tt__JobToken__() : __item() { }
        /// Destructor
        virtual ~tt__JobToken__() { }
        /// Friend allocator used by soap_new_tt__JobToken__(struct soap*, int)
        friend SOAP_FMAC1 tt__JobToken__ * SOAP_FMAC2 soap_instantiate_tt__JobToken__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3772 */
#ifndef SOAP_TYPE_tt__RecordingJobReference__
#define SOAP_TYPE_tt__RecordingJobReference__ (1020)
/* simple XML schema type 'tt:RecordingJobReference': */
class SOAP_CMAC tt__RecordingJobReference__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:RecordingJobReference' wrapped by this struct
        std::string __item;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobReference__
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobReference__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobReference__, default initialized and not managed by a soap context
        virtual tt__RecordingJobReference__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobReference__); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobReference__() : __item() { }
        /// Destructor
        virtual ~tt__RecordingJobReference__() { }
        /// Friend allocator used by soap_new_tt__RecordingJobReference__(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobReference__ * SOAP_FMAC2 soap_instantiate_tt__RecordingJobReference__(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:3847 */
#ifndef SOAP_TYPE__tds__Service_Capabilities
#define SOAP_TYPE__tds__Service_Capabilities (1021)
/* complex XML schema type 'tds:Service-Capabilities': */
class SOAP_CMAC _tds__Service_Capabilities {
      public:
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__tds__Service_Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tds__Service_Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__Service_Capabilities, default initialized and not managed by a soap context
        virtual _tds__Service_Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__Service_Capabilities); }
      public:
        /// Constructor with default initializations
        _tds__Service_Capabilities() : __any() { }
        /// Destructor
        virtual ~_tds__Service_Capabilities() { }
        /// Friend allocator used by soap_new__tds__Service_Capabilities(struct soap*, int)
        friend SOAP_FMAC1 _tds__Service_Capabilities * SOAP_FMAC2 soap_instantiate__tds__Service_Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:377 */
#ifndef SOAP_TYPE_tds__Service
#define SOAP_TYPE_tds__Service (96)
/* Type tds__Service is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tds:Service': */
class SOAP_CMAC tds__Service : public xsd__anyType {
      public:
        /// Required element 'tds:Namespace' of XML schema type 'xsd:anyURI'
        std::string Namespace;
        /// Required element 'tds:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        /// Optional element 'tds:Capabilities' of XML schema type 'tds:Service-Capabilities'
        _tds__Service_Capabilities *Capabilities;
        /// Required element 'tds:Version' of XML schema type 'tt:OnvifVersion'
        tt__OnvifVersion *Version;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tds__Service
        virtual long soap_type(void) const { return SOAP_TYPE_tds__Service; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__Service, default initialized and not managed by a soap context
        virtual tds__Service *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__Service); }
      public:
        /// Constructor with default initializations
        tds__Service() : Namespace(), XAddr(), Capabilities(), Version(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tds__Service() { }
        /// Friend allocator used by soap_new_tds__Service(struct soap*, int)
        friend SOAP_FMAC1 tds__Service * SOAP_FMAC2 soap_instantiate_tds__Service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:379 */
#ifndef SOAP_TYPE_tds__DeviceServiceCapabilities
#define SOAP_TYPE_tds__DeviceServiceCapabilities (97)
/* Type tds__DeviceServiceCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tds:DeviceServiceCapabilities': */
class SOAP_CMAC tds__DeviceServiceCapabilities : public xsd__anyType {
      public:
        /// Required element 'tds:Network' of XML schema type 'tds:NetworkCapabilities'
        tds__NetworkCapabilities *Network;
        /// Required element 'tds:Security' of XML schema type 'tds:SecurityCapabilities'
        tds__SecurityCapabilities *Security;
        /// Required element 'tds:System' of XML schema type 'tds:SystemCapabilities'
        tds__SystemCapabilities *System;
        /// Optional element 'tds:Misc' of XML schema type 'tds:MiscCapabilities'
        tds__MiscCapabilities *Misc;
      public:
        /// Return unique type id SOAP_TYPE_tds__DeviceServiceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tds__DeviceServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__DeviceServiceCapabilities, default initialized and not managed by a soap context
        virtual tds__DeviceServiceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__DeviceServiceCapabilities); }
      public:
        /// Constructor with default initializations
        tds__DeviceServiceCapabilities() : Network(), Security(), System(), Misc() { }
        /// Destructor
        virtual ~tds__DeviceServiceCapabilities() { }
        /// Friend allocator used by soap_new_tds__DeviceServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tds__DeviceServiceCapabilities * SOAP_FMAC2 soap_instantiate_tds__DeviceServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:381 */
#ifndef SOAP_TYPE_tds__NetworkCapabilities
#define SOAP_TYPE_tds__NetworkCapabilities (98)
/* Type tds__NetworkCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tds:NetworkCapabilities': */
class SOAP_CMAC tds__NetworkCapabilities : public xsd__anyType {
      public:
        /// Optional attribute 'IPFilter' of XML schema type 'xsd:boolean'
        bool *IPFilter;
        /// Optional attribute 'ZeroConfiguration' of XML schema type 'xsd:boolean'
        bool *ZeroConfiguration;
        /// Optional attribute 'IPVersion6' of XML schema type 'xsd:boolean'
        bool *IPVersion6;
        /// Optional attribute 'DynDNS' of XML schema type 'xsd:boolean'
        bool *DynDNS;
        /// Optional attribute 'Dot11Configuration' of XML schema type 'xsd:boolean'
        bool *Dot11Configuration;
        /// Optional attribute 'Dot1XConfigurations' of XML schema type 'xsd:int'
        int *Dot1XConfigurations;
        /// Optional attribute 'HostnameFromDHCP' of XML schema type 'xsd:boolean'
        bool *HostnameFromDHCP;
        /// Optional attribute 'NTP' of XML schema type 'xsd:int'
        int *NTP;
        /// Optional attribute 'DHCPv6' of XML schema type 'xsd:boolean'
        bool *DHCPv6;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tds__NetworkCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tds__NetworkCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__NetworkCapabilities, default initialized and not managed by a soap context
        virtual tds__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__NetworkCapabilities); }
      public:
        /// Constructor with default initializations
        tds__NetworkCapabilities() : IPFilter(), ZeroConfiguration(), IPVersion6(), DynDNS(), Dot11Configuration(), Dot1XConfigurations(), HostnameFromDHCP(), NTP(), DHCPv6(), __anyAttribute() { }
        /// Destructor
        virtual ~tds__NetworkCapabilities() { }
        /// Friend allocator used by soap_new_tds__NetworkCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tds__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tds__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:383 */
#ifndef SOAP_TYPE_tds__SecurityCapabilities
#define SOAP_TYPE_tds__SecurityCapabilities (99)
/* Type tds__SecurityCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tds:SecurityCapabilities': */
class SOAP_CMAC tds__SecurityCapabilities : public xsd__anyType {
      public:
        /// Optional attribute 'TLS1.0' of XML schema type 'xsd:boolean'
        bool *TLS1_x002e0;
        /// Optional attribute 'TLS1.1' of XML schema type 'xsd:boolean'
        bool *TLS1_x002e1;
        /// Optional attribute 'TLS1.2' of XML schema type 'xsd:boolean'
        bool *TLS1_x002e2;
        /// Optional attribute 'OnboardKeyGeneration' of XML schema type 'xsd:boolean'
        bool *OnboardKeyGeneration;
        /// Optional attribute 'AccessPolicyConfig' of XML schema type 'xsd:boolean'
        bool *AccessPolicyConfig;
        /// Optional attribute 'DefaultAccessPolicy' of XML schema type 'xsd:boolean'
        bool *DefaultAccessPolicy;
        /// Optional attribute 'Dot1X' of XML schema type 'xsd:boolean'
        bool *Dot1X;
        /// Optional attribute 'RemoteUserHandling' of XML schema type 'xsd:boolean'
        bool *RemoteUserHandling;
        /// Optional attribute 'X.509Token' of XML schema type 'xsd:boolean'
        bool *X_x002e509Token;
        /// Optional attribute 'SAMLToken' of XML schema type 'xsd:boolean'
        bool *SAMLToken;
        /// Optional attribute 'KerberosToken' of XML schema type 'xsd:boolean'
        bool *KerberosToken;
        /// Optional attribute 'UsernameToken' of XML schema type 'xsd:boolean'
        bool *UsernameToken;
        /// Optional attribute 'HttpDigest' of XML schema type 'xsd:boolean'
        bool *HttpDigest;
        /// Optional attribute 'RELToken' of XML schema type 'xsd:boolean'
        bool *RELToken;
        /// Optional attribute 'SupportedEAPMethods' of XML schema type 'tt:IntList'
        std::string *SupportedEAPMethods;
        /// Optional attribute 'MaxUsers' of XML schema type 'xsd:int'
        int *MaxUsers;
        /// Optional attribute 'MaxUserNameLength' of XML schema type 'xsd:int'
        int *MaxUserNameLength;
        /// Optional attribute 'MaxPasswordLength' of XML schema type 'xsd:int'
        int *MaxPasswordLength;
        /// Optional attribute 'SecurityPolicies' of XML schema type 'tt:StringList'
        std::string *SecurityPolicies;
        /// Optional attribute 'MaxPasswordHistory' of XML schema type 'xsd:int'
        int *MaxPasswordHistory;
        /// Optional attribute 'HashingAlgorithms' of XML schema type 'tt:StringList'
        std::string *HashingAlgorithms;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tds__SecurityCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tds__SecurityCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__SecurityCapabilities, default initialized and not managed by a soap context
        virtual tds__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__SecurityCapabilities); }
      public:
        /// Constructor with default initializations
        tds__SecurityCapabilities() : TLS1_x002e0(), TLS1_x002e1(), TLS1_x002e2(), OnboardKeyGeneration(), AccessPolicyConfig(), DefaultAccessPolicy(), Dot1X(), RemoteUserHandling(), X_x002e509Token(), SAMLToken(), KerberosToken(), UsernameToken(), HttpDigest(), RELToken(), SupportedEAPMethods(), MaxUsers(), MaxUserNameLength(), MaxPasswordLength(), SecurityPolicies(), MaxPasswordHistory(), HashingAlgorithms(), __anyAttribute() { }
        /// Destructor
        virtual ~tds__SecurityCapabilities() { }
        /// Friend allocator used by soap_new_tds__SecurityCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tds__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tds__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:385 */
#ifndef SOAP_TYPE_tds__SystemCapabilities
#define SOAP_TYPE_tds__SystemCapabilities (100)
/* Type tds__SystemCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tds:SystemCapabilities': */
class SOAP_CMAC tds__SystemCapabilities : public xsd__anyType {
      public:
        /// Optional attribute 'DiscoveryResolve' of XML schema type 'xsd:boolean'
        bool *DiscoveryResolve;
        /// Optional attribute 'DiscoveryBye' of XML schema type 'xsd:boolean'
        bool *DiscoveryBye;
        /// Optional attribute 'RemoteDiscovery' of XML schema type 'xsd:boolean'
        bool *RemoteDiscovery;
        /// Optional attribute 'SystemBackup' of XML schema type 'xsd:boolean'
        bool *SystemBackup;
        /// Optional attribute 'SystemLogging' of XML schema type 'xsd:boolean'
        bool *SystemLogging;
        /// Optional attribute 'FirmwareUpgrade' of XML schema type 'xsd:boolean'
        bool *FirmwareUpgrade;
        /// Optional attribute 'HttpFirmwareUpgrade' of XML schema type 'xsd:boolean'
        bool *HttpFirmwareUpgrade;
        /// Optional attribute 'HttpSystemBackup' of XML schema type 'xsd:boolean'
        bool *HttpSystemBackup;
        /// Optional attribute 'HttpSystemLogging' of XML schema type 'xsd:boolean'
        bool *HttpSystemLogging;
        /// Optional attribute 'HttpSupportInformation' of XML schema type 'xsd:boolean'
        bool *HttpSupportInformation;
        /// Optional attribute 'StorageConfiguration' of XML schema type 'xsd:boolean'
        bool *StorageConfiguration;
        /// Optional attribute 'MaxStorageConfigurations' of XML schema type 'xsd:int'
        int *MaxStorageConfigurations;
        /// Optional attribute 'GeoLocationEntries' of XML schema type 'xsd:int'
        int *GeoLocationEntries;
        /// Optional attribute 'AutoGeo' of XML schema type 'tt:StringAttrList'
        std::string *AutoGeo;
        /// Optional attribute 'StorageTypesSupported' of XML schema type 'tt:StringAttrList'
        std::string *StorageTypesSupported;
        /// Optional attribute 'DiscoveryNotSupported' of XML schema type 'xsd:boolean'
        bool *DiscoveryNotSupported;
        /// Optional attribute 'NetworkConfigNotSupported' of XML schema type 'xsd:boolean'
        bool *NetworkConfigNotSupported;
        /// Optional attribute 'UserConfigNotSupported' of XML schema type 'xsd:boolean'
        bool *UserConfigNotSupported;
        /// Optional attribute 'Addons' of XML schema type 'tt:StringAttrList'
        std::string *Addons;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tds__SystemCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tds__SystemCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__SystemCapabilities, default initialized and not managed by a soap context
        virtual tds__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__SystemCapabilities); }
      public:
        /// Constructor with default initializations
        tds__SystemCapabilities() : DiscoveryResolve(), DiscoveryBye(), RemoteDiscovery(), SystemBackup(), SystemLogging(), FirmwareUpgrade(), HttpFirmwareUpgrade(), HttpSystemBackup(), HttpSystemLogging(), HttpSupportInformation(), StorageConfiguration(), MaxStorageConfigurations(), GeoLocationEntries(), AutoGeo(), StorageTypesSupported(), DiscoveryNotSupported(), NetworkConfigNotSupported(), UserConfigNotSupported(), Addons(), __anyAttribute() { }
        /// Destructor
        virtual ~tds__SystemCapabilities() { }
        /// Friend allocator used by soap_new_tds__SystemCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tds__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tds__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:387 */
#ifndef SOAP_TYPE_tds__MiscCapabilities
#define SOAP_TYPE_tds__MiscCapabilities (101)
/* Type tds__MiscCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tds:MiscCapabilities': */
class SOAP_CMAC tds__MiscCapabilities : public xsd__anyType {
      public:
        /// Optional attribute 'AuxiliaryCommands' of XML schema type 'tt:StringAttrList'
        std::string *AuxiliaryCommands;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tds__MiscCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tds__MiscCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__MiscCapabilities, default initialized and not managed by a soap context
        virtual tds__MiscCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__MiscCapabilities); }
      public:
        /// Constructor with default initializations
        tds__MiscCapabilities() : AuxiliaryCommands(), __anyAttribute() { }
        /// Destructor
        virtual ~tds__MiscCapabilities() { }
        /// Friend allocator used by soap_new_tds__MiscCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tds__MiscCapabilities * SOAP_FMAC2 soap_instantiate_tds__MiscCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4350 */
#ifndef SOAP_TYPE__tds__UserCredential_Extension
#define SOAP_TYPE__tds__UserCredential_Extension (1034)
/* complex XML schema type 'tds:UserCredential-Extension': */
class SOAP_CMAC _tds__UserCredential_Extension {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE__tds__UserCredential_Extension
        virtual long soap_type(void) const { return SOAP_TYPE__tds__UserCredential_Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__UserCredential_Extension, default initialized and not managed by a soap context
        virtual _tds__UserCredential_Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__UserCredential_Extension); }
      public:
        /// Constructor with default initializations
        _tds__UserCredential_Extension() : __any() { }
        /// Destructor
        virtual ~_tds__UserCredential_Extension() { }
        /// Friend allocator used by soap_new__tds__UserCredential_Extension(struct soap*, int)
        friend SOAP_FMAC1 _tds__UserCredential_Extension * SOAP_FMAC2 soap_instantiate__tds__UserCredential_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:389 */
#ifndef SOAP_TYPE_tds__UserCredential
#define SOAP_TYPE_tds__UserCredential (102)
/* Type tds__UserCredential is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tds:UserCredential': */
class SOAP_CMAC tds__UserCredential : public xsd__anyType {
      public:
        /// Required element 'tds:UserName' of XML schema type 'xsd:string'
        std::string UserName;
        /// Optional element 'tds:Password' of XML schema type 'xsd:string'
        std::string *Password;
        /// Optional element 'tds:Extension' of XML schema type 'tds:UserCredential-Extension'
        _tds__UserCredential_Extension *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tds__UserCredential
        virtual long soap_type(void) const { return SOAP_TYPE_tds__UserCredential; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__UserCredential, default initialized and not managed by a soap context
        virtual tds__UserCredential *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__UserCredential); }
      public:
        /// Constructor with default initializations
        tds__UserCredential() : UserName(), Password(), Extension() { }
        /// Destructor
        virtual ~tds__UserCredential() { }
        /// Friend allocator used by soap_new_tds__UserCredential(struct soap*, int)
        friend SOAP_FMAC1 tds__UserCredential * SOAP_FMAC2 soap_instantiate_tds__UserCredential(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:4407 */
#ifndef SOAP_TYPE__tds__StorageConfigurationData_Extension
#define SOAP_TYPE__tds__StorageConfigurationData_Extension (1038)
/* complex XML schema type 'tds:StorageConfigurationData-Extension': */
class SOAP_CMAC _tds__StorageConfigurationData_Extension {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE__tds__StorageConfigurationData_Extension
        virtual long soap_type(void) const { return SOAP_TYPE__tds__StorageConfigurationData_Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__StorageConfigurationData_Extension, default initialized and not managed by a soap context
        virtual _tds__StorageConfigurationData_Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__StorageConfigurationData_Extension); }
      public:
        /// Constructor with default initializations
        _tds__StorageConfigurationData_Extension() : __any() { }
        /// Destructor
        virtual ~_tds__StorageConfigurationData_Extension() { }
        /// Friend allocator used by soap_new__tds__StorageConfigurationData_Extension(struct soap*, int)
        friend SOAP_FMAC1 _tds__StorageConfigurationData_Extension * SOAP_FMAC2 soap_instantiate__tds__StorageConfigurationData_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:391 */
#ifndef SOAP_TYPE_tds__StorageConfigurationData
#define SOAP_TYPE_tds__StorageConfigurationData (103)
/* Type tds__StorageConfigurationData is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tds:StorageConfigurationData': */
class SOAP_CMAC tds__StorageConfigurationData : public xsd__anyType {
      public:
        /// Optional element 'tds:LocalPath' of XML schema type 'xsd:anyURI'
        std::string *LocalPath;
        /// Optional element 'tds:StorageUri' of XML schema type 'xsd:anyURI'
        std::string *StorageUri;
        /// Optional element 'tds:User' of XML schema type 'tds:UserCredential'
        tds__UserCredential *User;
        /// Optional element 'tds:Extension' of XML schema type 'tds:StorageConfigurationData-Extension'
        _tds__StorageConfigurationData_Extension *Extension;
        /// Required attribute 'type' of XML schema type 'xsd:string'
        std::string type;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tds__StorageConfigurationData
        virtual long soap_type(void) const { return SOAP_TYPE_tds__StorageConfigurationData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__StorageConfigurationData, default initialized and not managed by a soap context
        virtual tds__StorageConfigurationData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__StorageConfigurationData); }
      public:
        /// Constructor with default initializations
        tds__StorageConfigurationData() : LocalPath(), StorageUri(), User(), Extension(), type(), __anyAttribute() { }
        /// Destructor
        virtual ~tds__StorageConfigurationData() { }
        /// Friend allocator used by soap_new_tds__StorageConfigurationData(struct soap*, int)
        friend SOAP_FMAC1 tds__StorageConfigurationData * SOAP_FMAC2 soap_instantiate_tds__StorageConfigurationData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:395 */
#ifndef SOAP_TYPE__tds__GetServices
#define SOAP_TYPE__tds__GetServices (105)
/* complex XML schema type 'tds:GetServices': */
class SOAP_CMAC _tds__GetServices {
      public:
        /// Required element 'tds:IncludeCapability' of XML schema type 'xsd:boolean'
        bool IncludeCapability;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetServices
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetServices; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetServices, default initialized and not managed by a soap context
        virtual _tds__GetServices *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetServices); }
      public:
        /// Constructor with default initializations
        _tds__GetServices() : IncludeCapability(), soap() { }
        /// Destructor
        virtual ~_tds__GetServices() { }
        /// Friend allocator used by soap_new__tds__GetServices(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetServices * SOAP_FMAC2 soap_instantiate__tds__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:397 */
#ifndef SOAP_TYPE__tds__GetServicesResponse
#define SOAP_TYPE__tds__GetServicesResponse (106)
/* complex XML schema type 'tds:GetServicesResponse': */
class SOAP_CMAC _tds__GetServicesResponse {
      public:
        /// Required element 'tds:Service' of XML schema type 'tds:Service'
        std::vector<tds__Service *> Service;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetServicesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetServicesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetServicesResponse, default initialized and not managed by a soap context
        virtual _tds__GetServicesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetServicesResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetServicesResponse() : Service(), soap() { }
        /// Destructor
        virtual ~_tds__GetServicesResponse() { }
        /// Friend allocator used by soap_new__tds__GetServicesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetServicesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServicesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:399 */
#ifndef SOAP_TYPE__tds__GetServiceCapabilities
#define SOAP_TYPE__tds__GetServiceCapabilities (107)
/* complex XML schema type 'tds:GetServiceCapabilities': */
class SOAP_CMAC _tds__GetServiceCapabilities {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetServiceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetServiceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetServiceCapabilities, default initialized and not managed by a soap context
        virtual _tds__GetServiceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetServiceCapabilities); }
      public:
        /// Constructor with default initializations
        _tds__GetServiceCapabilities() : soap() { }
        /// Destructor
        virtual ~_tds__GetServiceCapabilities() { }
        /// Friend allocator used by soap_new__tds__GetServiceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:401 */
#ifndef SOAP_TYPE__tds__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tds__GetServiceCapabilitiesResponse (108)
/* complex XML schema type 'tds:GetServiceCapabilitiesResponse': */
class SOAP_CMAC _tds__GetServiceCapabilitiesResponse {
      public:
        /// Required element 'tds:Capabilities' of XML schema type 'tds:DeviceServiceCapabilities'
        tds__DeviceServiceCapabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetServiceCapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetServiceCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetServiceCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _tds__GetServiceCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetServiceCapabilitiesResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetServiceCapabilitiesResponse() : Capabilities(), soap() { }
        /// Destructor
        virtual ~_tds__GetServiceCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__tds__GetServiceCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetServiceCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:403 */
#ifndef SOAP_TYPE__tds__GetDeviceInformation
#define SOAP_TYPE__tds__GetDeviceInformation (109)
/* complex XML schema type 'tds:GetDeviceInformation': */
class SOAP_CMAC _tds__GetDeviceInformation {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDeviceInformation
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDeviceInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDeviceInformation, default initialized and not managed by a soap context
        virtual _tds__GetDeviceInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDeviceInformation); }
      public:
        /// Constructor with default initializations
        _tds__GetDeviceInformation() : soap() { }
        /// Destructor
        virtual ~_tds__GetDeviceInformation() { }
        /// Friend allocator used by soap_new__tds__GetDeviceInformation(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:405 */
#ifndef SOAP_TYPE__tds__GetDeviceInformationResponse
#define SOAP_TYPE__tds__GetDeviceInformationResponse (110)
/* complex XML schema type 'tds:GetDeviceInformationResponse': */
class SOAP_CMAC _tds__GetDeviceInformationResponse {
      public:
        /// Required element 'tds:Manufacturer' of XML schema type 'xsd:string'
        std::string Manufacturer;
        /// Required element 'tds:Model' of XML schema type 'xsd:string'
        std::string Model;
        /// Required element 'tds:FirmwareVersion' of XML schema type 'xsd:string'
        std::string FirmwareVersion;
        /// Required element 'tds:SerialNumber' of XML schema type 'xsd:string'
        std::string SerialNumber;
        /// Required element 'tds:HardwareId' of XML schema type 'xsd:string'
        std::string HardwareId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDeviceInformationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDeviceInformationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDeviceInformationResponse, default initialized and not managed by a soap context
        virtual _tds__GetDeviceInformationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDeviceInformationResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetDeviceInformationResponse() : Manufacturer(), Model(), FirmwareVersion(), SerialNumber(), HardwareId(), soap() { }
        /// Destructor
        virtual ~_tds__GetDeviceInformationResponse() { }
        /// Friend allocator used by soap_new__tds__GetDeviceInformationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDeviceInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDeviceInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:407 */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTime
#define SOAP_TYPE__tds__SetSystemDateAndTime (111)
/* complex XML schema type 'tds:SetSystemDateAndTime': */
class SOAP_CMAC _tds__SetSystemDateAndTime {
      public:
        /// Required element 'tds:DateTimeType' of XML schema type 'tt:SetDateTimeType'
        enum tt__SetDateTimeType DateTimeType;
        /// Required element 'tds:DaylightSavings' of XML schema type 'xsd:boolean'
        bool DaylightSavings;
        /// Optional element 'tds:TimeZone' of XML schema type 'tt:TimeZone'
        tt__TimeZone *TimeZone;
        /// Optional element 'tds:UTCDateTime' of XML schema type 'tt:DateTime'
        tt__DateTime *UTCDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetSystemDateAndTime
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetSystemDateAndTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetSystemDateAndTime, default initialized and not managed by a soap context
        virtual _tds__SetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetSystemDateAndTime); }
      public:
        /// Constructor with default initializations
        _tds__SetSystemDateAndTime() : DateTimeType(), DaylightSavings(), TimeZone(), UTCDateTime(), soap() { }
        /// Destructor
        virtual ~_tds__SetSystemDateAndTime() { }
        /// Friend allocator used by soap_new__tds__SetSystemDateAndTime(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:409 */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__SetSystemDateAndTimeResponse (112)
/* complex XML schema type 'tds:SetSystemDateAndTimeResponse': */
class SOAP_CMAC _tds__SetSystemDateAndTimeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetSystemDateAndTimeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetSystemDateAndTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetSystemDateAndTimeResponse, default initialized and not managed by a soap context
        virtual _tds__SetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetSystemDateAndTimeResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetSystemDateAndTimeResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetSystemDateAndTimeResponse() { }
        /// Friend allocator used by soap_new__tds__SetSystemDateAndTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:411 */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTime
#define SOAP_TYPE__tds__GetSystemDateAndTime (113)
/* complex XML schema type 'tds:GetSystemDateAndTime': */
class SOAP_CMAC _tds__GetSystemDateAndTime {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemDateAndTime
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemDateAndTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemDateAndTime, default initialized and not managed by a soap context
        virtual _tds__GetSystemDateAndTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemDateAndTime); }
      public:
        /// Constructor with default initializations
        _tds__GetSystemDateAndTime() : soap() { }
        /// Destructor
        virtual ~_tds__GetSystemDateAndTime() { }
        /// Friend allocator used by soap_new__tds__GetSystemDateAndTime(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:413 */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__GetSystemDateAndTimeResponse (114)
/* complex XML schema type 'tds:GetSystemDateAndTimeResponse': */
class SOAP_CMAC _tds__GetSystemDateAndTimeResponse {
      public:
        /// Required element 'tds:SystemDateAndTime' of XML schema type 'tt:SystemDateTime'
        tt__SystemDateTime *SystemDateAndTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemDateAndTimeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemDateAndTimeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemDateAndTimeResponse, default initialized and not managed by a soap context
        virtual _tds__GetSystemDateAndTimeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemDateAndTimeResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetSystemDateAndTimeResponse() : SystemDateAndTime(), soap() { }
        /// Destructor
        virtual ~_tds__GetSystemDateAndTimeResponse() { }
        /// Friend allocator used by soap_new__tds__GetSystemDateAndTimeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemDateAndTimeResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemDateAndTimeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:415 */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefault
#define SOAP_TYPE__tds__SetSystemFactoryDefault (115)
/* complex XML schema type 'tds:SetSystemFactoryDefault': */
class SOAP_CMAC _tds__SetSystemFactoryDefault {
      public:
        /// Required element 'tds:FactoryDefault' of XML schema type 'tt:FactoryDefaultType'
        enum tt__FactoryDefaultType FactoryDefault;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetSystemFactoryDefault
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetSystemFactoryDefault; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetSystemFactoryDefault, default initialized and not managed by a soap context
        virtual _tds__SetSystemFactoryDefault *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetSystemFactoryDefault); }
      public:
        /// Constructor with default initializations
        _tds__SetSystemFactoryDefault() : FactoryDefault(), soap() { }
        /// Destructor
        virtual ~_tds__SetSystemFactoryDefault() { }
        /// Friend allocator used by soap_new__tds__SetSystemFactoryDefault(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:417 */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefaultResponse
#define SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (116)
/* complex XML schema type 'tds:SetSystemFactoryDefaultResponse': */
class SOAP_CMAC _tds__SetSystemFactoryDefaultResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetSystemFactoryDefaultResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetSystemFactoryDefaultResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetSystemFactoryDefaultResponse, default initialized and not managed by a soap context
        virtual _tds__SetSystemFactoryDefaultResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetSystemFactoryDefaultResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetSystemFactoryDefaultResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetSystemFactoryDefaultResponse() { }
        /// Friend allocator used by soap_new__tds__SetSystemFactoryDefaultResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetSystemFactoryDefaultResponse * SOAP_FMAC2 soap_instantiate__tds__SetSystemFactoryDefaultResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:419 */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmware
#define SOAP_TYPE__tds__UpgradeSystemFirmware (117)
/* complex XML schema type 'tds:UpgradeSystemFirmware': */
class SOAP_CMAC _tds__UpgradeSystemFirmware {
      public:
        /// Required element 'tds:Firmware' of XML schema type 'tt:AttachmentData'
        tt__AttachmentData *Firmware;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__UpgradeSystemFirmware
        virtual long soap_type(void) const { return SOAP_TYPE__tds__UpgradeSystemFirmware; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__UpgradeSystemFirmware, default initialized and not managed by a soap context
        virtual _tds__UpgradeSystemFirmware *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__UpgradeSystemFirmware); }
      public:
        /// Constructor with default initializations
        _tds__UpgradeSystemFirmware() : Firmware(), soap() { }
        /// Destructor
        virtual ~_tds__UpgradeSystemFirmware() { }
        /// Friend allocator used by soap_new__tds__UpgradeSystemFirmware(struct soap*, int)
        friend SOAP_FMAC1 _tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:421 */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmwareResponse
#define SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (118)
/* complex XML schema type 'tds:UpgradeSystemFirmwareResponse': */
class SOAP_CMAC _tds__UpgradeSystemFirmwareResponse {
      public:
        /// Optional element 'tds:Message' of XML schema type 'xsd:string'
        std::string *Message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__UpgradeSystemFirmwareResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__UpgradeSystemFirmwareResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__UpgradeSystemFirmwareResponse, default initialized and not managed by a soap context
        virtual _tds__UpgradeSystemFirmwareResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__UpgradeSystemFirmwareResponse); }
      public:
        /// Constructor with default initializations
        _tds__UpgradeSystemFirmwareResponse() : Message(), soap() { }
        /// Destructor
        virtual ~_tds__UpgradeSystemFirmwareResponse() { }
        /// Friend allocator used by soap_new__tds__UpgradeSystemFirmwareResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__UpgradeSystemFirmwareResponse * SOAP_FMAC2 soap_instantiate__tds__UpgradeSystemFirmwareResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:423 */
#ifndef SOAP_TYPE__tds__SystemReboot
#define SOAP_TYPE__tds__SystemReboot (119)
/* complex XML schema type 'tds:SystemReboot': */
class SOAP_CMAC _tds__SystemReboot {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SystemReboot
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SystemReboot; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SystemReboot, default initialized and not managed by a soap context
        virtual _tds__SystemReboot *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SystemReboot); }
      public:
        /// Constructor with default initializations
        _tds__SystemReboot() : soap() { }
        /// Destructor
        virtual ~_tds__SystemReboot() { }
        /// Friend allocator used by soap_new__tds__SystemReboot(struct soap*, int)
        friend SOAP_FMAC1 _tds__SystemReboot * SOAP_FMAC2 soap_instantiate__tds__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:425 */
#ifndef SOAP_TYPE__tds__SystemRebootResponse
#define SOAP_TYPE__tds__SystemRebootResponse (120)
/* complex XML schema type 'tds:SystemRebootResponse': */
class SOAP_CMAC _tds__SystemRebootResponse {
      public:
        /// Required element 'tds:Message' of XML schema type 'xsd:string'
        std::string Message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SystemRebootResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SystemRebootResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SystemRebootResponse, default initialized and not managed by a soap context
        virtual _tds__SystemRebootResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SystemRebootResponse); }
      public:
        /// Constructor with default initializations
        _tds__SystemRebootResponse() : Message(), soap() { }
        /// Destructor
        virtual ~_tds__SystemRebootResponse() { }
        /// Friend allocator used by soap_new__tds__SystemRebootResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SystemRebootResponse * SOAP_FMAC2 soap_instantiate__tds__SystemRebootResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:427 */
#ifndef SOAP_TYPE__tds__RestoreSystem
#define SOAP_TYPE__tds__RestoreSystem (121)
/* complex XML schema type 'tds:RestoreSystem': */
class SOAP_CMAC _tds__RestoreSystem {
      public:
        /// Required element 'tds:BackupFiles' of XML schema type 'tt:BackupFile'
        std::vector<tt__BackupFile *> BackupFiles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__RestoreSystem
        virtual long soap_type(void) const { return SOAP_TYPE__tds__RestoreSystem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__RestoreSystem, default initialized and not managed by a soap context
        virtual _tds__RestoreSystem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__RestoreSystem); }
      public:
        /// Constructor with default initializations
        _tds__RestoreSystem() : BackupFiles(), soap() { }
        /// Destructor
        virtual ~_tds__RestoreSystem() { }
        /// Friend allocator used by soap_new__tds__RestoreSystem(struct soap*, int)
        friend SOAP_FMAC1 _tds__RestoreSystem * SOAP_FMAC2 soap_instantiate__tds__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:429 */
#ifndef SOAP_TYPE__tds__RestoreSystemResponse
#define SOAP_TYPE__tds__RestoreSystemResponse (122)
/* complex XML schema type 'tds:RestoreSystemResponse': */
class SOAP_CMAC _tds__RestoreSystemResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__RestoreSystemResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__RestoreSystemResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__RestoreSystemResponse, default initialized and not managed by a soap context
        virtual _tds__RestoreSystemResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__RestoreSystemResponse); }
      public:
        /// Constructor with default initializations
        _tds__RestoreSystemResponse() : soap() { }
        /// Destructor
        virtual ~_tds__RestoreSystemResponse() { }
        /// Friend allocator used by soap_new__tds__RestoreSystemResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__RestoreSystemResponse * SOAP_FMAC2 soap_instantiate__tds__RestoreSystemResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:431 */
#ifndef SOAP_TYPE__tds__GetSystemBackup
#define SOAP_TYPE__tds__GetSystemBackup (123)
/* complex XML schema type 'tds:GetSystemBackup': */
class SOAP_CMAC _tds__GetSystemBackup {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemBackup
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemBackup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemBackup, default initialized and not managed by a soap context
        virtual _tds__GetSystemBackup *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemBackup); }
      public:
        /// Constructor with default initializations
        _tds__GetSystemBackup() : soap() { }
        /// Destructor
        virtual ~_tds__GetSystemBackup() { }
        /// Friend allocator used by soap_new__tds__GetSystemBackup(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:433 */
#ifndef SOAP_TYPE__tds__GetSystemBackupResponse
#define SOAP_TYPE__tds__GetSystemBackupResponse (124)
/* complex XML schema type 'tds:GetSystemBackupResponse': */
class SOAP_CMAC _tds__GetSystemBackupResponse {
      public:
        /// Required element 'tds:BackupFiles' of XML schema type 'tt:BackupFile'
        std::vector<tt__BackupFile *> BackupFiles;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemBackupResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemBackupResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemBackupResponse, default initialized and not managed by a soap context
        virtual _tds__GetSystemBackupResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemBackupResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetSystemBackupResponse() : BackupFiles(), soap() { }
        /// Destructor
        virtual ~_tds__GetSystemBackupResponse() { }
        /// Friend allocator used by soap_new__tds__GetSystemBackupResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemBackupResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemBackupResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:435 */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformation
#define SOAP_TYPE__tds__GetSystemSupportInformation (125)
/* complex XML schema type 'tds:GetSystemSupportInformation': */
class SOAP_CMAC _tds__GetSystemSupportInformation {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemSupportInformation
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemSupportInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemSupportInformation, default initialized and not managed by a soap context
        virtual _tds__GetSystemSupportInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemSupportInformation); }
      public:
        /// Constructor with default initializations
        _tds__GetSystemSupportInformation() : soap() { }
        /// Destructor
        virtual ~_tds__GetSystemSupportInformation() { }
        /// Friend allocator used by soap_new__tds__GetSystemSupportInformation(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:437 */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformationResponse
#define SOAP_TYPE__tds__GetSystemSupportInformationResponse (126)
/* complex XML schema type 'tds:GetSystemSupportInformationResponse': */
class SOAP_CMAC _tds__GetSystemSupportInformationResponse {
      public:
        /// Required element 'tds:SupportInformation' of XML schema type 'tt:SupportInformation'
        tt__SupportInformation *SupportInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemSupportInformationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemSupportInformationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemSupportInformationResponse, default initialized and not managed by a soap context
        virtual _tds__GetSystemSupportInformationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemSupportInformationResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetSystemSupportInformationResponse() : SupportInformation(), soap() { }
        /// Destructor
        virtual ~_tds__GetSystemSupportInformationResponse() { }
        /// Friend allocator used by soap_new__tds__GetSystemSupportInformationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemSupportInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemSupportInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:439 */
#ifndef SOAP_TYPE__tds__GetSystemLog
#define SOAP_TYPE__tds__GetSystemLog (127)
/* complex XML schema type 'tds:GetSystemLog': */
class SOAP_CMAC _tds__GetSystemLog {
      public:
        /// Required element 'tds:LogType' of XML schema type 'tt:SystemLogType'
        enum tt__SystemLogType LogType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemLog
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemLog, default initialized and not managed by a soap context
        virtual _tds__GetSystemLog *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemLog); }
      public:
        /// Constructor with default initializations
        _tds__GetSystemLog() : LogType(), soap() { }
        /// Destructor
        virtual ~_tds__GetSystemLog() { }
        /// Friend allocator used by soap_new__tds__GetSystemLog(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemLog * SOAP_FMAC2 soap_instantiate__tds__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:441 */
#ifndef SOAP_TYPE__tds__GetSystemLogResponse
#define SOAP_TYPE__tds__GetSystemLogResponse (128)
/* complex XML schema type 'tds:GetSystemLogResponse': */
class SOAP_CMAC _tds__GetSystemLogResponse {
      public:
        /// Required element 'tds:SystemLog' of XML schema type 'tt:SystemLog'
        tt__SystemLog *SystemLog;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemLogResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemLogResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemLogResponse, default initialized and not managed by a soap context
        virtual _tds__GetSystemLogResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemLogResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetSystemLogResponse() : SystemLog(), soap() { }
        /// Destructor
        virtual ~_tds__GetSystemLogResponse() { }
        /// Friend allocator used by soap_new__tds__GetSystemLogResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemLogResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemLogResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:443 */
#ifndef SOAP_TYPE__tds__GetScopes
#define SOAP_TYPE__tds__GetScopes (129)
/* complex XML schema type 'tds:GetScopes': */
class SOAP_CMAC _tds__GetScopes {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetScopes
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetScopes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetScopes, default initialized and not managed by a soap context
        virtual _tds__GetScopes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetScopes); }
      public:
        /// Constructor with default initializations
        _tds__GetScopes() : soap() { }
        /// Destructor
        virtual ~_tds__GetScopes() { }
        /// Friend allocator used by soap_new__tds__GetScopes(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetScopes * SOAP_FMAC2 soap_instantiate__tds__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:445 */
#ifndef SOAP_TYPE__tds__GetScopesResponse
#define SOAP_TYPE__tds__GetScopesResponse (130)
/* complex XML schema type 'tds:GetScopesResponse': */
class SOAP_CMAC _tds__GetScopesResponse {
      public:
        /// Required element 'tds:Scopes' of XML schema type 'tt:Scope'
        std::vector<tt__Scope *> Scopes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetScopesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetScopesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetScopesResponse, default initialized and not managed by a soap context
        virtual _tds__GetScopesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetScopesResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetScopesResponse() : Scopes(), soap() { }
        /// Destructor
        virtual ~_tds__GetScopesResponse() { }
        /// Friend allocator used by soap_new__tds__GetScopesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__GetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:447 */
#ifndef SOAP_TYPE__tds__SetScopes
#define SOAP_TYPE__tds__SetScopes (131)
/* complex XML schema type 'tds:SetScopes': */
class SOAP_CMAC _tds__SetScopes {
      public:
        /// Required element 'tds:Scopes' of XML schema type 'xsd:anyURI'
        std::vector<std::string> Scopes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetScopes
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetScopes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetScopes, default initialized and not managed by a soap context
        virtual _tds__SetScopes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetScopes); }
      public:
        /// Constructor with default initializations
        _tds__SetScopes() : Scopes(), soap() { }
        /// Destructor
        virtual ~_tds__SetScopes() { }
        /// Friend allocator used by soap_new__tds__SetScopes(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetScopes * SOAP_FMAC2 soap_instantiate__tds__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:449 */
#ifndef SOAP_TYPE__tds__SetScopesResponse
#define SOAP_TYPE__tds__SetScopesResponse (132)
/* complex XML schema type 'tds:SetScopesResponse': */
class SOAP_CMAC _tds__SetScopesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetScopesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetScopesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetScopesResponse, default initialized and not managed by a soap context
        virtual _tds__SetScopesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetScopesResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetScopesResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetScopesResponse() { }
        /// Friend allocator used by soap_new__tds__SetScopesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetScopesResponse * SOAP_FMAC2 soap_instantiate__tds__SetScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:451 */
#ifndef SOAP_TYPE__tds__AddScopes
#define SOAP_TYPE__tds__AddScopes (133)
/* complex XML schema type 'tds:AddScopes': */
class SOAP_CMAC _tds__AddScopes {
      public:
        /// Required element 'tds:ScopeItem' of XML schema type 'xsd:anyURI'
        std::vector<std::string> ScopeItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__AddScopes
        virtual long soap_type(void) const { return SOAP_TYPE__tds__AddScopes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__AddScopes, default initialized and not managed by a soap context
        virtual _tds__AddScopes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__AddScopes); }
      public:
        /// Constructor with default initializations
        _tds__AddScopes() : ScopeItem(), soap() { }
        /// Destructor
        virtual ~_tds__AddScopes() { }
        /// Friend allocator used by soap_new__tds__AddScopes(struct soap*, int)
        friend SOAP_FMAC1 _tds__AddScopes * SOAP_FMAC2 soap_instantiate__tds__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:453 */
#ifndef SOAP_TYPE__tds__AddScopesResponse
#define SOAP_TYPE__tds__AddScopesResponse (134)
/* complex XML schema type 'tds:AddScopesResponse': */
class SOAP_CMAC _tds__AddScopesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__AddScopesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__AddScopesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__AddScopesResponse, default initialized and not managed by a soap context
        virtual _tds__AddScopesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__AddScopesResponse); }
      public:
        /// Constructor with default initializations
        _tds__AddScopesResponse() : soap() { }
        /// Destructor
        virtual ~_tds__AddScopesResponse() { }
        /// Friend allocator used by soap_new__tds__AddScopesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__AddScopesResponse * SOAP_FMAC2 soap_instantiate__tds__AddScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:455 */
#ifndef SOAP_TYPE__tds__RemoveScopes
#define SOAP_TYPE__tds__RemoveScopes (135)
/* complex XML schema type 'tds:RemoveScopes': */
class SOAP_CMAC _tds__RemoveScopes {
      public:
        /// Required element 'tds:ScopeItem' of XML schema type 'xsd:anyURI'
        std::vector<std::string> ScopeItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__RemoveScopes
        virtual long soap_type(void) const { return SOAP_TYPE__tds__RemoveScopes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__RemoveScopes, default initialized and not managed by a soap context
        virtual _tds__RemoveScopes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__RemoveScopes); }
      public:
        /// Constructor with default initializations
        _tds__RemoveScopes() : ScopeItem(), soap() { }
        /// Destructor
        virtual ~_tds__RemoveScopes() { }
        /// Friend allocator used by soap_new__tds__RemoveScopes(struct soap*, int)
        friend SOAP_FMAC1 _tds__RemoveScopes * SOAP_FMAC2 soap_instantiate__tds__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:457 */
#ifndef SOAP_TYPE__tds__RemoveScopesResponse
#define SOAP_TYPE__tds__RemoveScopesResponse (136)
/* complex XML schema type 'tds:RemoveScopesResponse': */
class SOAP_CMAC _tds__RemoveScopesResponse {
      public:
        /// Optional element 'tds:ScopeItem' of XML schema type 'xsd:anyURI'
        std::vector<std::string> ScopeItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__RemoveScopesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__RemoveScopesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__RemoveScopesResponse, default initialized and not managed by a soap context
        virtual _tds__RemoveScopesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__RemoveScopesResponse); }
      public:
        /// Constructor with default initializations
        _tds__RemoveScopesResponse() : ScopeItem(), soap() { }
        /// Destructor
        virtual ~_tds__RemoveScopesResponse() { }
        /// Friend allocator used by soap_new__tds__RemoveScopesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__RemoveScopesResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveScopesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:459 */
#ifndef SOAP_TYPE__tds__GetDiscoveryMode
#define SOAP_TYPE__tds__GetDiscoveryMode (137)
/* complex XML schema type 'tds:GetDiscoveryMode': */
class SOAP_CMAC _tds__GetDiscoveryMode {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDiscoveryMode
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDiscoveryMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDiscoveryMode, default initialized and not managed by a soap context
        virtual _tds__GetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDiscoveryMode); }
      public:
        /// Constructor with default initializations
        _tds__GetDiscoveryMode() : soap() { }
        /// Destructor
        virtual ~_tds__GetDiscoveryMode() { }
        /// Friend allocator used by soap_new__tds__GetDiscoveryMode(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:461 */
#ifndef SOAP_TYPE__tds__GetDiscoveryModeResponse
#define SOAP_TYPE__tds__GetDiscoveryModeResponse (138)
/* complex XML schema type 'tds:GetDiscoveryModeResponse': */
class SOAP_CMAC _tds__GetDiscoveryModeResponse {
      public:
        /// Required element 'tds:DiscoveryMode' of XML schema type 'tt:DiscoveryMode'
        enum tt__DiscoveryMode DiscoveryMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDiscoveryModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDiscoveryModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDiscoveryModeResponse, default initialized and not managed by a soap context
        virtual _tds__GetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDiscoveryModeResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetDiscoveryModeResponse() : DiscoveryMode(), soap() { }
        /// Destructor
        virtual ~_tds__GetDiscoveryModeResponse() { }
        /// Friend allocator used by soap_new__tds__GetDiscoveryModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:463 */
#ifndef SOAP_TYPE__tds__SetDiscoveryMode
#define SOAP_TYPE__tds__SetDiscoveryMode (139)
/* complex XML schema type 'tds:SetDiscoveryMode': */
class SOAP_CMAC _tds__SetDiscoveryMode {
      public:
        /// Required element 'tds:DiscoveryMode' of XML schema type 'tt:DiscoveryMode'
        enum tt__DiscoveryMode DiscoveryMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDiscoveryMode
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDiscoveryMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDiscoveryMode, default initialized and not managed by a soap context
        virtual _tds__SetDiscoveryMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDiscoveryMode); }
      public:
        /// Constructor with default initializations
        _tds__SetDiscoveryMode() : DiscoveryMode(), soap() { }
        /// Destructor
        virtual ~_tds__SetDiscoveryMode() { }
        /// Friend allocator used by soap_new__tds__SetDiscoveryMode(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:465 */
#ifndef SOAP_TYPE__tds__SetDiscoveryModeResponse
#define SOAP_TYPE__tds__SetDiscoveryModeResponse (140)
/* complex XML schema type 'tds:SetDiscoveryModeResponse': */
class SOAP_CMAC _tds__SetDiscoveryModeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDiscoveryModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDiscoveryModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDiscoveryModeResponse, default initialized and not managed by a soap context
        virtual _tds__SetDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDiscoveryModeResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetDiscoveryModeResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetDiscoveryModeResponse() { }
        /// Friend allocator used by soap_new__tds__SetDiscoveryModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:467 */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryMode
#define SOAP_TYPE__tds__GetRemoteDiscoveryMode (141)
/* complex XML schema type 'tds:GetRemoteDiscoveryMode': */
class SOAP_CMAC _tds__GetRemoteDiscoveryMode {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetRemoteDiscoveryMode
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetRemoteDiscoveryMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetRemoteDiscoveryMode, default initialized and not managed by a soap context
        virtual _tds__GetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetRemoteDiscoveryMode); }
      public:
        /// Constructor with default initializations
        _tds__GetRemoteDiscoveryMode() : soap() { }
        /// Destructor
        virtual ~_tds__GetRemoteDiscoveryMode() { }
        /// Friend allocator used by soap_new__tds__GetRemoteDiscoveryMode(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:469 */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (142)
/* complex XML schema type 'tds:GetRemoteDiscoveryModeResponse': */
class SOAP_CMAC _tds__GetRemoteDiscoveryModeResponse {
      public:
        /// Required element 'tds:RemoteDiscoveryMode' of XML schema type 'tt:DiscoveryMode'
        enum tt__DiscoveryMode RemoteDiscoveryMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
        virtual _tds__GetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetRemoteDiscoveryModeResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetRemoteDiscoveryModeResponse() : RemoteDiscoveryMode(), soap() { }
        /// Destructor
        virtual ~_tds__GetRemoteDiscoveryModeResponse() { }
        /// Friend allocator used by soap_new__tds__GetRemoteDiscoveryModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:471 */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryMode
#define SOAP_TYPE__tds__SetRemoteDiscoveryMode (143)
/* complex XML schema type 'tds:SetRemoteDiscoveryMode': */
class SOAP_CMAC _tds__SetRemoteDiscoveryMode {
      public:
        /// Required element 'tds:RemoteDiscoveryMode' of XML schema type 'tt:DiscoveryMode'
        enum tt__DiscoveryMode RemoteDiscoveryMode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRemoteDiscoveryMode
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRemoteDiscoveryMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRemoteDiscoveryMode, default initialized and not managed by a soap context
        virtual _tds__SetRemoteDiscoveryMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRemoteDiscoveryMode); }
      public:
        /// Constructor with default initializations
        _tds__SetRemoteDiscoveryMode() : RemoteDiscoveryMode(), soap() { }
        /// Destructor
        virtual ~_tds__SetRemoteDiscoveryMode() { }
        /// Friend allocator used by soap_new__tds__SetRemoteDiscoveryMode(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:473 */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (144)
/* complex XML schema type 'tds:SetRemoteDiscoveryModeResponse': */
class SOAP_CMAC _tds__SetRemoteDiscoveryModeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRemoteDiscoveryModeResponse, default initialized and not managed by a soap context
        virtual _tds__SetRemoteDiscoveryModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRemoteDiscoveryModeResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetRemoteDiscoveryModeResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetRemoteDiscoveryModeResponse() { }
        /// Friend allocator used by soap_new__tds__SetRemoteDiscoveryModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRemoteDiscoveryModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteDiscoveryModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:475 */
#ifndef SOAP_TYPE__tds__GetDPAddresses
#define SOAP_TYPE__tds__GetDPAddresses (145)
/* complex XML schema type 'tds:GetDPAddresses': */
class SOAP_CMAC _tds__GetDPAddresses {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDPAddresses
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDPAddresses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDPAddresses, default initialized and not managed by a soap context
        virtual _tds__GetDPAddresses *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDPAddresses); }
      public:
        /// Constructor with default initializations
        _tds__GetDPAddresses() : soap() { }
        /// Destructor
        virtual ~_tds__GetDPAddresses() { }
        /// Friend allocator used by soap_new__tds__GetDPAddresses(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:477 */
#ifndef SOAP_TYPE__tds__GetDPAddressesResponse
#define SOAP_TYPE__tds__GetDPAddressesResponse (146)
/* complex XML schema type 'tds:GetDPAddressesResponse': */
class SOAP_CMAC _tds__GetDPAddressesResponse {
      public:
        /// Optional element 'tds:DPAddress' of XML schema type 'tt:NetworkHost'
        std::vector<tt__NetworkHost *> DPAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDPAddressesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDPAddressesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDPAddressesResponse, default initialized and not managed by a soap context
        virtual _tds__GetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDPAddressesResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetDPAddressesResponse() : DPAddress(), soap() { }
        /// Destructor
        virtual ~_tds__GetDPAddressesResponse() { }
        /// Friend allocator used by soap_new__tds__GetDPAddressesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:479 */
#ifndef SOAP_TYPE__tds__SetDPAddresses
#define SOAP_TYPE__tds__SetDPAddresses (147)
/* complex XML schema type 'tds:SetDPAddresses': */
class SOAP_CMAC _tds__SetDPAddresses {
      public:
        /// Optional element 'tds:DPAddress' of XML schema type 'tt:NetworkHost'
        std::vector<tt__NetworkHost *> DPAddress;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDPAddresses
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDPAddresses; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDPAddresses, default initialized and not managed by a soap context
        virtual _tds__SetDPAddresses *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDPAddresses); }
      public:
        /// Constructor with default initializations
        _tds__SetDPAddresses() : DPAddress(), soap() { }
        /// Destructor
        virtual ~_tds__SetDPAddresses() { }
        /// Friend allocator used by soap_new__tds__SetDPAddresses(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate__tds__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:481 */
#ifndef SOAP_TYPE__tds__SetDPAddressesResponse
#define SOAP_TYPE__tds__SetDPAddressesResponse (148)
/* complex XML schema type 'tds:SetDPAddressesResponse': */
class SOAP_CMAC _tds__SetDPAddressesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDPAddressesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDPAddressesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDPAddressesResponse, default initialized and not managed by a soap context
        virtual _tds__SetDPAddressesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDPAddressesResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetDPAddressesResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetDPAddressesResponse() { }
        /// Friend allocator used by soap_new__tds__SetDPAddressesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDPAddressesResponse * SOAP_FMAC2 soap_instantiate__tds__SetDPAddressesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:483 */
#ifndef SOAP_TYPE__tds__GetEndpointReference
#define SOAP_TYPE__tds__GetEndpointReference (149)
/* complex XML schema type 'tds:GetEndpointReference': */
class SOAP_CMAC _tds__GetEndpointReference {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetEndpointReference
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetEndpointReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetEndpointReference, default initialized and not managed by a soap context
        virtual _tds__GetEndpointReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetEndpointReference); }
      public:
        /// Constructor with default initializations
        _tds__GetEndpointReference() : soap() { }
        /// Destructor
        virtual ~_tds__GetEndpointReference() { }
        /// Friend allocator used by soap_new__tds__GetEndpointReference(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:485 */
#ifndef SOAP_TYPE__tds__GetEndpointReferenceResponse
#define SOAP_TYPE__tds__GetEndpointReferenceResponse (150)
/* complex XML schema type 'tds:GetEndpointReferenceResponse': */
class SOAP_CMAC _tds__GetEndpointReferenceResponse {
      public:
        /// Required element 'tds:GUID' of XML schema type 'xsd:string'
        std::string GUID;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetEndpointReferenceResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetEndpointReferenceResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetEndpointReferenceResponse, default initialized and not managed by a soap context
        virtual _tds__GetEndpointReferenceResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetEndpointReferenceResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetEndpointReferenceResponse() : GUID(), __any(), soap() { }
        /// Destructor
        virtual ~_tds__GetEndpointReferenceResponse() { }
        /// Friend allocator used by soap_new__tds__GetEndpointReferenceResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetEndpointReferenceResponse * SOAP_FMAC2 soap_instantiate__tds__GetEndpointReferenceResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:487 */
#ifndef SOAP_TYPE__tds__GetRemoteUser
#define SOAP_TYPE__tds__GetRemoteUser (151)
/* complex XML schema type 'tds:GetRemoteUser': */
class SOAP_CMAC _tds__GetRemoteUser {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetRemoteUser
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetRemoteUser; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetRemoteUser, default initialized and not managed by a soap context
        virtual _tds__GetRemoteUser *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetRemoteUser); }
      public:
        /// Constructor with default initializations
        _tds__GetRemoteUser() : soap() { }
        /// Destructor
        virtual ~_tds__GetRemoteUser() { }
        /// Friend allocator used by soap_new__tds__GetRemoteUser(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:489 */
#ifndef SOAP_TYPE__tds__GetRemoteUserResponse
#define SOAP_TYPE__tds__GetRemoteUserResponse (152)
/* complex XML schema type 'tds:GetRemoteUserResponse': */
class SOAP_CMAC _tds__GetRemoteUserResponse {
      public:
        /// Optional element 'tds:RemoteUser' of XML schema type 'tt:RemoteUser'
        tt__RemoteUser *RemoteUser;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetRemoteUserResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetRemoteUserResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetRemoteUserResponse, default initialized and not managed by a soap context
        virtual _tds__GetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetRemoteUserResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetRemoteUserResponse() : RemoteUser(), soap() { }
        /// Destructor
        virtual ~_tds__GetRemoteUserResponse() { }
        /// Friend allocator used by soap_new__tds__GetRemoteUserResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__GetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:491 */
#ifndef SOAP_TYPE__tds__SetRemoteUser
#define SOAP_TYPE__tds__SetRemoteUser (153)
/* complex XML schema type 'tds:SetRemoteUser': */
class SOAP_CMAC _tds__SetRemoteUser {
      public:
        /// Optional element 'tds:RemoteUser' of XML schema type 'tt:RemoteUser'
        tt__RemoteUser *RemoteUser;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRemoteUser
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRemoteUser; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRemoteUser, default initialized and not managed by a soap context
        virtual _tds__SetRemoteUser *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRemoteUser); }
      public:
        /// Constructor with default initializations
        _tds__SetRemoteUser() : RemoteUser(), soap() { }
        /// Destructor
        virtual ~_tds__SetRemoteUser() { }
        /// Friend allocator used by soap_new__tds__SetRemoteUser(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:493 */
#ifndef SOAP_TYPE__tds__SetRemoteUserResponse
#define SOAP_TYPE__tds__SetRemoteUserResponse (154)
/* complex XML schema type 'tds:SetRemoteUserResponse': */
class SOAP_CMAC _tds__SetRemoteUserResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRemoteUserResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRemoteUserResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRemoteUserResponse, default initialized and not managed by a soap context
        virtual _tds__SetRemoteUserResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRemoteUserResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetRemoteUserResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetRemoteUserResponse() { }
        /// Friend allocator used by soap_new__tds__SetRemoteUserResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRemoteUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetRemoteUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:495 */
#ifndef SOAP_TYPE__tds__GetUsers
#define SOAP_TYPE__tds__GetUsers (155)
/* complex XML schema type 'tds:GetUsers': */
class SOAP_CMAC _tds__GetUsers {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetUsers
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetUsers; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetUsers, default initialized and not managed by a soap context
        virtual _tds__GetUsers *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetUsers); }
      public:
        /// Constructor with default initializations
        _tds__GetUsers() : soap() { }
        /// Destructor
        virtual ~_tds__GetUsers() { }
        /// Friend allocator used by soap_new__tds__GetUsers(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetUsers * SOAP_FMAC2 soap_instantiate__tds__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:497 */
#ifndef SOAP_TYPE__tds__GetUsersResponse
#define SOAP_TYPE__tds__GetUsersResponse (156)
/* complex XML schema type 'tds:GetUsersResponse': */
class SOAP_CMAC _tds__GetUsersResponse {
      public:
        /// Optional element 'tds:User' of XML schema type 'tt:User'
        std::vector<tt__User *> User;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetUsersResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetUsersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetUsersResponse, default initialized and not managed by a soap context
        virtual _tds__GetUsersResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetUsersResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetUsersResponse() : User(), soap() { }
        /// Destructor
        virtual ~_tds__GetUsersResponse() { }
        /// Friend allocator used by soap_new__tds__GetUsersResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetUsersResponse * SOAP_FMAC2 soap_instantiate__tds__GetUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:499 */
#ifndef SOAP_TYPE__tds__CreateUsers
#define SOAP_TYPE__tds__CreateUsers (157)
/* complex XML schema type 'tds:CreateUsers': */
class SOAP_CMAC _tds__CreateUsers {
      public:
        /// Required element 'tds:User' of XML schema type 'tt:User'
        std::vector<tt__User *> User;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateUsers
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateUsers; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateUsers, default initialized and not managed by a soap context
        virtual _tds__CreateUsers *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateUsers); }
      public:
        /// Constructor with default initializations
        _tds__CreateUsers() : User(), soap() { }
        /// Destructor
        virtual ~_tds__CreateUsers() { }
        /// Friend allocator used by soap_new__tds__CreateUsers(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateUsers * SOAP_FMAC2 soap_instantiate__tds__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:501 */
#ifndef SOAP_TYPE__tds__CreateUsersResponse
#define SOAP_TYPE__tds__CreateUsersResponse (158)
/* complex XML schema type 'tds:CreateUsersResponse': */
class SOAP_CMAC _tds__CreateUsersResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateUsersResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateUsersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateUsersResponse, default initialized and not managed by a soap context
        virtual _tds__CreateUsersResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateUsersResponse); }
      public:
        /// Constructor with default initializations
        _tds__CreateUsersResponse() : soap() { }
        /// Destructor
        virtual ~_tds__CreateUsersResponse() { }
        /// Friend allocator used by soap_new__tds__CreateUsersResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateUsersResponse * SOAP_FMAC2 soap_instantiate__tds__CreateUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:503 */
#ifndef SOAP_TYPE__tds__DeleteUsers
#define SOAP_TYPE__tds__DeleteUsers (159)
/* complex XML schema type 'tds:DeleteUsers': */
class SOAP_CMAC _tds__DeleteUsers {
      public:
        /// Required element 'tds:Username' of XML schema type 'xsd:string'
        std::vector<std::string> Username;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteUsers
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteUsers; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteUsers, default initialized and not managed by a soap context
        virtual _tds__DeleteUsers *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteUsers); }
      public:
        /// Constructor with default initializations
        _tds__DeleteUsers() : Username(), soap() { }
        /// Destructor
        virtual ~_tds__DeleteUsers() { }
        /// Friend allocator used by soap_new__tds__DeleteUsers(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteUsers * SOAP_FMAC2 soap_instantiate__tds__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:505 */
#ifndef SOAP_TYPE__tds__DeleteUsersResponse
#define SOAP_TYPE__tds__DeleteUsersResponse (160)
/* complex XML schema type 'tds:DeleteUsersResponse': */
class SOAP_CMAC _tds__DeleteUsersResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteUsersResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteUsersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteUsersResponse, default initialized and not managed by a soap context
        virtual _tds__DeleteUsersResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteUsersResponse); }
      public:
        /// Constructor with default initializations
        _tds__DeleteUsersResponse() : soap() { }
        /// Destructor
        virtual ~_tds__DeleteUsersResponse() { }
        /// Friend allocator used by soap_new__tds__DeleteUsersResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteUsersResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteUsersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:507 */
#ifndef SOAP_TYPE__tds__SetUser
#define SOAP_TYPE__tds__SetUser (161)
/* complex XML schema type 'tds:SetUser': */
class SOAP_CMAC _tds__SetUser {
      public:
        /// Required element 'tds:User' of XML schema type 'tt:User'
        std::vector<tt__User *> User;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetUser
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetUser; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetUser, default initialized and not managed by a soap context
        virtual _tds__SetUser *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetUser); }
      public:
        /// Constructor with default initializations
        _tds__SetUser() : User(), soap() { }
        /// Destructor
        virtual ~_tds__SetUser() { }
        /// Friend allocator used by soap_new__tds__SetUser(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetUser * SOAP_FMAC2 soap_instantiate__tds__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:509 */
#ifndef SOAP_TYPE__tds__SetUserResponse
#define SOAP_TYPE__tds__SetUserResponse (162)
/* complex XML schema type 'tds:SetUserResponse': */
class SOAP_CMAC _tds__SetUserResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetUserResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetUserResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetUserResponse, default initialized and not managed by a soap context
        virtual _tds__SetUserResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetUserResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetUserResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetUserResponse() { }
        /// Friend allocator used by soap_new__tds__SetUserResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetUserResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:511 */
#ifndef SOAP_TYPE__tds__GetWsdlUrl
#define SOAP_TYPE__tds__GetWsdlUrl (163)
/* complex XML schema type 'tds:GetWsdlUrl': */
class SOAP_CMAC _tds__GetWsdlUrl {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetWsdlUrl
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetWsdlUrl; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetWsdlUrl, default initialized and not managed by a soap context
        virtual _tds__GetWsdlUrl *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetWsdlUrl); }
      public:
        /// Constructor with default initializations
        _tds__GetWsdlUrl() : soap() { }
        /// Destructor
        virtual ~_tds__GetWsdlUrl() { }
        /// Friend allocator used by soap_new__tds__GetWsdlUrl(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:513 */
#ifndef SOAP_TYPE__tds__GetWsdlUrlResponse
#define SOAP_TYPE__tds__GetWsdlUrlResponse (164)
/* complex XML schema type 'tds:GetWsdlUrlResponse': */
class SOAP_CMAC _tds__GetWsdlUrlResponse {
      public:
        /// Required element 'tds:WsdlUrl' of XML schema type 'xsd:anyURI'
        std::string WsdlUrl;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetWsdlUrlResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetWsdlUrlResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetWsdlUrlResponse, default initialized and not managed by a soap context
        virtual _tds__GetWsdlUrlResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetWsdlUrlResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetWsdlUrlResponse() : WsdlUrl(), soap() { }
        /// Destructor
        virtual ~_tds__GetWsdlUrlResponse() { }
        /// Friend allocator used by soap_new__tds__GetWsdlUrlResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetWsdlUrlResponse * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrlResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:515 */
#ifndef SOAP_TYPE__tds__GetPasswordComplexityOptions
#define SOAP_TYPE__tds__GetPasswordComplexityOptions (165)
/* complex XML schema type 'tds:GetPasswordComplexityOptions': */
class SOAP_CMAC _tds__GetPasswordComplexityOptions {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetPasswordComplexityOptions
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetPasswordComplexityOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetPasswordComplexityOptions, default initialized and not managed by a soap context
        virtual _tds__GetPasswordComplexityOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetPasswordComplexityOptions); }
      public:
        /// Constructor with default initializations
        _tds__GetPasswordComplexityOptions() : soap() { }
        /// Destructor
        virtual ~_tds__GetPasswordComplexityOptions() { }
        /// Friend allocator used by soap_new__tds__GetPasswordComplexityOptions(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetPasswordComplexityOptions * SOAP_FMAC2 soap_instantiate__tds__GetPasswordComplexityOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:517 */
#ifndef SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse
#define SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse (166)
/* complex XML schema type 'tds:GetPasswordComplexityOptionsResponse': */
class SOAP_CMAC _tds__GetPasswordComplexityOptionsResponse {
      public:
        /// Optional element 'tds:MinLenRange' of XML schema type 'tt:IntRange'
        tt__IntRange *MinLenRange;
        /// Optional element 'tds:UppercaseRange' of XML schema type 'tt:IntRange'
        tt__IntRange *UppercaseRange;
        /// Optional element 'tds:NumberRange' of XML schema type 'tt:IntRange'
        tt__IntRange *NumberRange;
        /// Optional element 'tds:SpecialCharsRange' of XML schema type 'tt:IntRange'
        tt__IntRange *SpecialCharsRange;
        /// Optional element 'tds:BlockUsernameOccurrenceSupported' of XML schema type 'xsd:boolean'
        bool *BlockUsernameOccurrenceSupported;
        /// Optional element 'tds:PolicyConfigurationLockSupported' of XML schema type 'xsd:boolean'
        bool *PolicyConfigurationLockSupported;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetPasswordComplexityOptionsResponse, default initialized and not managed by a soap context
        virtual _tds__GetPasswordComplexityOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetPasswordComplexityOptionsResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetPasswordComplexityOptionsResponse() : MinLenRange(), UppercaseRange(), NumberRange(), SpecialCharsRange(), BlockUsernameOccurrenceSupported(), PolicyConfigurationLockSupported(), soap() { }
        /// Destructor
        virtual ~_tds__GetPasswordComplexityOptionsResponse() { }
        /// Friend allocator used by soap_new__tds__GetPasswordComplexityOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetPasswordComplexityOptionsResponse * SOAP_FMAC2 soap_instantiate__tds__GetPasswordComplexityOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:519 */
#ifndef SOAP_TYPE__tds__GetPasswordComplexityConfiguration
#define SOAP_TYPE__tds__GetPasswordComplexityConfiguration (167)
/* complex XML schema type 'tds:GetPasswordComplexityConfiguration': */
class SOAP_CMAC _tds__GetPasswordComplexityConfiguration {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetPasswordComplexityConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetPasswordComplexityConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetPasswordComplexityConfiguration, default initialized and not managed by a soap context
        virtual _tds__GetPasswordComplexityConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetPasswordComplexityConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__GetPasswordComplexityConfiguration() : soap() { }
        /// Destructor
        virtual ~_tds__GetPasswordComplexityConfiguration() { }
        /// Friend allocator used by soap_new__tds__GetPasswordComplexityConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetPasswordComplexityConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetPasswordComplexityConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:521 */
#ifndef SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse
#define SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse (168)
/* complex XML schema type 'tds:GetPasswordComplexityConfigurationResponse': */
class SOAP_CMAC _tds__GetPasswordComplexityConfigurationResponse {
      public:
        /// Optional element 'tds:MinLen' of XML schema type 'xsd:int'
        int *MinLen;
        /// Optional element 'tds:Uppercase' of XML schema type 'xsd:int'
        int *Uppercase;
        /// Optional element 'tds:Number' of XML schema type 'xsd:int'
        int *Number;
        /// Optional element 'tds:SpecialChars' of XML schema type 'xsd:int'
        int *SpecialChars;
        /// Optional element 'tds:BlockUsernameOccurrence' of XML schema type 'xsd:boolean'
        bool *BlockUsernameOccurrence;
        /// Optional element 'tds:PolicyConfigurationLocked' of XML schema type 'xsd:boolean'
        bool *PolicyConfigurationLocked;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetPasswordComplexityConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__GetPasswordComplexityConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetPasswordComplexityConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetPasswordComplexityConfigurationResponse() : MinLen(), Uppercase(), Number(), SpecialChars(), BlockUsernameOccurrence(), PolicyConfigurationLocked(), soap() { }
        /// Destructor
        virtual ~_tds__GetPasswordComplexityConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__GetPasswordComplexityConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetPasswordComplexityConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetPasswordComplexityConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:523 */
#ifndef SOAP_TYPE__tds__SetPasswordComplexityConfiguration
#define SOAP_TYPE__tds__SetPasswordComplexityConfiguration (169)
/* complex XML schema type 'tds:SetPasswordComplexityConfiguration': */
class SOAP_CMAC _tds__SetPasswordComplexityConfiguration {
      public:
        /// Optional element 'tds:MinLen' of XML schema type 'xsd:int'
        int *MinLen;
        /// Optional element 'tds:Uppercase' of XML schema type 'xsd:int'
        int *Uppercase;
        /// Optional element 'tds:Number' of XML schema type 'xsd:int'
        int *Number;
        /// Optional element 'tds:SpecialChars' of XML schema type 'xsd:int'
        int *SpecialChars;
        /// Optional element 'tds:BlockUsernameOccurrence' of XML schema type 'xsd:boolean'
        bool *BlockUsernameOccurrence;
        /// Optional element 'tds:PolicyConfigurationLocked' of XML schema type 'xsd:boolean'
        bool *PolicyConfigurationLocked;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetPasswordComplexityConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetPasswordComplexityConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetPasswordComplexityConfiguration, default initialized and not managed by a soap context
        virtual _tds__SetPasswordComplexityConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetPasswordComplexityConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__SetPasswordComplexityConfiguration() : MinLen(), Uppercase(), Number(), SpecialChars(), BlockUsernameOccurrence(), PolicyConfigurationLocked(), soap() { }
        /// Destructor
        virtual ~_tds__SetPasswordComplexityConfiguration() { }
        /// Friend allocator used by soap_new__tds__SetPasswordComplexityConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetPasswordComplexityConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetPasswordComplexityConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:525 */
#ifndef SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse
#define SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse (170)
/* complex XML schema type 'tds:SetPasswordComplexityConfigurationResponse': */
class SOAP_CMAC _tds__SetPasswordComplexityConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetPasswordComplexityConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__SetPasswordComplexityConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetPasswordComplexityConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetPasswordComplexityConfigurationResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetPasswordComplexityConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__SetPasswordComplexityConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetPasswordComplexityConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetPasswordComplexityConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:527 */
#ifndef SOAP_TYPE__tds__GetPasswordHistoryConfiguration
#define SOAP_TYPE__tds__GetPasswordHistoryConfiguration (171)
/* complex XML schema type 'tds:GetPasswordHistoryConfiguration': */
class SOAP_CMAC _tds__GetPasswordHistoryConfiguration {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetPasswordHistoryConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetPasswordHistoryConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetPasswordHistoryConfiguration, default initialized and not managed by a soap context
        virtual _tds__GetPasswordHistoryConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetPasswordHistoryConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__GetPasswordHistoryConfiguration() : soap() { }
        /// Destructor
        virtual ~_tds__GetPasswordHistoryConfiguration() { }
        /// Friend allocator used by soap_new__tds__GetPasswordHistoryConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetPasswordHistoryConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetPasswordHistoryConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:529 */
#ifndef SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse
#define SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse (172)
/* complex XML schema type 'tds:GetPasswordHistoryConfigurationResponse': */
class SOAP_CMAC _tds__GetPasswordHistoryConfigurationResponse {
      public:
        /// Required element 'tds:Enabled' of XML schema type 'xsd:boolean'
        bool Enabled;
        /// Required element 'tds:Length' of XML schema type 'xsd:int'
        int Length;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetPasswordHistoryConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__GetPasswordHistoryConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetPasswordHistoryConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetPasswordHistoryConfigurationResponse() : Enabled(), Length(), soap() { }
        /// Destructor
        virtual ~_tds__GetPasswordHistoryConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__GetPasswordHistoryConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetPasswordHistoryConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetPasswordHistoryConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:531 */
#ifndef SOAP_TYPE__tds__SetPasswordHistoryConfiguration
#define SOAP_TYPE__tds__SetPasswordHistoryConfiguration (173)
/* complex XML schema type 'tds:SetPasswordHistoryConfiguration': */
class SOAP_CMAC _tds__SetPasswordHistoryConfiguration {
      public:
        /// Required element 'tds:Enabled' of XML schema type 'xsd:boolean'
        bool Enabled;
        /// Required element 'tds:Length' of XML schema type 'xsd:int'
        int Length;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetPasswordHistoryConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetPasswordHistoryConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetPasswordHistoryConfiguration, default initialized and not managed by a soap context
        virtual _tds__SetPasswordHistoryConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetPasswordHistoryConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__SetPasswordHistoryConfiguration() : Enabled(), Length(), soap() { }
        /// Destructor
        virtual ~_tds__SetPasswordHistoryConfiguration() { }
        /// Friend allocator used by soap_new__tds__SetPasswordHistoryConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetPasswordHistoryConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetPasswordHistoryConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:533 */
#ifndef SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse
#define SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse (174)
/* complex XML schema type 'tds:SetPasswordHistoryConfigurationResponse': */
class SOAP_CMAC _tds__SetPasswordHistoryConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetPasswordHistoryConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__SetPasswordHistoryConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetPasswordHistoryConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetPasswordHistoryConfigurationResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetPasswordHistoryConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__SetPasswordHistoryConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetPasswordHistoryConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetPasswordHistoryConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:535 */
#ifndef SOAP_TYPE__tds__GetAuthFailureWarningOptions
#define SOAP_TYPE__tds__GetAuthFailureWarningOptions (175)
/* complex XML schema type 'tds:GetAuthFailureWarningOptions': */
class SOAP_CMAC _tds__GetAuthFailureWarningOptions {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetAuthFailureWarningOptions
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetAuthFailureWarningOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetAuthFailureWarningOptions, default initialized and not managed by a soap context
        virtual _tds__GetAuthFailureWarningOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetAuthFailureWarningOptions); }
      public:
        /// Constructor with default initializations
        _tds__GetAuthFailureWarningOptions() : soap() { }
        /// Destructor
        virtual ~_tds__GetAuthFailureWarningOptions() { }
        /// Friend allocator used by soap_new__tds__GetAuthFailureWarningOptions(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetAuthFailureWarningOptions * SOAP_FMAC2 soap_instantiate__tds__GetAuthFailureWarningOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:537 */
#ifndef SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse
#define SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse (176)
/* complex XML schema type 'tds:GetAuthFailureWarningOptionsResponse': */
class SOAP_CMAC _tds__GetAuthFailureWarningOptionsResponse {
      public:
        /// Required element 'tds:MonitorPeriodRange' of XML schema type 'tt:IntRange'
        tt__IntRange *MonitorPeriodRange;
        /// Required element 'tds:AuthFailureRange' of XML schema type 'tt:IntRange'
        tt__IntRange *AuthFailureRange;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetAuthFailureWarningOptionsResponse, default initialized and not managed by a soap context
        virtual _tds__GetAuthFailureWarningOptionsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetAuthFailureWarningOptionsResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetAuthFailureWarningOptionsResponse() : MonitorPeriodRange(), AuthFailureRange(), soap() { }
        /// Destructor
        virtual ~_tds__GetAuthFailureWarningOptionsResponse() { }
        /// Friend allocator used by soap_new__tds__GetAuthFailureWarningOptionsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetAuthFailureWarningOptionsResponse * SOAP_FMAC2 soap_instantiate__tds__GetAuthFailureWarningOptionsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:539 */
#ifndef SOAP_TYPE__tds__GetAuthFailureWarningConfiguration
#define SOAP_TYPE__tds__GetAuthFailureWarningConfiguration (177)
/* complex XML schema type 'tds:GetAuthFailureWarningConfiguration': */
class SOAP_CMAC _tds__GetAuthFailureWarningConfiguration {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetAuthFailureWarningConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetAuthFailureWarningConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetAuthFailureWarningConfiguration, default initialized and not managed by a soap context
        virtual _tds__GetAuthFailureWarningConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetAuthFailureWarningConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__GetAuthFailureWarningConfiguration() : soap() { }
        /// Destructor
        virtual ~_tds__GetAuthFailureWarningConfiguration() { }
        /// Friend allocator used by soap_new__tds__GetAuthFailureWarningConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetAuthFailureWarningConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:541 */
#ifndef SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse
#define SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse (178)
/* complex XML schema type 'tds:GetAuthFailureWarningConfigurationResponse': */
class SOAP_CMAC _tds__GetAuthFailureWarningConfigurationResponse {
      public:
        /// Required element 'tds:Enabled' of XML schema type 'xsd:boolean'
        bool Enabled;
        /// Required element 'tds:MonitorPeriod' of XML schema type 'xsd:int'
        int MonitorPeriod;
        /// Required element 'tds:MaxAuthFailures' of XML schema type 'xsd:int'
        int MaxAuthFailures;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetAuthFailureWarningConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__GetAuthFailureWarningConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetAuthFailureWarningConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetAuthFailureWarningConfigurationResponse() : Enabled(), MonitorPeriod(), MaxAuthFailures(), soap() { }
        /// Destructor
        virtual ~_tds__GetAuthFailureWarningConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__GetAuthFailureWarningConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetAuthFailureWarningConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetAuthFailureWarningConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:543 */
#ifndef SOAP_TYPE__tds__SetAuthFailureWarningConfiguration
#define SOAP_TYPE__tds__SetAuthFailureWarningConfiguration (179)
/* complex XML schema type 'tds:SetAuthFailureWarningConfiguration': */
class SOAP_CMAC _tds__SetAuthFailureWarningConfiguration {
      public:
        /// Required element 'tds:Enabled' of XML schema type 'xsd:boolean'
        bool Enabled;
        /// Required element 'tds:MonitorPeriod' of XML schema type 'xsd:int'
        int MonitorPeriod;
        /// Required element 'tds:MaxAuthFailures' of XML schema type 'xsd:int'
        int MaxAuthFailures;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetAuthFailureWarningConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetAuthFailureWarningConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetAuthFailureWarningConfiguration, default initialized and not managed by a soap context
        virtual _tds__SetAuthFailureWarningConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetAuthFailureWarningConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__SetAuthFailureWarningConfiguration() : Enabled(), MonitorPeriod(), MaxAuthFailures(), soap() { }
        /// Destructor
        virtual ~_tds__SetAuthFailureWarningConfiguration() { }
        /// Friend allocator used by soap_new__tds__SetAuthFailureWarningConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetAuthFailureWarningConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:545 */
#ifndef SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse
#define SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse (180)
/* complex XML schema type 'tds:SetAuthFailureWarningConfigurationResponse': */
class SOAP_CMAC _tds__SetAuthFailureWarningConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetAuthFailureWarningConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__SetAuthFailureWarningConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetAuthFailureWarningConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetAuthFailureWarningConfigurationResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetAuthFailureWarningConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__SetAuthFailureWarningConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetAuthFailureWarningConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetAuthFailureWarningConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:547 */
#ifndef SOAP_TYPE__tds__GetCapabilities
#define SOAP_TYPE__tds__GetCapabilities (181)
/* complex XML schema type 'tds:GetCapabilities': */
class SOAP_CMAC _tds__GetCapabilities {
      public:
        /// Optional element 'tds:Category' of XML schema type 'tt:CapabilityCategory'
        std::vector<enum tt__CapabilityCategory> Category;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCapabilities, default initialized and not managed by a soap context
        virtual _tds__GetCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCapabilities); }
      public:
        /// Constructor with default initializations
        _tds__GetCapabilities() : Category(), soap() { }
        /// Destructor
        virtual ~_tds__GetCapabilities() { }
        /// Friend allocator used by soap_new__tds__GetCapabilities(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:549 */
#ifndef SOAP_TYPE__tds__GetCapabilitiesResponse
#define SOAP_TYPE__tds__GetCapabilitiesResponse (182)
/* complex XML schema type 'tds:GetCapabilitiesResponse': */
class SOAP_CMAC _tds__GetCapabilitiesResponse {
      public:
        /// Required element 'tds:Capabilities' of XML schema type 'tt:Capabilities'
        tt__Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCapabilitiesResponse, default initialized and not managed by a soap context
        virtual _tds__GetCapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCapabilitiesResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetCapabilitiesResponse() : Capabilities(), soap() { }
        /// Destructor
        virtual ~_tds__GetCapabilitiesResponse() { }
        /// Friend allocator used by soap_new__tds__GetCapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:551 */
#ifndef SOAP_TYPE__tds__GetHostname
#define SOAP_TYPE__tds__GetHostname (183)
/* complex XML schema type 'tds:GetHostname': */
class SOAP_CMAC _tds__GetHostname {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetHostname
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetHostname; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetHostname, default initialized and not managed by a soap context
        virtual _tds__GetHostname *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetHostname); }
      public:
        /// Constructor with default initializations
        _tds__GetHostname() : soap() { }
        /// Destructor
        virtual ~_tds__GetHostname() { }
        /// Friend allocator used by soap_new__tds__GetHostname(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetHostname * SOAP_FMAC2 soap_instantiate__tds__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:553 */
#ifndef SOAP_TYPE__tds__GetHostnameResponse
#define SOAP_TYPE__tds__GetHostnameResponse (184)
/* complex XML schema type 'tds:GetHostnameResponse': */
class SOAP_CMAC _tds__GetHostnameResponse {
      public:
        /// Required element 'tds:HostnameInformation' of XML schema type 'tt:HostnameInformation'
        tt__HostnameInformation *HostnameInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetHostnameResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetHostnameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetHostnameResponse, default initialized and not managed by a soap context
        virtual _tds__GetHostnameResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetHostnameResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetHostnameResponse() : HostnameInformation(), soap() { }
        /// Destructor
        virtual ~_tds__GetHostnameResponse() { }
        /// Friend allocator used by soap_new__tds__GetHostnameResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__GetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:555 */
#ifndef SOAP_TYPE__tds__SetHostname
#define SOAP_TYPE__tds__SetHostname (185)
/* complex XML schema type 'tds:SetHostname': */
class SOAP_CMAC _tds__SetHostname {
      public:
        /// Required element 'tds:Name' of XML schema type 'xsd:token'
        std::string Name;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetHostname
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetHostname; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetHostname, default initialized and not managed by a soap context
        virtual _tds__SetHostname *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetHostname); }
      public:
        /// Constructor with default initializations
        _tds__SetHostname() : Name(), soap() { }
        /// Destructor
        virtual ~_tds__SetHostname() { }
        /// Friend allocator used by soap_new__tds__SetHostname(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetHostname * SOAP_FMAC2 soap_instantiate__tds__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:557 */
#ifndef SOAP_TYPE__tds__SetHostnameResponse
#define SOAP_TYPE__tds__SetHostnameResponse (186)
/* complex XML schema type 'tds:SetHostnameResponse': */
class SOAP_CMAC _tds__SetHostnameResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetHostnameResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetHostnameResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetHostnameResponse, default initialized and not managed by a soap context
        virtual _tds__SetHostnameResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetHostnameResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetHostnameResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetHostnameResponse() { }
        /// Friend allocator used by soap_new__tds__SetHostnameResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:559 */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCP
#define SOAP_TYPE__tds__SetHostnameFromDHCP (187)
/* complex XML schema type 'tds:SetHostnameFromDHCP': */
class SOAP_CMAC _tds__SetHostnameFromDHCP {
      public:
        /// Required element 'tds:FromDHCP' of XML schema type 'xsd:boolean'
        bool FromDHCP;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetHostnameFromDHCP
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetHostnameFromDHCP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetHostnameFromDHCP, default initialized and not managed by a soap context
        virtual _tds__SetHostnameFromDHCP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetHostnameFromDHCP); }
      public:
        /// Constructor with default initializations
        _tds__SetHostnameFromDHCP() : FromDHCP(), soap() { }
        /// Destructor
        virtual ~_tds__SetHostnameFromDHCP() { }
        /// Friend allocator used by soap_new__tds__SetHostnameFromDHCP(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:561 */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCPResponse
#define SOAP_TYPE__tds__SetHostnameFromDHCPResponse (188)
/* complex XML schema type 'tds:SetHostnameFromDHCPResponse': */
class SOAP_CMAC _tds__SetHostnameFromDHCPResponse {
      public:
        /// Required element 'tds:RebootNeeded' of XML schema type 'xsd:boolean'
        bool RebootNeeded;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetHostnameFromDHCPResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetHostnameFromDHCPResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetHostnameFromDHCPResponse, default initialized and not managed by a soap context
        virtual _tds__SetHostnameFromDHCPResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetHostnameFromDHCPResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetHostnameFromDHCPResponse() : RebootNeeded(), soap() { }
        /// Destructor
        virtual ~_tds__SetHostnameFromDHCPResponse() { }
        /// Friend allocator used by soap_new__tds__SetHostnameFromDHCPResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:563 */
#ifndef SOAP_TYPE__tds__GetDNS
#define SOAP_TYPE__tds__GetDNS (189)
/* complex XML schema type 'tds:GetDNS': */
class SOAP_CMAC _tds__GetDNS {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDNS
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDNS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDNS, default initialized and not managed by a soap context
        virtual _tds__GetDNS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDNS); }
      public:
        /// Constructor with default initializations
        _tds__GetDNS() : soap() { }
        /// Destructor
        virtual ~_tds__GetDNS() { }
        /// Friend allocator used by soap_new__tds__GetDNS(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDNS * SOAP_FMAC2 soap_instantiate__tds__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:565 */
#ifndef SOAP_TYPE__tds__GetDNSResponse
#define SOAP_TYPE__tds__GetDNSResponse (190)
/* complex XML schema type 'tds:GetDNSResponse': */
class SOAP_CMAC _tds__GetDNSResponse {
      public:
        /// Required element 'tds:DNSInformation' of XML schema type 'tt:DNSInformation'
        tt__DNSInformation *DNSInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDNSResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDNSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDNSResponse, default initialized and not managed by a soap context
        virtual _tds__GetDNSResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDNSResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetDNSResponse() : DNSInformation(), soap() { }
        /// Destructor
        virtual ~_tds__GetDNSResponse() { }
        /// Friend allocator used by soap_new__tds__GetDNSResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:567 */
#ifndef SOAP_TYPE__tds__SetDNS
#define SOAP_TYPE__tds__SetDNS (191)
/* complex XML schema type 'tds:SetDNS': */
class SOAP_CMAC _tds__SetDNS {
      public:
        /// Required element 'tds:FromDHCP' of XML schema type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'tds:SearchDomain' of XML schema type 'xsd:token'
        std::vector<std::string> SearchDomain;
        /// Optional element 'tds:DNSManual' of XML schema type 'tt:IPAddress'
        std::vector<tt__IPAddress *> DNSManual;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDNS
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDNS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDNS, default initialized and not managed by a soap context
        virtual _tds__SetDNS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDNS); }
      public:
        /// Constructor with default initializations
        _tds__SetDNS() : FromDHCP(), SearchDomain(), DNSManual(), soap() { }
        /// Destructor
        virtual ~_tds__SetDNS() { }
        /// Friend allocator used by soap_new__tds__SetDNS(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDNS * SOAP_FMAC2 soap_instantiate__tds__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:569 */
#ifndef SOAP_TYPE__tds__SetDNSResponse
#define SOAP_TYPE__tds__SetDNSResponse (192)
/* complex XML schema type 'tds:SetDNSResponse': */
class SOAP_CMAC _tds__SetDNSResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDNSResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDNSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDNSResponse, default initialized and not managed by a soap context
        virtual _tds__SetDNSResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDNSResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetDNSResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetDNSResponse() { }
        /// Friend allocator used by soap_new__tds__SetDNSResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:571 */
#ifndef SOAP_TYPE__tds__GetNTP
#define SOAP_TYPE__tds__GetNTP (193)
/* complex XML schema type 'tds:GetNTP': */
class SOAP_CMAC _tds__GetNTP {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNTP
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNTP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNTP, default initialized and not managed by a soap context
        virtual _tds__GetNTP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNTP); }
      public:
        /// Constructor with default initializations
        _tds__GetNTP() : soap() { }
        /// Destructor
        virtual ~_tds__GetNTP() { }
        /// Friend allocator used by soap_new__tds__GetNTP(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNTP * SOAP_FMAC2 soap_instantiate__tds__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:573 */
#ifndef SOAP_TYPE__tds__GetNTPResponse
#define SOAP_TYPE__tds__GetNTPResponse (194)
/* complex XML schema type 'tds:GetNTPResponse': */
class SOAP_CMAC _tds__GetNTPResponse {
      public:
        /// Required element 'tds:NTPInformation' of XML schema type 'tt:NTPInformation'
        tt__NTPInformation *NTPInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNTPResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNTPResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNTPResponse, default initialized and not managed by a soap context
        virtual _tds__GetNTPResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNTPResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetNTPResponse() : NTPInformation(), soap() { }
        /// Destructor
        virtual ~_tds__GetNTPResponse() { }
        /// Friend allocator used by soap_new__tds__GetNTPResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__GetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:575 */
#ifndef SOAP_TYPE__tds__SetNTP
#define SOAP_TYPE__tds__SetNTP (195)
/* complex XML schema type 'tds:SetNTP': */
class SOAP_CMAC _tds__SetNTP {
      public:
        /// Required element 'tds:FromDHCP' of XML schema type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'tds:NTPManual' of XML schema type 'tt:NetworkHost'
        std::vector<tt__NetworkHost *> NTPManual;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNTP
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNTP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNTP, default initialized and not managed by a soap context
        virtual _tds__SetNTP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNTP); }
      public:
        /// Constructor with default initializations
        _tds__SetNTP() : FromDHCP(), NTPManual(), soap() { }
        /// Destructor
        virtual ~_tds__SetNTP() { }
        /// Friend allocator used by soap_new__tds__SetNTP(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNTP * SOAP_FMAC2 soap_instantiate__tds__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:577 */
#ifndef SOAP_TYPE__tds__SetNTPResponse
#define SOAP_TYPE__tds__SetNTPResponse (196)
/* complex XML schema type 'tds:SetNTPResponse': */
class SOAP_CMAC _tds__SetNTPResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNTPResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNTPResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNTPResponse, default initialized and not managed by a soap context
        virtual _tds__SetNTPResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNTPResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetNTPResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetNTPResponse() { }
        /// Friend allocator used by soap_new__tds__SetNTPResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__SetNTPResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:579 */
#ifndef SOAP_TYPE__tds__GetDynamicDNS
#define SOAP_TYPE__tds__GetDynamicDNS (197)
/* complex XML schema type 'tds:GetDynamicDNS': */
class SOAP_CMAC _tds__GetDynamicDNS {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDynamicDNS
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDynamicDNS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDynamicDNS, default initialized and not managed by a soap context
        virtual _tds__GetDynamicDNS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDynamicDNS); }
      public:
        /// Constructor with default initializations
        _tds__GetDynamicDNS() : soap() { }
        /// Destructor
        virtual ~_tds__GetDynamicDNS() { }
        /// Friend allocator used by soap_new__tds__GetDynamicDNS(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:581 */
#ifndef SOAP_TYPE__tds__GetDynamicDNSResponse
#define SOAP_TYPE__tds__GetDynamicDNSResponse (198)
/* complex XML schema type 'tds:GetDynamicDNSResponse': */
class SOAP_CMAC _tds__GetDynamicDNSResponse {
      public:
        /// Required element 'tds:DynamicDNSInformation' of XML schema type 'tt:DynamicDNSInformation'
        tt__DynamicDNSInformation *DynamicDNSInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDynamicDNSResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDynamicDNSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDynamicDNSResponse, default initialized and not managed by a soap context
        virtual _tds__GetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDynamicDNSResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetDynamicDNSResponse() : DynamicDNSInformation(), soap() { }
        /// Destructor
        virtual ~_tds__GetDynamicDNSResponse() { }
        /// Friend allocator used by soap_new__tds__GetDynamicDNSResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:583 */
#ifndef SOAP_TYPE__tds__SetDynamicDNS
#define SOAP_TYPE__tds__SetDynamicDNS (199)
/* complex XML schema type 'tds:SetDynamicDNS': */
class SOAP_CMAC _tds__SetDynamicDNS {
      public:
        /// Required element 'tds:Type' of XML schema type 'tt:DynamicDNSType'
        enum tt__DynamicDNSType Type;
        /// Optional element 'tds:Name' of XML schema type 'tt:DNSName'
        std::string *Name;
        /// Optional element 'tds:TTL' of XML schema type 'xsd:duration'
        std::string *TTL;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDynamicDNS
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDynamicDNS; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDynamicDNS, default initialized and not managed by a soap context
        virtual _tds__SetDynamicDNS *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDynamicDNS); }
      public:
        /// Constructor with default initializations
        _tds__SetDynamicDNS() : Type(), Name(), TTL(), soap() { }
        /// Destructor
        virtual ~_tds__SetDynamicDNS() { }
        /// Friend allocator used by soap_new__tds__SetDynamicDNS(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:585 */
#ifndef SOAP_TYPE__tds__SetDynamicDNSResponse
#define SOAP_TYPE__tds__SetDynamicDNSResponse (200)
/* complex XML schema type 'tds:SetDynamicDNSResponse': */
class SOAP_CMAC _tds__SetDynamicDNSResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDynamicDNSResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDynamicDNSResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDynamicDNSResponse, default initialized and not managed by a soap context
        virtual _tds__SetDynamicDNSResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDynamicDNSResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetDynamicDNSResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetDynamicDNSResponse() { }
        /// Friend allocator used by soap_new__tds__SetDynamicDNSResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNSResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:587 */
#ifndef SOAP_TYPE__tds__GetNetworkInterfaces
#define SOAP_TYPE__tds__GetNetworkInterfaces (201)
/* complex XML schema type 'tds:GetNetworkInterfaces': */
class SOAP_CMAC _tds__GetNetworkInterfaces {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNetworkInterfaces
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNetworkInterfaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNetworkInterfaces, default initialized and not managed by a soap context
        virtual _tds__GetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNetworkInterfaces); }
      public:
        /// Constructor with default initializations
        _tds__GetNetworkInterfaces() : soap() { }
        /// Destructor
        virtual ~_tds__GetNetworkInterfaces() { }
        /// Friend allocator used by soap_new__tds__GetNetworkInterfaces(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:589 */
#ifndef SOAP_TYPE__tds__GetNetworkInterfacesResponse
#define SOAP_TYPE__tds__GetNetworkInterfacesResponse (202)
/* complex XML schema type 'tds:GetNetworkInterfacesResponse': */
class SOAP_CMAC _tds__GetNetworkInterfacesResponse {
      public:
        /// Required element 'tds:NetworkInterfaces' of XML schema type 'tt:NetworkInterface'
        std::vector<tt__NetworkInterface *> NetworkInterfaces;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNetworkInterfacesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNetworkInterfacesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNetworkInterfacesResponse, default initialized and not managed by a soap context
        virtual _tds__GetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNetworkInterfacesResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetNetworkInterfacesResponse() : NetworkInterfaces(), soap() { }
        /// Destructor
        virtual ~_tds__GetNetworkInterfacesResponse() { }
        /// Friend allocator used by soap_new__tds__GetNetworkInterfacesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:591 */
#ifndef SOAP_TYPE__tds__SetNetworkInterfaces
#define SOAP_TYPE__tds__SetNetworkInterfaces (203)
/* complex XML schema type 'tds:SetNetworkInterfaces': */
class SOAP_CMAC _tds__SetNetworkInterfaces {
      public:
        /// Required element 'tds:InterfaceToken' of XML schema type 'tt:ReferenceToken'
        std::string InterfaceToken;
        /// Required element 'tds:NetworkInterface' of XML schema type 'tt:NetworkInterfaceSetConfiguration'
        tt__NetworkInterfaceSetConfiguration *NetworkInterface;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNetworkInterfaces
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNetworkInterfaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNetworkInterfaces, default initialized and not managed by a soap context
        virtual _tds__SetNetworkInterfaces *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNetworkInterfaces); }
      public:
        /// Constructor with default initializations
        _tds__SetNetworkInterfaces() : InterfaceToken(), NetworkInterface(), soap() { }
        /// Destructor
        virtual ~_tds__SetNetworkInterfaces() { }
        /// Friend allocator used by soap_new__tds__SetNetworkInterfaces(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:593 */
#ifndef SOAP_TYPE__tds__SetNetworkInterfacesResponse
#define SOAP_TYPE__tds__SetNetworkInterfacesResponse (204)
/* complex XML schema type 'tds:SetNetworkInterfacesResponse': */
class SOAP_CMAC _tds__SetNetworkInterfacesResponse {
      public:
        /// Required element 'tds:RebootNeeded' of XML schema type 'xsd:boolean'
        bool RebootNeeded;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNetworkInterfacesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNetworkInterfacesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNetworkInterfacesResponse, default initialized and not managed by a soap context
        virtual _tds__SetNetworkInterfacesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNetworkInterfacesResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetNetworkInterfacesResponse() : RebootNeeded(), soap() { }
        /// Destructor
        virtual ~_tds__SetNetworkInterfacesResponse() { }
        /// Friend allocator used by soap_new__tds__SetNetworkInterfacesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfacesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:595 */
#ifndef SOAP_TYPE__tds__GetNetworkProtocols
#define SOAP_TYPE__tds__GetNetworkProtocols (205)
/* complex XML schema type 'tds:GetNetworkProtocols': */
class SOAP_CMAC _tds__GetNetworkProtocols {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNetworkProtocols
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNetworkProtocols; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNetworkProtocols, default initialized and not managed by a soap context
        virtual _tds__GetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNetworkProtocols); }
      public:
        /// Constructor with default initializations
        _tds__GetNetworkProtocols() : soap() { }
        /// Destructor
        virtual ~_tds__GetNetworkProtocols() { }
        /// Friend allocator used by soap_new__tds__GetNetworkProtocols(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:597 */
#ifndef SOAP_TYPE__tds__GetNetworkProtocolsResponse
#define SOAP_TYPE__tds__GetNetworkProtocolsResponse (206)
/* complex XML schema type 'tds:GetNetworkProtocolsResponse': */
class SOAP_CMAC _tds__GetNetworkProtocolsResponse {
      public:
        /// Optional element 'tds:NetworkProtocols' of XML schema type 'tt:NetworkProtocol'
        std::vector<tt__NetworkProtocol *> NetworkProtocols;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNetworkProtocolsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNetworkProtocolsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNetworkProtocolsResponse, default initialized and not managed by a soap context
        virtual _tds__GetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNetworkProtocolsResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetNetworkProtocolsResponse() : NetworkProtocols(), soap() { }
        /// Destructor
        virtual ~_tds__GetNetworkProtocolsResponse() { }
        /// Friend allocator used by soap_new__tds__GetNetworkProtocolsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:599 */
#ifndef SOAP_TYPE__tds__SetNetworkProtocols
#define SOAP_TYPE__tds__SetNetworkProtocols (207)
/* complex XML schema type 'tds:SetNetworkProtocols': */
class SOAP_CMAC _tds__SetNetworkProtocols {
      public:
        /// Required element 'tds:NetworkProtocols' of XML schema type 'tt:NetworkProtocol'
        std::vector<tt__NetworkProtocol *> NetworkProtocols;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNetworkProtocols
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNetworkProtocols; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNetworkProtocols, default initialized and not managed by a soap context
        virtual _tds__SetNetworkProtocols *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNetworkProtocols); }
      public:
        /// Constructor with default initializations
        _tds__SetNetworkProtocols() : NetworkProtocols(), soap() { }
        /// Destructor
        virtual ~_tds__SetNetworkProtocols() { }
        /// Friend allocator used by soap_new__tds__SetNetworkProtocols(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:601 */
#ifndef SOAP_TYPE__tds__SetNetworkProtocolsResponse
#define SOAP_TYPE__tds__SetNetworkProtocolsResponse (208)
/* complex XML schema type 'tds:SetNetworkProtocolsResponse': */
class SOAP_CMAC _tds__SetNetworkProtocolsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNetworkProtocolsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNetworkProtocolsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNetworkProtocolsResponse, default initialized and not managed by a soap context
        virtual _tds__SetNetworkProtocolsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNetworkProtocolsResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetNetworkProtocolsResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetNetworkProtocolsResponse() { }
        /// Friend allocator used by soap_new__tds__SetNetworkProtocolsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocolsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:603 */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGateway
#define SOAP_TYPE__tds__GetNetworkDefaultGateway (209)
/* complex XML schema type 'tds:GetNetworkDefaultGateway': */
class SOAP_CMAC _tds__GetNetworkDefaultGateway {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNetworkDefaultGateway
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNetworkDefaultGateway; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNetworkDefaultGateway, default initialized and not managed by a soap context
        virtual _tds__GetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNetworkDefaultGateway); }
      public:
        /// Constructor with default initializations
        _tds__GetNetworkDefaultGateway() : soap() { }
        /// Destructor
        virtual ~_tds__GetNetworkDefaultGateway() { }
        /// Friend allocator used by soap_new__tds__GetNetworkDefaultGateway(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:605 */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (210)
/* complex XML schema type 'tds:GetNetworkDefaultGatewayResponse': */
class SOAP_CMAC _tds__GetNetworkDefaultGatewayResponse {
      public:
        /// Required element 'tds:NetworkGateway' of XML schema type 'tt:NetworkGateway'
        tt__NetworkGateway *NetworkGateway;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
        virtual _tds__GetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetNetworkDefaultGatewayResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetNetworkDefaultGatewayResponse() : NetworkGateway(), soap() { }
        /// Destructor
        virtual ~_tds__GetNetworkDefaultGatewayResponse() { }
        /// Friend allocator used by soap_new__tds__GetNetworkDefaultGatewayResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:607 */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGateway
#define SOAP_TYPE__tds__SetNetworkDefaultGateway (211)
/* complex XML schema type 'tds:SetNetworkDefaultGateway': */
class SOAP_CMAC _tds__SetNetworkDefaultGateway {
      public:
        /// Optional element 'tds:IPv4Address' of XML schema type 'tt:IPv4Address'
        std::vector<std::string> IPv4Address;
        /// Optional element 'tds:IPv6Address' of XML schema type 'tt:IPv6Address'
        std::vector<std::string> IPv6Address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNetworkDefaultGateway
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNetworkDefaultGateway; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNetworkDefaultGateway, default initialized and not managed by a soap context
        virtual _tds__SetNetworkDefaultGateway *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNetworkDefaultGateway); }
      public:
        /// Constructor with default initializations
        _tds__SetNetworkDefaultGateway() : IPv4Address(), IPv6Address(), soap() { }
        /// Destructor
        virtual ~_tds__SetNetworkDefaultGateway() { }
        /// Friend allocator used by soap_new__tds__SetNetworkDefaultGateway(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:609 */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (212)
/* complex XML schema type 'tds:SetNetworkDefaultGatewayResponse': */
class SOAP_CMAC _tds__SetNetworkDefaultGatewayResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetNetworkDefaultGatewayResponse, default initialized and not managed by a soap context
        virtual _tds__SetNetworkDefaultGatewayResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetNetworkDefaultGatewayResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetNetworkDefaultGatewayResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetNetworkDefaultGatewayResponse() { }
        /// Friend allocator used by soap_new__tds__SetNetworkDefaultGatewayResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGatewayResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:611 */
#ifndef SOAP_TYPE__tds__GetZeroConfiguration
#define SOAP_TYPE__tds__GetZeroConfiguration (213)
/* complex XML schema type 'tds:GetZeroConfiguration': */
class SOAP_CMAC _tds__GetZeroConfiguration {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetZeroConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetZeroConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetZeroConfiguration, default initialized and not managed by a soap context
        virtual _tds__GetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetZeroConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__GetZeroConfiguration() : soap() { }
        /// Destructor
        virtual ~_tds__GetZeroConfiguration() { }
        /// Friend allocator used by soap_new__tds__GetZeroConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:613 */
#ifndef SOAP_TYPE__tds__GetZeroConfigurationResponse
#define SOAP_TYPE__tds__GetZeroConfigurationResponse (214)
/* complex XML schema type 'tds:GetZeroConfigurationResponse': */
class SOAP_CMAC _tds__GetZeroConfigurationResponse {
      public:
        /// Required element 'tds:ZeroConfiguration' of XML schema type 'tt:NetworkZeroConfiguration'
        tt__NetworkZeroConfiguration *ZeroConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetZeroConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetZeroConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetZeroConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__GetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetZeroConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetZeroConfigurationResponse() : ZeroConfiguration(), soap() { }
        /// Destructor
        virtual ~_tds__GetZeroConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__GetZeroConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:615 */
#ifndef SOAP_TYPE__tds__SetZeroConfiguration
#define SOAP_TYPE__tds__SetZeroConfiguration (215)
/* complex XML schema type 'tds:SetZeroConfiguration': */
class SOAP_CMAC _tds__SetZeroConfiguration {
      public:
        /// Required element 'tds:InterfaceToken' of XML schema type 'tt:ReferenceToken'
        std::string InterfaceToken;
        /// Required element 'tds:Enabled' of XML schema type 'xsd:boolean'
        bool Enabled;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetZeroConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetZeroConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetZeroConfiguration, default initialized and not managed by a soap context
        virtual _tds__SetZeroConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetZeroConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__SetZeroConfiguration() : InterfaceToken(), Enabled(), soap() { }
        /// Destructor
        virtual ~_tds__SetZeroConfiguration() { }
        /// Friend allocator used by soap_new__tds__SetZeroConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:617 */
#ifndef SOAP_TYPE__tds__SetZeroConfigurationResponse
#define SOAP_TYPE__tds__SetZeroConfigurationResponse (216)
/* complex XML schema type 'tds:SetZeroConfigurationResponse': */
class SOAP_CMAC _tds__SetZeroConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetZeroConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetZeroConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetZeroConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__SetZeroConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetZeroConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetZeroConfigurationResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetZeroConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__SetZeroConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:619 */
#ifndef SOAP_TYPE__tds__GetIPAddressFilter
#define SOAP_TYPE__tds__GetIPAddressFilter (217)
/* complex XML schema type 'tds:GetIPAddressFilter': */
class SOAP_CMAC _tds__GetIPAddressFilter {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetIPAddressFilter
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetIPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetIPAddressFilter, default initialized and not managed by a soap context
        virtual _tds__GetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetIPAddressFilter); }
      public:
        /// Constructor with default initializations
        _tds__GetIPAddressFilter() : soap() { }
        /// Destructor
        virtual ~_tds__GetIPAddressFilter() { }
        /// Friend allocator used by soap_new__tds__GetIPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:621 */
#ifndef SOAP_TYPE__tds__GetIPAddressFilterResponse
#define SOAP_TYPE__tds__GetIPAddressFilterResponse (218)
/* complex XML schema type 'tds:GetIPAddressFilterResponse': */
class SOAP_CMAC _tds__GetIPAddressFilterResponse {
      public:
        /// Required element 'tds:IPAddressFilter' of XML schema type 'tt:IPAddressFilter'
        tt__IPAddressFilter *IPAddressFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetIPAddressFilterResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetIPAddressFilterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetIPAddressFilterResponse, default initialized and not managed by a soap context
        virtual _tds__GetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetIPAddressFilterResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetIPAddressFilterResponse() : IPAddressFilter(), soap() { }
        /// Destructor
        virtual ~_tds__GetIPAddressFilterResponse() { }
        /// Friend allocator used by soap_new__tds__GetIPAddressFilterResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:623 */
#ifndef SOAP_TYPE__tds__SetIPAddressFilter
#define SOAP_TYPE__tds__SetIPAddressFilter (219)
/* complex XML schema type 'tds:SetIPAddressFilter': */
class SOAP_CMAC _tds__SetIPAddressFilter {
      public:
        /// Required element 'tds:IPAddressFilter' of XML schema type 'tt:IPAddressFilter'
        tt__IPAddressFilter *IPAddressFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetIPAddressFilter
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetIPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetIPAddressFilter, default initialized and not managed by a soap context
        virtual _tds__SetIPAddressFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetIPAddressFilter); }
      public:
        /// Constructor with default initializations
        _tds__SetIPAddressFilter() : IPAddressFilter(), soap() { }
        /// Destructor
        virtual ~_tds__SetIPAddressFilter() { }
        /// Friend allocator used by soap_new__tds__SetIPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:625 */
#ifndef SOAP_TYPE__tds__SetIPAddressFilterResponse
#define SOAP_TYPE__tds__SetIPAddressFilterResponse (220)
/* complex XML schema type 'tds:SetIPAddressFilterResponse': */
class SOAP_CMAC _tds__SetIPAddressFilterResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetIPAddressFilterResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetIPAddressFilterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetIPAddressFilterResponse, default initialized and not managed by a soap context
        virtual _tds__SetIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetIPAddressFilterResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetIPAddressFilterResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetIPAddressFilterResponse() { }
        /// Friend allocator used by soap_new__tds__SetIPAddressFilterResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:627 */
#ifndef SOAP_TYPE__tds__AddIPAddressFilter
#define SOAP_TYPE__tds__AddIPAddressFilter (221)
/* complex XML schema type 'tds:AddIPAddressFilter': */
class SOAP_CMAC _tds__AddIPAddressFilter {
      public:
        /// Required element 'tds:IPAddressFilter' of XML schema type 'tt:IPAddressFilter'
        tt__IPAddressFilter *IPAddressFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__AddIPAddressFilter
        virtual long soap_type(void) const { return SOAP_TYPE__tds__AddIPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__AddIPAddressFilter, default initialized and not managed by a soap context
        virtual _tds__AddIPAddressFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__AddIPAddressFilter); }
      public:
        /// Constructor with default initializations
        _tds__AddIPAddressFilter() : IPAddressFilter(), soap() { }
        /// Destructor
        virtual ~_tds__AddIPAddressFilter() { }
        /// Friend allocator used by soap_new__tds__AddIPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 _tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:629 */
#ifndef SOAP_TYPE__tds__AddIPAddressFilterResponse
#define SOAP_TYPE__tds__AddIPAddressFilterResponse (222)
/* complex XML schema type 'tds:AddIPAddressFilterResponse': */
class SOAP_CMAC _tds__AddIPAddressFilterResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__AddIPAddressFilterResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__AddIPAddressFilterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__AddIPAddressFilterResponse, default initialized and not managed by a soap context
        virtual _tds__AddIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__AddIPAddressFilterResponse); }
      public:
        /// Constructor with default initializations
        _tds__AddIPAddressFilterResponse() : soap() { }
        /// Destructor
        virtual ~_tds__AddIPAddressFilterResponse() { }
        /// Friend allocator used by soap_new__tds__AddIPAddressFilterResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__AddIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:631 */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilter
#define SOAP_TYPE__tds__RemoveIPAddressFilter (223)
/* complex XML schema type 'tds:RemoveIPAddressFilter': */
class SOAP_CMAC _tds__RemoveIPAddressFilter {
      public:
        /// Required element 'tds:IPAddressFilter' of XML schema type 'tt:IPAddressFilter'
        tt__IPAddressFilter *IPAddressFilter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__RemoveIPAddressFilter
        virtual long soap_type(void) const { return SOAP_TYPE__tds__RemoveIPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__RemoveIPAddressFilter, default initialized and not managed by a soap context
        virtual _tds__RemoveIPAddressFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__RemoveIPAddressFilter); }
      public:
        /// Constructor with default initializations
        _tds__RemoveIPAddressFilter() : IPAddressFilter(), soap() { }
        /// Destructor
        virtual ~_tds__RemoveIPAddressFilter() { }
        /// Friend allocator used by soap_new__tds__RemoveIPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 _tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:633 */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilterResponse
#define SOAP_TYPE__tds__RemoveIPAddressFilterResponse (224)
/* complex XML schema type 'tds:RemoveIPAddressFilterResponse': */
class SOAP_CMAC _tds__RemoveIPAddressFilterResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__RemoveIPAddressFilterResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__RemoveIPAddressFilterResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__RemoveIPAddressFilterResponse, default initialized and not managed by a soap context
        virtual _tds__RemoveIPAddressFilterResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__RemoveIPAddressFilterResponse); }
      public:
        /// Constructor with default initializations
        _tds__RemoveIPAddressFilterResponse() : soap() { }
        /// Destructor
        virtual ~_tds__RemoveIPAddressFilterResponse() { }
        /// Friend allocator used by soap_new__tds__RemoveIPAddressFilterResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilterResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:635 */
#ifndef SOAP_TYPE__tds__GetAccessPolicy
#define SOAP_TYPE__tds__GetAccessPolicy (225)
/* complex XML schema type 'tds:GetAccessPolicy': */
class SOAP_CMAC _tds__GetAccessPolicy {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetAccessPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetAccessPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetAccessPolicy, default initialized and not managed by a soap context
        virtual _tds__GetAccessPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetAccessPolicy); }
      public:
        /// Constructor with default initializations
        _tds__GetAccessPolicy() : soap() { }
        /// Destructor
        virtual ~_tds__GetAccessPolicy() { }
        /// Friend allocator used by soap_new__tds__GetAccessPolicy(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:637 */
#ifndef SOAP_TYPE__tds__GetAccessPolicyResponse
#define SOAP_TYPE__tds__GetAccessPolicyResponse (226)
/* complex XML schema type 'tds:GetAccessPolicyResponse': */
class SOAP_CMAC _tds__GetAccessPolicyResponse {
      public:
        /// Required element 'tds:PolicyFile' of XML schema type 'tt:BinaryData'
        tt__BinaryData *PolicyFile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetAccessPolicyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetAccessPolicyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetAccessPolicyResponse, default initialized and not managed by a soap context
        virtual _tds__GetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetAccessPolicyResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetAccessPolicyResponse() : PolicyFile(), soap() { }
        /// Destructor
        virtual ~_tds__GetAccessPolicyResponse() { }
        /// Friend allocator used by soap_new__tds__GetAccessPolicyResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:639 */
#ifndef SOAP_TYPE__tds__SetAccessPolicy
#define SOAP_TYPE__tds__SetAccessPolicy (227)
/* complex XML schema type 'tds:SetAccessPolicy': */
class SOAP_CMAC _tds__SetAccessPolicy {
      public:
        /// Required element 'tds:PolicyFile' of XML schema type 'tt:BinaryData'
        tt__BinaryData *PolicyFile;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetAccessPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetAccessPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetAccessPolicy, default initialized and not managed by a soap context
        virtual _tds__SetAccessPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetAccessPolicy); }
      public:
        /// Constructor with default initializations
        _tds__SetAccessPolicy() : PolicyFile(), soap() { }
        /// Destructor
        virtual ~_tds__SetAccessPolicy() { }
        /// Friend allocator used by soap_new__tds__SetAccessPolicy(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:641 */
#ifndef SOAP_TYPE__tds__SetAccessPolicyResponse
#define SOAP_TYPE__tds__SetAccessPolicyResponse (228)
/* complex XML schema type 'tds:SetAccessPolicyResponse': */
class SOAP_CMAC _tds__SetAccessPolicyResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetAccessPolicyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetAccessPolicyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetAccessPolicyResponse, default initialized and not managed by a soap context
        virtual _tds__SetAccessPolicyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetAccessPolicyResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetAccessPolicyResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetAccessPolicyResponse() { }
        /// Friend allocator used by soap_new__tds__SetAccessPolicyResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:643 */
#ifndef SOAP_TYPE__tds__CreateCertificate
#define SOAP_TYPE__tds__CreateCertificate (229)
/* complex XML schema type 'tds:CreateCertificate': */
class SOAP_CMAC _tds__CreateCertificate {
      public:
        /// Optional element 'tds:CertificateID' of XML schema type 'xsd:token'
        std::string *CertificateID;
        /// Optional element 'tds:Subject' of XML schema type 'xsd:string'
        std::string *Subject;
        /// Optional element 'tds:ValidNotBefore' of XML schema type 'xsd:dateTime'
        time_t *ValidNotBefore;
        /// Optional element 'tds:ValidNotAfter' of XML schema type 'xsd:dateTime'
        time_t *ValidNotAfter;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateCertificate
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateCertificate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateCertificate, default initialized and not managed by a soap context
        virtual _tds__CreateCertificate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateCertificate); }
      public:
        /// Constructor with default initializations
        _tds__CreateCertificate() : CertificateID(), Subject(), ValidNotBefore(), ValidNotAfter(), soap() { }
        /// Destructor
        virtual ~_tds__CreateCertificate() { }
        /// Friend allocator used by soap_new__tds__CreateCertificate(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateCertificate * SOAP_FMAC2 soap_instantiate__tds__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:645 */
#ifndef SOAP_TYPE__tds__CreateCertificateResponse
#define SOAP_TYPE__tds__CreateCertificateResponse (230)
/* complex XML schema type 'tds:CreateCertificateResponse': */
class SOAP_CMAC _tds__CreateCertificateResponse {
      public:
        /// Required element 'tds:NvtCertificate' of XML schema type 'tt:Certificate'
        tt__Certificate *NvtCertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateCertificateResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateCertificateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateCertificateResponse, default initialized and not managed by a soap context
        virtual _tds__CreateCertificateResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateCertificateResponse); }
      public:
        /// Constructor with default initializations
        _tds__CreateCertificateResponse() : NvtCertificate(), soap() { }
        /// Destructor
        virtual ~_tds__CreateCertificateResponse() { }
        /// Friend allocator used by soap_new__tds__CreateCertificateResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateCertificateResponse * SOAP_FMAC2 soap_instantiate__tds__CreateCertificateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:647 */
#ifndef SOAP_TYPE__tds__GetCertificates
#define SOAP_TYPE__tds__GetCertificates (231)
/* complex XML schema type 'tds:GetCertificates': */
class SOAP_CMAC _tds__GetCertificates {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCertificates
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCertificates, default initialized and not managed by a soap context
        virtual _tds__GetCertificates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCertificates); }
      public:
        /// Constructor with default initializations
        _tds__GetCertificates() : soap() { }
        /// Destructor
        virtual ~_tds__GetCertificates() { }
        /// Friend allocator used by soap_new__tds__GetCertificates(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCertificates * SOAP_FMAC2 soap_instantiate__tds__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:649 */
#ifndef SOAP_TYPE__tds__GetCertificatesResponse
#define SOAP_TYPE__tds__GetCertificatesResponse (232)
/* complex XML schema type 'tds:GetCertificatesResponse': */
class SOAP_CMAC _tds__GetCertificatesResponse {
      public:
        /// Optional element 'tds:NvtCertificate' of XML schema type 'tt:Certificate'
        std::vector<tt__Certificate *> NvtCertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCertificatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCertificatesResponse, default initialized and not managed by a soap context
        virtual _tds__GetCertificatesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCertificatesResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetCertificatesResponse() : NvtCertificate(), soap() { }
        /// Destructor
        virtual ~_tds__GetCertificatesResponse() { }
        /// Friend allocator used by soap_new__tds__GetCertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:651 */
#ifndef SOAP_TYPE__tds__GetCertificatesStatus
#define SOAP_TYPE__tds__GetCertificatesStatus (233)
/* complex XML schema type 'tds:GetCertificatesStatus': */
class SOAP_CMAC _tds__GetCertificatesStatus {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCertificatesStatus
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCertificatesStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCertificatesStatus, default initialized and not managed by a soap context
        virtual _tds__GetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCertificatesStatus); }
      public:
        /// Constructor with default initializations
        _tds__GetCertificatesStatus() : soap() { }
        /// Destructor
        virtual ~_tds__GetCertificatesStatus() { }
        /// Friend allocator used by soap_new__tds__GetCertificatesStatus(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:653 */
#ifndef SOAP_TYPE__tds__GetCertificatesStatusResponse
#define SOAP_TYPE__tds__GetCertificatesStatusResponse (234)
/* complex XML schema type 'tds:GetCertificatesStatusResponse': */
class SOAP_CMAC _tds__GetCertificatesStatusResponse {
      public:
        /// Optional element 'tds:CertificateStatus' of XML schema type 'tt:CertificateStatus'
        std::vector<tt__CertificateStatus *> CertificateStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCertificatesStatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCertificatesStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCertificatesStatusResponse, default initialized and not managed by a soap context
        virtual _tds__GetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCertificatesStatusResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetCertificatesStatusResponse() : CertificateStatus(), soap() { }
        /// Destructor
        virtual ~_tds__GetCertificatesStatusResponse() { }
        /// Friend allocator used by soap_new__tds__GetCertificatesStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:655 */
#ifndef SOAP_TYPE__tds__SetCertificatesStatus
#define SOAP_TYPE__tds__SetCertificatesStatus (235)
/* complex XML schema type 'tds:SetCertificatesStatus': */
class SOAP_CMAC _tds__SetCertificatesStatus {
      public:
        /// Optional element 'tds:CertificateStatus' of XML schema type 'tt:CertificateStatus'
        std::vector<tt__CertificateStatus *> CertificateStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetCertificatesStatus
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetCertificatesStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetCertificatesStatus, default initialized and not managed by a soap context
        virtual _tds__SetCertificatesStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetCertificatesStatus); }
      public:
        /// Constructor with default initializations
        _tds__SetCertificatesStatus() : CertificateStatus(), soap() { }
        /// Destructor
        virtual ~_tds__SetCertificatesStatus() { }
        /// Friend allocator used by soap_new__tds__SetCertificatesStatus(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:657 */
#ifndef SOAP_TYPE__tds__SetCertificatesStatusResponse
#define SOAP_TYPE__tds__SetCertificatesStatusResponse (236)
/* complex XML schema type 'tds:SetCertificatesStatusResponse': */
class SOAP_CMAC _tds__SetCertificatesStatusResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetCertificatesStatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetCertificatesStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetCertificatesStatusResponse, default initialized and not managed by a soap context
        virtual _tds__SetCertificatesStatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetCertificatesStatusResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetCertificatesStatusResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetCertificatesStatusResponse() { }
        /// Friend allocator used by soap_new__tds__SetCertificatesStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:659 */
#ifndef SOAP_TYPE__tds__DeleteCertificates
#define SOAP_TYPE__tds__DeleteCertificates (237)
/* complex XML schema type 'tds:DeleteCertificates': */
class SOAP_CMAC _tds__DeleteCertificates {
      public:
        /// Required element 'tds:CertificateID' of XML schema type 'xsd:token'
        std::vector<std::string> CertificateID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteCertificates
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteCertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteCertificates, default initialized and not managed by a soap context
        virtual _tds__DeleteCertificates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteCertificates); }
      public:
        /// Constructor with default initializations
        _tds__DeleteCertificates() : CertificateID(), soap() { }
        /// Destructor
        virtual ~_tds__DeleteCertificates() { }
        /// Friend allocator used by soap_new__tds__DeleteCertificates(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:661 */
#ifndef SOAP_TYPE__tds__DeleteCertificatesResponse
#define SOAP_TYPE__tds__DeleteCertificatesResponse (238)
/* complex XML schema type 'tds:DeleteCertificatesResponse': */
class SOAP_CMAC _tds__DeleteCertificatesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteCertificatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteCertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteCertificatesResponse, default initialized and not managed by a soap context
        virtual _tds__DeleteCertificatesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteCertificatesResponse); }
      public:
        /// Constructor with default initializations
        _tds__DeleteCertificatesResponse() : soap() { }
        /// Destructor
        virtual ~_tds__DeleteCertificatesResponse() { }
        /// Friend allocator used by soap_new__tds__DeleteCertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:663 */
#ifndef SOAP_TYPE__tds__GetPkcs10Request
#define SOAP_TYPE__tds__GetPkcs10Request (239)
/* complex XML schema type 'tds:GetPkcs10Request': */
class SOAP_CMAC _tds__GetPkcs10Request {
      public:
        /// Required element 'tds:CertificateID' of XML schema type 'xsd:token'
        std::string CertificateID;
        /// Optional element 'tds:Subject' of XML schema type 'xsd:string'
        std::string *Subject;
        /// Optional element 'tds:Attributes' of XML schema type 'tt:BinaryData'
        tt__BinaryData *Attributes;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetPkcs10Request
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetPkcs10Request; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetPkcs10Request, default initialized and not managed by a soap context
        virtual _tds__GetPkcs10Request *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetPkcs10Request); }
      public:
        /// Constructor with default initializations
        _tds__GetPkcs10Request() : CertificateID(), Subject(), Attributes(), soap() { }
        /// Destructor
        virtual ~_tds__GetPkcs10Request() { }
        /// Friend allocator used by soap_new__tds__GetPkcs10Request(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:665 */
#ifndef SOAP_TYPE__tds__GetPkcs10RequestResponse
#define SOAP_TYPE__tds__GetPkcs10RequestResponse (240)
/* complex XML schema type 'tds:GetPkcs10RequestResponse': */
class SOAP_CMAC _tds__GetPkcs10RequestResponse {
      public:
        /// Required element 'tds:Pkcs10Request' of XML schema type 'tt:BinaryData'
        tt__BinaryData *Pkcs10Request;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetPkcs10RequestResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetPkcs10RequestResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetPkcs10RequestResponse, default initialized and not managed by a soap context
        virtual _tds__GetPkcs10RequestResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetPkcs10RequestResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetPkcs10RequestResponse() : Pkcs10Request(), soap() { }
        /// Destructor
        virtual ~_tds__GetPkcs10RequestResponse() { }
        /// Friend allocator used by soap_new__tds__GetPkcs10RequestResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetPkcs10RequestResponse * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10RequestResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:667 */
#ifndef SOAP_TYPE__tds__LoadCertificates
#define SOAP_TYPE__tds__LoadCertificates (241)
/* complex XML schema type 'tds:LoadCertificates': */
class SOAP_CMAC _tds__LoadCertificates {
      public:
        /// Required element 'tds:NVTCertificate' of XML schema type 'tt:Certificate'
        std::vector<tt__Certificate *> NVTCertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__LoadCertificates
        virtual long soap_type(void) const { return SOAP_TYPE__tds__LoadCertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__LoadCertificates, default initialized and not managed by a soap context
        virtual _tds__LoadCertificates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__LoadCertificates); }
      public:
        /// Constructor with default initializations
        _tds__LoadCertificates() : NVTCertificate(), soap() { }
        /// Destructor
        virtual ~_tds__LoadCertificates() { }
        /// Friend allocator used by soap_new__tds__LoadCertificates(struct soap*, int)
        friend SOAP_FMAC1 _tds__LoadCertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:669 */
#ifndef SOAP_TYPE__tds__LoadCertificatesResponse
#define SOAP_TYPE__tds__LoadCertificatesResponse (242)
/* complex XML schema type 'tds:LoadCertificatesResponse': */
class SOAP_CMAC _tds__LoadCertificatesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__LoadCertificatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__LoadCertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__LoadCertificatesResponse, default initialized and not managed by a soap context
        virtual _tds__LoadCertificatesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__LoadCertificatesResponse); }
      public:
        /// Constructor with default initializations
        _tds__LoadCertificatesResponse() : soap() { }
        /// Destructor
        virtual ~_tds__LoadCertificatesResponse() { }
        /// Friend allocator used by soap_new__tds__LoadCertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__LoadCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:671 */
#ifndef SOAP_TYPE__tds__GetClientCertificateMode
#define SOAP_TYPE__tds__GetClientCertificateMode (243)
/* complex XML schema type 'tds:GetClientCertificateMode': */
class SOAP_CMAC _tds__GetClientCertificateMode {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetClientCertificateMode
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetClientCertificateMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetClientCertificateMode, default initialized and not managed by a soap context
        virtual _tds__GetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetClientCertificateMode); }
      public:
        /// Constructor with default initializations
        _tds__GetClientCertificateMode() : soap() { }
        /// Destructor
        virtual ~_tds__GetClientCertificateMode() { }
        /// Friend allocator used by soap_new__tds__GetClientCertificateMode(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:673 */
#ifndef SOAP_TYPE__tds__GetClientCertificateModeResponse
#define SOAP_TYPE__tds__GetClientCertificateModeResponse (244)
/* complex XML schema type 'tds:GetClientCertificateModeResponse': */
class SOAP_CMAC _tds__GetClientCertificateModeResponse {
      public:
        /// Required element 'tds:Enabled' of XML schema type 'xsd:boolean'
        bool Enabled;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetClientCertificateModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetClientCertificateModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetClientCertificateModeResponse, default initialized and not managed by a soap context
        virtual _tds__GetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetClientCertificateModeResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetClientCertificateModeResponse() : Enabled(), soap() { }
        /// Destructor
        virtual ~_tds__GetClientCertificateModeResponse() { }
        /// Friend allocator used by soap_new__tds__GetClientCertificateModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:675 */
#ifndef SOAP_TYPE__tds__SetClientCertificateMode
#define SOAP_TYPE__tds__SetClientCertificateMode (245)
/* complex XML schema type 'tds:SetClientCertificateMode': */
class SOAP_CMAC _tds__SetClientCertificateMode {
      public:
        /// Required element 'tds:Enabled' of XML schema type 'xsd:boolean'
        bool Enabled;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetClientCertificateMode
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetClientCertificateMode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetClientCertificateMode, default initialized and not managed by a soap context
        virtual _tds__SetClientCertificateMode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetClientCertificateMode); }
      public:
        /// Constructor with default initializations
        _tds__SetClientCertificateMode() : Enabled(), soap() { }
        /// Destructor
        virtual ~_tds__SetClientCertificateMode() { }
        /// Friend allocator used by soap_new__tds__SetClientCertificateMode(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:677 */
#ifndef SOAP_TYPE__tds__SetClientCertificateModeResponse
#define SOAP_TYPE__tds__SetClientCertificateModeResponse (246)
/* complex XML schema type 'tds:SetClientCertificateModeResponse': */
class SOAP_CMAC _tds__SetClientCertificateModeResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetClientCertificateModeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetClientCertificateModeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetClientCertificateModeResponse, default initialized and not managed by a soap context
        virtual _tds__SetClientCertificateModeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetClientCertificateModeResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetClientCertificateModeResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetClientCertificateModeResponse() { }
        /// Friend allocator used by soap_new__tds__SetClientCertificateModeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateModeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:679 */
#ifndef SOAP_TYPE__tds__GetCACertificates
#define SOAP_TYPE__tds__GetCACertificates (247)
/* complex XML schema type 'tds:GetCACertificates': */
class SOAP_CMAC _tds__GetCACertificates {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCACertificates
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCACertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCACertificates, default initialized and not managed by a soap context
        virtual _tds__GetCACertificates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCACertificates); }
      public:
        /// Constructor with default initializations
        _tds__GetCACertificates() : soap() { }
        /// Destructor
        virtual ~_tds__GetCACertificates() { }
        /// Friend allocator used by soap_new__tds__GetCACertificates(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCACertificates * SOAP_FMAC2 soap_instantiate__tds__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:681 */
#ifndef SOAP_TYPE__tds__GetCACertificatesResponse
#define SOAP_TYPE__tds__GetCACertificatesResponse (248)
/* complex XML schema type 'tds:GetCACertificatesResponse': */
class SOAP_CMAC _tds__GetCACertificatesResponse {
      public:
        /// Optional element 'tds:CACertificate' of XML schema type 'tt:Certificate'
        std::vector<tt__Certificate *> CACertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCACertificatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCACertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCACertificatesResponse, default initialized and not managed by a soap context
        virtual _tds__GetCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCACertificatesResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetCACertificatesResponse() : CACertificate(), soap() { }
        /// Destructor
        virtual ~_tds__GetCACertificatesResponse() { }
        /// Friend allocator used by soap_new__tds__GetCACertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:683 */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKey (249)
/* complex XML schema type 'tds:LoadCertificateWithPrivateKey': */
class SOAP_CMAC _tds__LoadCertificateWithPrivateKey {
      public:
        /// Required element 'tds:CertificateWithPrivateKey' of XML schema type 'tt:CertificateWithPrivateKey'
        std::vector<tt__CertificateWithPrivateKey *> CertificateWithPrivateKey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__LoadCertificateWithPrivateKey
        virtual long soap_type(void) const { return SOAP_TYPE__tds__LoadCertificateWithPrivateKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__LoadCertificateWithPrivateKey, default initialized and not managed by a soap context
        virtual _tds__LoadCertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__LoadCertificateWithPrivateKey); }
      public:
        /// Constructor with default initializations
        _tds__LoadCertificateWithPrivateKey() : CertificateWithPrivateKey(), soap() { }
        /// Destructor
        virtual ~_tds__LoadCertificateWithPrivateKey() { }
        /// Friend allocator used by soap_new__tds__LoadCertificateWithPrivateKey(struct soap*, int)
        friend SOAP_FMAC1 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:685 */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse (250)
/* complex XML schema type 'tds:LoadCertificateWithPrivateKeyResponse': */
class SOAP_CMAC _tds__LoadCertificateWithPrivateKeyResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__LoadCertificateWithPrivateKeyResponse, default initialized and not managed by a soap context
        virtual _tds__LoadCertificateWithPrivateKeyResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__LoadCertificateWithPrivateKeyResponse); }
      public:
        /// Constructor with default initializations
        _tds__LoadCertificateWithPrivateKeyResponse() : soap() { }
        /// Destructor
        virtual ~_tds__LoadCertificateWithPrivateKeyResponse() { }
        /// Friend allocator used by soap_new__tds__LoadCertificateWithPrivateKeyResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:687 */
#ifndef SOAP_TYPE__tds__GetCertificateInformation
#define SOAP_TYPE__tds__GetCertificateInformation (251)
/* complex XML schema type 'tds:GetCertificateInformation': */
class SOAP_CMAC _tds__GetCertificateInformation {
      public:
        /// Required element 'tds:CertificateID' of XML schema type 'xsd:token'
        std::string CertificateID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCertificateInformation
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCertificateInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCertificateInformation, default initialized and not managed by a soap context
        virtual _tds__GetCertificateInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCertificateInformation); }
      public:
        /// Constructor with default initializations
        _tds__GetCertificateInformation() : CertificateID(), soap() { }
        /// Destructor
        virtual ~_tds__GetCertificateInformation() { }
        /// Friend allocator used by soap_new__tds__GetCertificateInformation(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:689 */
#ifndef SOAP_TYPE__tds__GetCertificateInformationResponse
#define SOAP_TYPE__tds__GetCertificateInformationResponse (252)
/* complex XML schema type 'tds:GetCertificateInformationResponse': */
class SOAP_CMAC _tds__GetCertificateInformationResponse {
      public:
        /// Required element 'tds:CertificateInformation' of XML schema type 'tt:CertificateInformation'
        tt__CertificateInformation *CertificateInformation;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetCertificateInformationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetCertificateInformationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetCertificateInformationResponse, default initialized and not managed by a soap context
        virtual _tds__GetCertificateInformationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetCertificateInformationResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetCertificateInformationResponse() : CertificateInformation(), soap() { }
        /// Destructor
        virtual ~_tds__GetCertificateInformationResponse() { }
        /// Friend allocator used by soap_new__tds__GetCertificateInformationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetCertificateInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:691 */
#ifndef SOAP_TYPE__tds__LoadCACertificates
#define SOAP_TYPE__tds__LoadCACertificates (253)
/* complex XML schema type 'tds:LoadCACertificates': */
class SOAP_CMAC _tds__LoadCACertificates {
      public:
        /// Required element 'tds:CACertificate' of XML schema type 'tt:Certificate'
        std::vector<tt__Certificate *> CACertificate;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__LoadCACertificates
        virtual long soap_type(void) const { return SOAP_TYPE__tds__LoadCACertificates; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__LoadCACertificates, default initialized and not managed by a soap context
        virtual _tds__LoadCACertificates *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__LoadCACertificates); }
      public:
        /// Constructor with default initializations
        _tds__LoadCACertificates() : CACertificate(), soap() { }
        /// Destructor
        virtual ~_tds__LoadCACertificates() { }
        /// Friend allocator used by soap_new__tds__LoadCACertificates(struct soap*, int)
        friend SOAP_FMAC1 _tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:693 */
#ifndef SOAP_TYPE__tds__LoadCACertificatesResponse
#define SOAP_TYPE__tds__LoadCACertificatesResponse (254)
/* complex XML schema type 'tds:LoadCACertificatesResponse': */
class SOAP_CMAC _tds__LoadCACertificatesResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__LoadCACertificatesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__LoadCACertificatesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__LoadCACertificatesResponse, default initialized and not managed by a soap context
        virtual _tds__LoadCACertificatesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__LoadCACertificatesResponse); }
      public:
        /// Constructor with default initializations
        _tds__LoadCACertificatesResponse() : soap() { }
        /// Destructor
        virtual ~_tds__LoadCACertificatesResponse() { }
        /// Friend allocator used by soap_new__tds__LoadCACertificatesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__LoadCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificatesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:695 */
#ifndef SOAP_TYPE__tds__CreateDot1XConfiguration
#define SOAP_TYPE__tds__CreateDot1XConfiguration (255)
/* complex XML schema type 'tds:CreateDot1XConfiguration': */
class SOAP_CMAC _tds__CreateDot1XConfiguration {
      public:
        /// Required element 'tds:Dot1XConfiguration' of XML schema type 'tt:Dot1XConfiguration'
        tt__Dot1XConfiguration *Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tds__CreateDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateDot1XConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__CreateDot1XConfiguration() : Dot1XConfiguration(), soap() { }
        /// Destructor
        virtual ~_tds__CreateDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tds__CreateDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:697 */
#ifndef SOAP_TYPE__tds__CreateDot1XConfigurationResponse
#define SOAP_TYPE__tds__CreateDot1XConfigurationResponse (256)
/* complex XML schema type 'tds:CreateDot1XConfigurationResponse': */
class SOAP_CMAC _tds__CreateDot1XConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__CreateDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateDot1XConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__CreateDot1XConfigurationResponse() : soap() { }
        /// Destructor
        virtual ~_tds__CreateDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__CreateDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:699 */
#ifndef SOAP_TYPE__tds__SetDot1XConfiguration
#define SOAP_TYPE__tds__SetDot1XConfiguration (257)
/* complex XML schema type 'tds:SetDot1XConfiguration': */
class SOAP_CMAC _tds__SetDot1XConfiguration {
      public:
        /// Required element 'tds:Dot1XConfiguration' of XML schema type 'tt:Dot1XConfiguration'
        tt__Dot1XConfiguration *Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tds__SetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDot1XConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__SetDot1XConfiguration() : Dot1XConfiguration(), soap() { }
        /// Destructor
        virtual ~_tds__SetDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tds__SetDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:701 */
#ifndef SOAP_TYPE__tds__SetDot1XConfigurationResponse
#define SOAP_TYPE__tds__SetDot1XConfigurationResponse (258)
/* complex XML schema type 'tds:SetDot1XConfigurationResponse': */
class SOAP_CMAC _tds__SetDot1XConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__SetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetDot1XConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetDot1XConfigurationResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__SetDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:703 */
#ifndef SOAP_TYPE__tds__GetDot1XConfiguration
#define SOAP_TYPE__tds__GetDot1XConfiguration (259)
/* complex XML schema type 'tds:GetDot1XConfiguration': */
class SOAP_CMAC _tds__GetDot1XConfiguration {
      public:
        /// Required element 'tds:Dot1XConfigurationToken' of XML schema type 'tt:ReferenceToken'
        std::string Dot1XConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tds__GetDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot1XConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__GetDot1XConfiguration() : Dot1XConfigurationToken(), soap() { }
        /// Destructor
        virtual ~_tds__GetDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tds__GetDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:705 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationResponse (260)
/* complex XML schema type 'tds:GetDot1XConfigurationResponse': */
class SOAP_CMAC _tds__GetDot1XConfigurationResponse {
      public:
        /// Required element 'tds:Dot1XConfiguration' of XML schema type 'tt:Dot1XConfiguration'
        tt__Dot1XConfiguration *Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__GetDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot1XConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetDot1XConfigurationResponse() : Dot1XConfiguration(), soap() { }
        /// Destructor
        virtual ~_tds__GetDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__GetDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:707 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurations
#define SOAP_TYPE__tds__GetDot1XConfigurations (261)
/* complex XML schema type 'tds:GetDot1XConfigurations': */
class SOAP_CMAC _tds__GetDot1XConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot1XConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot1XConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot1XConfigurations, default initialized and not managed by a soap context
        virtual _tds__GetDot1XConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot1XConfigurations); }
      public:
        /// Constructor with default initializations
        _tds__GetDot1XConfigurations() : soap() { }
        /// Destructor
        virtual ~_tds__GetDot1XConfigurations() { }
        /// Friend allocator used by soap_new__tds__GetDot1XConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:709 */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationsResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationsResponse (262)
/* complex XML schema type 'tds:GetDot1XConfigurationsResponse': */
class SOAP_CMAC _tds__GetDot1XConfigurationsResponse {
      public:
        /// Optional element 'tds:Dot1XConfiguration' of XML schema type 'tt:Dot1XConfiguration'
        std::vector<tt__Dot1XConfiguration *> Dot1XConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot1XConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot1XConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot1XConfigurationsResponse, default initialized and not managed by a soap context
        virtual _tds__GetDot1XConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot1XConfigurationsResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetDot1XConfigurationsResponse() : Dot1XConfiguration(), soap() { }
        /// Destructor
        virtual ~_tds__GetDot1XConfigurationsResponse() { }
        /// Friend allocator used by soap_new__tds__GetDot1XConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:711 */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfiguration
#define SOAP_TYPE__tds__DeleteDot1XConfiguration (263)
/* complex XML schema type 'tds:DeleteDot1XConfiguration': */
class SOAP_CMAC _tds__DeleteDot1XConfiguration {
      public:
        /// Optional element 'tds:Dot1XConfigurationToken' of XML schema type 'tt:ReferenceToken'
        std::vector<std::string> Dot1XConfigurationToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteDot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteDot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteDot1XConfiguration, default initialized and not managed by a soap context
        virtual _tds__DeleteDot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteDot1XConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__DeleteDot1XConfiguration() : Dot1XConfigurationToken(), soap() { }
        /// Destructor
        virtual ~_tds__DeleteDot1XConfiguration() { }
        /// Friend allocator used by soap_new__tds__DeleteDot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:713 */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfigurationResponse
#define SOAP_TYPE__tds__DeleteDot1XConfigurationResponse (264)
/* complex XML schema type 'tds:DeleteDot1XConfigurationResponse': */
class SOAP_CMAC _tds__DeleteDot1XConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteDot1XConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteDot1XConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteDot1XConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__DeleteDot1XConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteDot1XConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__DeleteDot1XConfigurationResponse() : soap() { }
        /// Destructor
        virtual ~_tds__DeleteDot1XConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__DeleteDot1XConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:715 */
#ifndef SOAP_TYPE__tds__GetRelayOutputs
#define SOAP_TYPE__tds__GetRelayOutputs (265)
/* complex XML schema type 'tds:GetRelayOutputs': */
class SOAP_CMAC _tds__GetRelayOutputs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetRelayOutputs
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetRelayOutputs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetRelayOutputs, default initialized and not managed by a soap context
        virtual _tds__GetRelayOutputs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetRelayOutputs); }
      public:
        /// Constructor with default initializations
        _tds__GetRelayOutputs() : soap() { }
        /// Destructor
        virtual ~_tds__GetRelayOutputs() { }
        /// Friend allocator used by soap_new__tds__GetRelayOutputs(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:717 */
#ifndef SOAP_TYPE__tds__GetRelayOutputsResponse
#define SOAP_TYPE__tds__GetRelayOutputsResponse (266)
/* complex XML schema type 'tds:GetRelayOutputsResponse': */
class SOAP_CMAC _tds__GetRelayOutputsResponse {
      public:
        /// Optional element 'tds:RelayOutputs' of XML schema type 'tt:RelayOutput'
        std::vector<tt__RelayOutput *> RelayOutputs;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetRelayOutputsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetRelayOutputsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetRelayOutputsResponse, default initialized and not managed by a soap context
        virtual _tds__GetRelayOutputsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetRelayOutputsResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetRelayOutputsResponse() : RelayOutputs(), soap() { }
        /// Destructor
        virtual ~_tds__GetRelayOutputsResponse() { }
        /// Friend allocator used by soap_new__tds__GetRelayOutputsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetRelayOutputsResponse * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:719 */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettings
#define SOAP_TYPE__tds__SetRelayOutputSettings (267)
/* complex XML schema type 'tds:SetRelayOutputSettings': */
class SOAP_CMAC _tds__SetRelayOutputSettings {
      public:
        /// Required element 'tds:RelayOutputToken' of XML schema type 'tt:ReferenceToken'
        std::string RelayOutputToken;
        /// Required element 'tds:Properties' of XML schema type 'tt:RelayOutputSettings'
        tt__RelayOutputSettings *Properties;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRelayOutputSettings
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRelayOutputSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRelayOutputSettings, default initialized and not managed by a soap context
        virtual _tds__SetRelayOutputSettings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRelayOutputSettings); }
      public:
        /// Constructor with default initializations
        _tds__SetRelayOutputSettings() : RelayOutputToken(), Properties(), soap() { }
        /// Destructor
        virtual ~_tds__SetRelayOutputSettings() { }
        /// Friend allocator used by soap_new__tds__SetRelayOutputSettings(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:721 */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tds__SetRelayOutputSettingsResponse (268)
/* complex XML schema type 'tds:SetRelayOutputSettingsResponse': */
class SOAP_CMAC _tds__SetRelayOutputSettingsResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRelayOutputSettingsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRelayOutputSettingsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRelayOutputSettingsResponse, default initialized and not managed by a soap context
        virtual _tds__SetRelayOutputSettingsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRelayOutputSettingsResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetRelayOutputSettingsResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetRelayOutputSettingsResponse() { }
        /// Friend allocator used by soap_new__tds__SetRelayOutputSettingsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettingsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:723 */
#ifndef SOAP_TYPE__tds__SetRelayOutputState
#define SOAP_TYPE__tds__SetRelayOutputState (269)
/* complex XML schema type 'tds:SetRelayOutputState': */
class SOAP_CMAC _tds__SetRelayOutputState {
      public:
        /// Required element 'tds:RelayOutputToken' of XML schema type 'tt:ReferenceToken'
        std::string RelayOutputToken;
        /// Required element 'tds:LogicalState' of XML schema type 'tt:RelayLogicalState'
        enum tt__RelayLogicalState LogicalState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRelayOutputState
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRelayOutputState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRelayOutputState, default initialized and not managed by a soap context
        virtual _tds__SetRelayOutputState *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRelayOutputState); }
      public:
        /// Constructor with default initializations
        _tds__SetRelayOutputState() : RelayOutputToken(), LogicalState(), soap() { }
        /// Destructor
        virtual ~_tds__SetRelayOutputState() { }
        /// Friend allocator used by soap_new__tds__SetRelayOutputState(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:725 */
#ifndef SOAP_TYPE__tds__SetRelayOutputStateResponse
#define SOAP_TYPE__tds__SetRelayOutputStateResponse (270)
/* complex XML schema type 'tds:SetRelayOutputStateResponse': */
class SOAP_CMAC _tds__SetRelayOutputStateResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetRelayOutputStateResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetRelayOutputStateResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetRelayOutputStateResponse, default initialized and not managed by a soap context
        virtual _tds__SetRelayOutputStateResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetRelayOutputStateResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetRelayOutputStateResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetRelayOutputStateResponse() { }
        /// Friend allocator used by soap_new__tds__SetRelayOutputStateResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetRelayOutputStateResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputStateResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:727 */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommand
#define SOAP_TYPE__tds__SendAuxiliaryCommand (271)
/* complex XML schema type 'tds:SendAuxiliaryCommand': */
class SOAP_CMAC _tds__SendAuxiliaryCommand {
      public:
        /// Required element 'tds:AuxiliaryCommand' of XML schema type 'tt:AuxiliaryData'
        std::string AuxiliaryCommand;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SendAuxiliaryCommand
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SendAuxiliaryCommand; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SendAuxiliaryCommand, default initialized and not managed by a soap context
        virtual _tds__SendAuxiliaryCommand *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SendAuxiliaryCommand); }
      public:
        /// Constructor with default initializations
        _tds__SendAuxiliaryCommand() : AuxiliaryCommand(), soap() { }
        /// Destructor
        virtual ~_tds__SendAuxiliaryCommand() { }
        /// Friend allocator used by soap_new__tds__SendAuxiliaryCommand(struct soap*, int)
        friend SOAP_FMAC1 _tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:729 */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tds__SendAuxiliaryCommandResponse (272)
/* complex XML schema type 'tds:SendAuxiliaryCommandResponse': */
class SOAP_CMAC _tds__SendAuxiliaryCommandResponse {
      public:
        /// Optional element 'tds:AuxiliaryCommandResponse' of XML schema type 'tt:AuxiliaryData'
        std::string *AuxiliaryCommandResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SendAuxiliaryCommandResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SendAuxiliaryCommandResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SendAuxiliaryCommandResponse, default initialized and not managed by a soap context
        virtual _tds__SendAuxiliaryCommandResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SendAuxiliaryCommandResponse); }
      public:
        /// Constructor with default initializations
        _tds__SendAuxiliaryCommandResponse() : AuxiliaryCommandResponse(), soap() { }
        /// Destructor
        virtual ~_tds__SendAuxiliaryCommandResponse() { }
        /// Friend allocator used by soap_new__tds__SendAuxiliaryCommandResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommandResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:731 */
#ifndef SOAP_TYPE__tds__GetDot11Capabilities
#define SOAP_TYPE__tds__GetDot11Capabilities (273)
/* complex XML schema type 'tds:GetDot11Capabilities': */
class SOAP_CMAC _tds__GetDot11Capabilities {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot11Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot11Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot11Capabilities, default initialized and not managed by a soap context
        virtual _tds__GetDot11Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot11Capabilities); }
      public:
        /// Constructor with default initializations
        _tds__GetDot11Capabilities() : __any(), soap() { }
        /// Destructor
        virtual ~_tds__GetDot11Capabilities() { }
        /// Friend allocator used by soap_new__tds__GetDot11Capabilities(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate__tds__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:733 */
#ifndef SOAP_TYPE__tds__GetDot11CapabilitiesResponse
#define SOAP_TYPE__tds__GetDot11CapabilitiesResponse (274)
/* complex XML schema type 'tds:GetDot11CapabilitiesResponse': */
class SOAP_CMAC _tds__GetDot11CapabilitiesResponse {
      public:
        /// Required element 'tds:Capabilities' of XML schema type 'tt:Dot11Capabilities'
        tt__Dot11Capabilities *Capabilities;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot11CapabilitiesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot11CapabilitiesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot11CapabilitiesResponse, default initialized and not managed by a soap context
        virtual _tds__GetDot11CapabilitiesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot11CapabilitiesResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetDot11CapabilitiesResponse() : Capabilities(), soap() { }
        /// Destructor
        virtual ~_tds__GetDot11CapabilitiesResponse() { }
        /// Friend allocator used by soap_new__tds__GetDot11CapabilitiesResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11CapabilitiesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:735 */
#ifndef SOAP_TYPE__tds__GetDot11Status
#define SOAP_TYPE__tds__GetDot11Status (275)
/* complex XML schema type 'tds:GetDot11Status': */
class SOAP_CMAC _tds__GetDot11Status {
      public:
        /// Required element 'tds:InterfaceToken' of XML schema type 'tt:ReferenceToken'
        std::string InterfaceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot11Status
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot11Status; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot11Status, default initialized and not managed by a soap context
        virtual _tds__GetDot11Status *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot11Status); }
      public:
        /// Constructor with default initializations
        _tds__GetDot11Status() : InterfaceToken(), soap() { }
        /// Destructor
        virtual ~_tds__GetDot11Status() { }
        /// Friend allocator used by soap_new__tds__GetDot11Status(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot11Status * SOAP_FMAC2 soap_instantiate__tds__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:737 */
#ifndef SOAP_TYPE__tds__GetDot11StatusResponse
#define SOAP_TYPE__tds__GetDot11StatusResponse (276)
/* complex XML schema type 'tds:GetDot11StatusResponse': */
class SOAP_CMAC _tds__GetDot11StatusResponse {
      public:
        /// Required element 'tds:Status' of XML schema type 'tt:Dot11Status'
        tt__Dot11Status *Status;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetDot11StatusResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetDot11StatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetDot11StatusResponse, default initialized and not managed by a soap context
        virtual _tds__GetDot11StatusResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetDot11StatusResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetDot11StatusResponse() : Status(), soap() { }
        /// Destructor
        virtual ~_tds__GetDot11StatusResponse() { }
        /// Friend allocator used by soap_new__tds__GetDot11StatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetDot11StatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11StatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:739 */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11Networks
#define SOAP_TYPE__tds__ScanAvailableDot11Networks (277)
/* complex XML schema type 'tds:ScanAvailableDot11Networks': */
class SOAP_CMAC _tds__ScanAvailableDot11Networks {
      public:
        /// Required element 'tds:InterfaceToken' of XML schema type 'tt:ReferenceToken'
        std::string InterfaceToken;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__ScanAvailableDot11Networks
        virtual long soap_type(void) const { return SOAP_TYPE__tds__ScanAvailableDot11Networks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__ScanAvailableDot11Networks, default initialized and not managed by a soap context
        virtual _tds__ScanAvailableDot11Networks *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__ScanAvailableDot11Networks); }
      public:
        /// Constructor with default initializations
        _tds__ScanAvailableDot11Networks() : InterfaceToken(), soap() { }
        /// Destructor
        virtual ~_tds__ScanAvailableDot11Networks() { }
        /// Friend allocator used by soap_new__tds__ScanAvailableDot11Networks(struct soap*, int)
        friend SOAP_FMAC1 _tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:741 */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse
#define SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse (278)
/* complex XML schema type 'tds:ScanAvailableDot11NetworksResponse': */
class SOAP_CMAC _tds__ScanAvailableDot11NetworksResponse {
      public:
        /// Optional element 'tds:Networks' of XML schema type 'tt:Dot11AvailableNetworks'
        std::vector<tt__Dot11AvailableNetworks *> Networks;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__ScanAvailableDot11NetworksResponse, default initialized and not managed by a soap context
        virtual _tds__ScanAvailableDot11NetworksResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__ScanAvailableDot11NetworksResponse); }
      public:
        /// Constructor with default initializations
        _tds__ScanAvailableDot11NetworksResponse() : Networks(), soap() { }
        /// Destructor
        virtual ~_tds__ScanAvailableDot11NetworksResponse() { }
        /// Friend allocator used by soap_new__tds__ScanAvailableDot11NetworksResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11NetworksResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:743 */
#ifndef SOAP_TYPE__tds__GetSystemUris
#define SOAP_TYPE__tds__GetSystemUris (279)
/* complex XML schema type 'tds:GetSystemUris': */
class SOAP_CMAC _tds__GetSystemUris {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemUris
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemUris; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemUris, default initialized and not managed by a soap context
        virtual _tds__GetSystemUris *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemUris); }
      public:
        /// Constructor with default initializations
        _tds__GetSystemUris() : soap() { }
        /// Destructor
        virtual ~_tds__GetSystemUris() { }
        /// Friend allocator used by soap_new__tds__GetSystemUris(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemUris * SOAP_FMAC2 soap_instantiate__tds__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:8583 */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse_Extension
#define SOAP_TYPE__tds__GetSystemUrisResponse_Extension (1104)
/* complex XML schema type 'tds:GetSystemUrisResponse-Extension': */
class SOAP_CMAC _tds__GetSystemUrisResponse_Extension {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemUrisResponse_Extension
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemUrisResponse_Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemUrisResponse_Extension, default initialized and not managed by a soap context
        virtual _tds__GetSystemUrisResponse_Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemUrisResponse_Extension); }
      public:
        /// Constructor with default initializations
        _tds__GetSystemUrisResponse_Extension() : __any() { }
        /// Destructor
        virtual ~_tds__GetSystemUrisResponse_Extension() { }
        /// Friend allocator used by soap_new__tds__GetSystemUrisResponse_Extension(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemUrisResponse_Extension * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse_Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:745 */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse
#define SOAP_TYPE__tds__GetSystemUrisResponse (280)
/* complex XML schema type 'tds:GetSystemUrisResponse': */
class SOAP_CMAC _tds__GetSystemUrisResponse {
      public:
        /// Optional element 'tds:SystemLogUris' of XML schema type 'tt:SystemLogUriList'
        tt__SystemLogUriList *SystemLogUris;
        /// Optional element 'tds:SupportInfoUri' of XML schema type 'xsd:anyURI'
        std::string *SupportInfoUri;
        /// Optional element 'tds:SystemBackupUri' of XML schema type 'xsd:anyURI'
        std::string *SystemBackupUri;
        /// Optional element 'tds:Extension' of XML schema type 'tds:GetSystemUrisResponse-Extension'
        _tds__GetSystemUrisResponse_Extension *Extension;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetSystemUrisResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetSystemUrisResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetSystemUrisResponse, default initialized and not managed by a soap context
        virtual _tds__GetSystemUrisResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetSystemUrisResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetSystemUrisResponse() : SystemLogUris(), SupportInfoUri(), SystemBackupUri(), Extension(), soap() { }
        /// Destructor
        virtual ~_tds__GetSystemUrisResponse() { }
        /// Friend allocator used by soap_new__tds__GetSystemUrisResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetSystemUrisResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:747 */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgrade
#define SOAP_TYPE__tds__StartFirmwareUpgrade (281)
/* complex XML schema type 'tds:StartFirmwareUpgrade': */
class SOAP_CMAC _tds__StartFirmwareUpgrade {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__StartFirmwareUpgrade
        virtual long soap_type(void) const { return SOAP_TYPE__tds__StartFirmwareUpgrade; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__StartFirmwareUpgrade, default initialized and not managed by a soap context
        virtual _tds__StartFirmwareUpgrade *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__StartFirmwareUpgrade); }
      public:
        /// Constructor with default initializations
        _tds__StartFirmwareUpgrade() : soap() { }
        /// Destructor
        virtual ~_tds__StartFirmwareUpgrade() { }
        /// Friend allocator used by soap_new__tds__StartFirmwareUpgrade(struct soap*, int)
        friend SOAP_FMAC1 _tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:749 */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgradeResponse
#define SOAP_TYPE__tds__StartFirmwareUpgradeResponse (282)
/* complex XML schema type 'tds:StartFirmwareUpgradeResponse': */
class SOAP_CMAC _tds__StartFirmwareUpgradeResponse {
      public:
        /// Required element 'tds:UploadUri' of XML schema type 'xsd:anyURI'
        std::string UploadUri;
        /// Required element 'tds:UploadDelay' of XML schema type 'xsd:duration'
        std::string UploadDelay;
        /// Required element 'tds:ExpectedDownTime' of XML schema type 'xsd:duration'
        std::string ExpectedDownTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__StartFirmwareUpgradeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__StartFirmwareUpgradeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__StartFirmwareUpgradeResponse, default initialized and not managed by a soap context
        virtual _tds__StartFirmwareUpgradeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__StartFirmwareUpgradeResponse); }
      public:
        /// Constructor with default initializations
        _tds__StartFirmwareUpgradeResponse() : UploadUri(), UploadDelay(), ExpectedDownTime(), soap() { }
        /// Destructor
        virtual ~_tds__StartFirmwareUpgradeResponse() { }
        /// Friend allocator used by soap_new__tds__StartFirmwareUpgradeResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgradeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:751 */
#ifndef SOAP_TYPE__tds__StartSystemRestore
#define SOAP_TYPE__tds__StartSystemRestore (283)
/* complex XML schema type 'tds:StartSystemRestore': */
class SOAP_CMAC _tds__StartSystemRestore {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__StartSystemRestore
        virtual long soap_type(void) const { return SOAP_TYPE__tds__StartSystemRestore; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__StartSystemRestore, default initialized and not managed by a soap context
        virtual _tds__StartSystemRestore *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__StartSystemRestore); }
      public:
        /// Constructor with default initializations
        _tds__StartSystemRestore() : soap() { }
        /// Destructor
        virtual ~_tds__StartSystemRestore() { }
        /// Friend allocator used by soap_new__tds__StartSystemRestore(struct soap*, int)
        friend SOAP_FMAC1 _tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:753 */
#ifndef SOAP_TYPE__tds__StartSystemRestoreResponse
#define SOAP_TYPE__tds__StartSystemRestoreResponse (284)
/* complex XML schema type 'tds:StartSystemRestoreResponse': */
class SOAP_CMAC _tds__StartSystemRestoreResponse {
      public:
        /// Required element 'tds:UploadUri' of XML schema type 'xsd:anyURI'
        std::string UploadUri;
        /// Required element 'tds:ExpectedDownTime' of XML schema type 'xsd:duration'
        std::string ExpectedDownTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__StartSystemRestoreResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__StartSystemRestoreResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__StartSystemRestoreResponse, default initialized and not managed by a soap context
        virtual _tds__StartSystemRestoreResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__StartSystemRestoreResponse); }
      public:
        /// Constructor with default initializations
        _tds__StartSystemRestoreResponse() : UploadUri(), ExpectedDownTime(), soap() { }
        /// Destructor
        virtual ~_tds__StartSystemRestoreResponse() { }
        /// Friend allocator used by soap_new__tds__StartSystemRestoreResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__StartSystemRestoreResponse * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestoreResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:755 */
#ifndef SOAP_TYPE__tds__SetHashingAlgorithm
#define SOAP_TYPE__tds__SetHashingAlgorithm (285)
/* complex XML schema type 'tds:SetHashingAlgorithm': */
class SOAP_CMAC _tds__SetHashingAlgorithm {
      public:
        /// Required element 'tds:Algorithm' of XML schema type 'tt:StringList'
        std::string Algorithm;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetHashingAlgorithm
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetHashingAlgorithm; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetHashingAlgorithm, default initialized and not managed by a soap context
        virtual _tds__SetHashingAlgorithm *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetHashingAlgorithm); }
      public:
        /// Constructor with default initializations
        _tds__SetHashingAlgorithm() : Algorithm(), soap() { }
        /// Destructor
        virtual ~_tds__SetHashingAlgorithm() { }
        /// Friend allocator used by soap_new__tds__SetHashingAlgorithm(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetHashingAlgorithm * SOAP_FMAC2 soap_instantiate__tds__SetHashingAlgorithm(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:757 */
#ifndef SOAP_TYPE__tds__SetHashingAlgorithmResponse
#define SOAP_TYPE__tds__SetHashingAlgorithmResponse (286)
/* complex XML schema type 'tds:SetHashingAlgorithmResponse': */
class SOAP_CMAC _tds__SetHashingAlgorithmResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetHashingAlgorithmResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetHashingAlgorithmResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetHashingAlgorithmResponse, default initialized and not managed by a soap context
        virtual _tds__SetHashingAlgorithmResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetHashingAlgorithmResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetHashingAlgorithmResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetHashingAlgorithmResponse() { }
        /// Friend allocator used by soap_new__tds__SetHashingAlgorithmResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetHashingAlgorithmResponse * SOAP_FMAC2 soap_instantiate__tds__SetHashingAlgorithmResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:759 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurations
#define SOAP_TYPE__tds__GetStorageConfigurations (287)
/* complex XML schema type 'tds:GetStorageConfigurations': */
class SOAP_CMAC _tds__GetStorageConfigurations {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetStorageConfigurations
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetStorageConfigurations; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetStorageConfigurations, default initialized and not managed by a soap context
        virtual _tds__GetStorageConfigurations *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetStorageConfigurations); }
      public:
        /// Constructor with default initializations
        _tds__GetStorageConfigurations() : soap() { }
        /// Destructor
        virtual ~_tds__GetStorageConfigurations() { }
        /// Friend allocator used by soap_new__tds__GetStorageConfigurations(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:761 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationsResponse
#define SOAP_TYPE__tds__GetStorageConfigurationsResponse (288)
/* complex XML schema type 'tds:GetStorageConfigurationsResponse': */
class SOAP_CMAC _tds__GetStorageConfigurationsResponse {
      public:
        /// Optional element 'tds:StorageConfigurations' of XML schema type 'tds:StorageConfiguration'
        std::vector<tds__StorageConfiguration *> StorageConfigurations;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetStorageConfigurationsResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetStorageConfigurationsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetStorageConfigurationsResponse, default initialized and not managed by a soap context
        virtual _tds__GetStorageConfigurationsResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetStorageConfigurationsResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetStorageConfigurationsResponse() : StorageConfigurations(), soap() { }
        /// Destructor
        virtual ~_tds__GetStorageConfigurationsResponse() { }
        /// Friend allocator used by soap_new__tds__GetStorageConfigurationsResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetStorageConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:763 */
#ifndef SOAP_TYPE__tds__CreateStorageConfiguration
#define SOAP_TYPE__tds__CreateStorageConfiguration (289)
/* complex XML schema type 'tds:CreateStorageConfiguration': */
class SOAP_CMAC _tds__CreateStorageConfiguration {
      public:
        /// Required element 'tds:StorageConfiguration' of XML schema type 'tds:StorageConfigurationData'
        tds__StorageConfigurationData *StorageConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateStorageConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateStorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateStorageConfiguration, default initialized and not managed by a soap context
        virtual _tds__CreateStorageConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateStorageConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__CreateStorageConfiguration() : StorageConfiguration(), soap() { }
        /// Destructor
        virtual ~_tds__CreateStorageConfiguration() { }
        /// Friend allocator used by soap_new__tds__CreateStorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:765 */
#ifndef SOAP_TYPE__tds__CreateStorageConfigurationResponse
#define SOAP_TYPE__tds__CreateStorageConfigurationResponse (290)
/* complex XML schema type 'tds:CreateStorageConfigurationResponse': */
class SOAP_CMAC _tds__CreateStorageConfigurationResponse {
      public:
        /// Required element 'tds:Token' of XML schema type 'tt:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__CreateStorageConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__CreateStorageConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__CreateStorageConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__CreateStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__CreateStorageConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__CreateStorageConfigurationResponse() : Token(), soap() { }
        /// Destructor
        virtual ~_tds__CreateStorageConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__CreateStorageConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__CreateStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:767 */
#ifndef SOAP_TYPE__tds__GetStorageConfiguration
#define SOAP_TYPE__tds__GetStorageConfiguration (291)
/* complex XML schema type 'tds:GetStorageConfiguration': */
class SOAP_CMAC _tds__GetStorageConfiguration {
      public:
        /// Required element 'tds:Token' of XML schema type 'tt:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetStorageConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetStorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetStorageConfiguration, default initialized and not managed by a soap context
        virtual _tds__GetStorageConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetStorageConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__GetStorageConfiguration() : Token(), soap() { }
        /// Destructor
        virtual ~_tds__GetStorageConfiguration() { }
        /// Friend allocator used by soap_new__tds__GetStorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:769 */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationResponse
#define SOAP_TYPE__tds__GetStorageConfigurationResponse (292)
/* complex XML schema type 'tds:GetStorageConfigurationResponse': */
class SOAP_CMAC _tds__GetStorageConfigurationResponse {
      public:
        /// Required element 'tds:StorageConfiguration' of XML schema type 'tds:StorageConfiguration'
        tds__StorageConfiguration *StorageConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetStorageConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetStorageConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetStorageConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__GetStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetStorageConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetStorageConfigurationResponse() : StorageConfiguration(), soap() { }
        /// Destructor
        virtual ~_tds__GetStorageConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__GetStorageConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:771 */
#ifndef SOAP_TYPE__tds__SetStorageConfiguration
#define SOAP_TYPE__tds__SetStorageConfiguration (293)
/* complex XML schema type 'tds:SetStorageConfiguration': */
class SOAP_CMAC _tds__SetStorageConfiguration {
      public:
        /// Required element 'tds:StorageConfiguration' of XML schema type 'tds:StorageConfiguration'
        tds__StorageConfiguration *StorageConfiguration;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetStorageConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetStorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetStorageConfiguration, default initialized and not managed by a soap context
        virtual _tds__SetStorageConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetStorageConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__SetStorageConfiguration() : StorageConfiguration(), soap() { }
        /// Destructor
        virtual ~_tds__SetStorageConfiguration() { }
        /// Friend allocator used by soap_new__tds__SetStorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:773 */
#ifndef SOAP_TYPE__tds__SetStorageConfigurationResponse
#define SOAP_TYPE__tds__SetStorageConfigurationResponse (294)
/* complex XML schema type 'tds:SetStorageConfigurationResponse': */
class SOAP_CMAC _tds__SetStorageConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetStorageConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetStorageConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetStorageConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__SetStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetStorageConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetStorageConfigurationResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetStorageConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__SetStorageConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:775 */
#ifndef SOAP_TYPE__tds__DeleteStorageConfiguration
#define SOAP_TYPE__tds__DeleteStorageConfiguration (295)
/* complex XML schema type 'tds:DeleteStorageConfiguration': */
class SOAP_CMAC _tds__DeleteStorageConfiguration {
      public:
        /// Required element 'tds:Token' of XML schema type 'tt:ReferenceToken'
        std::string Token;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteStorageConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteStorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteStorageConfiguration, default initialized and not managed by a soap context
        virtual _tds__DeleteStorageConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteStorageConfiguration); }
      public:
        /// Constructor with default initializations
        _tds__DeleteStorageConfiguration() : Token(), soap() { }
        /// Destructor
        virtual ~_tds__DeleteStorageConfiguration() { }
        /// Friend allocator used by soap_new__tds__DeleteStorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:777 */
#ifndef SOAP_TYPE__tds__DeleteStorageConfigurationResponse
#define SOAP_TYPE__tds__DeleteStorageConfigurationResponse (296)
/* complex XML schema type 'tds:DeleteStorageConfigurationResponse': */
class SOAP_CMAC _tds__DeleteStorageConfigurationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteStorageConfigurationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteStorageConfigurationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteStorageConfigurationResponse, default initialized and not managed by a soap context
        virtual _tds__DeleteStorageConfigurationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteStorageConfigurationResponse); }
      public:
        /// Constructor with default initializations
        _tds__DeleteStorageConfigurationResponse() : soap() { }
        /// Destructor
        virtual ~_tds__DeleteStorageConfigurationResponse() { }
        /// Friend allocator used by soap_new__tds__DeleteStorageConfigurationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteStorageConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteStorageConfigurationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:779 */
#ifndef SOAP_TYPE__tds__GetGeoLocation
#define SOAP_TYPE__tds__GetGeoLocation (297)
/* complex XML schema type 'tds:GetGeoLocation': */
class SOAP_CMAC _tds__GetGeoLocation {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetGeoLocation
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetGeoLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetGeoLocation, default initialized and not managed by a soap context
        virtual _tds__GetGeoLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetGeoLocation); }
      public:
        /// Constructor with default initializations
        _tds__GetGeoLocation() : soap() { }
        /// Destructor
        virtual ~_tds__GetGeoLocation() { }
        /// Friend allocator used by soap_new__tds__GetGeoLocation(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:781 */
#ifndef SOAP_TYPE__tds__GetGeoLocationResponse
#define SOAP_TYPE__tds__GetGeoLocationResponse (298)
/* complex XML schema type 'tds:GetGeoLocationResponse': */
class SOAP_CMAC _tds__GetGeoLocationResponse {
      public:
        /// Optional element 'tds:Location' of XML schema type 'tt:LocationEntity'
        std::vector<tt__LocationEntity *> Location;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__GetGeoLocationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__GetGeoLocationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__GetGeoLocationResponse, default initialized and not managed by a soap context
        virtual _tds__GetGeoLocationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__GetGeoLocationResponse); }
      public:
        /// Constructor with default initializations
        _tds__GetGeoLocationResponse() : Location(), soap() { }
        /// Destructor
        virtual ~_tds__GetGeoLocationResponse() { }
        /// Friend allocator used by soap_new__tds__GetGeoLocationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__GetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__GetGeoLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:783 */
#ifndef SOAP_TYPE__tds__SetGeoLocation
#define SOAP_TYPE__tds__SetGeoLocation (299)
/* complex XML schema type 'tds:SetGeoLocation': */
class SOAP_CMAC _tds__SetGeoLocation {
      public:
        /// Required element 'tds:Location' of XML schema type 'tt:LocationEntity'
        std::vector<tt__LocationEntity *> Location;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetGeoLocation
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetGeoLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetGeoLocation, default initialized and not managed by a soap context
        virtual _tds__SetGeoLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetGeoLocation); }
      public:
        /// Constructor with default initializations
        _tds__SetGeoLocation() : Location(), soap() { }
        /// Destructor
        virtual ~_tds__SetGeoLocation() { }
        /// Friend allocator used by soap_new__tds__SetGeoLocation(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:785 */
#ifndef SOAP_TYPE__tds__SetGeoLocationResponse
#define SOAP_TYPE__tds__SetGeoLocationResponse (300)
/* complex XML schema type 'tds:SetGeoLocationResponse': */
class SOAP_CMAC _tds__SetGeoLocationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__SetGeoLocationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__SetGeoLocationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__SetGeoLocationResponse, default initialized and not managed by a soap context
        virtual _tds__SetGeoLocationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__SetGeoLocationResponse); }
      public:
        /// Constructor with default initializations
        _tds__SetGeoLocationResponse() : soap() { }
        /// Destructor
        virtual ~_tds__SetGeoLocationResponse() { }
        /// Friend allocator used by soap_new__tds__SetGeoLocationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__SetGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__SetGeoLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:787 */
#ifndef SOAP_TYPE__tds__DeleteGeoLocation
#define SOAP_TYPE__tds__DeleteGeoLocation (301)
/* complex XML schema type 'tds:DeleteGeoLocation': */
class SOAP_CMAC _tds__DeleteGeoLocation {
      public:
        /// Required element 'tds:Location' of XML schema type 'tt:LocationEntity'
        std::vector<tt__LocationEntity *> Location;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteGeoLocation
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteGeoLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteGeoLocation, default initialized and not managed by a soap context
        virtual _tds__DeleteGeoLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteGeoLocation); }
      public:
        /// Constructor with default initializations
        _tds__DeleteGeoLocation() : Location(), soap() { }
        /// Destructor
        virtual ~_tds__DeleteGeoLocation() { }
        /// Friend allocator used by soap_new__tds__DeleteGeoLocation(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:789 */
#ifndef SOAP_TYPE__tds__DeleteGeoLocationResponse
#define SOAP_TYPE__tds__DeleteGeoLocationResponse (302)
/* complex XML schema type 'tds:DeleteGeoLocationResponse': */
class SOAP_CMAC _tds__DeleteGeoLocationResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tds__DeleteGeoLocationResponse
        virtual long soap_type(void) const { return SOAP_TYPE__tds__DeleteGeoLocationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tds__DeleteGeoLocationResponse, default initialized and not managed by a soap context
        virtual _tds__DeleteGeoLocationResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tds__DeleteGeoLocationResponse); }
      public:
        /// Constructor with default initializations
        _tds__DeleteGeoLocationResponse() : soap() { }
        /// Destructor
        virtual ~_tds__DeleteGeoLocationResponse() { }
        /// Friend allocator used by soap_new__tds__DeleteGeoLocationResponse(struct soap*, int)
        friend SOAP_FMAC1 _tds__DeleteGeoLocationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteGeoLocationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:791 */
#ifndef SOAP_TYPE_tt__DeviceEntity
#define SOAP_TYPE_tt__DeviceEntity (303)
/* Type tt__DeviceEntity is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tt:DeviceEntity': */
class SOAP_CMAC tt__DeviceEntity : public xsd__anyType {
      public:
        /// Required attribute 'token' of XML schema type 'tt:ReferenceToken'
        std::string token;
      public:
        /// Return unique type id SOAP_TYPE_tt__DeviceEntity
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DeviceEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DeviceEntity, default initialized and not managed by a soap context
        virtual tt__DeviceEntity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DeviceEntity); }
      public:
        /// Constructor with default initializations
        tt__DeviceEntity() : token() { }
        /// Destructor
        virtual ~tt__DeviceEntity() { }
        /// Friend allocator used by soap_new_tt__DeviceEntity(struct soap*, int)
        friend SOAP_FMAC1 tt__DeviceEntity * SOAP_FMAC2 soap_instantiate_tt__DeviceEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:793 */
#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (304)
/* Type tt__IntRectangle is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tt:IntRectangle': */
class SOAP_CMAC tt__IntRectangle : public xsd__anyType {
      public:
        /// Required attribute 'x' of XML schema type 'xsd:int'
        int x;
        /// Required attribute 'y' of XML schema type 'xsd:int'
        int y;
        /// Required attribute 'width' of XML schema type 'xsd:int'
        int width;
        /// Required attribute 'height' of XML schema type 'xsd:int'
        int height;
      public:
        /// Return unique type id SOAP_TYPE_tt__IntRectangle
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IntRectangle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IntRectangle, default initialized and not managed by a soap context
        virtual tt__IntRectangle *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IntRectangle); }
      public:
        /// Constructor with default initializations
        tt__IntRectangle() : x(), y(), width(), height() { }
        /// Destructor
        virtual ~tt__IntRectangle() { }
        /// Friend allocator used by soap_new_tt__IntRectangle(struct soap*, int)
        friend SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 soap_instantiate_tt__IntRectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:795 */
#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (305)
/* Type tt__IntRectangleRange is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IntRectangleRange': */
class SOAP_CMAC tt__IntRectangleRange : public xsd__anyType {
      public:
        /// Required element 'tt:XRange' of XML schema type 'tt:IntRange'
        tt__IntRange *XRange;
        /// Required element 'tt:YRange' of XML schema type 'tt:IntRange'
        tt__IntRange *YRange;
        /// Required element 'tt:WidthRange' of XML schema type 'tt:IntRange'
        tt__IntRange *WidthRange;
        /// Required element 'tt:HeightRange' of XML schema type 'tt:IntRange'
        tt__IntRange *HeightRange;
      public:
        /// Return unique type id SOAP_TYPE_tt__IntRectangleRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IntRectangleRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IntRectangleRange, default initialized and not managed by a soap context
        virtual tt__IntRectangleRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IntRectangleRange); }
      public:
        /// Constructor with default initializations
        tt__IntRectangleRange() : XRange(), YRange(), WidthRange(), HeightRange() { }
        /// Destructor
        virtual ~tt__IntRectangleRange() { }
        /// Friend allocator used by soap_new_tt__IntRectangleRange(struct soap*, int)
        friend SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 soap_instantiate_tt__IntRectangleRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:797 */
#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (306)
/* Type tt__FloatRange is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FloatRange': */
class SOAP_CMAC tt__FloatRange : public xsd__anyType {
      public:
        /// Required element 'tt:Min' of XML schema type 'xsd:float'
        float Min;
        /// Required element 'tt:Max' of XML schema type 'xsd:float'
        float Max;
      public:
        /// Return unique type id SOAP_TYPE_tt__FloatRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FloatRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FloatRange, default initialized and not managed by a soap context
        virtual tt__FloatRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FloatRange); }
      public:
        /// Constructor with default initializations
        tt__FloatRange() : Min(), Max() { }
        /// Destructor
        virtual ~tt__FloatRange() { }
        /// Friend allocator used by soap_new_tt__FloatRange(struct soap*, int)
        friend SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 soap_instantiate_tt__FloatRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:799 */
#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (307)
/* Type tt__DurationRange is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DurationRange': */
class SOAP_CMAC tt__DurationRange : public xsd__anyType {
      public:
        /// Required element 'tt:Min' of XML schema type 'xsd:duration'
        std::string Min;
        /// Required element 'tt:Max' of XML schema type 'xsd:duration'
        std::string Max;
      public:
        /// Return unique type id SOAP_TYPE_tt__DurationRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DurationRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DurationRange, default initialized and not managed by a soap context
        virtual tt__DurationRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DurationRange); }
      public:
        /// Constructor with default initializations
        tt__DurationRange() : Min(), Max() { }
        /// Destructor
        virtual ~tt__DurationRange() { }
        /// Friend allocator used by soap_new_tt__DurationRange(struct soap*, int)
        friend SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 soap_instantiate_tt__DurationRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:801 */
#ifndef SOAP_TYPE_tt__IntItems
#define SOAP_TYPE_tt__IntItems (308)
/* Type tt__IntItems is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IntItems': */
class SOAP_CMAC tt__IntItems : public xsd__anyType {
      public:
        /// Optional element 'tt:Items' of XML schema type 'xsd:int'
        std::vector<int> Items;
      public:
        /// Return unique type id SOAP_TYPE_tt__IntItems
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IntItems; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IntItems, default initialized and not managed by a soap context
        virtual tt__IntItems *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IntItems); }
      public:
        /// Constructor with default initializations
        tt__IntItems() : Items() { }
        /// Destructor
        virtual ~tt__IntItems() { }
        /// Friend allocator used by soap_new_tt__IntItems(struct soap*, int)
        friend SOAP_FMAC1 tt__IntItems * SOAP_FMAC2 soap_instantiate_tt__IntItems(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:803 */
#ifndef SOAP_TYPE_tt__FloatItems
#define SOAP_TYPE_tt__FloatItems (309)
/* Type tt__FloatItems is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FloatItems': */
class SOAP_CMAC tt__FloatItems : public xsd__anyType {
      public:
        /// Optional element 'tt:Items' of XML schema type 'xsd:float'
        std::vector<float> Items;
      public:
        /// Return unique type id SOAP_TYPE_tt__FloatItems
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FloatItems; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FloatItems, default initialized and not managed by a soap context
        virtual tt__FloatItems *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FloatItems); }
      public:
        /// Constructor with default initializations
        tt__FloatItems() : Items() { }
        /// Destructor
        virtual ~tt__FloatItems() { }
        /// Friend allocator used by soap_new_tt__FloatItems(struct soap*, int)
        friend SOAP_FMAC1 tt__FloatItems * SOAP_FMAC2 soap_instantiate_tt__FloatItems(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:805 */
#ifndef SOAP_TYPE_tt__AnyHolder
#define SOAP_TYPE_tt__AnyHolder (310)
/* Type tt__AnyHolder is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnyHolder': */
class SOAP_CMAC tt__AnyHolder : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnyHolder
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnyHolder; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnyHolder, default initialized and not managed by a soap context
        virtual tt__AnyHolder *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnyHolder); }
      public:
        /// Constructor with default initializations
        tt__AnyHolder() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AnyHolder() { }
        /// Friend allocator used by soap_new_tt__AnyHolder(struct soap*, int)
        friend SOAP_FMAC1 tt__AnyHolder * SOAP_FMAC2 soap_instantiate_tt__AnyHolder(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:809 */
#ifndef SOAP_TYPE_tt__VideoSourceExtension
#define SOAP_TYPE_tt__VideoSourceExtension (312)
/* Type tt__VideoSourceExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoSourceExtension': */
class SOAP_CMAC tt__VideoSourceExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:Imaging' of XML schema type 'tt:ImagingSettings20'
        tt__ImagingSettings20 *Imaging;
        /// Optional element 'tt:Extension' of XML schema type 'tt:VideoSourceExtension2'
        tt__VideoSourceExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceExtension, default initialized and not managed by a soap context
        virtual tt__VideoSourceExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceExtension); }
      public:
        /// Constructor with default initializations
        tt__VideoSourceExtension() : __any(), Imaging(), Extension() { }
        /// Destructor
        virtual ~tt__VideoSourceExtension() { }
        /// Friend allocator used by soap_new_tt__VideoSourceExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:811 */
#ifndef SOAP_TYPE_tt__VideoSourceExtension2
#define SOAP_TYPE_tt__VideoSourceExtension2 (313)
/* Type tt__VideoSourceExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoSourceExtension2': */
class SOAP_CMAC tt__VideoSourceExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceExtension2, default initialized and not managed by a soap context
        virtual tt__VideoSourceExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceExtension2); }
      public:
        /// Constructor with default initializations
        tt__VideoSourceExtension2() : __any() { }
        /// Destructor
        virtual ~tt__VideoSourceExtension2() { }
        /// Friend allocator used by soap_new_tt__VideoSourceExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:815 */
#ifndef SOAP_TYPE_tt__Profile
#define SOAP_TYPE_tt__Profile (315)
/* Type tt__Profile is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Profile': */
class SOAP_CMAC tt__Profile : public xsd__anyType {
      public:
        /// Required element 'tt:Name' of XML schema type 'tt:Name'
        std::string Name;
        /// Optional element 'tt:VideoSourceConfiguration' of XML schema type 'tt:VideoSourceConfiguration'
        tt__VideoSourceConfiguration *VideoSourceConfiguration;
        /// Optional element 'tt:AudioSourceConfiguration' of XML schema type 'tt:AudioSourceConfiguration'
        tt__AudioSourceConfiguration *AudioSourceConfiguration;
        /// Optional element 'tt:VideoEncoderConfiguration' of XML schema type 'tt:VideoEncoderConfiguration'
        tt__VideoEncoderConfiguration *VideoEncoderConfiguration;
        /// Optional element 'tt:AudioEncoderConfiguration' of XML schema type 'tt:AudioEncoderConfiguration'
        tt__AudioEncoderConfiguration *AudioEncoderConfiguration;
        /// Optional element 'tt:VideoAnalyticsConfiguration' of XML schema type 'tt:VideoAnalyticsConfiguration'
        tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;
        /// Optional element 'tt:PTZConfiguration' of XML schema type 'tt:PTZConfiguration'
        tt__PTZConfiguration *PTZConfiguration;
        /// Optional element 'tt:MetadataConfiguration' of XML schema type 'tt:MetadataConfiguration'
        tt__MetadataConfiguration *MetadataConfiguration;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ProfileExtension'
        tt__ProfileExtension *Extension;
        /// Required attribute 'token' of XML schema type 'tt:ReferenceToken'
        std::string token;
        /// Optional attribute 'fixed' of XML schema type 'xsd:boolean'
        bool *fixed;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Profile
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Profile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Profile, default initialized and not managed by a soap context
        virtual tt__Profile *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Profile); }
      public:
        /// Constructor with default initializations
        tt__Profile() : Name(), VideoSourceConfiguration(), AudioSourceConfiguration(), VideoEncoderConfiguration(), AudioEncoderConfiguration(), VideoAnalyticsConfiguration(), PTZConfiguration(), MetadataConfiguration(), Extension(), token(), fixed(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Profile() { }
        /// Friend allocator used by soap_new_tt__Profile(struct soap*, int)
        friend SOAP_FMAC1 tt__Profile * SOAP_FMAC2 soap_instantiate_tt__Profile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:817 */
#ifndef SOAP_TYPE_tt__ProfileExtension
#define SOAP_TYPE_tt__ProfileExtension (316)
/* Type tt__ProfileExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ProfileExtension': */
class SOAP_CMAC tt__ProfileExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:AudioOutputConfiguration' of XML schema type 'tt:AudioOutputConfiguration'
        tt__AudioOutputConfiguration *AudioOutputConfiguration;
        /// Optional element 'tt:AudioDecoderConfiguration' of XML schema type 'tt:AudioDecoderConfiguration'
        tt__AudioDecoderConfiguration *AudioDecoderConfiguration;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ProfileExtension2'
        tt__ProfileExtension2 *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ProfileExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ProfileExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ProfileExtension, default initialized and not managed by a soap context
        virtual tt__ProfileExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ProfileExtension); }
      public:
        /// Constructor with default initializations
        tt__ProfileExtension() : __any(), AudioOutputConfiguration(), AudioDecoderConfiguration(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ProfileExtension() { }
        /// Friend allocator used by soap_new_tt__ProfileExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ProfileExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:819 */
#ifndef SOAP_TYPE_tt__ProfileExtension2
#define SOAP_TYPE_tt__ProfileExtension2 (317)
/* Type tt__ProfileExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ProfileExtension2': */
class SOAP_CMAC tt__ProfileExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ProfileExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ProfileExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ProfileExtension2, default initialized and not managed by a soap context
        virtual tt__ProfileExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ProfileExtension2); }
      public:
        /// Constructor with default initializations
        tt__ProfileExtension2() : __any() { }
        /// Destructor
        virtual ~tt__ProfileExtension2() { }
        /// Friend allocator used by soap_new_tt__ProfileExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__ProfileExtension2 * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:821 */
#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (318)
/* Type tt__ConfigurationEntity is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ConfigurationEntity': */
class SOAP_CMAC tt__ConfigurationEntity : public xsd__anyType {
      public:
        /// Required element 'tt:Name' of XML schema type 'tt:Name'
        std::string Name;
        /// Required element 'tt:UseCount' of XML schema type 'xsd:int'
        int UseCount;
        /// Required attribute 'token' of XML schema type 'tt:ReferenceToken'
        std::string token;
      public:
        /// Return unique type id SOAP_TYPE_tt__ConfigurationEntity
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ConfigurationEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ConfigurationEntity, default initialized and not managed by a soap context
        virtual tt__ConfigurationEntity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ConfigurationEntity); }
      public:
        /// Constructor with default initializations
        tt__ConfigurationEntity() : Name(), UseCount(), token() { }
        /// Destructor
        virtual ~tt__ConfigurationEntity() { }
        /// Friend allocator used by soap_new_tt__ConfigurationEntity(struct soap*, int)
        friend SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 soap_instantiate_tt__ConfigurationEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:825 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension (320)
/* Type tt__VideoSourceConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoSourceConfigurationExtension': */
class SOAP_CMAC tt__VideoSourceConfigurationExtension : public xsd__anyType {
      public:
        /// Optional element 'tt:Rotate' of XML schema type 'tt:Rotate'
        tt__Rotate *Rotate;
        /// Optional element 'tt:Extension' of XML schema type 'tt:VideoSourceConfigurationExtension2'
        tt__VideoSourceConfigurationExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__VideoSourceConfigurationExtension() : Rotate(), Extension() { }
        /// Destructor
        virtual ~tt__VideoSourceConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:827 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (321)
/* Type tt__VideoSourceConfigurationExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoSourceConfigurationExtension2': */
class SOAP_CMAC tt__VideoSourceConfigurationExtension2 : public xsd__anyType {
      public:
        /// Optional element 'tt:LensDescription' of XML schema type 'tt:LensDescription'
        std::vector<tt__LensDescription *> LensDescription;
        /// Optional element 'tt:SceneOrientation' of XML schema type 'tt:SceneOrientation'
        tt__SceneOrientation *SceneOrientation;
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfigurationExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfigurationExtension2, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfigurationExtension2); }
      public:
        /// Constructor with default initializations
        tt__VideoSourceConfigurationExtension2() : LensDescription(), SceneOrientation(), __any() { }
        /// Destructor
        virtual ~tt__VideoSourceConfigurationExtension2() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:829 */
#ifndef SOAP_TYPE_tt__Rotate
#define SOAP_TYPE_tt__Rotate (322)
/* Type tt__Rotate is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Rotate': */
class SOAP_CMAC tt__Rotate : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:RotateMode'
        enum tt__RotateMode Mode;
        /// Optional element 'tt:Degree' of XML schema type 'xsd:int'
        int *Degree;
        /// Optional element 'tt:Extension' of XML schema type 'tt:RotateExtension'
        tt__RotateExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Rotate
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Rotate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Rotate, default initialized and not managed by a soap context
        virtual tt__Rotate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Rotate); }
      public:
        /// Constructor with default initializations
        tt__Rotate() : Mode(), Degree(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Rotate() { }
        /// Friend allocator used by soap_new_tt__Rotate(struct soap*, int)
        friend SOAP_FMAC1 tt__Rotate * SOAP_FMAC2 soap_instantiate_tt__Rotate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:831 */
#ifndef SOAP_TYPE_tt__RotateExtension
#define SOAP_TYPE_tt__RotateExtension (323)
/* Type tt__RotateExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RotateExtension': */
class SOAP_CMAC tt__RotateExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__RotateExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RotateExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RotateExtension, default initialized and not managed by a soap context
        virtual tt__RotateExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RotateExtension); }
      public:
        /// Constructor with default initializations
        tt__RotateExtension() : __any() { }
        /// Destructor
        virtual ~tt__RotateExtension() { }
        /// Friend allocator used by soap_new_tt__RotateExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RotateExtension * SOAP_FMAC2 soap_instantiate_tt__RotateExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:833 */
#ifndef SOAP_TYPE_tt__LensProjection
#define SOAP_TYPE_tt__LensProjection (324)
/* Type tt__LensProjection is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:LensProjection': */
class SOAP_CMAC tt__LensProjection : public xsd__anyType {
      public:
        /// Required element 'tt:Angle' of XML schema type 'xsd:float'
        float Angle;
        /// Required element 'tt:Radius' of XML schema type 'xsd:float'
        float Radius;
        /// Optional element 'tt:Transmittance' of XML schema type 'xsd:float'
        float *Transmittance;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__LensProjection
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LensProjection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LensProjection, default initialized and not managed by a soap context
        virtual tt__LensProjection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LensProjection); }
      public:
        /// Constructor with default initializations
        tt__LensProjection() : Angle(), Radius(), Transmittance(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__LensProjection() { }
        /// Friend allocator used by soap_new_tt__LensProjection(struct soap*, int)
        friend SOAP_FMAC1 tt__LensProjection * SOAP_FMAC2 soap_instantiate_tt__LensProjection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:835 */
#ifndef SOAP_TYPE_tt__LensOffset
#define SOAP_TYPE_tt__LensOffset (325)
/* Type tt__LensOffset is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tt:LensOffset': */
class SOAP_CMAC tt__LensOffset : public xsd__anyType {
      public:
        /// Optional attribute 'x' of XML schema type 'xsd:float'
        float *x;
        /// Optional attribute 'y' of XML schema type 'xsd:float'
        float *y;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__LensOffset
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LensOffset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LensOffset, default initialized and not managed by a soap context
        virtual tt__LensOffset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LensOffset); }
      public:
        /// Constructor with default initializations
        tt__LensOffset() : x(), y(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__LensOffset() { }
        /// Friend allocator used by soap_new_tt__LensOffset(struct soap*, int)
        friend SOAP_FMAC1 tt__LensOffset * SOAP_FMAC2 soap_instantiate_tt__LensOffset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:837 */
#ifndef SOAP_TYPE_tt__LensDescription
#define SOAP_TYPE_tt__LensDescription (326)
/* Type tt__LensDescription is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:LensDescription': */
class SOAP_CMAC tt__LensDescription : public xsd__anyType {
      public:
        /// Required element 'tt:Offset' of XML schema type 'tt:LensOffset'
        tt__LensOffset *Offset;
        /// Required element 'tt:Projection' of XML schema type 'tt:LensProjection'
        std::vector<tt__LensProjection *> Projection;
        /// Required element 'tt:XFactor' of XML schema type 'xsd:float'
        float XFactor;
        std::vector<char *> __any;
        /// Optional attribute 'FocalLength' of XML schema type 'xsd:float'
        float *FocalLength;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__LensDescription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LensDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LensDescription, default initialized and not managed by a soap context
        virtual tt__LensDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LensDescription); }
      public:
        /// Constructor with default initializations
        tt__LensDescription() : Offset(), Projection(), XFactor(), __any(), FocalLength(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__LensDescription() { }
        /// Friend allocator used by soap_new_tt__LensDescription(struct soap*, int)
        friend SOAP_FMAC1 tt__LensDescription * SOAP_FMAC2 soap_instantiate_tt__LensDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:839 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptions
#define SOAP_TYPE_tt__VideoSourceConfigurationOptions (327)
/* Type tt__VideoSourceConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoSourceConfigurationOptions': */
class SOAP_CMAC tt__VideoSourceConfigurationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:BoundsRange' of XML schema type 'tt:IntRectangleRange'
        tt__IntRectangleRange *BoundsRange;
        /// Required element 'tt:VideoSourceTokensAvailable' of XML schema type 'tt:ReferenceToken'
        std::vector<std::string> VideoSourceTokensAvailable;
        /// Optional element 'tt:Extension' of XML schema type 'tt:VideoSourceConfigurationOptionsExtension'
        tt__VideoSourceConfigurationOptionsExtension *Extension;
        /// Optional attribute 'MaximumNumberOfProfiles' of XML schema type 'xsd:int'
        int *MaximumNumberOfProfiles;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__VideoSourceConfigurationOptions() : BoundsRange(), VideoSourceTokensAvailable(), Extension(), MaximumNumberOfProfiles(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoSourceConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:841 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (328)
/* Type tt__VideoSourceConfigurationOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoSourceConfigurationOptionsExtension': */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:Rotate' of XML schema type 'tt:RotateOptions'
        tt__RotateOptions *Rotate;
        /// Optional element 'tt:Extension' of XML schema type 'tt:VideoSourceConfigurationOptionsExtension2'
        tt__VideoSourceConfigurationOptionsExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfigurationOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__VideoSourceConfigurationOptionsExtension() : __any(), Rotate(), Extension() { }
        /// Destructor
        virtual ~tt__VideoSourceConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:843 */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (329)
/* Type tt__VideoSourceConfigurationOptionsExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoSourceConfigurationOptionsExtension2': */
class SOAP_CMAC tt__VideoSourceConfigurationOptionsExtension2 : public xsd__anyType {
      public:
        /// Optional element 'tt:SceneOrientationMode' of XML schema type 'tt:SceneOrientationMode'
        std::vector<enum tt__SceneOrientationMode> SceneOrientationMode;
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfigurationOptionsExtension2, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfigurationOptionsExtension2); }
      public:
        /// Constructor with default initializations
        tt__VideoSourceConfigurationOptionsExtension2() : SceneOrientationMode(), __any() { }
        /// Destructor
        virtual ~tt__VideoSourceConfigurationOptionsExtension2() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfigurationOptionsExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:845 */
#ifndef SOAP_TYPE_tt__RotateOptions
#define SOAP_TYPE_tt__RotateOptions (330)
/* Type tt__RotateOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RotateOptions': */
class SOAP_CMAC tt__RotateOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:RotateMode'
        std::vector<enum tt__RotateMode> Mode;
        /// Optional element 'tt:DegreeList' of XML schema type 'tt:IntItems'
        tt__IntItems *DegreeList;
        /// Optional element 'tt:Extension' of XML schema type 'tt:RotateOptionsExtension'
        tt__RotateOptionsExtension *Extension;
        /// Optional attribute 'Reboot' of XML schema type 'xsd:boolean'
        bool *Reboot;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RotateOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RotateOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RotateOptions, default initialized and not managed by a soap context
        virtual tt__RotateOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RotateOptions); }
      public:
        /// Constructor with default initializations
        tt__RotateOptions() : Mode(), DegreeList(), Extension(), Reboot(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RotateOptions() { }
        /// Friend allocator used by soap_new_tt__RotateOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__RotateOptions * SOAP_FMAC2 soap_instantiate_tt__RotateOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:847 */
#ifndef SOAP_TYPE_tt__RotateOptionsExtension
#define SOAP_TYPE_tt__RotateOptionsExtension (331)
/* Type tt__RotateOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RotateOptionsExtension': */
class SOAP_CMAC tt__RotateOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__RotateOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RotateOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RotateOptionsExtension, default initialized and not managed by a soap context
        virtual tt__RotateOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RotateOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__RotateOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__RotateOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__RotateOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RotateOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__RotateOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:849 */
#ifndef SOAP_TYPE_tt__SceneOrientation
#define SOAP_TYPE_tt__SceneOrientation (332)
/* Type tt__SceneOrientation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SceneOrientation': */
class SOAP_CMAC tt__SceneOrientation : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:SceneOrientationMode'
        enum tt__SceneOrientationMode Mode;
        /// Optional element 'tt:Orientation' of XML schema type 'xsd:string'
        std::string *Orientation;
      public:
        /// Return unique type id SOAP_TYPE_tt__SceneOrientation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SceneOrientation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SceneOrientation, default initialized and not managed by a soap context
        virtual tt__SceneOrientation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SceneOrientation); }
      public:
        /// Constructor with default initializations
        tt__SceneOrientation() : Mode(), Orientation() { }
        /// Destructor
        virtual ~tt__SceneOrientation() { }
        /// Friend allocator used by soap_new_tt__SceneOrientation(struct soap*, int)
        friend SOAP_FMAC1 tt__SceneOrientation * SOAP_FMAC2 soap_instantiate_tt__SceneOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:853 */
#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (334)
/* Type tt__VideoResolution is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoResolution': */
class SOAP_CMAC tt__VideoResolution : public xsd__anyType {
      public:
        /// Required element 'tt:Width' of XML schema type 'xsd:int'
        int Width;
        /// Required element 'tt:Height' of XML schema type 'xsd:int'
        int Height;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoResolution
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoResolution; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoResolution, default initialized and not managed by a soap context
        virtual tt__VideoResolution *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoResolution); }
      public:
        /// Constructor with default initializations
        tt__VideoResolution() : Width(), Height() { }
        /// Destructor
        virtual ~tt__VideoResolution() { }
        /// Friend allocator used by soap_new_tt__VideoResolution(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 soap_instantiate_tt__VideoResolution(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:855 */
#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (335)
/* Type tt__VideoRateControl is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoRateControl': */
class SOAP_CMAC tt__VideoRateControl : public xsd__anyType {
      public:
        /// Required element 'tt:FrameRateLimit' of XML schema type 'xsd:int'
        int FrameRateLimit;
        /// Required element 'tt:EncodingInterval' of XML schema type 'xsd:int'
        int EncodingInterval;
        /// Required element 'tt:BitrateLimit' of XML schema type 'xsd:int'
        int BitrateLimit;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoRateControl
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoRateControl; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoRateControl, default initialized and not managed by a soap context
        virtual tt__VideoRateControl *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoRateControl); }
      public:
        /// Constructor with default initializations
        tt__VideoRateControl() : FrameRateLimit(), EncodingInterval(), BitrateLimit() { }
        /// Destructor
        virtual ~tt__VideoRateControl() { }
        /// Friend allocator used by soap_new_tt__VideoRateControl(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:857 */
#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (336)
/* Type tt__Mpeg4Configuration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Mpeg4Configuration': */
class SOAP_CMAC tt__Mpeg4Configuration : public xsd__anyType {
      public:
        /// Required element 'tt:GovLength' of XML schema type 'xsd:int'
        int GovLength;
        /// Required element 'tt:Mpeg4Profile' of XML schema type 'tt:Mpeg4Profile'
        enum tt__Mpeg4Profile Mpeg4Profile;
      public:
        /// Return unique type id SOAP_TYPE_tt__Mpeg4Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Mpeg4Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Mpeg4Configuration, default initialized and not managed by a soap context
        virtual tt__Mpeg4Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Mpeg4Configuration); }
      public:
        /// Constructor with default initializations
        tt__Mpeg4Configuration() : GovLength(), Mpeg4Profile() { }
        /// Destructor
        virtual ~tt__Mpeg4Configuration() { }
        /// Friend allocator used by soap_new_tt__Mpeg4Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:859 */
#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (337)
/* Type tt__H264Configuration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:H264Configuration': */
class SOAP_CMAC tt__H264Configuration : public xsd__anyType {
      public:
        /// Required element 'tt:GovLength' of XML schema type 'xsd:int'
        int GovLength;
        /// Required element 'tt:H264Profile' of XML schema type 'tt:H264Profile'
        enum tt__H264Profile H264Profile;
      public:
        /// Return unique type id SOAP_TYPE_tt__H264Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__H264Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__H264Configuration, default initialized and not managed by a soap context
        virtual tt__H264Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__H264Configuration); }
      public:
        /// Constructor with default initializations
        tt__H264Configuration() : GovLength(), H264Profile() { }
        /// Destructor
        virtual ~tt__H264Configuration() { }
        /// Friend allocator used by soap_new_tt__H264Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 soap_instantiate_tt__H264Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:861 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoderConfigurationOptions (338)
/* Type tt__VideoEncoderConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoEncoderConfigurationOptions': */
class SOAP_CMAC tt__VideoEncoderConfigurationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:QualityRange' of XML schema type 'tt:IntRange'
        tt__IntRange *QualityRange;
        /// Optional element 'tt:JPEG' of XML schema type 'tt:JpegOptions'
        tt__JpegOptions *JPEG;
        /// Optional element 'tt:MPEG4' of XML schema type 'tt:Mpeg4Options'
        tt__Mpeg4Options *MPEG4;
        /// Optional element 'tt:H264' of XML schema type 'tt:H264Options'
        tt__H264Options *H264;
        /// Optional element 'tt:Extension' of XML schema type 'tt:VideoEncoderOptionsExtension'
        tt__VideoEncoderOptionsExtension *Extension;
        /// Optional attribute 'GuaranteedFrameRateSupported' of XML schema type 'xsd:boolean'
        bool *GuaranteedFrameRateSupported;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoderConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoderConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__VideoEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoderConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__VideoEncoderConfigurationOptions() : QualityRange(), JPEG(), MPEG4(), H264(), Extension(), GuaranteedFrameRateSupported(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoEncoderConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__VideoEncoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:863 */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension (339)
/* Type tt__VideoEncoderOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoEncoderOptionsExtension': */
class SOAP_CMAC tt__VideoEncoderOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:JPEG' of XML schema type 'tt:JpegOptions2'
        tt__JpegOptions2 *JPEG;
        /// Optional element 'tt:MPEG4' of XML schema type 'tt:Mpeg4Options2'
        tt__Mpeg4Options2 *MPEG4;
        /// Optional element 'tt:H264' of XML schema type 'tt:H264Options2'
        tt__H264Options2 *H264;
        /// Optional element 'tt:Extension' of XML schema type 'tt:VideoEncoderOptionsExtension2'
        tt__VideoEncoderOptionsExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoderOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoderOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoderOptionsExtension, default initialized and not managed by a soap context
        virtual tt__VideoEncoderOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoderOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__VideoEncoderOptionsExtension() : __any(), JPEG(), MPEG4(), H264(), Extension() { }
        /// Destructor
        virtual ~tt__VideoEncoderOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__VideoEncoderOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoderOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:865 */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension2
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (340)
/* Type tt__VideoEncoderOptionsExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoEncoderOptionsExtension2': */
class SOAP_CMAC tt__VideoEncoderOptionsExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoderOptionsExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoderOptionsExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoderOptionsExtension2, default initialized and not managed by a soap context
        virtual tt__VideoEncoderOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoderOptionsExtension2); }
      public:
        /// Constructor with default initializations
        tt__VideoEncoderOptionsExtension2() : __any() { }
        /// Destructor
        virtual ~tt__VideoEncoderOptionsExtension2() { }
        /// Friend allocator used by soap_new_tt__VideoEncoderOptionsExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:867 */
#ifndef SOAP_TYPE_tt__JpegOptions
#define SOAP_TYPE_tt__JpegOptions (341)
/* Type tt__JpegOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:JpegOptions': */
class SOAP_CMAC tt__JpegOptions : public xsd__anyType {
      public:
        /// Required element 'tt:ResolutionsAvailable' of XML schema type 'tt:VideoResolution'
        std::vector<tt__VideoResolution *> ResolutionsAvailable;
        /// Required element 'tt:FrameRateRange' of XML schema type 'tt:IntRange'
        tt__IntRange *FrameRateRange;
        /// Required element 'tt:EncodingIntervalRange' of XML schema type 'tt:IntRange'
        tt__IntRange *EncodingIntervalRange;
      public:
        /// Return unique type id SOAP_TYPE_tt__JpegOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__JpegOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__JpegOptions, default initialized and not managed by a soap context
        virtual tt__JpegOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__JpegOptions); }
      public:
        /// Constructor with default initializations
        tt__JpegOptions() : ResolutionsAvailable(), FrameRateRange(), EncodingIntervalRange() { }
        /// Destructor
        virtual ~tt__JpegOptions() { }
        /// Friend allocator used by soap_new_tt__JpegOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__JpegOptions * SOAP_FMAC2 soap_instantiate_tt__JpegOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:871 */
#ifndef SOAP_TYPE_tt__Mpeg4Options
#define SOAP_TYPE_tt__Mpeg4Options (343)
/* Type tt__Mpeg4Options is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Mpeg4Options': */
class SOAP_CMAC tt__Mpeg4Options : public xsd__anyType {
      public:
        /// Required element 'tt:ResolutionsAvailable' of XML schema type 'tt:VideoResolution'
        std::vector<tt__VideoResolution *> ResolutionsAvailable;
        /// Required element 'tt:GovLengthRange' of XML schema type 'tt:IntRange'
        tt__IntRange *GovLengthRange;
        /// Required element 'tt:FrameRateRange' of XML schema type 'tt:IntRange'
        tt__IntRange *FrameRateRange;
        /// Required element 'tt:EncodingIntervalRange' of XML schema type 'tt:IntRange'
        tt__IntRange *EncodingIntervalRange;
        /// Required element 'tt:Mpeg4ProfilesSupported' of XML schema type 'tt:Mpeg4Profile'
        std::vector<enum tt__Mpeg4Profile> Mpeg4ProfilesSupported;
      public:
        /// Return unique type id SOAP_TYPE_tt__Mpeg4Options
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Mpeg4Options; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Mpeg4Options, default initialized and not managed by a soap context
        virtual tt__Mpeg4Options *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Mpeg4Options); }
      public:
        /// Constructor with default initializations
        tt__Mpeg4Options() : ResolutionsAvailable(), GovLengthRange(), FrameRateRange(), EncodingIntervalRange(), Mpeg4ProfilesSupported() { }
        /// Destructor
        virtual ~tt__Mpeg4Options() { }
        /// Friend allocator used by soap_new_tt__Mpeg4Options(struct soap*, int)
        friend SOAP_FMAC1 tt__Mpeg4Options * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:875 */
#ifndef SOAP_TYPE_tt__H264Options
#define SOAP_TYPE_tt__H264Options (345)
/* Type tt__H264Options is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:H264Options': */
class SOAP_CMAC tt__H264Options : public xsd__anyType {
      public:
        /// Required element 'tt:ResolutionsAvailable' of XML schema type 'tt:VideoResolution'
        std::vector<tt__VideoResolution *> ResolutionsAvailable;
        /// Required element 'tt:GovLengthRange' of XML schema type 'tt:IntRange'
        tt__IntRange *GovLengthRange;
        /// Required element 'tt:FrameRateRange' of XML schema type 'tt:IntRange'
        tt__IntRange *FrameRateRange;
        /// Required element 'tt:EncodingIntervalRange' of XML schema type 'tt:IntRange'
        tt__IntRange *EncodingIntervalRange;
        /// Required element 'tt:H264ProfilesSupported' of XML schema type 'tt:H264Profile'
        std::vector<enum tt__H264Profile> H264ProfilesSupported;
      public:
        /// Return unique type id SOAP_TYPE_tt__H264Options
        virtual long soap_type(void) const { return SOAP_TYPE_tt__H264Options; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__H264Options, default initialized and not managed by a soap context
        virtual tt__H264Options *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__H264Options); }
      public:
        /// Constructor with default initializations
        tt__H264Options() : ResolutionsAvailable(), GovLengthRange(), FrameRateRange(), EncodingIntervalRange(), H264ProfilesSupported() { }
        /// Destructor
        virtual ~tt__H264Options() { }
        /// Friend allocator used by soap_new_tt__H264Options(struct soap*, int)
        friend SOAP_FMAC1 tt__H264Options * SOAP_FMAC2 soap_instantiate_tt__H264Options(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:881 */
#ifndef SOAP_TYPE_tt__VideoResolution2
#define SOAP_TYPE_tt__VideoResolution2 (348)
/* Type tt__VideoResolution2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoResolution2': */
class SOAP_CMAC tt__VideoResolution2 : public xsd__anyType {
      public:
        /// Required element 'tt:Width' of XML schema type 'xsd:int'
        int Width;
        /// Required element 'tt:Height' of XML schema type 'xsd:int'
        int Height;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoResolution2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoResolution2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoResolution2, default initialized and not managed by a soap context
        virtual tt__VideoResolution2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoResolution2); }
      public:
        /// Constructor with default initializations
        tt__VideoResolution2() : Width(), Height(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoResolution2() { }
        /// Friend allocator used by soap_new_tt__VideoResolution2(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoResolution2 * SOAP_FMAC2 soap_instantiate_tt__VideoResolution2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:883 */
#ifndef SOAP_TYPE_tt__VideoRateControl2
#define SOAP_TYPE_tt__VideoRateControl2 (349)
/* Type tt__VideoRateControl2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoRateControl2': */
class SOAP_CMAC tt__VideoRateControl2 : public xsd__anyType {
      public:
        /// Required element 'tt:FrameRateLimit' of XML schema type 'xsd:float'
        float FrameRateLimit;
        /// Required element 'tt:BitrateLimit' of XML schema type 'xsd:int'
        int BitrateLimit;
        std::vector<char *> __any;
        /// Optional attribute 'ConstantBitRate' of XML schema type 'xsd:boolean'
        bool *ConstantBitRate;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoRateControl2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoRateControl2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoRateControl2, default initialized and not managed by a soap context
        virtual tt__VideoRateControl2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoRateControl2); }
      public:
        /// Constructor with default initializations
        tt__VideoRateControl2() : FrameRateLimit(), BitrateLimit(), __any(), ConstantBitRate(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoRateControl2() { }
        /// Friend allocator used by soap_new_tt__VideoRateControl2(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoRateControl2 * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:885 */
#ifndef SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions (350)
/* Type tt__VideoEncoder2ConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoEncoder2ConfigurationOptions': */
class SOAP_CMAC tt__VideoEncoder2ConfigurationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Encoding' of XML schema type 'xsd:string'
        std::string Encoding;
        /// Required element 'tt:QualityRange' of XML schema type 'tt:FloatRange'
        tt__FloatRange *QualityRange;
        /// Required element 'tt:ResolutionsAvailable' of XML schema type 'tt:VideoResolution2'
        std::vector<tt__VideoResolution2 *> ResolutionsAvailable;
        /// Required element 'tt:BitrateRange' of XML schema type 'tt:IntRange'
        tt__IntRange *BitrateRange;
        std::vector<char *> __any;
        /// Optional attribute 'GovLengthRange' of XML schema type 'tt:IntList'
        std::string *GovLengthRange;
        /// Optional attribute 'FrameRatesSupported' of XML schema type 'tt:FloatList'
        std::string *FrameRatesSupported;
        /// Optional attribute 'ProfilesSupported' of XML schema type 'tt:StringAttrList'
        std::string *ProfilesSupported;
        /// Optional attribute 'ConstantBitRateSupported' of XML schema type 'xsd:boolean'
        bool *ConstantBitRateSupported;
        /// Optional attribute 'GuaranteedFrameRateSupported' of XML schema type 'xsd:boolean'
        bool *GuaranteedFrameRateSupported;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoder2ConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__VideoEncoder2ConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoder2ConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__VideoEncoder2ConfigurationOptions() : Encoding(), QualityRange(), ResolutionsAvailable(), BitrateRange(), __any(), GovLengthRange(), FrameRatesSupported(), ProfilesSupported(), ConstantBitRateSupported(), GuaranteedFrameRateSupported(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoEncoder2ConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__VideoEncoder2ConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoder2ConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoder2ConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:889 */
#ifndef SOAP_TYPE_tt__AudioSourceConfigurationOptions
#define SOAP_TYPE_tt__AudioSourceConfigurationOptions (352)
/* Type tt__AudioSourceConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioSourceConfigurationOptions': */
class SOAP_CMAC tt__AudioSourceConfigurationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:InputTokensAvailable' of XML schema type 'tt:ReferenceToken'
        std::vector<std::string> InputTokensAvailable;
        /// Optional element 'tt:Extension' of XML schema type 'tt:AudioSourceOptionsExtension'
        tt__AudioSourceOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioSourceConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioSourceConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioSourceConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__AudioSourceConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioSourceConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__AudioSourceConfigurationOptions() : InputTokensAvailable(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioSourceConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__AudioSourceConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:891 */
#ifndef SOAP_TYPE_tt__AudioSourceOptionsExtension
#define SOAP_TYPE_tt__AudioSourceOptionsExtension (353)
/* Type tt__AudioSourceOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioSourceOptionsExtension': */
class SOAP_CMAC tt__AudioSourceOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioSourceOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioSourceOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioSourceOptionsExtension, default initialized and not managed by a soap context
        virtual tt__AudioSourceOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioSourceOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__AudioSourceOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__AudioSourceOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__AudioSourceOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioSourceOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioSourceOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:895 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoderConfigurationOptions (355)
/* Type tt__AudioEncoderConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioEncoderConfigurationOptions': */
class SOAP_CMAC tt__AudioEncoderConfigurationOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:Options' of XML schema type 'tt:AudioEncoderConfigurationOption'
        std::vector<tt__AudioEncoderConfigurationOption *> Options;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioEncoderConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioEncoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioEncoderConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__AudioEncoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioEncoderConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__AudioEncoderConfigurationOptions() : Options(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioEncoderConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__AudioEncoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:897 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOption
#define SOAP_TYPE_tt__AudioEncoderConfigurationOption (356)
/* Type tt__AudioEncoderConfigurationOption is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioEncoderConfigurationOption': */
class SOAP_CMAC tt__AudioEncoderConfigurationOption : public xsd__anyType {
      public:
        /// Required element 'tt:Encoding' of XML schema type 'tt:AudioEncoding'
        enum tt__AudioEncoding Encoding;
        /// Required element 'tt:BitrateList' of XML schema type 'tt:IntItems'
        tt__IntItems *BitrateList;
        /// Required element 'tt:SampleRateList' of XML schema type 'tt:IntItems'
        tt__IntItems *SampleRateList;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioEncoderConfigurationOption
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioEncoderConfigurationOption; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioEncoderConfigurationOption, default initialized and not managed by a soap context
        virtual tt__AudioEncoderConfigurationOption *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioEncoderConfigurationOption); }
      public:
        /// Constructor with default initializations
        tt__AudioEncoderConfigurationOption() : Encoding(), BitrateList(), SampleRateList(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioEncoderConfigurationOption() { }
        /// Friend allocator used by soap_new_tt__AudioEncoderConfigurationOption(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioEncoderConfigurationOption * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOption(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:901 */
#ifndef SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions (358)
/* Type tt__AudioEncoder2ConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioEncoder2ConfigurationOptions': */
class SOAP_CMAC tt__AudioEncoder2ConfigurationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Encoding' of XML schema type 'xsd:string'
        std::string Encoding;
        /// Required element 'tt:BitrateList' of XML schema type 'tt:IntItems'
        tt__IntItems *BitrateList;
        /// Required element 'tt:SampleRateList' of XML schema type 'tt:IntItems'
        tt__IntItems *SampleRateList;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioEncoder2ConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__AudioEncoder2ConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioEncoder2ConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__AudioEncoder2ConfigurationOptions() : Encoding(), BitrateList(), SampleRateList(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioEncoder2ConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__AudioEncoder2ConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioEncoder2ConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoder2ConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:907 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension
#define SOAP_TYPE_tt__MetadataConfigurationExtension (361)
/* Type tt__MetadataConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MetadataConfigurationExtension': */
class SOAP_CMAC tt__MetadataConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__MetadataConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__MetadataConfigurationExtension() : __any() { }
        /// Destructor
        virtual ~tt__MetadataConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__MetadataConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:909 */
#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (362)
/* Type tt__PTZFilter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZFilter': */
class SOAP_CMAC tt__PTZFilter : public xsd__anyType {
      public:
        /// Required element 'tt:Status' of XML schema type 'xsd:boolean'
        bool Status;
        /// Required element 'tt:Position' of XML schema type 'xsd:boolean'
        bool Position;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZFilter
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZFilter, default initialized and not managed by a soap context
        virtual tt__PTZFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZFilter); }
      public:
        /// Constructor with default initializations
        tt__PTZFilter() : Status(), Position(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZFilter() { }
        /// Friend allocator used by soap_new_tt__PTZFilter(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZFilter * SOAP_FMAC2 soap_instantiate_tt__PTZFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:10912 */
#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1164)
/* complex XML schema type 'tt:EventSubscription-SubscriptionPolicy': */
class SOAP_CMAC _tt__EventSubscription_SubscriptionPolicy {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__EventSubscription_SubscriptionPolicy, default initialized and not managed by a soap context
        virtual _tt__EventSubscription_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__EventSubscription_SubscriptionPolicy); }
      public:
        /// Constructor with default initializations
        _tt__EventSubscription_SubscriptionPolicy() : __any() { }
        /// Destructor
        virtual ~_tt__EventSubscription_SubscriptionPolicy() { }
        /// Friend allocator used by soap_new__tt__EventSubscription_SubscriptionPolicy(struct soap*, int)
        friend SOAP_FMAC1 _tt__EventSubscription_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__tt__EventSubscription_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:911 */
#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (363)
/* Type tt__EventSubscription is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:EventSubscription': */
class SOAP_CMAC tt__EventSubscription : public xsd__anyType {
      public:
        /// Optional element 'tt:Filter' of XML schema type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'tt:SubscriptionPolicy' of XML schema type 'tt:EventSubscription-SubscriptionPolicy'
        _tt__EventSubscription_SubscriptionPolicy *SubscriptionPolicy;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__EventSubscription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EventSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EventSubscription, default initialized and not managed by a soap context
        virtual tt__EventSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EventSubscription); }
      public:
        /// Constructor with default initializations
        tt__EventSubscription() : Filter(), SubscriptionPolicy(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__EventSubscription() { }
        /// Friend allocator used by soap_new_tt__EventSubscription(struct soap*, int)
        friend SOAP_FMAC1 tt__EventSubscription * SOAP_FMAC2 soap_instantiate_tt__EventSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:913 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptions
#define SOAP_TYPE_tt__MetadataConfigurationOptions (364)
/* Type tt__MetadataConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MetadataConfigurationOptions': */
class SOAP_CMAC tt__MetadataConfigurationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:PTZStatusFilterOptions' of XML schema type 'tt:PTZStatusFilterOptions'
        tt__PTZStatusFilterOptions *PTZStatusFilterOptions;
        std::vector<char *> __any;
        /// Optional element 'tt:Extension' of XML schema type 'tt:MetadataConfigurationOptionsExtension'
        tt__MetadataConfigurationOptionsExtension *Extension;
        /// Optional attribute 'GeoLocation' of XML schema type 'xsd:boolean'
        bool *GeoLocation;
        /// Optional attribute 'MaxContentFilterSize' of XML schema type 'xsd:int'
        int *MaxContentFilterSize;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__MetadataConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__MetadataConfigurationOptions() : PTZStatusFilterOptions(), __any(), Extension(), GeoLocation(), MaxContentFilterSize(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MetadataConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__MetadataConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:915 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension (365)
/* Type tt__MetadataConfigurationOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MetadataConfigurationOptionsExtension': */
class SOAP_CMAC tt__MetadataConfigurationOptionsExtension : public xsd__anyType {
      public:
        /// Optional element 'tt:CompressionType' of XML schema type 'xsd:string'
        std::vector<std::string> CompressionType;
        /// Optional element 'tt:Extension' of XML schema type 'tt:MetadataConfigurationOptionsExtension2'
        tt__MetadataConfigurationOptionsExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataConfigurationOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual tt__MetadataConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataConfigurationOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__MetadataConfigurationOptionsExtension() : CompressionType(), Extension() { }
        /// Destructor
        virtual ~tt__MetadataConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__MetadataConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:917 */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 (366)
/* Type tt__MetadataConfigurationOptionsExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MetadataConfigurationOptionsExtension2': */
class SOAP_CMAC tt__MetadataConfigurationOptionsExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataConfigurationOptionsExtension2, default initialized and not managed by a soap context
        virtual tt__MetadataConfigurationOptionsExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataConfigurationOptionsExtension2); }
      public:
        /// Constructor with default initializations
        tt__MetadataConfigurationOptionsExtension2() : __any() { }
        /// Destructor
        virtual ~tt__MetadataConfigurationOptionsExtension2() { }
        /// Friend allocator used by soap_new_tt__MetadataConfigurationOptionsExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__MetadataConfigurationOptionsExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:919 */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptions
#define SOAP_TYPE_tt__PTZStatusFilterOptions (367)
/* Type tt__PTZStatusFilterOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZStatusFilterOptions': */
class SOAP_CMAC tt__PTZStatusFilterOptions : public xsd__anyType {
      public:
        /// Required element 'tt:PanTiltStatusSupported' of XML schema type 'xsd:boolean'
        bool PanTiltStatusSupported;
        /// Required element 'tt:ZoomStatusSupported' of XML schema type 'xsd:boolean'
        bool ZoomStatusSupported;
        std::vector<char *> __any;
        /// Optional element 'tt:PanTiltPositionSupported' of XML schema type 'xsd:boolean'
        bool *PanTiltPositionSupported;
        /// Optional element 'tt:ZoomPositionSupported' of XML schema type 'xsd:boolean'
        bool *ZoomPositionSupported;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZStatusFilterOptionsExtension'
        tt__PTZStatusFilterOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZStatusFilterOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZStatusFilterOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZStatusFilterOptions, default initialized and not managed by a soap context
        virtual tt__PTZStatusFilterOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZStatusFilterOptions); }
      public:
        /// Constructor with default initializations
        tt__PTZStatusFilterOptions() : PanTiltStatusSupported(), ZoomStatusSupported(), __any(), PanTiltPositionSupported(), ZoomPositionSupported(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZStatusFilterOptions() { }
        /// Friend allocator used by soap_new_tt__PTZStatusFilterOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZStatusFilterOptions * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:921 */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (368)
/* Type tt__PTZStatusFilterOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZStatusFilterOptionsExtension': */
class SOAP_CMAC tt__PTZStatusFilterOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZStatusFilterOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZStatusFilterOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZStatusFilterOptionsExtension, default initialized and not managed by a soap context
        virtual tt__PTZStatusFilterOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZStatusFilterOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZStatusFilterOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__PTZStatusFilterOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__PTZStatusFilterOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZStatusFilterOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZStatusFilterOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:925 */
#ifndef SOAP_TYPE_tt__VideoOutputExtension
#define SOAP_TYPE_tt__VideoOutputExtension (370)
/* Type tt__VideoOutputExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoOutputExtension': */
class SOAP_CMAC tt__VideoOutputExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoOutputExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoOutputExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoOutputExtension, default initialized and not managed by a soap context
        virtual tt__VideoOutputExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoOutputExtension); }
      public:
        /// Constructor with default initializations
        tt__VideoOutputExtension() : __any() { }
        /// Destructor
        virtual ~tt__VideoOutputExtension() { }
        /// Friend allocator used by soap_new_tt__VideoOutputExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoOutputExtension * SOAP_FMAC2 soap_instantiate_tt__VideoOutputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:929 */
#ifndef SOAP_TYPE_tt__VideoOutputConfigurationOptions
#define SOAP_TYPE_tt__VideoOutputConfigurationOptions (372)
/* Type tt__VideoOutputConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoOutputConfigurationOptions': */
class SOAP_CMAC tt__VideoOutputConfigurationOptions : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoOutputConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoOutputConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoOutputConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__VideoOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoOutputConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__VideoOutputConfigurationOptions() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoOutputConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__VideoOutputConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:931 */
#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptions
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptions (373)
/* Type tt__VideoDecoderConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoDecoderConfigurationOptions': */
class SOAP_CMAC tt__VideoDecoderConfigurationOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:JpegDecOptions' of XML schema type 'tt:JpegDecOptions'
        tt__JpegDecOptions *JpegDecOptions;
        /// Optional element 'tt:H264DecOptions' of XML schema type 'tt:H264DecOptions'
        tt__H264DecOptions *H264DecOptions;
        /// Optional element 'tt:Mpeg4DecOptions' of XML schema type 'tt:Mpeg4DecOptions'
        tt__Mpeg4DecOptions *Mpeg4DecOptions;
        /// Optional element 'tt:Extension' of XML schema type 'tt:VideoDecoderConfigurationOptionsExtension'
        tt__VideoDecoderConfigurationOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoDecoderConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoDecoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoDecoderConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__VideoDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoDecoderConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__VideoDecoderConfigurationOptions() : JpegDecOptions(), H264DecOptions(), Mpeg4DecOptions(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoDecoderConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__VideoDecoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:933 */
#ifndef SOAP_TYPE_tt__H264DecOptions
#define SOAP_TYPE_tt__H264DecOptions (374)
/* Type tt__H264DecOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:H264DecOptions': */
class SOAP_CMAC tt__H264DecOptions : public xsd__anyType {
      public:
        /// Required element 'tt:ResolutionsAvailable' of XML schema type 'tt:VideoResolution'
        std::vector<tt__VideoResolution *> ResolutionsAvailable;
        /// Required element 'tt:SupportedH264Profiles' of XML schema type 'tt:H264Profile'
        std::vector<enum tt__H264Profile> SupportedH264Profiles;
        /// Required element 'tt:SupportedInputBitrate' of XML schema type 'tt:IntRange'
        tt__IntRange *SupportedInputBitrate;
        /// Required element 'tt:SupportedFrameRate' of XML schema type 'tt:IntRange'
        tt__IntRange *SupportedFrameRate;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__H264DecOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__H264DecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__H264DecOptions, default initialized and not managed by a soap context
        virtual tt__H264DecOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__H264DecOptions); }
      public:
        /// Constructor with default initializations
        tt__H264DecOptions() : ResolutionsAvailable(), SupportedH264Profiles(), SupportedInputBitrate(), SupportedFrameRate(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__H264DecOptions() { }
        /// Friend allocator used by soap_new_tt__H264DecOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__H264DecOptions * SOAP_FMAC2 soap_instantiate_tt__H264DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:935 */
#ifndef SOAP_TYPE_tt__JpegDecOptions
#define SOAP_TYPE_tt__JpegDecOptions (375)
/* Type tt__JpegDecOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:JpegDecOptions': */
class SOAP_CMAC tt__JpegDecOptions : public xsd__anyType {
      public:
        /// Required element 'tt:ResolutionsAvailable' of XML schema type 'tt:VideoResolution'
        std::vector<tt__VideoResolution *> ResolutionsAvailable;
        /// Required element 'tt:SupportedInputBitrate' of XML schema type 'tt:IntRange'
        tt__IntRange *SupportedInputBitrate;
        /// Required element 'tt:SupportedFrameRate' of XML schema type 'tt:IntRange'
        tt__IntRange *SupportedFrameRate;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__JpegDecOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__JpegDecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__JpegDecOptions, default initialized and not managed by a soap context
        virtual tt__JpegDecOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__JpegDecOptions); }
      public:
        /// Constructor with default initializations
        tt__JpegDecOptions() : ResolutionsAvailable(), SupportedInputBitrate(), SupportedFrameRate(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__JpegDecOptions() { }
        /// Friend allocator used by soap_new_tt__JpegDecOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__JpegDecOptions * SOAP_FMAC2 soap_instantiate_tt__JpegDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:937 */
#ifndef SOAP_TYPE_tt__Mpeg4DecOptions
#define SOAP_TYPE_tt__Mpeg4DecOptions (376)
/* Type tt__Mpeg4DecOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Mpeg4DecOptions': */
class SOAP_CMAC tt__Mpeg4DecOptions : public xsd__anyType {
      public:
        /// Required element 'tt:ResolutionsAvailable' of XML schema type 'tt:VideoResolution'
        std::vector<tt__VideoResolution *> ResolutionsAvailable;
        /// Required element 'tt:SupportedMpeg4Profiles' of XML schema type 'tt:Mpeg4Profile'
        std::vector<enum tt__Mpeg4Profile> SupportedMpeg4Profiles;
        /// Required element 'tt:SupportedInputBitrate' of XML schema type 'tt:IntRange'
        tt__IntRange *SupportedInputBitrate;
        /// Required element 'tt:SupportedFrameRate' of XML schema type 'tt:IntRange'
        tt__IntRange *SupportedFrameRate;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Mpeg4DecOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Mpeg4DecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Mpeg4DecOptions, default initialized and not managed by a soap context
        virtual tt__Mpeg4DecOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Mpeg4DecOptions); }
      public:
        /// Constructor with default initializations
        tt__Mpeg4DecOptions() : ResolutionsAvailable(), SupportedMpeg4Profiles(), SupportedInputBitrate(), SupportedFrameRate(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Mpeg4DecOptions() { }
        /// Friend allocator used by soap_new_tt__Mpeg4DecOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__Mpeg4DecOptions * SOAP_FMAC2 soap_instantiate_tt__Mpeg4DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:939 */
#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension (377)
/* Type tt__VideoDecoderConfigurationOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoDecoderConfigurationOptionsExtension': */
class SOAP_CMAC tt__VideoDecoderConfigurationOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual tt__VideoDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoDecoderConfigurationOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__VideoDecoderConfigurationOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__VideoDecoderConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__VideoDecoderConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:945 */
#ifndef SOAP_TYPE_tt__AudioOutputConfigurationOptions
#define SOAP_TYPE_tt__AudioOutputConfigurationOptions (380)
/* Type tt__AudioOutputConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioOutputConfigurationOptions': */
class SOAP_CMAC tt__AudioOutputConfigurationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:OutputTokensAvailable' of XML schema type 'tt:ReferenceToken'
        std::vector<std::string> OutputTokensAvailable;
        /// Optional element 'tt:SendPrimacyOptions' of XML schema type 'xsd:anyURI'
        std::vector<std::string> SendPrimacyOptions;
        /// Required element 'tt:OutputLevelRange' of XML schema type 'tt:IntRange'
        tt__IntRange *OutputLevelRange;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioOutputConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioOutputConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioOutputConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__AudioOutputConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioOutputConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__AudioOutputConfigurationOptions() : OutputTokensAvailable(), SendPrimacyOptions(), OutputLevelRange(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioOutputConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__AudioOutputConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioOutputConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:949 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptions
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptions (382)
/* Type tt__AudioDecoderConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioDecoderConfigurationOptions': */
class SOAP_CMAC tt__AudioDecoderConfigurationOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:AACDecOptions' of XML schema type 'tt:AACDecOptions'
        tt__AACDecOptions *AACDecOptions;
        /// Optional element 'tt:G711DecOptions' of XML schema type 'tt:G711DecOptions'
        tt__G711DecOptions *G711DecOptions;
        /// Optional element 'tt:G726DecOptions' of XML schema type 'tt:G726DecOptions'
        tt__G726DecOptions *G726DecOptions;
        /// Optional element 'tt:Extension' of XML schema type 'tt:AudioDecoderConfigurationOptionsExtension'
        tt__AudioDecoderConfigurationOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioDecoderConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioDecoderConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioDecoderConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__AudioDecoderConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioDecoderConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__AudioDecoderConfigurationOptions() : AACDecOptions(), G711DecOptions(), G726DecOptions(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioDecoderConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__AudioDecoderConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioDecoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:951 */
#ifndef SOAP_TYPE_tt__G711DecOptions
#define SOAP_TYPE_tt__G711DecOptions (383)
/* Type tt__G711DecOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:G711DecOptions': */
class SOAP_CMAC tt__G711DecOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Bitrate' of XML schema type 'tt:IntItems'
        tt__IntItems *Bitrate;
        /// Required element 'tt:SampleRateRange' of XML schema type 'tt:IntItems'
        tt__IntItems *SampleRateRange;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__G711DecOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__G711DecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__G711DecOptions, default initialized and not managed by a soap context
        virtual tt__G711DecOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__G711DecOptions); }
      public:
        /// Constructor with default initializations
        tt__G711DecOptions() : Bitrate(), SampleRateRange(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__G711DecOptions() { }
        /// Friend allocator used by soap_new_tt__G711DecOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__G711DecOptions * SOAP_FMAC2 soap_instantiate_tt__G711DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:953 */
#ifndef SOAP_TYPE_tt__AACDecOptions
#define SOAP_TYPE_tt__AACDecOptions (384)
/* Type tt__AACDecOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AACDecOptions': */
class SOAP_CMAC tt__AACDecOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Bitrate' of XML schema type 'tt:IntItems'
        tt__IntItems *Bitrate;
        /// Required element 'tt:SampleRateRange' of XML schema type 'tt:IntItems'
        tt__IntItems *SampleRateRange;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AACDecOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AACDecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AACDecOptions, default initialized and not managed by a soap context
        virtual tt__AACDecOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AACDecOptions); }
      public:
        /// Constructor with default initializations
        tt__AACDecOptions() : Bitrate(), SampleRateRange(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AACDecOptions() { }
        /// Friend allocator used by soap_new_tt__AACDecOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AACDecOptions * SOAP_FMAC2 soap_instantiate_tt__AACDecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:955 */
#ifndef SOAP_TYPE_tt__G726DecOptions
#define SOAP_TYPE_tt__G726DecOptions (385)
/* Type tt__G726DecOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:G726DecOptions': */
class SOAP_CMAC tt__G726DecOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Bitrate' of XML schema type 'tt:IntItems'
        tt__IntItems *Bitrate;
        /// Required element 'tt:SampleRateRange' of XML schema type 'tt:IntItems'
        tt__IntItems *SampleRateRange;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__G726DecOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__G726DecOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__G726DecOptions, default initialized and not managed by a soap context
        virtual tt__G726DecOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__G726DecOptions); }
      public:
        /// Constructor with default initializations
        tt__G726DecOptions() : Bitrate(), SampleRateRange(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__G726DecOptions() { }
        /// Friend allocator used by soap_new_tt__G726DecOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__G726DecOptions * SOAP_FMAC2 soap_instantiate_tt__G726DecOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:957 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (386)
/* Type tt__AudioDecoderConfigurationOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioDecoderConfigurationOptionsExtension': */
class SOAP_CMAC tt__AudioDecoderConfigurationOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioDecoderConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual tt__AudioDecoderConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioDecoderConfigurationOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__AudioDecoderConfigurationOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__AudioDecoderConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__AudioDecoderConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioDecoderConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:959 */
#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (387)
/* Type tt__MulticastConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MulticastConfiguration': */
class SOAP_CMAC tt__MulticastConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:Address' of XML schema type 'tt:IPAddress'
        tt__IPAddress *Address;
        /// Required element 'tt:Port' of XML schema type 'xsd:int'
        int Port;
        /// Required element 'tt:TTL' of XML schema type 'xsd:int'
        int TTL;
        /// Required element 'tt:AutoStart' of XML schema type 'xsd:boolean'
        bool AutoStart;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MulticastConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MulticastConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MulticastConfiguration, default initialized and not managed by a soap context
        virtual tt__MulticastConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MulticastConfiguration); }
      public:
        /// Constructor with default initializations
        tt__MulticastConfiguration() : Address(), Port(), TTL(), AutoStart(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MulticastConfiguration() { }
        /// Friend allocator used by soap_new_tt__MulticastConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__MulticastConfiguration * SOAP_FMAC2 soap_instantiate_tt__MulticastConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:961 */
#ifndef SOAP_TYPE_tt__StreamSetup
#define SOAP_TYPE_tt__StreamSetup (388)
/* Type tt__StreamSetup is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:StreamSetup': */
class SOAP_CMAC tt__StreamSetup : public xsd__anyType {
      public:
        /// Required element 'tt:Stream' of XML schema type 'tt:StreamType'
        enum tt__StreamType Stream;
        /// Required element 'tt:Transport' of XML schema type 'tt:Transport'
        tt__Transport *Transport;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__StreamSetup
        virtual long soap_type(void) const { return SOAP_TYPE_tt__StreamSetup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__StreamSetup, default initialized and not managed by a soap context
        virtual tt__StreamSetup *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__StreamSetup); }
      public:
        /// Constructor with default initializations
        tt__StreamSetup() : Stream(), Transport(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__StreamSetup() { }
        /// Friend allocator used by soap_new_tt__StreamSetup(struct soap*, int)
        friend SOAP_FMAC1 tt__StreamSetup * SOAP_FMAC2 soap_instantiate_tt__StreamSetup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:963 */
#ifndef SOAP_TYPE_tt__Transport
#define SOAP_TYPE_tt__Transport (389)
/* Type tt__Transport is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Transport': */
class SOAP_CMAC tt__Transport : public xsd__anyType {
      public:
        /// Required element 'tt:Protocol' of XML schema type 'tt:TransportProtocol'
        enum tt__TransportProtocol Protocol;
        /// Optional element 'tt:Tunnel' of XML schema type 'tt:Transport'
        tt__Transport *Tunnel;
      public:
        /// Return unique type id SOAP_TYPE_tt__Transport
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Transport; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Transport, default initialized and not managed by a soap context
        virtual tt__Transport *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Transport); }
      public:
        /// Constructor with default initializations
        tt__Transport() : Protocol(), Tunnel() { }
        /// Destructor
        virtual ~tt__Transport() { }
        /// Friend allocator used by soap_new_tt__Transport(struct soap*, int)
        friend SOAP_FMAC1 tt__Transport * SOAP_FMAC2 soap_instantiate_tt__Transport(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:965 */
#ifndef SOAP_TYPE_tt__MediaUri
#define SOAP_TYPE_tt__MediaUri (390)
/* Type tt__MediaUri is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MediaUri': */
class SOAP_CMAC tt__MediaUri : public xsd__anyType {
      public:
        /// Required element 'tt:Uri' of XML schema type 'xsd:anyURI'
        std::string Uri;
        /// Required element 'tt:InvalidAfterConnect' of XML schema type 'xsd:boolean'
        bool InvalidAfterConnect;
        /// Required element 'tt:InvalidAfterReboot' of XML schema type 'xsd:boolean'
        bool InvalidAfterReboot;
        /// Required element 'tt:Timeout' of XML schema type 'xsd:duration'
        std::string Timeout;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MediaUri
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MediaUri; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MediaUri, default initialized and not managed by a soap context
        virtual tt__MediaUri *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MediaUri); }
      public:
        /// Constructor with default initializations
        tt__MediaUri() : Uri(), InvalidAfterConnect(), InvalidAfterReboot(), Timeout(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MediaUri() { }
        /// Friend allocator used by soap_new_tt__MediaUri(struct soap*, int)
        friend SOAP_FMAC1 tt__MediaUri * SOAP_FMAC2 soap_instantiate_tt__MediaUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:967 */
#ifndef SOAP_TYPE_tt__Scope
#define SOAP_TYPE_tt__Scope (391)
/* Type tt__Scope is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Scope': */
class SOAP_CMAC tt__Scope : public xsd__anyType {
      public:
        /// Required element 'tt:ScopeDef' of XML schema type 'tt:ScopeDefinition'
        enum tt__ScopeDefinition ScopeDef;
        /// Required element 'tt:ScopeItem' of XML schema type 'xsd:anyURI'
        std::string ScopeItem;
      public:
        /// Return unique type id SOAP_TYPE_tt__Scope
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Scope; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Scope, default initialized and not managed by a soap context
        virtual tt__Scope *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Scope); }
      public:
        /// Constructor with default initializations
        tt__Scope() : ScopeDef(), ScopeItem() { }
        /// Destructor
        virtual ~tt__Scope() { }
        /// Friend allocator used by soap_new_tt__Scope(struct soap*, int)
        friend SOAP_FMAC1 tt__Scope * SOAP_FMAC2 soap_instantiate_tt__Scope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:971 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension
#define SOAP_TYPE_tt__NetworkInterfaceExtension (393)
/* Type tt__NetworkInterfaceExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkInterfaceExtension': */
class SOAP_CMAC tt__NetworkInterfaceExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Required element 'tt:InterfaceType' of XML schema type 'tt:IANA-IfTypes'
        int InterfaceType;
        /// Optional element 'tt:Dot3' of XML schema type 'tt:Dot3Configuration'
        std::vector<tt__Dot3Configuration *> Dot3;
        /// Optional element 'tt:Dot11' of XML schema type 'tt:Dot11Configuration'
        std::vector<tt__Dot11Configuration *> Dot11;
        /// Optional element 'tt:Extension' of XML schema type 'tt:NetworkInterfaceExtension2'
        tt__NetworkInterfaceExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceExtension, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceExtension); }
      public:
        /// Constructor with default initializations
        tt__NetworkInterfaceExtension() : __any(), InterfaceType(), Dot3(), Dot11(), Extension() { }
        /// Destructor
        virtual ~tt__NetworkInterfaceExtension() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:973 */
#ifndef SOAP_TYPE_tt__Dot3Configuration
#define SOAP_TYPE_tt__Dot3Configuration (394)
/* Type tt__Dot3Configuration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Dot3Configuration': */
class SOAP_CMAC tt__Dot3Configuration : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot3Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot3Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot3Configuration, default initialized and not managed by a soap context
        virtual tt__Dot3Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot3Configuration); }
      public:
        /// Constructor with default initializations
        tt__Dot3Configuration() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Dot3Configuration() { }
        /// Friend allocator used by soap_new_tt__Dot3Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot3Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot3Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:975 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension2
#define SOAP_TYPE_tt__NetworkInterfaceExtension2 (395)
/* Type tt__NetworkInterfaceExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkInterfaceExtension2': */
class SOAP_CMAC tt__NetworkInterfaceExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceExtension2, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceExtension2); }
      public:
        /// Constructor with default initializations
        tt__NetworkInterfaceExtension2() : __any() { }
        /// Destructor
        virtual ~tt__NetworkInterfaceExtension2() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:977 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceLink
#define SOAP_TYPE_tt__NetworkInterfaceLink (396)
/* Type tt__NetworkInterfaceLink is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkInterfaceLink': */
class SOAP_CMAC tt__NetworkInterfaceLink : public xsd__anyType {
      public:
        /// Required element 'tt:AdminSettings' of XML schema type 'tt:NetworkInterfaceConnectionSetting'
        tt__NetworkInterfaceConnectionSetting *AdminSettings;
        /// Required element 'tt:OperSettings' of XML schema type 'tt:NetworkInterfaceConnectionSetting'
        tt__NetworkInterfaceConnectionSetting *OperSettings;
        /// Required element 'tt:InterfaceType' of XML schema type 'tt:IANA-IfTypes'
        int InterfaceType;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceLink
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceLink; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceLink, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceLink *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceLink); }
      public:
        /// Constructor with default initializations
        tt__NetworkInterfaceLink() : AdminSettings(), OperSettings(), InterfaceType() { }
        /// Destructor
        virtual ~tt__NetworkInterfaceLink() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceLink(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceLink * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceLink(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:979 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (397)
/* Type tt__NetworkInterfaceConnectionSetting is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkInterfaceConnectionSetting': */
class SOAP_CMAC tt__NetworkInterfaceConnectionSetting : public xsd__anyType {
      public:
        /// Required element 'tt:AutoNegotiation' of XML schema type 'xsd:boolean'
        bool AutoNegotiation;
        /// Required element 'tt:Speed' of XML schema type 'xsd:int'
        int Speed;
        /// Required element 'tt:Duplex' of XML schema type 'tt:Duplex'
        enum tt__Duplex Duplex;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceConnectionSetting; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceConnectionSetting, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceConnectionSetting *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceConnectionSetting); }
      public:
        /// Constructor with default initializations
        tt__NetworkInterfaceConnectionSetting() : AutoNegotiation(), Speed(), Duplex() { }
        /// Destructor
        virtual ~tt__NetworkInterfaceConnectionSetting() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceConnectionSetting(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceConnectionSetting * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceConnectionSetting(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:981 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceInfo
#define SOAP_TYPE_tt__NetworkInterfaceInfo (398)
/* Type tt__NetworkInterfaceInfo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkInterfaceInfo': */
class SOAP_CMAC tt__NetworkInterfaceInfo : public xsd__anyType {
      public:
        /// Optional element 'tt:Name' of XML schema type 'xsd:string'
        std::string *Name;
        /// Required element 'tt:HwAddress' of XML schema type 'tt:HwAddress'
        std::string HwAddress;
        /// Optional element 'tt:MTU' of XML schema type 'xsd:int'
        int *MTU;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceInfo
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceInfo, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceInfo); }
      public:
        /// Constructor with default initializations
        tt__NetworkInterfaceInfo() : Name(), HwAddress(), MTU() { }
        /// Destructor
        virtual ~tt__NetworkInterfaceInfo() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceInfo(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceInfo * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:983 */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterface
#define SOAP_TYPE_tt__IPv6NetworkInterface (399)
/* Type tt__IPv6NetworkInterface is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IPv6NetworkInterface': */
class SOAP_CMAC tt__IPv6NetworkInterface : public xsd__anyType {
      public:
        /// Required element 'tt:Enabled' of XML schema type 'xsd:boolean'
        bool Enabled;
        /// Optional element 'tt:Config' of XML schema type 'tt:IPv6Configuration'
        tt__IPv6Configuration *Config;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv6NetworkInterface
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv6NetworkInterface; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv6NetworkInterface, default initialized and not managed by a soap context
        virtual tt__IPv6NetworkInterface *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv6NetworkInterface); }
      public:
        /// Constructor with default initializations
        tt__IPv6NetworkInterface() : Enabled(), Config() { }
        /// Destructor
        virtual ~tt__IPv6NetworkInterface() { }
        /// Friend allocator used by soap_new_tt__IPv6NetworkInterface(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv6NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:985 */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterface
#define SOAP_TYPE_tt__IPv4NetworkInterface (400)
/* Type tt__IPv4NetworkInterface is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IPv4NetworkInterface': */
class SOAP_CMAC tt__IPv4NetworkInterface : public xsd__anyType {
      public:
        /// Required element 'tt:Enabled' of XML schema type 'xsd:boolean'
        bool Enabled;
        /// Required element 'tt:Config' of XML schema type 'tt:IPv4Configuration'
        tt__IPv4Configuration *Config;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv4NetworkInterface
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv4NetworkInterface; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv4NetworkInterface, default initialized and not managed by a soap context
        virtual tt__IPv4NetworkInterface *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv4NetworkInterface); }
      public:
        /// Constructor with default initializations
        tt__IPv4NetworkInterface() : Enabled(), Config() { }
        /// Destructor
        virtual ~tt__IPv4NetworkInterface() { }
        /// Friend allocator used by soap_new_tt__IPv4NetworkInterface(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv4NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:987 */
#ifndef SOAP_TYPE_tt__IPv4Configuration
#define SOAP_TYPE_tt__IPv4Configuration (401)
/* Type tt__IPv4Configuration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IPv4Configuration': */
class SOAP_CMAC tt__IPv4Configuration : public xsd__anyType {
      public:
        /// Optional element 'tt:Manual' of XML schema type 'tt:PrefixedIPv4Address'
        std::vector<tt__PrefixedIPv4Address *> Manual;
        /// Optional element 'tt:LinkLocal' of XML schema type 'tt:PrefixedIPv4Address'
        tt__PrefixedIPv4Address *LinkLocal;
        /// Optional element 'tt:FromDHCP' of XML schema type 'tt:PrefixedIPv4Address'
        tt__PrefixedIPv4Address *FromDHCP;
        /// Required element 'tt:DHCP' of XML schema type 'xsd:boolean'
        bool DHCP;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv4Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv4Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv4Configuration, default initialized and not managed by a soap context
        virtual tt__IPv4Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv4Configuration); }
      public:
        /// Constructor with default initializations
        tt__IPv4Configuration() : Manual(), LinkLocal(), FromDHCP(), DHCP(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__IPv4Configuration() { }
        /// Friend allocator used by soap_new_tt__IPv4Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv4Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv4Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:989 */
#ifndef SOAP_TYPE_tt__IPv6Configuration
#define SOAP_TYPE_tt__IPv6Configuration (402)
/* Type tt__IPv6Configuration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IPv6Configuration': */
class SOAP_CMAC tt__IPv6Configuration : public xsd__anyType {
      public:
        /// Optional element 'tt:AcceptRouterAdvert' of XML schema type 'xsd:boolean'
        bool *AcceptRouterAdvert;
        /// Required element 'tt:DHCP' of XML schema type 'tt:IPv6DHCPConfiguration'
        enum tt__IPv6DHCPConfiguration DHCP;
        /// Optional element 'tt:Manual' of XML schema type 'tt:PrefixedIPv6Address'
        std::vector<tt__PrefixedIPv6Address *> Manual;
        /// Optional element 'tt:LinkLocal' of XML schema type 'tt:PrefixedIPv6Address'
        std::vector<tt__PrefixedIPv6Address *> LinkLocal;
        /// Optional element 'tt:FromDHCP' of XML schema type 'tt:PrefixedIPv6Address'
        std::vector<tt__PrefixedIPv6Address *> FromDHCP;
        /// Optional element 'tt:FromRA' of XML schema type 'tt:PrefixedIPv6Address'
        std::vector<tt__PrefixedIPv6Address *> FromRA;
        /// Optional element 'tt:Extension' of XML schema type 'tt:IPv6ConfigurationExtension'
        tt__IPv6ConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv6Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv6Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv6Configuration, default initialized and not managed by a soap context
        virtual tt__IPv6Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv6Configuration); }
      public:
        /// Constructor with default initializations
        tt__IPv6Configuration() : AcceptRouterAdvert(), DHCP(), Manual(), LinkLocal(), FromDHCP(), FromRA(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__IPv6Configuration() { }
        /// Friend allocator used by soap_new_tt__IPv6Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv6Configuration * SOAP_FMAC2 soap_instantiate_tt__IPv6Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:991 */
#ifndef SOAP_TYPE_tt__IPv6ConfigurationExtension
#define SOAP_TYPE_tt__IPv6ConfigurationExtension (403)
/* Type tt__IPv6ConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IPv6ConfigurationExtension': */
class SOAP_CMAC tt__IPv6ConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv6ConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv6ConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv6ConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__IPv6ConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv6ConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__IPv6ConfigurationExtension() : __any() { }
        /// Destructor
        virtual ~tt__IPv6ConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__IPv6ConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv6ConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__IPv6ConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:993 */
#ifndef SOAP_TYPE_tt__NetworkProtocol
#define SOAP_TYPE_tt__NetworkProtocol (404)
/* Type tt__NetworkProtocol is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkProtocol': */
class SOAP_CMAC tt__NetworkProtocol : public xsd__anyType {
      public:
        /// Required element 'tt:Name' of XML schema type 'tt:NetworkProtocolType'
        enum tt__NetworkProtocolType Name;
        /// Required element 'tt:Enabled' of XML schema type 'xsd:boolean'
        bool Enabled;
        /// Required element 'tt:Port' of XML schema type 'xsd:int'
        std::vector<int> Port;
        /// Optional element 'tt:Extension' of XML schema type 'tt:NetworkProtocolExtension'
        tt__NetworkProtocolExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkProtocol
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkProtocol; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkProtocol, default initialized and not managed by a soap context
        virtual tt__NetworkProtocol *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkProtocol); }
      public:
        /// Constructor with default initializations
        tt__NetworkProtocol() : Name(), Enabled(), Port(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__NetworkProtocol() { }
        /// Friend allocator used by soap_new_tt__NetworkProtocol(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkProtocol * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocol(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:995 */
#ifndef SOAP_TYPE_tt__NetworkProtocolExtension
#define SOAP_TYPE_tt__NetworkProtocolExtension (405)
/* Type tt__NetworkProtocolExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkProtocolExtension': */
class SOAP_CMAC tt__NetworkProtocolExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkProtocolExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkProtocolExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkProtocolExtension, default initialized and not managed by a soap context
        virtual tt__NetworkProtocolExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkProtocolExtension); }
      public:
        /// Constructor with default initializations
        tt__NetworkProtocolExtension() : __any() { }
        /// Destructor
        virtual ~tt__NetworkProtocolExtension() { }
        /// Friend allocator used by soap_new_tt__NetworkProtocolExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkProtocolExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkProtocolExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:997 */
#ifndef SOAP_TYPE_tt__NetworkHost
#define SOAP_TYPE_tt__NetworkHost (406)
/* Type tt__NetworkHost is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkHost': */
class SOAP_CMAC tt__NetworkHost : public xsd__anyType {
      public:
        /// Required element 'tt:Type' of XML schema type 'tt:NetworkHostType'
        enum tt__NetworkHostType Type;
        /// Optional element 'tt:IPv4Address' of XML schema type 'tt:IPv4Address'
        std::string *IPv4Address;
        /// Optional element 'tt:IPv6Address' of XML schema type 'tt:IPv6Address'
        std::string *IPv6Address;
        /// Optional element 'tt:DNSname' of XML schema type 'tt:DNSName'
        std::string *DNSname;
        /// Optional element 'tt:Extension' of XML schema type 'tt:NetworkHostExtension'
        tt__NetworkHostExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkHost
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkHost; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkHost, default initialized and not managed by a soap context
        virtual tt__NetworkHost *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkHost); }
      public:
        /// Constructor with default initializations
        tt__NetworkHost() : Type(), IPv4Address(), IPv6Address(), DNSname(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__NetworkHost() { }
        /// Friend allocator used by soap_new_tt__NetworkHost(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkHost * SOAP_FMAC2 soap_instantiate_tt__NetworkHost(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:999 */
#ifndef SOAP_TYPE_tt__NetworkHostExtension
#define SOAP_TYPE_tt__NetworkHostExtension (407)
/* Type tt__NetworkHostExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkHostExtension': */
class SOAP_CMAC tt__NetworkHostExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkHostExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkHostExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkHostExtension, default initialized and not managed by a soap context
        virtual tt__NetworkHostExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkHostExtension); }
      public:
        /// Constructor with default initializations
        tt__NetworkHostExtension() : __any() { }
        /// Destructor
        virtual ~tt__NetworkHostExtension() { }
        /// Friend allocator used by soap_new_tt__NetworkHostExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkHostExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkHostExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1001 */
#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (408)
/* Type tt__IPAddress is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IPAddress': */
class SOAP_CMAC tt__IPAddress : public xsd__anyType {
      public:
        /// Required element 'tt:Type' of XML schema type 'tt:IPType'
        enum tt__IPType Type;
        /// Optional element 'tt:IPv4Address' of XML schema type 'tt:IPv4Address'
        std::string *IPv4Address;
        /// Optional element 'tt:IPv6Address' of XML schema type 'tt:IPv6Address'
        std::string *IPv6Address;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPAddress
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPAddress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPAddress, default initialized and not managed by a soap context
        virtual tt__IPAddress *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPAddress); }
      public:
        /// Constructor with default initializations
        tt__IPAddress() : Type(), IPv4Address(), IPv6Address() { }
        /// Destructor
        virtual ~tt__IPAddress() { }
        /// Friend allocator used by soap_new_tt__IPAddress(struct soap*, int)
        friend SOAP_FMAC1 tt__IPAddress * SOAP_FMAC2 soap_instantiate_tt__IPAddress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1003 */
#ifndef SOAP_TYPE_tt__PrefixedIPv4Address
#define SOAP_TYPE_tt__PrefixedIPv4Address (409)
/* Type tt__PrefixedIPv4Address is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PrefixedIPv4Address': */
class SOAP_CMAC tt__PrefixedIPv4Address : public xsd__anyType {
      public:
        /// Required element 'tt:Address' of XML schema type 'tt:IPv4Address'
        std::string Address;
        /// Required element 'tt:PrefixLength' of XML schema type 'xsd:int'
        int PrefixLength;
      public:
        /// Return unique type id SOAP_TYPE_tt__PrefixedIPv4Address
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PrefixedIPv4Address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PrefixedIPv4Address, default initialized and not managed by a soap context
        virtual tt__PrefixedIPv4Address *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PrefixedIPv4Address); }
      public:
        /// Constructor with default initializations
        tt__PrefixedIPv4Address() : Address(), PrefixLength() { }
        /// Destructor
        virtual ~tt__PrefixedIPv4Address() { }
        /// Friend allocator used by soap_new_tt__PrefixedIPv4Address(struct soap*, int)
        friend SOAP_FMAC1 tt__PrefixedIPv4Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv4Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1005 */
#ifndef SOAP_TYPE_tt__PrefixedIPv6Address
#define SOAP_TYPE_tt__PrefixedIPv6Address (410)
/* Type tt__PrefixedIPv6Address is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PrefixedIPv6Address': */
class SOAP_CMAC tt__PrefixedIPv6Address : public xsd__anyType {
      public:
        /// Required element 'tt:Address' of XML schema type 'tt:IPv6Address'
        std::string Address;
        /// Required element 'tt:PrefixLength' of XML schema type 'xsd:int'
        int PrefixLength;
      public:
        /// Return unique type id SOAP_TYPE_tt__PrefixedIPv6Address
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PrefixedIPv6Address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PrefixedIPv6Address, default initialized and not managed by a soap context
        virtual tt__PrefixedIPv6Address *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PrefixedIPv6Address); }
      public:
        /// Constructor with default initializations
        tt__PrefixedIPv6Address() : Address(), PrefixLength() { }
        /// Destructor
        virtual ~tt__PrefixedIPv6Address() { }
        /// Friend allocator used by soap_new_tt__PrefixedIPv6Address(struct soap*, int)
        friend SOAP_FMAC1 tt__PrefixedIPv6Address * SOAP_FMAC2 soap_instantiate_tt__PrefixedIPv6Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1007 */
#ifndef SOAP_TYPE_tt__HostnameInformation
#define SOAP_TYPE_tt__HostnameInformation (411)
/* Type tt__HostnameInformation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:HostnameInformation': */
class SOAP_CMAC tt__HostnameInformation : public xsd__anyType {
      public:
        /// Required element 'tt:FromDHCP' of XML schema type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'tt:Name' of XML schema type 'xsd:token'
        std::string *Name;
        /// Optional element 'tt:Extension' of XML schema type 'tt:HostnameInformationExtension'
        tt__HostnameInformationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__HostnameInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__HostnameInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__HostnameInformation, default initialized and not managed by a soap context
        virtual tt__HostnameInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__HostnameInformation); }
      public:
        /// Constructor with default initializations
        tt__HostnameInformation() : FromDHCP(), Name(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__HostnameInformation() { }
        /// Friend allocator used by soap_new_tt__HostnameInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__HostnameInformation * SOAP_FMAC2 soap_instantiate_tt__HostnameInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1009 */
#ifndef SOAP_TYPE_tt__HostnameInformationExtension
#define SOAP_TYPE_tt__HostnameInformationExtension (412)
/* Type tt__HostnameInformationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:HostnameInformationExtension': */
class SOAP_CMAC tt__HostnameInformationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__HostnameInformationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__HostnameInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__HostnameInformationExtension, default initialized and not managed by a soap context
        virtual tt__HostnameInformationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__HostnameInformationExtension); }
      public:
        /// Constructor with default initializations
        tt__HostnameInformationExtension() : __any() { }
        /// Destructor
        virtual ~tt__HostnameInformationExtension() { }
        /// Friend allocator used by soap_new_tt__HostnameInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__HostnameInformationExtension * SOAP_FMAC2 soap_instantiate_tt__HostnameInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1011 */
#ifndef SOAP_TYPE_tt__DNSInformation
#define SOAP_TYPE_tt__DNSInformation (413)
/* Type tt__DNSInformation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DNSInformation': */
class SOAP_CMAC tt__DNSInformation : public xsd__anyType {
      public:
        /// Required element 'tt:FromDHCP' of XML schema type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'tt:SearchDomain' of XML schema type 'xsd:token'
        std::vector<std::string> SearchDomain;
        /// Optional element 'tt:DNSFromDHCP' of XML schema type 'tt:IPAddress'
        std::vector<tt__IPAddress *> DNSFromDHCP;
        /// Optional element 'tt:DNSManual' of XML schema type 'tt:IPAddress'
        std::vector<tt__IPAddress *> DNSManual;
        /// Optional element 'tt:Extension' of XML schema type 'tt:DNSInformationExtension'
        tt__DNSInformationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__DNSInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DNSInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DNSInformation, default initialized and not managed by a soap context
        virtual tt__DNSInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DNSInformation); }
      public:
        /// Constructor with default initializations
        tt__DNSInformation() : FromDHCP(), SearchDomain(), DNSFromDHCP(), DNSManual(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__DNSInformation() { }
        /// Friend allocator used by soap_new_tt__DNSInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__DNSInformation * SOAP_FMAC2 soap_instantiate_tt__DNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1013 */
#ifndef SOAP_TYPE_tt__DNSInformationExtension
#define SOAP_TYPE_tt__DNSInformationExtension (414)
/* Type tt__DNSInformationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DNSInformationExtension': */
class SOAP_CMAC tt__DNSInformationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__DNSInformationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DNSInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DNSInformationExtension, default initialized and not managed by a soap context
        virtual tt__DNSInformationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DNSInformationExtension); }
      public:
        /// Constructor with default initializations
        tt__DNSInformationExtension() : __any() { }
        /// Destructor
        virtual ~tt__DNSInformationExtension() { }
        /// Friend allocator used by soap_new_tt__DNSInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__DNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1015 */
#ifndef SOAP_TYPE_tt__NTPInformation
#define SOAP_TYPE_tt__NTPInformation (415)
/* Type tt__NTPInformation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NTPInformation': */
class SOAP_CMAC tt__NTPInformation : public xsd__anyType {
      public:
        /// Required element 'tt:FromDHCP' of XML schema type 'xsd:boolean'
        bool FromDHCP;
        /// Optional element 'tt:NTPFromDHCP' of XML schema type 'tt:NetworkHost'
        std::vector<tt__NetworkHost *> NTPFromDHCP;
        /// Optional element 'tt:NTPManual' of XML schema type 'tt:NetworkHost'
        std::vector<tt__NetworkHost *> NTPManual;
        /// Optional element 'tt:Extension' of XML schema type 'tt:NTPInformationExtension'
        tt__NTPInformationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__NTPInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NTPInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NTPInformation, default initialized and not managed by a soap context
        virtual tt__NTPInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NTPInformation); }
      public:
        /// Constructor with default initializations
        tt__NTPInformation() : FromDHCP(), NTPFromDHCP(), NTPManual(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__NTPInformation() { }
        /// Friend allocator used by soap_new_tt__NTPInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__NTPInformation * SOAP_FMAC2 soap_instantiate_tt__NTPInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1017 */
#ifndef SOAP_TYPE_tt__NTPInformationExtension
#define SOAP_TYPE_tt__NTPInformationExtension (416)
/* Type tt__NTPInformationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NTPInformationExtension': */
class SOAP_CMAC tt__NTPInformationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__NTPInformationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NTPInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NTPInformationExtension, default initialized and not managed by a soap context
        virtual tt__NTPInformationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NTPInformationExtension); }
      public:
        /// Constructor with default initializations
        tt__NTPInformationExtension() : __any() { }
        /// Destructor
        virtual ~tt__NTPInformationExtension() { }
        /// Friend allocator used by soap_new_tt__NTPInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NTPInformationExtension * SOAP_FMAC2 soap_instantiate_tt__NTPInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1019 */
#ifndef SOAP_TYPE_tt__DynamicDNSInformation
#define SOAP_TYPE_tt__DynamicDNSInformation (417)
/* Type tt__DynamicDNSInformation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DynamicDNSInformation': */
class SOAP_CMAC tt__DynamicDNSInformation : public xsd__anyType {
      public:
        /// Required element 'tt:Type' of XML schema type 'tt:DynamicDNSType'
        enum tt__DynamicDNSType Type;
        /// Optional element 'tt:Name' of XML schema type 'tt:DNSName'
        std::string *Name;
        /// Optional element 'tt:TTL' of XML schema type 'xsd:duration'
        std::string *TTL;
        /// Optional element 'tt:Extension' of XML schema type 'tt:DynamicDNSInformationExtension'
        tt__DynamicDNSInformationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__DynamicDNSInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DynamicDNSInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DynamicDNSInformation, default initialized and not managed by a soap context
        virtual tt__DynamicDNSInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DynamicDNSInformation); }
      public:
        /// Constructor with default initializations
        tt__DynamicDNSInformation() : Type(), Name(), TTL(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__DynamicDNSInformation() { }
        /// Friend allocator used by soap_new_tt__DynamicDNSInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__DynamicDNSInformation * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1021 */
#ifndef SOAP_TYPE_tt__DynamicDNSInformationExtension
#define SOAP_TYPE_tt__DynamicDNSInformationExtension (418)
/* Type tt__DynamicDNSInformationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DynamicDNSInformationExtension': */
class SOAP_CMAC tt__DynamicDNSInformationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__DynamicDNSInformationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DynamicDNSInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DynamicDNSInformationExtension, default initialized and not managed by a soap context
        virtual tt__DynamicDNSInformationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DynamicDNSInformationExtension); }
      public:
        /// Constructor with default initializations
        tt__DynamicDNSInformationExtension() : __any() { }
        /// Destructor
        virtual ~tt__DynamicDNSInformationExtension() { }
        /// Friend allocator used by soap_new_tt__DynamicDNSInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__DynamicDNSInformationExtension * SOAP_FMAC2 soap_instantiate_tt__DynamicDNSInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1023 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (419)
/* Type tt__NetworkInterfaceSetConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkInterfaceSetConfiguration': */
class SOAP_CMAC tt__NetworkInterfaceSetConfiguration : public xsd__anyType {
      public:
        /// Optional element 'tt:Enabled' of XML schema type 'xsd:boolean'
        bool *Enabled;
        /// Optional element 'tt:Link' of XML schema type 'tt:NetworkInterfaceConnectionSetting'
        tt__NetworkInterfaceConnectionSetting *Link;
        /// Optional element 'tt:MTU' of XML schema type 'xsd:int'
        int *MTU;
        /// Optional element 'tt:IPv4' of XML schema type 'tt:IPv4NetworkInterfaceSetConfiguration'
        tt__IPv4NetworkInterfaceSetConfiguration *IPv4;
        /// Optional element 'tt:IPv6' of XML schema type 'tt:IPv6NetworkInterfaceSetConfiguration'
        tt__IPv6NetworkInterfaceSetConfiguration *IPv6;
        /// Optional element 'tt:Extension' of XML schema type 'tt:NetworkInterfaceSetConfigurationExtension'
        tt__NetworkInterfaceSetConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceSetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceSetConfiguration); }
      public:
        /// Constructor with default initializations
        tt__NetworkInterfaceSetConfiguration() : Enabled(), Link(), MTU(), IPv4(), IPv6(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__NetworkInterfaceSetConfiguration() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceSetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1025 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (420)
/* Type tt__NetworkInterfaceSetConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkInterfaceSetConfigurationExtension': */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:Dot3' of XML schema type 'tt:Dot3Configuration'
        std::vector<tt__Dot3Configuration *> Dot3;
        /// Optional element 'tt:Dot11' of XML schema type 'tt:Dot11Configuration'
        std::vector<tt__Dot11Configuration *> Dot11;
        /// Optional element 'tt:Extension' of XML schema type 'tt:NetworkInterfaceSetConfigurationExtension2'
        tt__NetworkInterfaceSetConfigurationExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceSetConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceSetConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceSetConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__NetworkInterfaceSetConfigurationExtension() : __any(), Dot3(), Dot11(), Extension() { }
        /// Destructor
        virtual ~tt__NetworkInterfaceSetConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceSetConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1027 */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (421)
/* Type tt__IPv6NetworkInterfaceSetConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IPv6NetworkInterfaceSetConfiguration': */
class SOAP_CMAC tt__IPv6NetworkInterfaceSetConfiguration : public xsd__anyType {
      public:
        /// Optional element 'tt:Enabled' of XML schema type 'xsd:boolean'
        bool *Enabled;
        /// Optional element 'tt:AcceptRouterAdvert' of XML schema type 'xsd:boolean'
        bool *AcceptRouterAdvert;
        /// Optional element 'tt:Manual' of XML schema type 'tt:PrefixedIPv6Address'
        std::vector<tt__PrefixedIPv6Address *> Manual;
        /// Optional element 'tt:DHCP' of XML schema type 'tt:IPv6DHCPConfiguration'
        enum tt__IPv6DHCPConfiguration *DHCP;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv6NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
        virtual tt__IPv6NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv6NetworkInterfaceSetConfiguration); }
      public:
        /// Constructor with default initializations
        tt__IPv6NetworkInterfaceSetConfiguration() : Enabled(), AcceptRouterAdvert(), Manual(), DHCP() { }
        /// Destructor
        virtual ~tt__IPv6NetworkInterfaceSetConfiguration() { }
        /// Friend allocator used by soap_new_tt__IPv6NetworkInterfaceSetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv6NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv6NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1029 */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (422)
/* Type tt__IPv4NetworkInterfaceSetConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IPv4NetworkInterfaceSetConfiguration': */
class SOAP_CMAC tt__IPv4NetworkInterfaceSetConfiguration : public xsd__anyType {
      public:
        /// Optional element 'tt:Enabled' of XML schema type 'xsd:boolean'
        bool *Enabled;
        /// Optional element 'tt:Manual' of XML schema type 'tt:PrefixedIPv4Address'
        std::vector<tt__PrefixedIPv4Address *> Manual;
        /// Optional element 'tt:DHCP' of XML schema type 'xsd:boolean'
        bool *DHCP;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPv4NetworkInterfaceSetConfiguration, default initialized and not managed by a soap context
        virtual tt__IPv4NetworkInterfaceSetConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPv4NetworkInterfaceSetConfiguration); }
      public:
        /// Constructor with default initializations
        tt__IPv4NetworkInterfaceSetConfiguration() : Enabled(), Manual(), DHCP() { }
        /// Destructor
        virtual ~tt__IPv4NetworkInterfaceSetConfiguration() { }
        /// Friend allocator used by soap_new_tt__IPv4NetworkInterfaceSetConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__IPv4NetworkInterfaceSetConfiguration * SOAP_FMAC2 soap_instantiate_tt__IPv4NetworkInterfaceSetConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1031 */
#ifndef SOAP_TYPE_tt__NetworkGateway
#define SOAP_TYPE_tt__NetworkGateway (423)
/* Type tt__NetworkGateway is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkGateway': */
class SOAP_CMAC tt__NetworkGateway : public xsd__anyType {
      public:
        /// Optional element 'tt:IPv4Address' of XML schema type 'tt:IPv4Address'
        std::vector<std::string> IPv4Address;
        /// Optional element 'tt:IPv6Address' of XML schema type 'tt:IPv6Address'
        std::vector<std::string> IPv6Address;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkGateway
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkGateway; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkGateway, default initialized and not managed by a soap context
        virtual tt__NetworkGateway *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkGateway); }
      public:
        /// Constructor with default initializations
        tt__NetworkGateway() : IPv4Address(), IPv6Address() { }
        /// Destructor
        virtual ~tt__NetworkGateway() { }
        /// Friend allocator used by soap_new_tt__NetworkGateway(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkGateway * SOAP_FMAC2 soap_instantiate_tt__NetworkGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1033 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfiguration
#define SOAP_TYPE_tt__NetworkZeroConfiguration (424)
/* Type tt__NetworkZeroConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkZeroConfiguration': */
class SOAP_CMAC tt__NetworkZeroConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:InterfaceToken' of XML schema type 'tt:ReferenceToken'
        std::string InterfaceToken;
        /// Required element 'tt:Enabled' of XML schema type 'xsd:boolean'
        bool Enabled;
        /// Optional element 'tt:Addresses' of XML schema type 'tt:IPv4Address'
        std::vector<std::string> Addresses;
        /// Optional element 'tt:Extension' of XML schema type 'tt:NetworkZeroConfigurationExtension'
        tt__NetworkZeroConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkZeroConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkZeroConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkZeroConfiguration, default initialized and not managed by a soap context
        virtual tt__NetworkZeroConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkZeroConfiguration); }
      public:
        /// Constructor with default initializations
        tt__NetworkZeroConfiguration() : InterfaceToken(), Enabled(), Addresses(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__NetworkZeroConfiguration() { }
        /// Friend allocator used by soap_new_tt__NetworkZeroConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkZeroConfiguration * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1035 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension (425)
/* Type tt__NetworkZeroConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkZeroConfigurationExtension': */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:Additional' of XML schema type 'tt:NetworkZeroConfiguration'
        std::vector<tt__NetworkZeroConfiguration *> Additional;
        /// Optional element 'tt:Extension' of XML schema type 'tt:NetworkZeroConfigurationExtension2'
        tt__NetworkZeroConfigurationExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkZeroConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkZeroConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkZeroConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__NetworkZeroConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkZeroConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__NetworkZeroConfigurationExtension() : __any(), Additional(), Extension() { }
        /// Destructor
        virtual ~tt__NetworkZeroConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__NetworkZeroConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkZeroConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1037 */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (426)
/* Type tt__NetworkZeroConfigurationExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkZeroConfigurationExtension2': */
class SOAP_CMAC tt__NetworkZeroConfigurationExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkZeroConfigurationExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkZeroConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkZeroConfigurationExtension2, default initialized and not managed by a soap context
        virtual tt__NetworkZeroConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkZeroConfigurationExtension2); }
      public:
        /// Constructor with default initializations
        tt__NetworkZeroConfigurationExtension2() : __any() { }
        /// Destructor
        virtual ~tt__NetworkZeroConfigurationExtension2() { }
        /// Friend allocator used by soap_new_tt__NetworkZeroConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkZeroConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkZeroConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1039 */
#ifndef SOAP_TYPE_tt__IPAddressFilter
#define SOAP_TYPE_tt__IPAddressFilter (427)
/* Type tt__IPAddressFilter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IPAddressFilter': */
class SOAP_CMAC tt__IPAddressFilter : public xsd__anyType {
      public:
        /// Required element 'tt:Type' of XML schema type 'tt:IPAddressFilterType'
        enum tt__IPAddressFilterType Type;
        /// Optional element 'tt:IPv4Address' of XML schema type 'tt:PrefixedIPv4Address'
        std::vector<tt__PrefixedIPv4Address *> IPv4Address;
        /// Optional element 'tt:IPv6Address' of XML schema type 'tt:PrefixedIPv6Address'
        std::vector<tt__PrefixedIPv6Address *> IPv6Address;
        /// Optional element 'tt:Extension' of XML schema type 'tt:IPAddressFilterExtension'
        tt__IPAddressFilterExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPAddressFilter
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPAddressFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPAddressFilter, default initialized and not managed by a soap context
        virtual tt__IPAddressFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPAddressFilter); }
      public:
        /// Constructor with default initializations
        tt__IPAddressFilter() : Type(), IPv4Address(), IPv6Address(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__IPAddressFilter() { }
        /// Friend allocator used by soap_new_tt__IPAddressFilter(struct soap*, int)
        friend SOAP_FMAC1 tt__IPAddressFilter * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1041 */
#ifndef SOAP_TYPE_tt__IPAddressFilterExtension
#define SOAP_TYPE_tt__IPAddressFilterExtension (428)
/* Type tt__IPAddressFilterExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IPAddressFilterExtension': */
class SOAP_CMAC tt__IPAddressFilterExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__IPAddressFilterExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IPAddressFilterExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IPAddressFilterExtension, default initialized and not managed by a soap context
        virtual tt__IPAddressFilterExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IPAddressFilterExtension); }
      public:
        /// Constructor with default initializations
        tt__IPAddressFilterExtension() : __any() { }
        /// Destructor
        virtual ~tt__IPAddressFilterExtension() { }
        /// Friend allocator used by soap_new_tt__IPAddressFilterExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__IPAddressFilterExtension * SOAP_FMAC2 soap_instantiate_tt__IPAddressFilterExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1043 */
#ifndef SOAP_TYPE_tt__Dot11Configuration
#define SOAP_TYPE_tt__Dot11Configuration (429)
/* Type tt__Dot11Configuration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Dot11Configuration': */
class SOAP_CMAC tt__Dot11Configuration : public xsd__anyType {
      public:
        /// Required element 'tt:SSID' of XML schema type 'tt:Dot11SSIDType'
        xsd__hexBinary SSID;
        /// Required element 'tt:Mode' of XML schema type 'tt:Dot11StationMode'
        enum tt__Dot11StationMode Mode;
        /// Required element 'tt:Alias' of XML schema type 'tt:Name'
        std::string Alias;
        /// Required element 'tt:Priority' of XML schema type 'tt:NetworkInterfaceConfigPriority'
        std::string Priority;
        /// Required element 'tt:Security' of XML schema type 'tt:Dot11SecurityConfiguration'
        tt__Dot11SecurityConfiguration *Security;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11Configuration, default initialized and not managed by a soap context
        virtual tt__Dot11Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11Configuration); }
      public:
        /// Constructor with default initializations
        tt__Dot11Configuration() : SSID(), Mode(), Alias(), Priority(), Security(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Dot11Configuration() { }
        /// Friend allocator used by soap_new_tt__Dot11Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11Configuration * SOAP_FMAC2 soap_instantiate_tt__Dot11Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1045 */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfiguration
#define SOAP_TYPE_tt__Dot11SecurityConfiguration (430)
/* Type tt__Dot11SecurityConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Dot11SecurityConfiguration': */
class SOAP_CMAC tt__Dot11SecurityConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:Dot11SecurityMode'
        enum tt__Dot11SecurityMode Mode;
        /// Optional element 'tt:Algorithm' of XML schema type 'tt:Dot11Cipher'
        enum tt__Dot11Cipher *Algorithm;
        /// Optional element 'tt:PSK' of XML schema type 'tt:Dot11PSKSet'
        tt__Dot11PSKSet *PSK;
        /// Optional element 'tt:Dot1X' of XML schema type 'tt:ReferenceToken'
        std::string *Dot1X;
        /// Optional element 'tt:Extension' of XML schema type 'tt:Dot11SecurityConfigurationExtension'
        tt__Dot11SecurityConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11SecurityConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11SecurityConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11SecurityConfiguration, default initialized and not managed by a soap context
        virtual tt__Dot11SecurityConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11SecurityConfiguration); }
      public:
        /// Constructor with default initializations
        tt__Dot11SecurityConfiguration() : Mode(), Algorithm(), PSK(), Dot1X(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Dot11SecurityConfiguration() { }
        /// Friend allocator used by soap_new_tt__Dot11SecurityConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11SecurityConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1047 */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (431)
/* Type tt__Dot11SecurityConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Dot11SecurityConfigurationExtension': */
class SOAP_CMAC tt__Dot11SecurityConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11SecurityConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11SecurityConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11SecurityConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__Dot11SecurityConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11SecurityConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__Dot11SecurityConfigurationExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Dot11SecurityConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__Dot11SecurityConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11SecurityConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11SecurityConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1049 */
#ifndef SOAP_TYPE_tt__Dot11PSKSet
#define SOAP_TYPE_tt__Dot11PSKSet (432)
/* Type tt__Dot11PSKSet is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Dot11PSKSet': */
class SOAP_CMAC tt__Dot11PSKSet : public xsd__anyType {
      public:
        /// Optional element 'tt:Key' of XML schema type 'tt:Dot11PSK'
        xsd__hexBinary *Key;
        /// Optional element 'tt:Passphrase' of XML schema type 'tt:Dot11PSKPassphrase'
        std::string *Passphrase;
        /// Optional element 'tt:Extension' of XML schema type 'tt:Dot11PSKSetExtension'
        tt__Dot11PSKSetExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11PSKSet
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11PSKSet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11PSKSet, default initialized and not managed by a soap context
        virtual tt__Dot11PSKSet *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11PSKSet); }
      public:
        /// Constructor with default initializations
        tt__Dot11PSKSet() : Key(), Passphrase(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Dot11PSKSet() { }
        /// Friend allocator used by soap_new_tt__Dot11PSKSet(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11PSKSet * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1051 */
#ifndef SOAP_TYPE_tt__Dot11PSKSetExtension
#define SOAP_TYPE_tt__Dot11PSKSetExtension (433)
/* Type tt__Dot11PSKSetExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Dot11PSKSetExtension': */
class SOAP_CMAC tt__Dot11PSKSetExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11PSKSetExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11PSKSetExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11PSKSetExtension, default initialized and not managed by a soap context
        virtual tt__Dot11PSKSetExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11PSKSetExtension); }
      public:
        /// Constructor with default initializations
        tt__Dot11PSKSetExtension() : __any() { }
        /// Destructor
        virtual ~tt__Dot11PSKSetExtension() { }
        /// Friend allocator used by soap_new_tt__Dot11PSKSetExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11PSKSetExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11PSKSetExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1053 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (434)
/* Type tt__NetworkInterfaceSetConfigurationExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkInterfaceSetConfigurationExtension2': */
class SOAP_CMAC tt__NetworkInterfaceSetConfigurationExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterfaceSetConfigurationExtension2, default initialized and not managed by a soap context
        virtual tt__NetworkInterfaceSetConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterfaceSetConfigurationExtension2); }
      public:
        /// Constructor with default initializations
        tt__NetworkInterfaceSetConfigurationExtension2() : __any() { }
        /// Destructor
        virtual ~tt__NetworkInterfaceSetConfigurationExtension2() { }
        /// Friend allocator used by soap_new_tt__NetworkInterfaceSetConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterfaceSetConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkInterfaceSetConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1055 */
#ifndef SOAP_TYPE_tt__Dot11Capabilities
#define SOAP_TYPE_tt__Dot11Capabilities (435)
/* Type tt__Dot11Capabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Dot11Capabilities': */
class SOAP_CMAC tt__Dot11Capabilities : public xsd__anyType {
      public:
        /// Required element 'tt:TKIP' of XML schema type 'xsd:boolean'
        bool TKIP;
        /// Required element 'tt:ScanAvailableNetworks' of XML schema type 'xsd:boolean'
        bool ScanAvailableNetworks;
        /// Required element 'tt:MultipleConfiguration' of XML schema type 'xsd:boolean'
        bool MultipleConfiguration;
        /// Required element 'tt:AdHocStationMode' of XML schema type 'xsd:boolean'
        bool AdHocStationMode;
        /// Required element 'tt:WEP' of XML schema type 'xsd:boolean'
        bool WEP;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11Capabilities, default initialized and not managed by a soap context
        virtual tt__Dot11Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11Capabilities); }
      public:
        /// Constructor with default initializations
        tt__Dot11Capabilities() : TKIP(), ScanAvailableNetworks(), MultipleConfiguration(), AdHocStationMode(), WEP(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Dot11Capabilities() { }
        /// Friend allocator used by soap_new_tt__Dot11Capabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11Capabilities * SOAP_FMAC2 soap_instantiate_tt__Dot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1057 */
#ifndef SOAP_TYPE_tt__Dot11Status
#define SOAP_TYPE_tt__Dot11Status (436)
/* Type tt__Dot11Status is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Dot11Status': */
class SOAP_CMAC tt__Dot11Status : public xsd__anyType {
      public:
        /// Required element 'tt:SSID' of XML schema type 'tt:Dot11SSIDType'
        xsd__hexBinary SSID;
        /// Optional element 'tt:BSSID' of XML schema type 'xsd:string'
        std::string *BSSID;
        /// Optional element 'tt:PairCipher' of XML schema type 'tt:Dot11Cipher'
        enum tt__Dot11Cipher *PairCipher;
        /// Optional element 'tt:GroupCipher' of XML schema type 'tt:Dot11Cipher'
        enum tt__Dot11Cipher *GroupCipher;
        /// Optional element 'tt:SignalStrength' of XML schema type 'tt:Dot11SignalStrength'
        enum tt__Dot11SignalStrength *SignalStrength;
        /// Required element 'tt:ActiveConfigAlias' of XML schema type 'tt:ReferenceToken'
        std::string ActiveConfigAlias;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11Status
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11Status; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11Status, default initialized and not managed by a soap context
        virtual tt__Dot11Status *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11Status); }
      public:
        /// Constructor with default initializations
        tt__Dot11Status() : SSID(), BSSID(), PairCipher(), GroupCipher(), SignalStrength(), ActiveConfigAlias(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Dot11Status() { }
        /// Friend allocator used by soap_new_tt__Dot11Status(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11Status * SOAP_FMAC2 soap_instantiate_tt__Dot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1059 */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworks
#define SOAP_TYPE_tt__Dot11AvailableNetworks (437)
/* Type tt__Dot11AvailableNetworks is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Dot11AvailableNetworks': */
class SOAP_CMAC tt__Dot11AvailableNetworks : public xsd__anyType {
      public:
        /// Required element 'tt:SSID' of XML schema type 'tt:Dot11SSIDType'
        xsd__hexBinary SSID;
        /// Optional element 'tt:BSSID' of XML schema type 'xsd:string'
        std::string *BSSID;
        /// Optional element 'tt:AuthAndMangementSuite' of XML schema type 'tt:Dot11AuthAndMangementSuite'
        std::vector<enum tt__Dot11AuthAndMangementSuite> AuthAndMangementSuite;
        /// Optional element 'tt:PairCipher' of XML schema type 'tt:Dot11Cipher'
        std::vector<enum tt__Dot11Cipher> PairCipher;
        /// Optional element 'tt:GroupCipher' of XML schema type 'tt:Dot11Cipher'
        std::vector<enum tt__Dot11Cipher> GroupCipher;
        /// Optional element 'tt:SignalStrength' of XML schema type 'tt:Dot11SignalStrength'
        enum tt__Dot11SignalStrength *SignalStrength;
        /// Optional element 'tt:Extension' of XML schema type 'tt:Dot11AvailableNetworksExtension'
        tt__Dot11AvailableNetworksExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11AvailableNetworks
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11AvailableNetworks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11AvailableNetworks, default initialized and not managed by a soap context
        virtual tt__Dot11AvailableNetworks *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11AvailableNetworks); }
      public:
        /// Constructor with default initializations
        tt__Dot11AvailableNetworks() : SSID(), BSSID(), AuthAndMangementSuite(), PairCipher(), GroupCipher(), SignalStrength(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Dot11AvailableNetworks() { }
        /// Friend allocator used by soap_new_tt__Dot11AvailableNetworks(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11AvailableNetworks * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1061 */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworksExtension
#define SOAP_TYPE_tt__Dot11AvailableNetworksExtension (438)
/* Type tt__Dot11AvailableNetworksExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Dot11AvailableNetworksExtension': */
class SOAP_CMAC tt__Dot11AvailableNetworksExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot11AvailableNetworksExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot11AvailableNetworksExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot11AvailableNetworksExtension, default initialized and not managed by a soap context
        virtual tt__Dot11AvailableNetworksExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot11AvailableNetworksExtension); }
      public:
        /// Constructor with default initializations
        tt__Dot11AvailableNetworksExtension() : __any() { }
        /// Destructor
        virtual ~tt__Dot11AvailableNetworksExtension() { }
        /// Friend allocator used by soap_new_tt__Dot11AvailableNetworksExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot11AvailableNetworksExtension * SOAP_FMAC2 soap_instantiate_tt__Dot11AvailableNetworksExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1063 */
#ifndef SOAP_TYPE_tt__Capabilities
#define SOAP_TYPE_tt__Capabilities (439)
/* Type tt__Capabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Capabilities': */
class SOAP_CMAC tt__Capabilities : public xsd__anyType {
      public:
        /// Optional element 'tt:Analytics' of XML schema type 'tt:AnalyticsCapabilities'
        tt__AnalyticsCapabilities *Analytics;
        /// Optional element 'tt:Device' of XML schema type 'tt:DeviceCapabilities'
        tt__DeviceCapabilities *Device;
        /// Optional element 'tt:Events' of XML schema type 'tt:EventCapabilities'
        tt__EventCapabilities *Events;
        /// Optional element 'tt:Imaging' of XML schema type 'tt:ImagingCapabilities'
        tt__ImagingCapabilities *Imaging;
        /// Optional element 'tt:Media' of XML schema type 'tt:MediaCapabilities'
        tt__MediaCapabilities *Media;
        /// Optional element 'tt:PTZ' of XML schema type 'tt:PTZCapabilities'
        tt__PTZCapabilities *PTZ;
        /// Optional element 'tt:Extension' of XML schema type 'tt:CapabilitiesExtension'
        tt__CapabilitiesExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Capabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Capabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Capabilities, default initialized and not managed by a soap context
        virtual tt__Capabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Capabilities); }
      public:
        /// Constructor with default initializations
        tt__Capabilities() : Analytics(), Device(), Events(), Imaging(), Media(), PTZ(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Capabilities() { }
        /// Friend allocator used by soap_new_tt__Capabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__Capabilities * SOAP_FMAC2 soap_instantiate_tt__Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1065 */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension
#define SOAP_TYPE_tt__CapabilitiesExtension (440)
/* Type tt__CapabilitiesExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:CapabilitiesExtension': */
class SOAP_CMAC tt__CapabilitiesExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:DeviceIO' of XML schema type 'tt:DeviceIOCapabilities'
        tt__DeviceIOCapabilities *DeviceIO;
        /// Optional element 'tt:Display' of XML schema type 'tt:DisplayCapabilities'
        tt__DisplayCapabilities *Display;
        /// Optional element 'tt:Recording' of XML schema type 'tt:RecordingCapabilities'
        tt__RecordingCapabilities *Recording;
        /// Optional element 'tt:Search' of XML schema type 'tt:SearchCapabilities'
        tt__SearchCapabilities *Search;
        /// Optional element 'tt:Replay' of XML schema type 'tt:ReplayCapabilities'
        tt__ReplayCapabilities *Replay;
        /// Optional element 'tt:Receiver' of XML schema type 'tt:ReceiverCapabilities'
        tt__ReceiverCapabilities *Receiver;
        /// Optional element 'tt:AnalyticsDevice' of XML schema type 'tt:AnalyticsDeviceCapabilities'
        tt__AnalyticsDeviceCapabilities *AnalyticsDevice;
        /// Optional element 'tt:Extensions' of XML schema type 'tt:CapabilitiesExtension2'
        tt__CapabilitiesExtension2 *Extensions;
      public:
        /// Return unique type id SOAP_TYPE_tt__CapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__CapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CapabilitiesExtension); }
      public:
        /// Constructor with default initializations
        tt__CapabilitiesExtension() : __any(), DeviceIO(), Display(), Recording(), Search(), Replay(), Receiver(), AnalyticsDevice(), Extensions() { }
        /// Destructor
        virtual ~tt__CapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__CapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__CapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1067 */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension2
#define SOAP_TYPE_tt__CapabilitiesExtension2 (441)
/* Type tt__CapabilitiesExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:CapabilitiesExtension2': */
class SOAP_CMAC tt__CapabilitiesExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__CapabilitiesExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CapabilitiesExtension2, default initialized and not managed by a soap context
        virtual tt__CapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CapabilitiesExtension2); }
      public:
        /// Constructor with default initializations
        tt__CapabilitiesExtension2() : __any() { }
        /// Destructor
        virtual ~tt__CapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_tt__CapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__CapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__CapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1069 */
#ifndef SOAP_TYPE_tt__AnalyticsCapabilities
#define SOAP_TYPE_tt__AnalyticsCapabilities (442)
/* Type tt__AnalyticsCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsCapabilities': */
class SOAP_CMAC tt__AnalyticsCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:RuleSupport' of XML schema type 'xsd:boolean'
        bool RuleSupport;
        /// Required element 'tt:AnalyticsModuleSupport' of XML schema type 'xsd:boolean'
        bool AnalyticsModuleSupport;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsCapabilities, default initialized and not managed by a soap context
        virtual tt__AnalyticsCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsCapabilities); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsCapabilities() : XAddr(), RuleSupport(), AnalyticsModuleSupport(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AnalyticsCapabilities() { }
        /// Friend allocator used by soap_new_tt__AnalyticsCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1071 */
#ifndef SOAP_TYPE_tt__DeviceCapabilities
#define SOAP_TYPE_tt__DeviceCapabilities (443)
/* Type tt__DeviceCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DeviceCapabilities': */
class SOAP_CMAC tt__DeviceCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        /// Optional element 'tt:Network' of XML schema type 'tt:NetworkCapabilities'
        tt__NetworkCapabilities *Network;
        /// Optional element 'tt:System' of XML schema type 'tt:SystemCapabilities'
        tt__SystemCapabilities *System;
        /// Optional element 'tt:IO' of XML schema type 'tt:IOCapabilities'
        tt__IOCapabilities *IO;
        /// Optional element 'tt:Security' of XML schema type 'tt:SecurityCapabilities'
        tt__SecurityCapabilities *Security;
        /// Optional element 'tt:Extension' of XML schema type 'tt:DeviceCapabilitiesExtension'
        tt__DeviceCapabilitiesExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__DeviceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DeviceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DeviceCapabilities, default initialized and not managed by a soap context
        virtual tt__DeviceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DeviceCapabilities); }
      public:
        /// Constructor with default initializations
        tt__DeviceCapabilities() : XAddr(), Network(), System(), IO(), Security(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__DeviceCapabilities() { }
        /// Friend allocator used by soap_new_tt__DeviceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__DeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1073 */
#ifndef SOAP_TYPE_tt__DeviceCapabilitiesExtension
#define SOAP_TYPE_tt__DeviceCapabilitiesExtension (444)
/* Type tt__DeviceCapabilitiesExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DeviceCapabilitiesExtension': */
class SOAP_CMAC tt__DeviceCapabilitiesExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__DeviceCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DeviceCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DeviceCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__DeviceCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DeviceCapabilitiesExtension); }
      public:
        /// Constructor with default initializations
        tt__DeviceCapabilitiesExtension() : __any() { }
        /// Destructor
        virtual ~tt__DeviceCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__DeviceCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__DeviceCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__DeviceCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1075 */
#ifndef SOAP_TYPE_tt__EventCapabilities
#define SOAP_TYPE_tt__EventCapabilities (445)
/* Type tt__EventCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:EventCapabilities': */
class SOAP_CMAC tt__EventCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:WSSubscriptionPolicySupport' of XML schema type 'xsd:boolean'
        bool WSSubscriptionPolicySupport;
        /// Required element 'tt:WSPullPointSupport' of XML schema type 'xsd:boolean'
        bool WSPullPointSupport;
        /// Required element 'tt:WSPausableSubscriptionManagerInterfaceSupport' of XML schema type 'xsd:boolean'
        bool WSPausableSubscriptionManagerInterfaceSupport;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__EventCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EventCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EventCapabilities, default initialized and not managed by a soap context
        virtual tt__EventCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EventCapabilities); }
      public:
        /// Constructor with default initializations
        tt__EventCapabilities() : XAddr(), WSSubscriptionPolicySupport(), WSPullPointSupport(), WSPausableSubscriptionManagerInterfaceSupport(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__EventCapabilities() { }
        /// Friend allocator used by soap_new_tt__EventCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__EventCapabilities * SOAP_FMAC2 soap_instantiate_tt__EventCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1077 */
#ifndef SOAP_TYPE_tt__IOCapabilities
#define SOAP_TYPE_tt__IOCapabilities (446)
/* Type tt__IOCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IOCapabilities': */
class SOAP_CMAC tt__IOCapabilities : public xsd__anyType {
      public:
        /// Optional element 'tt:InputConnectors' of XML schema type 'xsd:int'
        int *InputConnectors;
        /// Optional element 'tt:RelayOutputs' of XML schema type 'xsd:int'
        int *RelayOutputs;
        /// Optional element 'tt:Extension' of XML schema type 'tt:IOCapabilitiesExtension'
        tt__IOCapabilitiesExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__IOCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IOCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IOCapabilities, default initialized and not managed by a soap context
        virtual tt__IOCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IOCapabilities); }
      public:
        /// Constructor with default initializations
        tt__IOCapabilities() : InputConnectors(), RelayOutputs(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__IOCapabilities() { }
        /// Friend allocator used by soap_new_tt__IOCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__IOCapabilities * SOAP_FMAC2 soap_instantiate_tt__IOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1079 */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension
#define SOAP_TYPE_tt__IOCapabilitiesExtension (447)
/* Type tt__IOCapabilitiesExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IOCapabilitiesExtension': */
class SOAP_CMAC tt__IOCapabilitiesExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:Auxiliary' of XML schema type 'xsd:boolean'
        bool *Auxiliary;
        /// Optional element 'tt:AuxiliaryCommands' of XML schema type 'tt:AuxiliaryData'
        std::vector<std::string> AuxiliaryCommands;
        /// Required element 'tt:Extension' of XML schema type 'tt:IOCapabilitiesExtension2'
        tt__IOCapabilitiesExtension2 *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__IOCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IOCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IOCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__IOCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IOCapabilitiesExtension); }
      public:
        /// Constructor with default initializations
        tt__IOCapabilitiesExtension() : __any(), Auxiliary(), AuxiliaryCommands(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__IOCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__IOCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__IOCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1081 */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension2
#define SOAP_TYPE_tt__IOCapabilitiesExtension2 (448)
/* Type tt__IOCapabilitiesExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IOCapabilitiesExtension2': */
class SOAP_CMAC tt__IOCapabilitiesExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__IOCapabilitiesExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IOCapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IOCapabilitiesExtension2, default initialized and not managed by a soap context
        virtual tt__IOCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IOCapabilitiesExtension2); }
      public:
        /// Constructor with default initializations
        tt__IOCapabilitiesExtension2() : __any() { }
        /// Destructor
        virtual ~tt__IOCapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_tt__IOCapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__IOCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__IOCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1083 */
#ifndef SOAP_TYPE_tt__MediaCapabilities
#define SOAP_TYPE_tt__MediaCapabilities (449)
/* Type tt__MediaCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MediaCapabilities': */
class SOAP_CMAC tt__MediaCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:StreamingCapabilities' of XML schema type 'tt:RealTimeStreamingCapabilities'
        tt__RealTimeStreamingCapabilities *StreamingCapabilities;
        std::vector<char *> __any;
        /// Optional element 'tt:Extension' of XML schema type 'tt:MediaCapabilitiesExtension'
        tt__MediaCapabilitiesExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MediaCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MediaCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MediaCapabilities, default initialized and not managed by a soap context
        virtual tt__MediaCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MediaCapabilities); }
      public:
        /// Constructor with default initializations
        tt__MediaCapabilities() : XAddr(), StreamingCapabilities(), __any(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MediaCapabilities() { }
        /// Friend allocator used by soap_new_tt__MediaCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__MediaCapabilities * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1085 */
#ifndef SOAP_TYPE_tt__MediaCapabilitiesExtension
#define SOAP_TYPE_tt__MediaCapabilitiesExtension (450)
/* Type tt__MediaCapabilitiesExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MediaCapabilitiesExtension': */
class SOAP_CMAC tt__MediaCapabilitiesExtension : public xsd__anyType {
      public:
        /// Required element 'tt:ProfileCapabilities' of XML schema type 'tt:ProfileCapabilities'
        tt__ProfileCapabilities *ProfileCapabilities;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MediaCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MediaCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MediaCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__MediaCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MediaCapabilitiesExtension); }
      public:
        /// Constructor with default initializations
        tt__MediaCapabilitiesExtension() : ProfileCapabilities(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MediaCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__MediaCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__MediaCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__MediaCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1087 */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilities
#define SOAP_TYPE_tt__RealTimeStreamingCapabilities (451)
/* Type tt__RealTimeStreamingCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RealTimeStreamingCapabilities': */
class SOAP_CMAC tt__RealTimeStreamingCapabilities : public xsd__anyType {
      public:
        /// Optional element 'tt:RTPMulticast' of XML schema type 'xsd:boolean'
        bool *RTPMulticast;
        /// Optional element 'tt:RTP_TCP' of XML schema type 'xsd:boolean'
        bool *RTP_USCORETCP;
        /// Optional element 'tt:RTP_RTSP_TCP' of XML schema type 'xsd:boolean'
        bool *RTP_USCORERTSP_USCORETCP;
        /// Optional element 'tt:Extension' of XML schema type 'tt:RealTimeStreamingCapabilitiesExtension'
        tt__RealTimeStreamingCapabilitiesExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RealTimeStreamingCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RealTimeStreamingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RealTimeStreamingCapabilities, default initialized and not managed by a soap context
        virtual tt__RealTimeStreamingCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RealTimeStreamingCapabilities); }
      public:
        /// Constructor with default initializations
        tt__RealTimeStreamingCapabilities() : RTPMulticast(), RTP_USCORETCP(), RTP_USCORERTSP_USCORETCP(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RealTimeStreamingCapabilities() { }
        /// Friend allocator used by soap_new_tt__RealTimeStreamingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__RealTimeStreamingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1089 */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (452)
/* Type tt__RealTimeStreamingCapabilitiesExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RealTimeStreamingCapabilitiesExtension': */
class SOAP_CMAC tt__RealTimeStreamingCapabilitiesExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RealTimeStreamingCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__RealTimeStreamingCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RealTimeStreamingCapabilitiesExtension); }
      public:
        /// Constructor with default initializations
        tt__RealTimeStreamingCapabilitiesExtension() : __any() { }
        /// Destructor
        virtual ~tt__RealTimeStreamingCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__RealTimeStreamingCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RealTimeStreamingCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__RealTimeStreamingCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1091 */
#ifndef SOAP_TYPE_tt__ProfileCapabilities
#define SOAP_TYPE_tt__ProfileCapabilities (453)
/* Type tt__ProfileCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ProfileCapabilities': */
class SOAP_CMAC tt__ProfileCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:MaximumNumberOfProfiles' of XML schema type 'xsd:int'
        int MaximumNumberOfProfiles;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ProfileCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ProfileCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ProfileCapabilities, default initialized and not managed by a soap context
        virtual tt__ProfileCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ProfileCapabilities); }
      public:
        /// Constructor with default initializations
        tt__ProfileCapabilities() : MaximumNumberOfProfiles(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ProfileCapabilities() { }
        /// Friend allocator used by soap_new_tt__ProfileCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__ProfileCapabilities * SOAP_FMAC2 soap_instantiate_tt__ProfileCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1093 */
#ifndef SOAP_TYPE_tt__NetworkCapabilities
#define SOAP_TYPE_tt__NetworkCapabilities (454)
/* Type tt__NetworkCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkCapabilities': */
class SOAP_CMAC tt__NetworkCapabilities : public xsd__anyType {
      public:
        /// Optional element 'tt:IPFilter' of XML schema type 'xsd:boolean'
        bool *IPFilter;
        /// Optional element 'tt:ZeroConfiguration' of XML schema type 'xsd:boolean'
        bool *ZeroConfiguration;
        /// Optional element 'tt:IPVersion6' of XML schema type 'xsd:boolean'
        bool *IPVersion6;
        /// Optional element 'tt:DynDNS' of XML schema type 'xsd:boolean'
        bool *DynDNS;
        /// Optional element 'tt:Extension' of XML schema type 'tt:NetworkCapabilitiesExtension'
        tt__NetworkCapabilitiesExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkCapabilities, default initialized and not managed by a soap context
        virtual tt__NetworkCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkCapabilities); }
      public:
        /// Constructor with default initializations
        tt__NetworkCapabilities() : IPFilter(), ZeroConfiguration(), IPVersion6(), DynDNS(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__NetworkCapabilities() { }
        /// Friend allocator used by soap_new_tt__NetworkCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkCapabilities * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1095 */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension (455)
/* Type tt__NetworkCapabilitiesExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkCapabilitiesExtension': */
class SOAP_CMAC tt__NetworkCapabilitiesExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:Dot11Configuration' of XML schema type 'xsd:boolean'
        bool *Dot11Configuration;
        /// Optional element 'tt:Extension' of XML schema type 'tt:NetworkCapabilitiesExtension2'
        tt__NetworkCapabilitiesExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__NetworkCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkCapabilitiesExtension); }
      public:
        /// Constructor with default initializations
        tt__NetworkCapabilitiesExtension() : __any(), Dot11Configuration(), Extension() { }
        /// Destructor
        virtual ~tt__NetworkCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__NetworkCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1097 */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension2
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (456)
/* Type tt__NetworkCapabilitiesExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkCapabilitiesExtension2': */
class SOAP_CMAC tt__NetworkCapabilitiesExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkCapabilitiesExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkCapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkCapabilitiesExtension2, default initialized and not managed by a soap context
        virtual tt__NetworkCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkCapabilitiesExtension2); }
      public:
        /// Constructor with default initializations
        tt__NetworkCapabilitiesExtension2() : __any() { }
        /// Destructor
        virtual ~tt__NetworkCapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_tt__NetworkCapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__NetworkCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1099 */
#ifndef SOAP_TYPE_tt__SecurityCapabilities
#define SOAP_TYPE_tt__SecurityCapabilities (457)
/* Type tt__SecurityCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SecurityCapabilities': */
class SOAP_CMAC tt__SecurityCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:TLS1.1' of XML schema type 'xsd:boolean'
        bool TLS1_x002e1;
        /// Required element 'tt:TLS1.2' of XML schema type 'xsd:boolean'
        bool TLS1_x002e2;
        /// Required element 'tt:OnboardKeyGeneration' of XML schema type 'xsd:boolean'
        bool OnboardKeyGeneration;
        /// Required element 'tt:AccessPolicyConfig' of XML schema type 'xsd:boolean'
        bool AccessPolicyConfig;
        /// Required element 'tt:X.509Token' of XML schema type 'xsd:boolean'
        bool X_x002e509Token;
        /// Required element 'tt:SAMLToken' of XML schema type 'xsd:boolean'
        bool SAMLToken;
        /// Required element 'tt:KerberosToken' of XML schema type 'xsd:boolean'
        bool KerberosToken;
        /// Required element 'tt:RELToken' of XML schema type 'xsd:boolean'
        bool RELToken;
        std::vector<char *> __any;
        /// Optional element 'tt:Extension' of XML schema type 'tt:SecurityCapabilitiesExtension'
        tt__SecurityCapabilitiesExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__SecurityCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SecurityCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SecurityCapabilities, default initialized and not managed by a soap context
        virtual tt__SecurityCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SecurityCapabilities); }
      public:
        /// Constructor with default initializations
        tt__SecurityCapabilities() : TLS1_x002e1(), TLS1_x002e2(), OnboardKeyGeneration(), AccessPolicyConfig(), X_x002e509Token(), SAMLToken(), KerberosToken(), RELToken(), __any(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__SecurityCapabilities() { }
        /// Friend allocator used by soap_new_tt__SecurityCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__SecurityCapabilities * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1101 */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension (458)
/* Type tt__SecurityCapabilitiesExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SecurityCapabilitiesExtension': */
class SOAP_CMAC tt__SecurityCapabilitiesExtension : public xsd__anyType {
      public:
        /// Required element 'tt:TLS1.0' of XML schema type 'xsd:boolean'
        bool TLS1_x002e0;
        /// Optional element 'tt:Extension' of XML schema type 'tt:SecurityCapabilitiesExtension2'
        tt__SecurityCapabilitiesExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__SecurityCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SecurityCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SecurityCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__SecurityCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SecurityCapabilitiesExtension); }
      public:
        /// Constructor with default initializations
        tt__SecurityCapabilitiesExtension() : TLS1_x002e0(), Extension() { }
        /// Destructor
        virtual ~tt__SecurityCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__SecurityCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__SecurityCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1103 */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension2
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (459)
/* Type tt__SecurityCapabilitiesExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SecurityCapabilitiesExtension2': */
class SOAP_CMAC tt__SecurityCapabilitiesExtension2 : public xsd__anyType {
      public:
        /// Required element 'tt:Dot1X' of XML schema type 'xsd:boolean'
        bool Dot1X;
        /// Optional element 'tt:SupportedEAPMethod' of XML schema type 'xsd:int'
        std::vector<int> SupportedEAPMethod;
        /// Required element 'tt:RemoteUserHandling' of XML schema type 'xsd:boolean'
        bool RemoteUserHandling;
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__SecurityCapabilitiesExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SecurityCapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SecurityCapabilitiesExtension2, default initialized and not managed by a soap context
        virtual tt__SecurityCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SecurityCapabilitiesExtension2); }
      public:
        /// Constructor with default initializations
        tt__SecurityCapabilitiesExtension2() : Dot1X(), SupportedEAPMethod(), RemoteUserHandling(), __any() { }
        /// Destructor
        virtual ~tt__SecurityCapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_tt__SecurityCapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__SecurityCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SecurityCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1105 */
#ifndef SOAP_TYPE_tt__SystemCapabilities
#define SOAP_TYPE_tt__SystemCapabilities (460)
/* Type tt__SystemCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SystemCapabilities': */
class SOAP_CMAC tt__SystemCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:DiscoveryResolve' of XML schema type 'xsd:boolean'
        bool DiscoveryResolve;
        /// Required element 'tt:DiscoveryBye' of XML schema type 'xsd:boolean'
        bool DiscoveryBye;
        /// Required element 'tt:RemoteDiscovery' of XML schema type 'xsd:boolean'
        bool RemoteDiscovery;
        /// Required element 'tt:SystemBackup' of XML schema type 'xsd:boolean'
        bool SystemBackup;
        /// Required element 'tt:SystemLogging' of XML schema type 'xsd:boolean'
        bool SystemLogging;
        /// Required element 'tt:FirmwareUpgrade' of XML schema type 'xsd:boolean'
        bool FirmwareUpgrade;
        /// Required element 'tt:SupportedVersions' of XML schema type 'tt:OnvifVersion'
        std::vector<tt__OnvifVersion *> SupportedVersions;
        /// Optional element 'tt:Extension' of XML schema type 'tt:SystemCapabilitiesExtension'
        tt__SystemCapabilitiesExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemCapabilities, default initialized and not managed by a soap context
        virtual tt__SystemCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemCapabilities); }
      public:
        /// Constructor with default initializations
        tt__SystemCapabilities() : DiscoveryResolve(), DiscoveryBye(), RemoteDiscovery(), SystemBackup(), SystemLogging(), FirmwareUpgrade(), SupportedVersions(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__SystemCapabilities() { }
        /// Friend allocator used by soap_new_tt__SystemCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemCapabilities * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1107 */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension
#define SOAP_TYPE_tt__SystemCapabilitiesExtension (461)
/* Type tt__SystemCapabilitiesExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SystemCapabilitiesExtension': */
class SOAP_CMAC tt__SystemCapabilitiesExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:HttpFirmwareUpgrade' of XML schema type 'xsd:boolean'
        bool *HttpFirmwareUpgrade;
        /// Optional element 'tt:HttpSystemBackup' of XML schema type 'xsd:boolean'
        bool *HttpSystemBackup;
        /// Optional element 'tt:HttpSystemLogging' of XML schema type 'xsd:boolean'
        bool *HttpSystemLogging;
        /// Optional element 'tt:HttpSupportInformation' of XML schema type 'xsd:boolean'
        bool *HttpSupportInformation;
        /// Optional element 'tt:Extension' of XML schema type 'tt:SystemCapabilitiesExtension2'
        tt__SystemCapabilitiesExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemCapabilitiesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemCapabilitiesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemCapabilitiesExtension, default initialized and not managed by a soap context
        virtual tt__SystemCapabilitiesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemCapabilitiesExtension); }
      public:
        /// Constructor with default initializations
        tt__SystemCapabilitiesExtension() : __any(), HttpFirmwareUpgrade(), HttpSystemBackup(), HttpSystemLogging(), HttpSupportInformation(), Extension() { }
        /// Destructor
        virtual ~tt__SystemCapabilitiesExtension() { }
        /// Friend allocator used by soap_new_tt__SystemCapabilitiesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemCapabilitiesExtension * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1109 */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension2
#define SOAP_TYPE_tt__SystemCapabilitiesExtension2 (462)
/* Type tt__SystemCapabilitiesExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SystemCapabilitiesExtension2': */
class SOAP_CMAC tt__SystemCapabilitiesExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemCapabilitiesExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemCapabilitiesExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemCapabilitiesExtension2, default initialized and not managed by a soap context
        virtual tt__SystemCapabilitiesExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemCapabilitiesExtension2); }
      public:
        /// Constructor with default initializations
        tt__SystemCapabilitiesExtension2() : __any() { }
        /// Destructor
        virtual ~tt__SystemCapabilitiesExtension2() { }
        /// Friend allocator used by soap_new_tt__SystemCapabilitiesExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemCapabilitiesExtension2 * SOAP_FMAC2 soap_instantiate_tt__SystemCapabilitiesExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1111 */
#ifndef SOAP_TYPE_tt__OnvifVersion
#define SOAP_TYPE_tt__OnvifVersion (463)
/* Type tt__OnvifVersion is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OnvifVersion': */
class SOAP_CMAC tt__OnvifVersion : public xsd__anyType {
      public:
        /// Required element 'tt:Major' of XML schema type 'xsd:int'
        int Major;
        /// Required element 'tt:Minor' of XML schema type 'xsd:int'
        int Minor;
      public:
        /// Return unique type id SOAP_TYPE_tt__OnvifVersion
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OnvifVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OnvifVersion, default initialized and not managed by a soap context
        virtual tt__OnvifVersion *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OnvifVersion); }
      public:
        /// Constructor with default initializations
        tt__OnvifVersion() : Major(), Minor() { }
        /// Destructor
        virtual ~tt__OnvifVersion() { }
        /// Friend allocator used by soap_new_tt__OnvifVersion(struct soap*, int)
        friend SOAP_FMAC1 tt__OnvifVersion * SOAP_FMAC2 soap_instantiate_tt__OnvifVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1113 */
#ifndef SOAP_TYPE_tt__ImagingCapabilities
#define SOAP_TYPE_tt__ImagingCapabilities (464)
/* Type tt__ImagingCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingCapabilities': */
class SOAP_CMAC tt__ImagingCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingCapabilities, default initialized and not managed by a soap context
        virtual tt__ImagingCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingCapabilities); }
      public:
        /// Constructor with default initializations
        tt__ImagingCapabilities() : XAddr(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ImagingCapabilities() { }
        /// Friend allocator used by soap_new_tt__ImagingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingCapabilities * SOAP_FMAC2 soap_instantiate_tt__ImagingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1115 */
#ifndef SOAP_TYPE_tt__PTZCapabilities
#define SOAP_TYPE_tt__PTZCapabilities (465)
/* Type tt__PTZCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZCapabilities': */
class SOAP_CMAC tt__PTZCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZCapabilities, default initialized and not managed by a soap context
        virtual tt__PTZCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZCapabilities); }
      public:
        /// Constructor with default initializations
        tt__PTZCapabilities() : XAddr(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZCapabilities() { }
        /// Friend allocator used by soap_new_tt__PTZCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZCapabilities * SOAP_FMAC2 soap_instantiate_tt__PTZCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1117 */
#ifndef SOAP_TYPE_tt__DeviceIOCapabilities
#define SOAP_TYPE_tt__DeviceIOCapabilities (466)
/* Type tt__DeviceIOCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DeviceIOCapabilities': */
class SOAP_CMAC tt__DeviceIOCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:VideoSources' of XML schema type 'xsd:int'
        int VideoSources;
        /// Required element 'tt:VideoOutputs' of XML schema type 'xsd:int'
        int VideoOutputs;
        /// Required element 'tt:AudioSources' of XML schema type 'xsd:int'
        int AudioSources;
        /// Required element 'tt:AudioOutputs' of XML schema type 'xsd:int'
        int AudioOutputs;
        /// Required element 'tt:RelayOutputs' of XML schema type 'xsd:int'
        int RelayOutputs;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__DeviceIOCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DeviceIOCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DeviceIOCapabilities, default initialized and not managed by a soap context
        virtual tt__DeviceIOCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DeviceIOCapabilities); }
      public:
        /// Constructor with default initializations
        tt__DeviceIOCapabilities() : XAddr(), VideoSources(), VideoOutputs(), AudioSources(), AudioOutputs(), RelayOutputs(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__DeviceIOCapabilities() { }
        /// Friend allocator used by soap_new_tt__DeviceIOCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__DeviceIOCapabilities * SOAP_FMAC2 soap_instantiate_tt__DeviceIOCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1119 */
#ifndef SOAP_TYPE_tt__DisplayCapabilities
#define SOAP_TYPE_tt__DisplayCapabilities (467)
/* Type tt__DisplayCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DisplayCapabilities': */
class SOAP_CMAC tt__DisplayCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:FixedLayout' of XML schema type 'xsd:boolean'
        bool FixedLayout;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__DisplayCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DisplayCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DisplayCapabilities, default initialized and not managed by a soap context
        virtual tt__DisplayCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DisplayCapabilities); }
      public:
        /// Constructor with default initializations
        tt__DisplayCapabilities() : XAddr(), FixedLayout(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__DisplayCapabilities() { }
        /// Friend allocator used by soap_new_tt__DisplayCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__DisplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__DisplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1121 */
#ifndef SOAP_TYPE_tt__RecordingCapabilities
#define SOAP_TYPE_tt__RecordingCapabilities (468)
/* Type tt__RecordingCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingCapabilities': */
class SOAP_CMAC tt__RecordingCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:ReceiverSource' of XML schema type 'xsd:boolean'
        bool ReceiverSource;
        /// Required element 'tt:MediaProfileSource' of XML schema type 'xsd:boolean'
        bool MediaProfileSource;
        /// Required element 'tt:DynamicRecordings' of XML schema type 'xsd:boolean'
        bool DynamicRecordings;
        /// Required element 'tt:DynamicTracks' of XML schema type 'xsd:boolean'
        bool DynamicTracks;
        /// Required element 'tt:MaxStringLength' of XML schema type 'xsd:int'
        int MaxStringLength;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingCapabilities, default initialized and not managed by a soap context
        virtual tt__RecordingCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingCapabilities); }
      public:
        /// Constructor with default initializations
        tt__RecordingCapabilities() : XAddr(), ReceiverSource(), MediaProfileSource(), DynamicRecordings(), DynamicTracks(), MaxStringLength(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingCapabilities() { }
        /// Friend allocator used by soap_new_tt__RecordingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingCapabilities * SOAP_FMAC2 soap_instantiate_tt__RecordingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1123 */
#ifndef SOAP_TYPE_tt__SearchCapabilities
#define SOAP_TYPE_tt__SearchCapabilities (469)
/* Type tt__SearchCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SearchCapabilities': */
class SOAP_CMAC tt__SearchCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:MetadataSearch' of XML schema type 'xsd:boolean'
        bool MetadataSearch;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__SearchCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SearchCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SearchCapabilities, default initialized and not managed by a soap context
        virtual tt__SearchCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SearchCapabilities); }
      public:
        /// Constructor with default initializations
        tt__SearchCapabilities() : XAddr(), MetadataSearch(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__SearchCapabilities() { }
        /// Friend allocator used by soap_new_tt__SearchCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__SearchCapabilities * SOAP_FMAC2 soap_instantiate_tt__SearchCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1125 */
#ifndef SOAP_TYPE_tt__ReplayCapabilities
#define SOAP_TYPE_tt__ReplayCapabilities (470)
/* Type tt__ReplayCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ReplayCapabilities': */
class SOAP_CMAC tt__ReplayCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReplayCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReplayCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReplayCapabilities, default initialized and not managed by a soap context
        virtual tt__ReplayCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReplayCapabilities); }
      public:
        /// Constructor with default initializations
        tt__ReplayCapabilities() : XAddr(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ReplayCapabilities() { }
        /// Friend allocator used by soap_new_tt__ReplayCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__ReplayCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReplayCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1127 */
#ifndef SOAP_TYPE_tt__ReceiverCapabilities
#define SOAP_TYPE_tt__ReceiverCapabilities (471)
/* Type tt__ReceiverCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ReceiverCapabilities': */
class SOAP_CMAC tt__ReceiverCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        /// Required element 'tt:RTP_Multicast' of XML schema type 'xsd:boolean'
        bool RTP_USCOREMulticast;
        /// Required element 'tt:RTP_TCP' of XML schema type 'xsd:boolean'
        bool RTP_USCORETCP;
        /// Required element 'tt:RTP_RTSP_TCP' of XML schema type 'xsd:boolean'
        bool RTP_USCORERTSP_USCORETCP;
        /// Required element 'tt:SupportedReceivers' of XML schema type 'xsd:int'
        int SupportedReceivers;
        /// Required element 'tt:MaximumRTSPURILength' of XML schema type 'xsd:int'
        int MaximumRTSPURILength;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReceiverCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReceiverCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReceiverCapabilities, default initialized and not managed by a soap context
        virtual tt__ReceiverCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReceiverCapabilities); }
      public:
        /// Constructor with default initializations
        tt__ReceiverCapabilities() : XAddr(), RTP_USCOREMulticast(), RTP_USCORETCP(), RTP_USCORERTSP_USCORETCP(), SupportedReceivers(), MaximumRTSPURILength(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ReceiverCapabilities() { }
        /// Friend allocator used by soap_new_tt__ReceiverCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__ReceiverCapabilities * SOAP_FMAC2 soap_instantiate_tt__ReceiverCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1129 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceCapabilities
#define SOAP_TYPE_tt__AnalyticsDeviceCapabilities (472)
/* Type tt__AnalyticsDeviceCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsDeviceCapabilities': */
class SOAP_CMAC tt__AnalyticsDeviceCapabilities : public xsd__anyType {
      public:
        /// Required element 'tt:XAddr' of XML schema type 'xsd:anyURI'
        std::string XAddr;
        /// Optional element 'tt:RuleSupport' of XML schema type 'xsd:boolean'
        bool *RuleSupport;
        /// Optional element 'tt:Extension' of XML schema type 'tt:AnalyticsDeviceExtension'
        tt__AnalyticsDeviceExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsDeviceCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsDeviceCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsDeviceCapabilities, default initialized and not managed by a soap context
        virtual tt__AnalyticsDeviceCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsDeviceCapabilities); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsDeviceCapabilities() : XAddr(), RuleSupport(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AnalyticsDeviceCapabilities() { }
        /// Friend allocator used by soap_new_tt__AnalyticsDeviceCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsDeviceCapabilities * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1131 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceExtension
#define SOAP_TYPE_tt__AnalyticsDeviceExtension (473)
/* Type tt__AnalyticsDeviceExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsDeviceExtension': */
class SOAP_CMAC tt__AnalyticsDeviceExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsDeviceExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsDeviceExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsDeviceExtension, default initialized and not managed by a soap context
        virtual tt__AnalyticsDeviceExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsDeviceExtension); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsDeviceExtension() : __any() { }
        /// Destructor
        virtual ~tt__AnalyticsDeviceExtension() { }
        /// Friend allocator used by soap_new_tt__AnalyticsDeviceExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsDeviceExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1133 */
#ifndef SOAP_TYPE_tt__SystemLog
#define SOAP_TYPE_tt__SystemLog (474)
/* Type tt__SystemLog is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SystemLog': */
class SOAP_CMAC tt__SystemLog : public xsd__anyType {
      public:
        /// Optional element 'tt:Binary' of XML schema type 'tt:AttachmentData'
        tt__AttachmentData *Binary;
        /// Optional element 'tt:String' of XML schema type 'xsd:string'
        std::string *String;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemLog
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemLog; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemLog, default initialized and not managed by a soap context
        virtual tt__SystemLog *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemLog); }
      public:
        /// Constructor with default initializations
        tt__SystemLog() : Binary(), String() { }
        /// Destructor
        virtual ~tt__SystemLog() { }
        /// Friend allocator used by soap_new_tt__SystemLog(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemLog * SOAP_FMAC2 soap_instantiate_tt__SystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1135 */
#ifndef SOAP_TYPE_tt__SupportInformation
#define SOAP_TYPE_tt__SupportInformation (475)
/* Type tt__SupportInformation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SupportInformation': */
class SOAP_CMAC tt__SupportInformation : public xsd__anyType {
      public:
        /// Optional element 'tt:Binary' of XML schema type 'tt:AttachmentData'
        tt__AttachmentData *Binary;
        /// Optional element 'tt:String' of XML schema type 'xsd:string'
        std::string *String;
      public:
        /// Return unique type id SOAP_TYPE_tt__SupportInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SupportInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SupportInformation, default initialized and not managed by a soap context
        virtual tt__SupportInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SupportInformation); }
      public:
        /// Constructor with default initializations
        tt__SupportInformation() : Binary(), String() { }
        /// Destructor
        virtual ~tt__SupportInformation() { }
        /// Friend allocator used by soap_new_tt__SupportInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__SupportInformation * SOAP_FMAC2 soap_instantiate_tt__SupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1137 */
#ifndef SOAP_TYPE_tt__BinaryData
#define SOAP_TYPE_tt__BinaryData (476)
/* Type tt__BinaryData is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:BinaryData': */
class SOAP_CMAC tt__BinaryData : public xsd__anyType {
      public:
        /// Required element 'tt:Data' of XML schema type 'xsd:base64Binary'
        xsd__base64Binary Data;
        /// Optional attribute 'xmime:contentType' of XML schema type 'xsd:string'
        char *xmime__contentType;
      public:
        /// Return unique type id SOAP_TYPE_tt__BinaryData
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BinaryData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BinaryData, default initialized and not managed by a soap context
        virtual tt__BinaryData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BinaryData); }
      public:
        /// Constructor with default initializations
        tt__BinaryData() : Data(), xmime__contentType() { }
        /// Destructor
        virtual ~tt__BinaryData() { }
        /// Friend allocator used by soap_new_tt__BinaryData(struct soap*, int)
        friend SOAP_FMAC1 tt__BinaryData * SOAP_FMAC2 soap_instantiate_tt__BinaryData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1139 */
#ifndef SOAP_TYPE_tt__AttachmentData
#define SOAP_TYPE_tt__AttachmentData (477)
/* Type tt__AttachmentData is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AttachmentData': */
class SOAP_CMAC tt__AttachmentData : public xsd__anyType {
      public:
        /// Required element 'xop:Include' of XML schema type 'xop:Include'
        struct _xop__Include xop__Include;
        /// Optional attribute 'xmime:contentType' of XML schema type 'xsd:string'
        char *xmime__contentType;
      public:
        /// Return unique type id SOAP_TYPE_tt__AttachmentData
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AttachmentData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AttachmentData, default initialized and not managed by a soap context
        virtual tt__AttachmentData *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AttachmentData); }
      public:
        /// Constructor with default initializations
        tt__AttachmentData() : xop__Include(), xmime__contentType() { }
        /// Destructor
        virtual ~tt__AttachmentData() { }
        /// Friend allocator used by soap_new_tt__AttachmentData(struct soap*, int)
        friend SOAP_FMAC1 tt__AttachmentData * SOAP_FMAC2 soap_instantiate_tt__AttachmentData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1141 */
#ifndef SOAP_TYPE_tt__BackupFile
#define SOAP_TYPE_tt__BackupFile (478)
/* Type tt__BackupFile is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:BackupFile': */
class SOAP_CMAC tt__BackupFile : public xsd__anyType {
      public:
        /// Required element 'tt:Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Required element 'tt:Data' of XML schema type 'tt:AttachmentData'
        tt__AttachmentData *Data;
      public:
        /// Return unique type id SOAP_TYPE_tt__BackupFile
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BackupFile; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BackupFile, default initialized and not managed by a soap context
        virtual tt__BackupFile *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BackupFile); }
      public:
        /// Constructor with default initializations
        tt__BackupFile() : Name(), Data() { }
        /// Destructor
        virtual ~tt__BackupFile() { }
        /// Friend allocator used by soap_new_tt__BackupFile(struct soap*, int)
        friend SOAP_FMAC1 tt__BackupFile * SOAP_FMAC2 soap_instantiate_tt__BackupFile(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1143 */
#ifndef SOAP_TYPE_tt__SystemLogUriList
#define SOAP_TYPE_tt__SystemLogUriList (479)
/* Type tt__SystemLogUriList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SystemLogUriList': */
class SOAP_CMAC tt__SystemLogUriList : public xsd__anyType {
      public:
        /// Optional element 'tt:SystemLog' of XML schema type 'tt:SystemLogUri'
        std::vector<tt__SystemLogUri *> SystemLog;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemLogUriList
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemLogUriList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemLogUriList, default initialized and not managed by a soap context
        virtual tt__SystemLogUriList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemLogUriList); }
      public:
        /// Constructor with default initializations
        tt__SystemLogUriList() : SystemLog() { }
        /// Destructor
        virtual ~tt__SystemLogUriList() { }
        /// Friend allocator used by soap_new_tt__SystemLogUriList(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemLogUriList * SOAP_FMAC2 soap_instantiate_tt__SystemLogUriList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1145 */
#ifndef SOAP_TYPE_tt__SystemLogUri
#define SOAP_TYPE_tt__SystemLogUri (480)
/* Type tt__SystemLogUri is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SystemLogUri': */
class SOAP_CMAC tt__SystemLogUri : public xsd__anyType {
      public:
        /// Required element 'tt:Type' of XML schema type 'tt:SystemLogType'
        enum tt__SystemLogType Type;
        /// Required element 'tt:Uri' of XML schema type 'xsd:anyURI'
        std::string Uri;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemLogUri
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemLogUri; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemLogUri, default initialized and not managed by a soap context
        virtual tt__SystemLogUri *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemLogUri); }
      public:
        /// Constructor with default initializations
        tt__SystemLogUri() : Type(), Uri(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__SystemLogUri() { }
        /// Friend allocator used by soap_new_tt__SystemLogUri(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemLogUri * SOAP_FMAC2 soap_instantiate_tt__SystemLogUri(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1147 */
#ifndef SOAP_TYPE_tt__SystemDateTime
#define SOAP_TYPE_tt__SystemDateTime (481)
/* Type tt__SystemDateTime is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SystemDateTime': */
class SOAP_CMAC tt__SystemDateTime : public xsd__anyType {
      public:
        /// Required element 'tt:DateTimeType' of XML schema type 'tt:SetDateTimeType'
        enum tt__SetDateTimeType DateTimeType;
        /// Required element 'tt:DaylightSavings' of XML schema type 'xsd:boolean'
        bool DaylightSavings;
        /// Optional element 'tt:TimeZone' of XML schema type 'tt:TimeZone'
        tt__TimeZone *TimeZone;
        /// Optional element 'tt:UTCDateTime' of XML schema type 'tt:DateTime'
        tt__DateTime *UTCDateTime;
        /// Optional element 'tt:LocalDateTime' of XML schema type 'tt:DateTime'
        tt__DateTime *LocalDateTime;
        /// Optional element 'tt:Extension' of XML schema type 'tt:SystemDateTimeExtension'
        tt__SystemDateTimeExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemDateTime
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemDateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemDateTime, default initialized and not managed by a soap context
        virtual tt__SystemDateTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemDateTime); }
      public:
        /// Constructor with default initializations
        tt__SystemDateTime() : DateTimeType(), DaylightSavings(), TimeZone(), UTCDateTime(), LocalDateTime(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__SystemDateTime() { }
        /// Friend allocator used by soap_new_tt__SystemDateTime(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemDateTime * SOAP_FMAC2 soap_instantiate_tt__SystemDateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1149 */
#ifndef SOAP_TYPE_tt__SystemDateTimeExtension
#define SOAP_TYPE_tt__SystemDateTimeExtension (482)
/* Type tt__SystemDateTimeExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SystemDateTimeExtension': */
class SOAP_CMAC tt__SystemDateTimeExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__SystemDateTimeExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SystemDateTimeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SystemDateTimeExtension, default initialized and not managed by a soap context
        virtual tt__SystemDateTimeExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SystemDateTimeExtension); }
      public:
        /// Constructor with default initializations
        tt__SystemDateTimeExtension() : __any() { }
        /// Destructor
        virtual ~tt__SystemDateTimeExtension() { }
        /// Friend allocator used by soap_new_tt__SystemDateTimeExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__SystemDateTimeExtension * SOAP_FMAC2 soap_instantiate_tt__SystemDateTimeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1151 */
#ifndef SOAP_TYPE_tt__DateTime
#define SOAP_TYPE_tt__DateTime (483)
/* Type tt__DateTime is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DateTime': */
class SOAP_CMAC tt__DateTime : public xsd__anyType {
      public:
        /// Required element 'tt:Time' of XML schema type 'tt:Time'
        tt__Time *Time;
        /// Required element 'tt:Date' of XML schema type 'tt:Date'
        tt__Date *Date;
      public:
        /// Return unique type id SOAP_TYPE_tt__DateTime
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DateTime; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DateTime, default initialized and not managed by a soap context
        virtual tt__DateTime *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DateTime); }
      public:
        /// Constructor with default initializations
        tt__DateTime() : Time(), Date() { }
        /// Destructor
        virtual ~tt__DateTime() { }
        /// Friend allocator used by soap_new_tt__DateTime(struct soap*, int)
        friend SOAP_FMAC1 tt__DateTime * SOAP_FMAC2 soap_instantiate_tt__DateTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1153 */
#ifndef SOAP_TYPE_tt__Date
#define SOAP_TYPE_tt__Date (484)
/* Type tt__Date is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Date': */
class SOAP_CMAC tt__Date : public xsd__anyType {
      public:
        /// Required element 'tt:Year' of XML schema type 'xsd:int'
        int Year;
        /// Required element 'tt:Month' of XML schema type 'xsd:int'
        int Month;
        /// Required element 'tt:Day' of XML schema type 'xsd:int'
        int Day;
      public:
        /// Return unique type id SOAP_TYPE_tt__Date
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Date; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Date, default initialized and not managed by a soap context
        virtual tt__Date *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Date); }
      public:
        /// Constructor with default initializations
        tt__Date() : Year(), Month(), Day() { }
        /// Destructor
        virtual ~tt__Date() { }
        /// Friend allocator used by soap_new_tt__Date(struct soap*, int)
        friend SOAP_FMAC1 tt__Date * SOAP_FMAC2 soap_instantiate_tt__Date(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1155 */
#ifndef SOAP_TYPE_tt__Time
#define SOAP_TYPE_tt__Time (485)
/* Type tt__Time is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Time': */
class SOAP_CMAC tt__Time : public xsd__anyType {
      public:
        /// Required element 'tt:Hour' of XML schema type 'xsd:int'
        int Hour;
        /// Required element 'tt:Minute' of XML schema type 'xsd:int'
        int Minute;
        /// Required element 'tt:Second' of XML schema type 'xsd:int'
        int Second;
      public:
        /// Return unique type id SOAP_TYPE_tt__Time
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Time; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Time, default initialized and not managed by a soap context
        virtual tt__Time *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Time); }
      public:
        /// Constructor with default initializations
        tt__Time() : Hour(), Minute(), Second() { }
        /// Destructor
        virtual ~tt__Time() { }
        /// Friend allocator used by soap_new_tt__Time(struct soap*, int)
        friend SOAP_FMAC1 tt__Time * SOAP_FMAC2 soap_instantiate_tt__Time(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1157 */
#ifndef SOAP_TYPE_tt__TimeZone
#define SOAP_TYPE_tt__TimeZone (486)
/* Type tt__TimeZone is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:TimeZone': */
class SOAP_CMAC tt__TimeZone : public xsd__anyType {
      public:
        /// Required element 'tt:TZ' of XML schema type 'xsd:token'
        std::string TZ;
      public:
        /// Return unique type id SOAP_TYPE_tt__TimeZone
        virtual long soap_type(void) const { return SOAP_TYPE_tt__TimeZone; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__TimeZone, default initialized and not managed by a soap context
        virtual tt__TimeZone *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__TimeZone); }
      public:
        /// Constructor with default initializations
        tt__TimeZone() : TZ() { }
        /// Destructor
        virtual ~tt__TimeZone() { }
        /// Friend allocator used by soap_new_tt__TimeZone(struct soap*, int)
        friend SOAP_FMAC1 tt__TimeZone * SOAP_FMAC2 soap_instantiate_tt__TimeZone(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1159 */
#ifndef SOAP_TYPE_tt__RemoteUser
#define SOAP_TYPE_tt__RemoteUser (487)
/* Type tt__RemoteUser is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RemoteUser': */
class SOAP_CMAC tt__RemoteUser : public xsd__anyType {
      public:
        /// Required element 'tt:Username' of XML schema type 'xsd:string'
        std::string Username;
        /// Optional element 'tt:Password' of XML schema type 'xsd:string'
        std::string *Password;
        /// Required element 'tt:UseDerivedPassword' of XML schema type 'xsd:boolean'
        bool UseDerivedPassword;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RemoteUser
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RemoteUser; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RemoteUser, default initialized and not managed by a soap context
        virtual tt__RemoteUser *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RemoteUser); }
      public:
        /// Constructor with default initializations
        tt__RemoteUser() : Username(), Password(), UseDerivedPassword(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RemoteUser() { }
        /// Friend allocator used by soap_new_tt__RemoteUser(struct soap*, int)
        friend SOAP_FMAC1 tt__RemoteUser * SOAP_FMAC2 soap_instantiate_tt__RemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1161 */
#ifndef SOAP_TYPE_tt__User
#define SOAP_TYPE_tt__User (488)
/* Type tt__User is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:User': */
class SOAP_CMAC tt__User : public xsd__anyType {
      public:
        /// Required element 'tt:Username' of XML schema type 'xsd:string'
        std::string Username;
        /// Optional element 'tt:Password' of XML schema type 'xsd:string'
        std::string *Password;
        /// Required element 'tt:UserLevel' of XML schema type 'tt:UserLevel'
        enum tt__UserLevel UserLevel;
        /// Optional element 'tt:Extension' of XML schema type 'tt:UserExtension'
        tt__UserExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__User
        virtual long soap_type(void) const { return SOAP_TYPE_tt__User; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__User, default initialized and not managed by a soap context
        virtual tt__User *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__User); }
      public:
        /// Constructor with default initializations
        tt__User() : Username(), Password(), UserLevel(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__User() { }
        /// Friend allocator used by soap_new_tt__User(struct soap*, int)
        friend SOAP_FMAC1 tt__User * SOAP_FMAC2 soap_instantiate_tt__User(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1163 */
#ifndef SOAP_TYPE_tt__UserExtension
#define SOAP_TYPE_tt__UserExtension (489)
/* Type tt__UserExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:UserExtension': */
class SOAP_CMAC tt__UserExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__UserExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__UserExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__UserExtension, default initialized and not managed by a soap context
        virtual tt__UserExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__UserExtension); }
      public:
        /// Constructor with default initializations
        tt__UserExtension() : __any() { }
        /// Destructor
        virtual ~tt__UserExtension() { }
        /// Friend allocator used by soap_new_tt__UserExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__UserExtension * SOAP_FMAC2 soap_instantiate_tt__UserExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1165 */
#ifndef SOAP_TYPE_tt__CertificateGenerationParameters
#define SOAP_TYPE_tt__CertificateGenerationParameters (490)
/* Type tt__CertificateGenerationParameters is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:CertificateGenerationParameters': */
class SOAP_CMAC tt__CertificateGenerationParameters : public xsd__anyType {
      public:
        /// Optional element 'tt:CertificateID' of XML schema type 'xsd:token'
        std::string *CertificateID;
        /// Optional element 'tt:Subject' of XML schema type 'xsd:string'
        std::string *Subject;
        /// Optional element 'tt:ValidNotBefore' of XML schema type 'xsd:token'
        std::string *ValidNotBefore;
        /// Optional element 'tt:ValidNotAfter' of XML schema type 'xsd:token'
        std::string *ValidNotAfter;
        /// Optional element 'tt:Extension' of XML schema type 'tt:CertificateGenerationParametersExtension'
        tt__CertificateGenerationParametersExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__CertificateGenerationParameters
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CertificateGenerationParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CertificateGenerationParameters, default initialized and not managed by a soap context
        virtual tt__CertificateGenerationParameters *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CertificateGenerationParameters); }
      public:
        /// Constructor with default initializations
        tt__CertificateGenerationParameters() : CertificateID(), Subject(), ValidNotBefore(), ValidNotAfter(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__CertificateGenerationParameters() { }
        /// Friend allocator used by soap_new_tt__CertificateGenerationParameters(struct soap*, int)
        friend SOAP_FMAC1 tt__CertificateGenerationParameters * SOAP_FMAC2 soap_instantiate_tt__CertificateGenerationParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1167 */
#ifndef SOAP_TYPE_tt__CertificateGenerationParametersExtension
#define SOAP_TYPE_tt__CertificateGenerationParametersExtension (491)
/* Type tt__CertificateGenerationParametersExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:CertificateGenerationParametersExtension': */
class SOAP_CMAC tt__CertificateGenerationParametersExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__CertificateGenerationParametersExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CertificateGenerationParametersExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CertificateGenerationParametersExtension, default initialized and not managed by a soap context
        virtual tt__CertificateGenerationParametersExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CertificateGenerationParametersExtension); }
      public:
        /// Constructor with default initializations
        tt__CertificateGenerationParametersExtension() : __any() { }
        /// Destructor
        virtual ~tt__CertificateGenerationParametersExtension() { }
        /// Friend allocator used by soap_new_tt__CertificateGenerationParametersExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__CertificateGenerationParametersExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateGenerationParametersExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1169 */
#ifndef SOAP_TYPE_tt__Certificate
#define SOAP_TYPE_tt__Certificate (492)
/* Type tt__Certificate is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Certificate': */
class SOAP_CMAC tt__Certificate : public xsd__anyType {
      public:
        /// Required element 'tt:CertificateID' of XML schema type 'xsd:token'
        std::string CertificateID;
        /// Required element 'tt:Certificate' of XML schema type 'tt:BinaryData'
        tt__BinaryData *Certificate;
      public:
        /// Return unique type id SOAP_TYPE_tt__Certificate
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Certificate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Certificate, default initialized and not managed by a soap context
        virtual tt__Certificate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Certificate); }
      public:
        /// Constructor with default initializations
        tt__Certificate() : CertificateID(), Certificate() { }
        /// Destructor
        virtual ~tt__Certificate() { }
        /// Friend allocator used by soap_new_tt__Certificate(struct soap*, int)
        friend SOAP_FMAC1 tt__Certificate * SOAP_FMAC2 soap_instantiate_tt__Certificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1171 */
#ifndef SOAP_TYPE_tt__CertificateStatus
#define SOAP_TYPE_tt__CertificateStatus (493)
/* Type tt__CertificateStatus is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:CertificateStatus': */
class SOAP_CMAC tt__CertificateStatus : public xsd__anyType {
      public:
        /// Required element 'tt:CertificateID' of XML schema type 'xsd:token'
        std::string CertificateID;
        /// Required element 'tt:Status' of XML schema type 'xsd:boolean'
        bool Status;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__CertificateStatus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CertificateStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CertificateStatus, default initialized and not managed by a soap context
        virtual tt__CertificateStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CertificateStatus); }
      public:
        /// Constructor with default initializations
        tt__CertificateStatus() : CertificateID(), Status(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__CertificateStatus() { }
        /// Friend allocator used by soap_new_tt__CertificateStatus(struct soap*, int)
        friend SOAP_FMAC1 tt__CertificateStatus * SOAP_FMAC2 soap_instantiate_tt__CertificateStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1173 */
#ifndef SOAP_TYPE_tt__CertificateWithPrivateKey
#define SOAP_TYPE_tt__CertificateWithPrivateKey (494)
/* Type tt__CertificateWithPrivateKey is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:CertificateWithPrivateKey': */
class SOAP_CMAC tt__CertificateWithPrivateKey : public xsd__anyType {
      public:
        /// Optional element 'tt:CertificateID' of XML schema type 'xsd:token'
        std::string *CertificateID;
        /// Required element 'tt:Certificate' of XML schema type 'tt:BinaryData'
        tt__BinaryData *Certificate;
        /// Required element 'tt:PrivateKey' of XML schema type 'tt:BinaryData'
        tt__BinaryData *PrivateKey;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__CertificateWithPrivateKey
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CertificateWithPrivateKey; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CertificateWithPrivateKey, default initialized and not managed by a soap context
        virtual tt__CertificateWithPrivateKey *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CertificateWithPrivateKey); }
      public:
        /// Constructor with default initializations
        tt__CertificateWithPrivateKey() : CertificateID(), Certificate(), PrivateKey(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__CertificateWithPrivateKey() { }
        /// Friend allocator used by soap_new_tt__CertificateWithPrivateKey(struct soap*, int)
        friend SOAP_FMAC1 tt__CertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate_tt__CertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1175 */
#ifndef SOAP_TYPE_tt__CertificateInformation
#define SOAP_TYPE_tt__CertificateInformation (495)
/* Type tt__CertificateInformation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:CertificateInformation': */
class SOAP_CMAC tt__CertificateInformation : public xsd__anyType {
      public:
        /// Required element 'tt:CertificateID' of XML schema type 'xsd:token'
        std::string CertificateID;
        /// Optional element 'tt:IssuerDN' of XML schema type 'xsd:string'
        std::string *IssuerDN;
        /// Optional element 'tt:SubjectDN' of XML schema type 'xsd:string'
        std::string *SubjectDN;
        /// Optional element 'tt:KeyUsage' of XML schema type 'tt:CertificateUsage'
        tt__CertificateUsage *KeyUsage;
        /// Optional element 'tt:ExtendedKeyUsage' of XML schema type 'tt:CertificateUsage'
        tt__CertificateUsage *ExtendedKeyUsage;
        /// Optional element 'tt:KeyLength' of XML schema type 'xsd:int'
        int *KeyLength;
        /// Optional element 'tt:Version' of XML schema type 'xsd:string'
        std::string *Version;
        /// Optional element 'tt:SerialNum' of XML schema type 'xsd:string'
        std::string *SerialNum;
        /// Optional element 'tt:SignatureAlgorithm' of XML schema type 'xsd:string'
        std::string *SignatureAlgorithm;
        /// Optional element 'tt:Validity' of XML schema type 'tt:DateTimeRange'
        tt__DateTimeRange *Validity;
        /// Optional element 'tt:Extension' of XML schema type 'tt:CertificateInformationExtension'
        tt__CertificateInformationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__CertificateInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CertificateInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CertificateInformation, default initialized and not managed by a soap context
        virtual tt__CertificateInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CertificateInformation); }
      public:
        /// Constructor with default initializations
        tt__CertificateInformation() : CertificateID(), IssuerDN(), SubjectDN(), KeyUsage(), ExtendedKeyUsage(), KeyLength(), Version(), SerialNum(), SignatureAlgorithm(), Validity(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__CertificateInformation() { }
        /// Friend allocator used by soap_new_tt__CertificateInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__CertificateInformation * SOAP_FMAC2 soap_instantiate_tt__CertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1179 */
#ifndef SOAP_TYPE_tt__CertificateInformationExtension
#define SOAP_TYPE_tt__CertificateInformationExtension (497)
/* Type tt__CertificateInformationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:CertificateInformationExtension': */
class SOAP_CMAC tt__CertificateInformationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__CertificateInformationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CertificateInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CertificateInformationExtension, default initialized and not managed by a soap context
        virtual tt__CertificateInformationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CertificateInformationExtension); }
      public:
        /// Constructor with default initializations
        tt__CertificateInformationExtension() : __any() { }
        /// Destructor
        virtual ~tt__CertificateInformationExtension() { }
        /// Friend allocator used by soap_new_tt__CertificateInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__CertificateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__CertificateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1181 */
#ifndef SOAP_TYPE_tt__Dot1XConfiguration
#define SOAP_TYPE_tt__Dot1XConfiguration (498)
/* Type tt__Dot1XConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Dot1XConfiguration': */
class SOAP_CMAC tt__Dot1XConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:Dot1XConfigurationToken' of XML schema type 'tt:ReferenceToken'
        std::string Dot1XConfigurationToken;
        /// Required element 'tt:Identity' of XML schema type 'xsd:string'
        std::string Identity;
        /// Optional element 'tt:AnonymousID' of XML schema type 'xsd:string'
        std::string *AnonymousID;
        /// Required element 'tt:EAPMethod' of XML schema type 'xsd:int'
        int EAPMethod;
        /// Optional element 'tt:CACertificateID' of XML schema type 'xsd:token'
        std::vector<std::string> CACertificateID;
        /// Optional element 'tt:EAPMethodConfiguration' of XML schema type 'tt:EAPMethodConfiguration'
        tt__EAPMethodConfiguration *EAPMethodConfiguration;
        /// Optional element 'tt:Extension' of XML schema type 'tt:Dot1XConfigurationExtension'
        tt__Dot1XConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot1XConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot1XConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot1XConfiguration, default initialized and not managed by a soap context
        virtual tt__Dot1XConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot1XConfiguration); }
      public:
        /// Constructor with default initializations
        tt__Dot1XConfiguration() : Dot1XConfigurationToken(), Identity(), AnonymousID(), EAPMethod(), CACertificateID(), EAPMethodConfiguration(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Dot1XConfiguration() { }
        /// Friend allocator used by soap_new_tt__Dot1XConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot1XConfiguration * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1183 */
#ifndef SOAP_TYPE_tt__Dot1XConfigurationExtension
#define SOAP_TYPE_tt__Dot1XConfigurationExtension (499)
/* Type tt__Dot1XConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Dot1XConfigurationExtension': */
class SOAP_CMAC tt__Dot1XConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__Dot1XConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Dot1XConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Dot1XConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__Dot1XConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Dot1XConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__Dot1XConfigurationExtension() : __any() { }
        /// Destructor
        virtual ~tt__Dot1XConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__Dot1XConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__Dot1XConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__Dot1XConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1185 */
#ifndef SOAP_TYPE_tt__EAPMethodConfiguration
#define SOAP_TYPE_tt__EAPMethodConfiguration (500)
/* Type tt__EAPMethodConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:EAPMethodConfiguration': */
class SOAP_CMAC tt__EAPMethodConfiguration : public xsd__anyType {
      public:
        /// Optional element 'tt:TLSConfiguration' of XML schema type 'tt:TLSConfiguration'
        tt__TLSConfiguration *TLSConfiguration;
        /// Optional element 'tt:Password' of XML schema type 'xsd:string'
        std::string *Password;
        /// Optional element 'tt:Extension' of XML schema type 'tt:EapMethodExtension'
        tt__EapMethodExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__EAPMethodConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EAPMethodConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EAPMethodConfiguration, default initialized and not managed by a soap context
        virtual tt__EAPMethodConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EAPMethodConfiguration); }
      public:
        /// Constructor with default initializations
        tt__EAPMethodConfiguration() : TLSConfiguration(), Password(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__EAPMethodConfiguration() { }
        /// Friend allocator used by soap_new_tt__EAPMethodConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__EAPMethodConfiguration * SOAP_FMAC2 soap_instantiate_tt__EAPMethodConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1187 */
#ifndef SOAP_TYPE_tt__EapMethodExtension
#define SOAP_TYPE_tt__EapMethodExtension (501)
/* Type tt__EapMethodExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:EapMethodExtension': */
class SOAP_CMAC tt__EapMethodExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__EapMethodExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EapMethodExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EapMethodExtension, default initialized and not managed by a soap context
        virtual tt__EapMethodExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EapMethodExtension); }
      public:
        /// Constructor with default initializations
        tt__EapMethodExtension() : __any() { }
        /// Destructor
        virtual ~tt__EapMethodExtension() { }
        /// Friend allocator used by soap_new_tt__EapMethodExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__EapMethodExtension * SOAP_FMAC2 soap_instantiate_tt__EapMethodExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1189 */
#ifndef SOAP_TYPE_tt__TLSConfiguration
#define SOAP_TYPE_tt__TLSConfiguration (502)
/* Type tt__TLSConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:TLSConfiguration': */
class SOAP_CMAC tt__TLSConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:CertificateID' of XML schema type 'xsd:token'
        std::string CertificateID;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__TLSConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__TLSConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__TLSConfiguration, default initialized and not managed by a soap context
        virtual tt__TLSConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__TLSConfiguration); }
      public:
        /// Constructor with default initializations
        tt__TLSConfiguration() : CertificateID(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__TLSConfiguration() { }
        /// Friend allocator used by soap_new_tt__TLSConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__TLSConfiguration * SOAP_FMAC2 soap_instantiate_tt__TLSConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1191 */
#ifndef SOAP_TYPE_tt__GenericEapPwdConfigurationExtension
#define SOAP_TYPE_tt__GenericEapPwdConfigurationExtension (503)
/* Type tt__GenericEapPwdConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:GenericEapPwdConfigurationExtension': */
class SOAP_CMAC tt__GenericEapPwdConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__GenericEapPwdConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__GenericEapPwdConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__GenericEapPwdConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__GenericEapPwdConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__GenericEapPwdConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__GenericEapPwdConfigurationExtension() : __any() { }
        /// Destructor
        virtual ~tt__GenericEapPwdConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__GenericEapPwdConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__GenericEapPwdConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__GenericEapPwdConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1193 */
#ifndef SOAP_TYPE_tt__RelayOutputSettings
#define SOAP_TYPE_tt__RelayOutputSettings (504)
/* Type tt__RelayOutputSettings is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RelayOutputSettings': */
class SOAP_CMAC tt__RelayOutputSettings : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:RelayMode'
        enum tt__RelayMode Mode;
        /// Required element 'tt:DelayTime' of XML schema type 'xsd:duration'
        std::string DelayTime;
        /// Required element 'tt:IdleState' of XML schema type 'tt:RelayIdleState'
        enum tt__RelayIdleState IdleState;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelayOutputSettings
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelayOutputSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelayOutputSettings, default initialized and not managed by a soap context
        virtual tt__RelayOutputSettings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelayOutputSettings); }
      public:
        /// Constructor with default initializations
        tt__RelayOutputSettings() : Mode(), DelayTime(), IdleState() { }
        /// Destructor
        virtual ~tt__RelayOutputSettings() { }
        /// Friend allocator used by soap_new_tt__RelayOutputSettings(struct soap*, int)
        friend SOAP_FMAC1 tt__RelayOutputSettings * SOAP_FMAC2 soap_instantiate_tt__RelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1201 */
#ifndef SOAP_TYPE_tt__PTZNodeExtension
#define SOAP_TYPE_tt__PTZNodeExtension (508)
/* Type tt__PTZNodeExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZNodeExtension': */
class SOAP_CMAC tt__PTZNodeExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:SupportedPresetTour' of XML schema type 'tt:PTZPresetTourSupported'
        tt__PTZPresetTourSupported *SupportedPresetTour;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZNodeExtension2'
        tt__PTZNodeExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZNodeExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZNodeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZNodeExtension, default initialized and not managed by a soap context
        virtual tt__PTZNodeExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZNodeExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZNodeExtension() : __any(), SupportedPresetTour(), Extension() { }
        /// Destructor
        virtual ~tt__PTZNodeExtension() { }
        /// Friend allocator used by soap_new_tt__PTZNodeExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZNodeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1203 */
#ifndef SOAP_TYPE_tt__PTZNodeExtension2
#define SOAP_TYPE_tt__PTZNodeExtension2 (509)
/* Type tt__PTZNodeExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZNodeExtension2': */
class SOAP_CMAC tt__PTZNodeExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZNodeExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZNodeExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZNodeExtension2, default initialized and not managed by a soap context
        virtual tt__PTZNodeExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZNodeExtension2); }
      public:
        /// Constructor with default initializations
        tt__PTZNodeExtension2() : __any() { }
        /// Destructor
        virtual ~tt__PTZNodeExtension2() { }
        /// Friend allocator used by soap_new_tt__PTZNodeExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZNodeExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1205 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupported
#define SOAP_TYPE_tt__PTZPresetTourSupported (510)
/* Type tt__PTZPresetTourSupported is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourSupported': */
class SOAP_CMAC tt__PTZPresetTourSupported : public xsd__anyType {
      public:
        /// Required element 'tt:MaximumNumberOfPresetTours' of XML schema type 'xsd:int'
        int MaximumNumberOfPresetTours;
        /// Optional element 'tt:PTZPresetTourOperation' of XML schema type 'tt:PTZPresetTourOperation'
        std::vector<enum tt__PTZPresetTourOperation> PTZPresetTourOperation;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZPresetTourSupportedExtension'
        tt__PTZPresetTourSupportedExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourSupported
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourSupported; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourSupported, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourSupported *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourSupported); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourSupported() : MaximumNumberOfPresetTours(), PTZPresetTourOperation(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZPresetTourSupported() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourSupported(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourSupported * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupported(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1207 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupportedExtension
#define SOAP_TYPE_tt__PTZPresetTourSupportedExtension (511)
/* Type tt__PTZPresetTourSupportedExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourSupportedExtension': */
class SOAP_CMAC tt__PTZPresetTourSupportedExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourSupportedExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourSupportedExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourSupportedExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourSupportedExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourSupportedExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourSupportedExtension() : __any() { }
        /// Destructor
        virtual ~tt__PTZPresetTourSupportedExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourSupportedExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourSupportedExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupportedExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1211 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (513)
/* Type tt__PTZConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZConfigurationExtension': */
class SOAP_CMAC tt__PTZConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:PTControlDirection' of XML schema type 'tt:PTControlDirection'
        tt__PTControlDirection *PTControlDirection;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZConfigurationExtension2'
        tt__PTZConfigurationExtension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__PTZConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZConfigurationExtension() : __any(), PTControlDirection(), Extension() { }
        /// Destructor
        virtual ~tt__PTZConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__PTZConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1213 */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2
#define SOAP_TYPE_tt__PTZConfigurationExtension2 (514)
/* Type tt__PTZConfigurationExtension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZConfigurationExtension2': */
class SOAP_CMAC tt__PTZConfigurationExtension2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfigurationExtension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfigurationExtension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfigurationExtension2, default initialized and not managed by a soap context
        virtual tt__PTZConfigurationExtension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfigurationExtension2); }
      public:
        /// Constructor with default initializations
        tt__PTZConfigurationExtension2() : __any() { }
        /// Destructor
        virtual ~tt__PTZConfigurationExtension2() { }
        /// Friend allocator used by soap_new_tt__PTZConfigurationExtension2(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1215 */
#ifndef SOAP_TYPE_tt__PTControlDirection
#define SOAP_TYPE_tt__PTControlDirection (515)
/* Type tt__PTControlDirection is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTControlDirection': */
class SOAP_CMAC tt__PTControlDirection : public xsd__anyType {
      public:
        /// Optional element 'tt:EFlip' of XML schema type 'tt:EFlip'
        tt__EFlip *EFlip;
        /// Optional element 'tt:Reverse' of XML schema type 'tt:Reverse'
        tt__Reverse *Reverse;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTControlDirectionExtension'
        tt__PTControlDirectionExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTControlDirection
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTControlDirection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTControlDirection, default initialized and not managed by a soap context
        virtual tt__PTControlDirection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTControlDirection); }
      public:
        /// Constructor with default initializations
        tt__PTControlDirection() : EFlip(), Reverse(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTControlDirection() { }
        /// Friend allocator used by soap_new_tt__PTControlDirection(struct soap*, int)
        friend SOAP_FMAC1 tt__PTControlDirection * SOAP_FMAC2 soap_instantiate_tt__PTControlDirection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1217 */
#ifndef SOAP_TYPE_tt__PTControlDirectionExtension
#define SOAP_TYPE_tt__PTControlDirectionExtension (516)
/* Type tt__PTControlDirectionExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTControlDirectionExtension': */
class SOAP_CMAC tt__PTControlDirectionExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTControlDirectionExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTControlDirectionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTControlDirectionExtension, default initialized and not managed by a soap context
        virtual tt__PTControlDirectionExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTControlDirectionExtension); }
      public:
        /// Constructor with default initializations
        tt__PTControlDirectionExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTControlDirectionExtension() { }
        /// Friend allocator used by soap_new_tt__PTControlDirectionExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTControlDirectionExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1219 */
#ifndef SOAP_TYPE_tt__EFlip
#define SOAP_TYPE_tt__EFlip (517)
/* Type tt__EFlip is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:EFlip': */
class SOAP_CMAC tt__EFlip : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:EFlipMode'
        enum tt__EFlipMode Mode;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__EFlip
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EFlip; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EFlip, default initialized and not managed by a soap context
        virtual tt__EFlip *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EFlip); }
      public:
        /// Constructor with default initializations
        tt__EFlip() : Mode(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__EFlip() { }
        /// Friend allocator used by soap_new_tt__EFlip(struct soap*, int)
        friend SOAP_FMAC1 tt__EFlip * SOAP_FMAC2 soap_instantiate_tt__EFlip(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1221 */
#ifndef SOAP_TYPE_tt__Reverse
#define SOAP_TYPE_tt__Reverse (518)
/* Type tt__Reverse is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Reverse': */
class SOAP_CMAC tt__Reverse : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ReverseMode'
        enum tt__ReverseMode Mode;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Reverse
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Reverse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Reverse, default initialized and not managed by a soap context
        virtual tt__Reverse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Reverse); }
      public:
        /// Constructor with default initializations
        tt__Reverse() : Mode(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Reverse() { }
        /// Friend allocator used by soap_new_tt__Reverse(struct soap*, int)
        friend SOAP_FMAC1 tt__Reverse * SOAP_FMAC2 soap_instantiate_tt__Reverse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1223 */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions
#define SOAP_TYPE_tt__PTZConfigurationOptions (519)
/* Type tt__PTZConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZConfigurationOptions': */
class SOAP_CMAC tt__PTZConfigurationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Spaces' of XML schema type 'tt:PTZSpaces'
        tt__PTZSpaces *Spaces;
        /// Required element 'tt:PTZTimeout' of XML schema type 'tt:DurationRange'
        tt__DurationRange *PTZTimeout;
        std::vector<char *> __any;
        /// Optional element 'tt:PTControlDirection' of XML schema type 'tt:PTControlDirectionOptions'
        tt__PTControlDirectionOptions *PTControlDirection;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZConfigurationOptions2'
        tt__PTZConfigurationOptions2 *Extension;
        /// Optional attribute 'PTZRamps' of XML schema type 'tt:IntList'
        std::string *PTZRamps;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__PTZConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__PTZConfigurationOptions() : Spaces(), PTZTimeout(), __any(), PTControlDirection(), Extension(), PTZRamps(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__PTZConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1225 */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions2
#define SOAP_TYPE_tt__PTZConfigurationOptions2 (520)
/* Type tt__PTZConfigurationOptions2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZConfigurationOptions2': */
class SOAP_CMAC tt__PTZConfigurationOptions2 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfigurationOptions2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfigurationOptions2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfigurationOptions2, default initialized and not managed by a soap context
        virtual tt__PTZConfigurationOptions2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfigurationOptions2); }
      public:
        /// Constructor with default initializations
        tt__PTZConfigurationOptions2() : __any() { }
        /// Destructor
        virtual ~tt__PTZConfigurationOptions2() { }
        /// Friend allocator used by soap_new_tt__PTZConfigurationOptions2(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfigurationOptions2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1227 */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptions
#define SOAP_TYPE_tt__PTControlDirectionOptions (521)
/* Type tt__PTControlDirectionOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTControlDirectionOptions': */
class SOAP_CMAC tt__PTControlDirectionOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:EFlip' of XML schema type 'tt:EFlipOptions'
        tt__EFlipOptions *EFlip;
        /// Optional element 'tt:Reverse' of XML schema type 'tt:ReverseOptions'
        tt__ReverseOptions *Reverse;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTControlDirectionOptionsExtension'
        tt__PTControlDirectionOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTControlDirectionOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTControlDirectionOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTControlDirectionOptions, default initialized and not managed by a soap context
        virtual tt__PTControlDirectionOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTControlDirectionOptions); }
      public:
        /// Constructor with default initializations
        tt__PTControlDirectionOptions() : EFlip(), Reverse(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTControlDirectionOptions() { }
        /// Friend allocator used by soap_new_tt__PTControlDirectionOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTControlDirectionOptions * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1229 */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptionsExtension
#define SOAP_TYPE_tt__PTControlDirectionOptionsExtension (522)
/* Type tt__PTControlDirectionOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTControlDirectionOptionsExtension': */
class SOAP_CMAC tt__PTControlDirectionOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTControlDirectionOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTControlDirectionOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTControlDirectionOptionsExtension, default initialized and not managed by a soap context
        virtual tt__PTControlDirectionOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTControlDirectionOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__PTControlDirectionOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__PTControlDirectionOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__PTControlDirectionOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTControlDirectionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1231 */
#ifndef SOAP_TYPE_tt__EFlipOptions
#define SOAP_TYPE_tt__EFlipOptions (523)
/* Type tt__EFlipOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:EFlipOptions': */
class SOAP_CMAC tt__EFlipOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:Mode' of XML schema type 'tt:EFlipMode'
        std::vector<enum tt__EFlipMode> Mode;
        /// Optional element 'tt:Extension' of XML schema type 'tt:EFlipOptionsExtension'
        tt__EFlipOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__EFlipOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EFlipOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EFlipOptions, default initialized and not managed by a soap context
        virtual tt__EFlipOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EFlipOptions); }
      public:
        /// Constructor with default initializations
        tt__EFlipOptions() : Mode(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__EFlipOptions() { }
        /// Friend allocator used by soap_new_tt__EFlipOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__EFlipOptions * SOAP_FMAC2 soap_instantiate_tt__EFlipOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1233 */
#ifndef SOAP_TYPE_tt__EFlipOptionsExtension
#define SOAP_TYPE_tt__EFlipOptionsExtension (524)
/* Type tt__EFlipOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:EFlipOptionsExtension': */
class SOAP_CMAC tt__EFlipOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__EFlipOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EFlipOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EFlipOptionsExtension, default initialized and not managed by a soap context
        virtual tt__EFlipOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EFlipOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__EFlipOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__EFlipOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__EFlipOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__EFlipOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__EFlipOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1235 */
#ifndef SOAP_TYPE_tt__ReverseOptions
#define SOAP_TYPE_tt__ReverseOptions (525)
/* Type tt__ReverseOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ReverseOptions': */
class SOAP_CMAC tt__ReverseOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:Mode' of XML schema type 'tt:ReverseMode'
        std::vector<enum tt__ReverseMode> Mode;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ReverseOptionsExtension'
        tt__ReverseOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReverseOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReverseOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReverseOptions, default initialized and not managed by a soap context
        virtual tt__ReverseOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReverseOptions); }
      public:
        /// Constructor with default initializations
        tt__ReverseOptions() : Mode(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ReverseOptions() { }
        /// Friend allocator used by soap_new_tt__ReverseOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ReverseOptions * SOAP_FMAC2 soap_instantiate_tt__ReverseOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1237 */
#ifndef SOAP_TYPE_tt__ReverseOptionsExtension
#define SOAP_TYPE_tt__ReverseOptionsExtension (526)
/* Type tt__ReverseOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ReverseOptionsExtension': */
class SOAP_CMAC tt__ReverseOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReverseOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReverseOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReverseOptionsExtension, default initialized and not managed by a soap context
        virtual tt__ReverseOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReverseOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__ReverseOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__ReverseOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__ReverseOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ReverseOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ReverseOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1239 */
#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (527)
/* Type tt__PanTiltLimits is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PanTiltLimits': */
class SOAP_CMAC tt__PanTiltLimits : public xsd__anyType {
      public:
        /// Required element 'tt:Range' of XML schema type 'tt:Space2DDescription'
        tt__Space2DDescription *Range;
      public:
        /// Return unique type id SOAP_TYPE_tt__PanTiltLimits
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PanTiltLimits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PanTiltLimits, default initialized and not managed by a soap context
        virtual tt__PanTiltLimits *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PanTiltLimits); }
      public:
        /// Constructor with default initializations
        tt__PanTiltLimits() : Range() { }
        /// Destructor
        virtual ~tt__PanTiltLimits() { }
        /// Friend allocator used by soap_new_tt__PanTiltLimits(struct soap*, int)
        friend SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 soap_instantiate_tt__PanTiltLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1241 */
#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (528)
/* Type tt__ZoomLimits is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ZoomLimits': */
class SOAP_CMAC tt__ZoomLimits : public xsd__anyType {
      public:
        /// Required element 'tt:Range' of XML schema type 'tt:Space1DDescription'
        tt__Space1DDescription *Range;
      public:
        /// Return unique type id SOAP_TYPE_tt__ZoomLimits
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ZoomLimits; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ZoomLimits, default initialized and not managed by a soap context
        virtual tt__ZoomLimits *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ZoomLimits); }
      public:
        /// Constructor with default initializations
        tt__ZoomLimits() : Range() { }
        /// Destructor
        virtual ~tt__ZoomLimits() { }
        /// Friend allocator used by soap_new_tt__ZoomLimits(struct soap*, int)
        friend SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 soap_instantiate_tt__ZoomLimits(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1243 */
#ifndef SOAP_TYPE_tt__PTZSpaces
#define SOAP_TYPE_tt__PTZSpaces (529)
/* Type tt__PTZSpaces is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZSpaces': */
class SOAP_CMAC tt__PTZSpaces : public xsd__anyType {
      public:
        /// Optional element 'tt:AbsolutePanTiltPositionSpace' of XML schema type 'tt:Space2DDescription'
        std::vector<tt__Space2DDescription *> AbsolutePanTiltPositionSpace;
        /// Optional element 'tt:AbsoluteZoomPositionSpace' of XML schema type 'tt:Space1DDescription'
        std::vector<tt__Space1DDescription *> AbsoluteZoomPositionSpace;
        /// Optional element 'tt:RelativePanTiltTranslationSpace' of XML schema type 'tt:Space2DDescription'
        std::vector<tt__Space2DDescription *> RelativePanTiltTranslationSpace;
        /// Optional element 'tt:RelativeZoomTranslationSpace' of XML schema type 'tt:Space1DDescription'
        std::vector<tt__Space1DDescription *> RelativeZoomTranslationSpace;
        /// Optional element 'tt:ContinuousPanTiltVelocitySpace' of XML schema type 'tt:Space2DDescription'
        std::vector<tt__Space2DDescription *> ContinuousPanTiltVelocitySpace;
        /// Optional element 'tt:ContinuousZoomVelocitySpace' of XML schema type 'tt:Space1DDescription'
        std::vector<tt__Space1DDescription *> ContinuousZoomVelocitySpace;
        /// Optional element 'tt:PanTiltSpeedSpace' of XML schema type 'tt:Space1DDescription'
        std::vector<tt__Space1DDescription *> PanTiltSpeedSpace;
        /// Optional element 'tt:ZoomSpeedSpace' of XML schema type 'tt:Space1DDescription'
        std::vector<tt__Space1DDescription *> ZoomSpeedSpace;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZSpacesExtension'
        tt__PTZSpacesExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZSpaces
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZSpaces; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZSpaces, default initialized and not managed by a soap context
        virtual tt__PTZSpaces *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZSpaces); }
      public:
        /// Constructor with default initializations
        tt__PTZSpaces() : AbsolutePanTiltPositionSpace(), AbsoluteZoomPositionSpace(), RelativePanTiltTranslationSpace(), RelativeZoomTranslationSpace(), ContinuousPanTiltVelocitySpace(), ContinuousZoomVelocitySpace(), PanTiltSpeedSpace(), ZoomSpeedSpace(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZSpaces() { }
        /// Friend allocator used by soap_new_tt__PTZSpaces(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZSpaces * SOAP_FMAC2 soap_instantiate_tt__PTZSpaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1245 */
#ifndef SOAP_TYPE_tt__PTZSpacesExtension
#define SOAP_TYPE_tt__PTZSpacesExtension (530)
/* Type tt__PTZSpacesExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZSpacesExtension': */
class SOAP_CMAC tt__PTZSpacesExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZSpacesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZSpacesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZSpacesExtension, default initialized and not managed by a soap context
        virtual tt__PTZSpacesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZSpacesExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZSpacesExtension() : __any() { }
        /// Destructor
        virtual ~tt__PTZSpacesExtension() { }
        /// Friend allocator used by soap_new_tt__PTZSpacesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZSpacesExtension * SOAP_FMAC2 soap_instantiate_tt__PTZSpacesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1247 */
#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (531)
/* Type tt__Space2DDescription is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Space2DDescription': */
class SOAP_CMAC tt__Space2DDescription : public xsd__anyType {
      public:
        /// Required element 'tt:URI' of XML schema type 'xsd:anyURI'
        std::string URI;
        /// Required element 'tt:XRange' of XML schema type 'tt:FloatRange'
        tt__FloatRange *XRange;
        /// Required element 'tt:YRange' of XML schema type 'tt:FloatRange'
        tt__FloatRange *YRange;
      public:
        /// Return unique type id SOAP_TYPE_tt__Space2DDescription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Space2DDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Space2DDescription, default initialized and not managed by a soap context
        virtual tt__Space2DDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Space2DDescription); }
      public:
        /// Constructor with default initializations
        tt__Space2DDescription() : URI(), XRange(), YRange() { }
        /// Destructor
        virtual ~tt__Space2DDescription() { }
        /// Friend allocator used by soap_new_tt__Space2DDescription(struct soap*, int)
        friend SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 soap_instantiate_tt__Space2DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1249 */
#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (532)
/* Type tt__Space1DDescription is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Space1DDescription': */
class SOAP_CMAC tt__Space1DDescription : public xsd__anyType {
      public:
        /// Required element 'tt:URI' of XML schema type 'xsd:anyURI'
        std::string URI;
        /// Required element 'tt:XRange' of XML schema type 'tt:FloatRange'
        tt__FloatRange *XRange;
      public:
        /// Return unique type id SOAP_TYPE_tt__Space1DDescription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Space1DDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Space1DDescription, default initialized and not managed by a soap context
        virtual tt__Space1DDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Space1DDescription); }
      public:
        /// Constructor with default initializations
        tt__Space1DDescription() : URI(), XRange() { }
        /// Destructor
        virtual ~tt__Space1DDescription() { }
        /// Friend allocator used by soap_new_tt__Space1DDescription(struct soap*, int)
        friend SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 soap_instantiate_tt__Space1DDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1251 */
#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (533)
/* Type tt__PTZSpeed is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZSpeed': */
class SOAP_CMAC tt__PTZSpeed : public xsd__anyType {
      public:
        /// Optional element 'tt:PanTilt' of XML schema type 'tt:Vector2D'
        tt__Vector2D *PanTilt;
        /// Optional element 'tt:Zoom' of XML schema type 'tt:Vector1D'
        tt__Vector1D *Zoom;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZSpeed
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZSpeed; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZSpeed, default initialized and not managed by a soap context
        virtual tt__PTZSpeed *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZSpeed); }
      public:
        /// Constructor with default initializations
        tt__PTZSpeed() : PanTilt(), Zoom() { }
        /// Destructor
        virtual ~tt__PTZSpeed() { }
        /// Friend allocator used by soap_new_tt__PTZSpeed(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 soap_instantiate_tt__PTZSpeed(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1253 */
#ifndef SOAP_TYPE_tt__PTZPreset
#define SOAP_TYPE_tt__PTZPreset (534)
/* Type tt__PTZPreset is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPreset': */
class SOAP_CMAC tt__PTZPreset : public xsd__anyType {
      public:
        /// Optional element 'tt:Name' of XML schema type 'tt:Name'
        std::string *Name;
        /// Optional element 'tt:PTZPosition' of XML schema type 'tt:PTZVector'
        tt__PTZVector *PTZPosition;
        /// Optional attribute 'token' of XML schema type 'tt:ReferenceToken'
        std::string *token;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPreset
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPreset; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPreset, default initialized and not managed by a soap context
        virtual tt__PTZPreset *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPreset); }
      public:
        /// Constructor with default initializations
        tt__PTZPreset() : Name(), PTZPosition(), token(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZPreset() { }
        /// Friend allocator used by soap_new_tt__PTZPreset(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPreset * SOAP_FMAC2 soap_instantiate_tt__PTZPreset(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1255 */
#ifndef SOAP_TYPE_tt__PresetTour
#define SOAP_TYPE_tt__PresetTour (535)
/* Type tt__PresetTour is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PresetTour': */
class SOAP_CMAC tt__PresetTour : public xsd__anyType {
      public:
        /// Optional element 'tt:Name' of XML schema type 'tt:Name'
        std::string *Name;
        /// Required element 'tt:Status' of XML schema type 'tt:PTZPresetTourStatus'
        tt__PTZPresetTourStatus *Status;
        /// Required element 'tt:AutoStart' of XML schema type 'xsd:boolean'
        bool AutoStart;
        /// Required element 'tt:StartingCondition' of XML schema type 'tt:PTZPresetTourStartingCondition'
        tt__PTZPresetTourStartingCondition *StartingCondition;
        /// Optional element 'tt:TourSpot' of XML schema type 'tt:PTZPresetTourSpot'
        std::vector<tt__PTZPresetTourSpot *> TourSpot;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZPresetTourExtension'
        tt__PTZPresetTourExtension *Extension;
        /// Optional attribute 'token' of XML schema type 'tt:ReferenceToken'
        std::string *token;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PresetTour
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PresetTour; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PresetTour, default initialized and not managed by a soap context
        virtual tt__PresetTour *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PresetTour); }
      public:
        /// Constructor with default initializations
        tt__PresetTour() : Name(), Status(), AutoStart(), StartingCondition(), TourSpot(), Extension(), token(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PresetTour() { }
        /// Friend allocator used by soap_new_tt__PresetTour(struct soap*, int)
        friend SOAP_FMAC1 tt__PresetTour * SOAP_FMAC2 soap_instantiate_tt__PresetTour(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1257 */
#ifndef SOAP_TYPE_tt__PTZPresetTourExtension
#define SOAP_TYPE_tt__PTZPresetTourExtension (536)
/* Type tt__PTZPresetTourExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourExtension': */
class SOAP_CMAC tt__PTZPresetTourExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourExtension() : __any() { }
        /// Destructor
        virtual ~tt__PTZPresetTourExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1259 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpot
#define SOAP_TYPE_tt__PTZPresetTourSpot (537)
/* Type tt__PTZPresetTourSpot is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourSpot': */
class SOAP_CMAC tt__PTZPresetTourSpot : public xsd__anyType {
      public:
        /// Required element 'tt:PresetDetail' of XML schema type 'tt:PTZPresetTourPresetDetail'
        tt__PTZPresetTourPresetDetail *PresetDetail;
        /// Optional element 'tt:Speed' of XML schema type 'tt:PTZSpeed'
        tt__PTZSpeed *Speed;
        /// Optional element 'tt:StayTime' of XML schema type 'xsd:duration'
        std::string *StayTime;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZPresetTourSpotExtension'
        tt__PTZPresetTourSpotExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourSpot
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourSpot; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourSpot, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourSpot *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourSpot); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourSpot() : PresetDetail(), Speed(), StayTime(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZPresetTourSpot() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourSpot(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourSpot * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1261 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotExtension
#define SOAP_TYPE_tt__PTZPresetTourSpotExtension (538)
/* Type tt__PTZPresetTourSpotExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourSpotExtension': */
class SOAP_CMAC tt__PTZPresetTourSpotExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourSpotExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourSpotExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourSpotExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourSpotExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourSpotExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourSpotExtension() : __any() { }
        /// Destructor
        virtual ~tt__PTZPresetTourSpotExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourSpotExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourSpotExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:16834 */
#ifndef SOAP_TYPE__tt__union_PTZPresetTourPresetDetail
#define SOAP_TYPE__tt__union_PTZPresetTourPresetDetail (1307)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _tt__union_PTZPresetTourPresetDetail
{
        #define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken	(1)	/**< union variant selector value for member PresetToken */
        std::string *PresetToken;
        #define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home	(2)	/**< union variant selector value for member Home */
        bool Home;
        #define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition	(3)	/**< union variant selector value for member PTZPosition */
        tt__PTZVector *PTZPosition;
        #define SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension	(4)	/**< union variant selector value for member TypeExtension */
        tt__PTZPresetTourTypeExtension *TypeExtension;
};
#endif

/* onvif.h:1263 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetail
#define SOAP_TYPE_tt__PTZPresetTourPresetDetail (539)
/* Type tt__PTZPresetTourPresetDetail is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourPresetDetail': */
class SOAP_CMAC tt__PTZPresetTourPresetDetail : public xsd__anyType {
      public:
        /// Union with union _tt__union_PTZPresetTourPresetDetail variant selector __union_PTZPresetTourPresetDetail set to one of: SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension
        int __union_PTZPresetTourPresetDetail;
        union _tt__union_PTZPresetTourPresetDetail union_PTZPresetTourPresetDetail;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourPresetDetail
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourPresetDetail; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourPresetDetail, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourPresetDetail *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourPresetDetail); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourPresetDetail() : __union_PTZPresetTourPresetDetail(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZPresetTourPresetDetail() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourPresetDetail(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourPresetDetail * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetail(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1265 */
#ifndef SOAP_TYPE_tt__PTZPresetTourTypeExtension
#define SOAP_TYPE_tt__PTZPresetTourTypeExtension (540)
/* Type tt__PTZPresetTourTypeExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourTypeExtension': */
class SOAP_CMAC tt__PTZPresetTourTypeExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourTypeExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourTypeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourTypeExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourTypeExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourTypeExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourTypeExtension() : __any() { }
        /// Destructor
        virtual ~tt__PTZPresetTourTypeExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourTypeExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourTypeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourTypeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1267 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatus
#define SOAP_TYPE_tt__PTZPresetTourStatus (541)
/* Type tt__PTZPresetTourStatus is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourStatus': */
class SOAP_CMAC tt__PTZPresetTourStatus : public xsd__anyType {
      public:
        /// Required element 'tt:State' of XML schema type 'tt:PTZPresetTourState'
        enum tt__PTZPresetTourState State;
        /// Optional element 'tt:CurrentTourSpot' of XML schema type 'tt:PTZPresetTourSpot'
        tt__PTZPresetTourSpot *CurrentTourSpot;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZPresetTourStatusExtension'
        tt__PTZPresetTourStatusExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourStatus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourStatus, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourStatus); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourStatus() : State(), CurrentTourSpot(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZPresetTourStatus() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourStatus(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourStatus * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1269 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatusExtension
#define SOAP_TYPE_tt__PTZPresetTourStatusExtension (542)
/* Type tt__PTZPresetTourStatusExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourStatusExtension': */
class SOAP_CMAC tt__PTZPresetTourStatusExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourStatusExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourStatusExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourStatusExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourStatusExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourStatusExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourStatusExtension() : __any() { }
        /// Destructor
        virtual ~tt__PTZPresetTourStatusExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourStatusExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourStatusExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatusExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1271 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingCondition
#define SOAP_TYPE_tt__PTZPresetTourStartingCondition (543)
/* Type tt__PTZPresetTourStartingCondition is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourStartingCondition': */
class SOAP_CMAC tt__PTZPresetTourStartingCondition : public xsd__anyType {
      public:
        /// Optional element 'tt:RecurringTime' of XML schema type 'xsd:int'
        int *RecurringTime;
        /// Optional element 'tt:RecurringDuration' of XML schema type 'xsd:duration'
        std::string *RecurringDuration;
        /// Optional element 'tt:Direction' of XML schema type 'tt:PTZPresetTourDirection'
        enum tt__PTZPresetTourDirection *Direction;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZPresetTourStartingConditionExtension'
        tt__PTZPresetTourStartingConditionExtension *Extension;
        /// Optional attribute 'RandomPresetOrder' of XML schema type 'xsd:boolean'
        bool *RandomPresetOrder;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourStartingCondition
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourStartingCondition; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourStartingCondition, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourStartingCondition *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourStartingCondition); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourStartingCondition() : RecurringTime(), RecurringDuration(), Direction(), Extension(), RandomPresetOrder(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZPresetTourStartingCondition() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourStartingCondition(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourStartingCondition * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingCondition(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1273 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (544)
/* Type tt__PTZPresetTourStartingConditionExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourStartingConditionExtension': */
class SOAP_CMAC tt__PTZPresetTourStartingConditionExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourStartingConditionExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourStartingConditionExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourStartingConditionExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourStartingConditionExtension() : __any() { }
        /// Destructor
        virtual ~tt__PTZPresetTourStartingConditionExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourStartingConditionExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1275 */
#ifndef SOAP_TYPE_tt__PTZPresetTourOptions
#define SOAP_TYPE_tt__PTZPresetTourOptions (545)
/* Type tt__PTZPresetTourOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourOptions': */
class SOAP_CMAC tt__PTZPresetTourOptions : public xsd__anyType {
      public:
        /// Required element 'tt:AutoStart' of XML schema type 'xsd:boolean'
        bool AutoStart;
        /// Required element 'tt:StartingCondition' of XML schema type 'tt:PTZPresetTourStartingConditionOptions'
        tt__PTZPresetTourStartingConditionOptions *StartingCondition;
        /// Required element 'tt:TourSpot' of XML schema type 'tt:PTZPresetTourSpotOptions'
        tt__PTZPresetTourSpotOptions *TourSpot;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourOptions, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourOptions); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourOptions() : AutoStart(), StartingCondition(), TourSpot(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZPresetTourOptions() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1277 */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotOptions
#define SOAP_TYPE_tt__PTZPresetTourSpotOptions (546)
/* Type tt__PTZPresetTourSpotOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourSpotOptions': */
class SOAP_CMAC tt__PTZPresetTourSpotOptions : public xsd__anyType {
      public:
        /// Required element 'tt:PresetDetail' of XML schema type 'tt:PTZPresetTourPresetDetailOptions'
        tt__PTZPresetTourPresetDetailOptions *PresetDetail;
        /// Required element 'tt:StayTime' of XML schema type 'tt:DurationRange'
        tt__DurationRange *StayTime;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourSpotOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourSpotOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourSpotOptions, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourSpotOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourSpotOptions); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourSpotOptions() : PresetDetail(), StayTime(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZPresetTourSpotOptions() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourSpotOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourSpotOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1279 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (547)
/* Type tt__PTZPresetTourPresetDetailOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourPresetDetailOptions': */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:PresetToken' of XML schema type 'tt:ReferenceToken'
        std::vector<std::string> PresetToken;
        /// Optional element 'tt:Home' of XML schema type 'xsd:boolean'
        bool *Home;
        /// Optional element 'tt:PanTiltPositionSpace' of XML schema type 'tt:Space2DDescription'
        tt__Space2DDescription *PanTiltPositionSpace;
        /// Optional element 'tt:ZoomPositionSpace' of XML schema type 'tt:Space1DDescription'
        tt__Space1DDescription *ZoomPositionSpace;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZPresetTourPresetDetailOptionsExtension'
        tt__PTZPresetTourPresetDetailOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourPresetDetailOptions, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourPresetDetailOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourPresetDetailOptions); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourPresetDetailOptions() : PresetToken(), Home(), PanTiltPositionSpace(), ZoomPositionSpace(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZPresetTourPresetDetailOptions() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourPresetDetailOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1281 */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (548)
/* Type tt__PTZPresetTourPresetDetailOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourPresetDetailOptionsExtension': */
class SOAP_CMAC tt__PTZPresetTourPresetDetailOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourPresetDetailOptionsExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourPresetDetailOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourPresetDetailOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourPresetDetailOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__PTZPresetTourPresetDetailOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1283 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (549)
/* Type tt__PTZPresetTourStartingConditionOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourStartingConditionOptions': */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:RecurringTime' of XML schema type 'tt:IntRange'
        tt__IntRange *RecurringTime;
        /// Optional element 'tt:RecurringDuration' of XML schema type 'tt:DurationRange'
        tt__DurationRange *RecurringDuration;
        /// Optional element 'tt:Direction' of XML schema type 'tt:PTZPresetTourDirection'
        std::vector<enum tt__PTZPresetTourDirection> Direction;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZPresetTourStartingConditionOptionsExtension'
        tt__PTZPresetTourStartingConditionOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourStartingConditionOptions, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourStartingConditionOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourStartingConditionOptions); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourStartingConditionOptions() : RecurringTime(), RecurringDuration(), Direction(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZPresetTourStartingConditionOptions() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourStartingConditionOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1285 */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (550)
/* Type tt__PTZPresetTourStartingConditionOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPresetTourStartingConditionOptionsExtension': */
class SOAP_CMAC tt__PTZPresetTourStartingConditionOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPresetTourStartingConditionOptionsExtension, default initialized and not managed by a soap context
        virtual tt__PTZPresetTourStartingConditionOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPresetTourStartingConditionOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__PTZPresetTourStartingConditionOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__PTZPresetTourStartingConditionOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1287 */
#ifndef SOAP_TYPE_tt__ImagingStatus
#define SOAP_TYPE_tt__ImagingStatus (551)
/* Type tt__ImagingStatus is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingStatus': */
class SOAP_CMAC tt__ImagingStatus : public xsd__anyType {
      public:
        /// Required element 'tt:FocusStatus' of XML schema type 'tt:FocusStatus'
        tt__FocusStatus *FocusStatus;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingStatus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingStatus, default initialized and not managed by a soap context
        virtual tt__ImagingStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingStatus); }
      public:
        /// Constructor with default initializations
        tt__ImagingStatus() : FocusStatus(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ImagingStatus() { }
        /// Friend allocator used by soap_new_tt__ImagingStatus(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingStatus * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1289 */
#ifndef SOAP_TYPE_tt__FocusStatus
#define SOAP_TYPE_tt__FocusStatus (552)
/* Type tt__FocusStatus is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FocusStatus': */
class SOAP_CMAC tt__FocusStatus : public xsd__anyType {
      public:
        /// Required element 'tt:Position' of XML schema type 'xsd:float'
        float Position;
        /// Required element 'tt:MoveStatus' of XML schema type 'tt:MoveStatus'
        enum tt__MoveStatus MoveStatus;
        /// Required element 'tt:Error' of XML schema type 'xsd:string'
        std::string Error;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusStatus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusStatus, default initialized and not managed by a soap context
        virtual tt__FocusStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusStatus); }
      public:
        /// Constructor with default initializations
        tt__FocusStatus() : Position(), MoveStatus(), Error(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__FocusStatus() { }
        /// Friend allocator used by soap_new_tt__FocusStatus(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusStatus * SOAP_FMAC2 soap_instantiate_tt__FocusStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1291 */
#ifndef SOAP_TYPE_tt__FocusConfiguration
#define SOAP_TYPE_tt__FocusConfiguration (553)
/* Type tt__FocusConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FocusConfiguration': */
class SOAP_CMAC tt__FocusConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:AutoFocusMode' of XML schema type 'tt:AutoFocusMode'
        enum tt__AutoFocusMode AutoFocusMode;
        /// Required element 'tt:DefaultSpeed' of XML schema type 'xsd:float'
        float DefaultSpeed;
        /// Required element 'tt:NearLimit' of XML schema type 'xsd:float'
        float NearLimit;
        /// Required element 'tt:FarLimit' of XML schema type 'xsd:float'
        float FarLimit;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusConfiguration, default initialized and not managed by a soap context
        virtual tt__FocusConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusConfiguration); }
      public:
        /// Constructor with default initializations
        tt__FocusConfiguration() : AutoFocusMode(), DefaultSpeed(), NearLimit(), FarLimit(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__FocusConfiguration() { }
        /// Friend allocator used by soap_new_tt__FocusConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusConfiguration * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1293 */
#ifndef SOAP_TYPE_tt__ImagingSettings
#define SOAP_TYPE_tt__ImagingSettings (554)
/* Type tt__ImagingSettings is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingSettings': */
class SOAP_CMAC tt__ImagingSettings : public xsd__anyType {
      public:
        /// Optional element 'tt:BacklightCompensation' of XML schema type 'tt:BacklightCompensation'
        tt__BacklightCompensation *BacklightCompensation;
        /// Optional element 'tt:Brightness' of XML schema type 'xsd:float'
        float *Brightness;
        /// Optional element 'tt:ColorSaturation' of XML schema type 'xsd:float'
        float *ColorSaturation;
        /// Optional element 'tt:Contrast' of XML schema type 'xsd:float'
        float *Contrast;
        /// Optional element 'tt:Exposure' of XML schema type 'tt:Exposure'
        tt__Exposure *Exposure;
        /// Optional element 'tt:Focus' of XML schema type 'tt:FocusConfiguration'
        tt__FocusConfiguration *Focus;
        /// Optional element 'tt:IrCutFilter' of XML schema type 'tt:IrCutFilterMode'
        enum tt__IrCutFilterMode *IrCutFilter;
        /// Optional element 'tt:Sharpness' of XML schema type 'xsd:float'
        float *Sharpness;
        /// Optional element 'tt:WideDynamicRange' of XML schema type 'tt:WideDynamicRange'
        tt__WideDynamicRange *WideDynamicRange;
        /// Optional element 'tt:WhiteBalance' of XML schema type 'tt:WhiteBalance'
        tt__WhiteBalance *WhiteBalance;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingSettingsExtension'
        tt__ImagingSettingsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettings
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettings; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettings, default initialized and not managed by a soap context
        virtual tt__ImagingSettings *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettings); }
      public:
        /// Constructor with default initializations
        tt__ImagingSettings() : BacklightCompensation(), Brightness(), ColorSaturation(), Contrast(), Exposure(), Focus(), IrCutFilter(), Sharpness(), WideDynamicRange(), WhiteBalance(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ImagingSettings() { }
        /// Friend allocator used by soap_new_tt__ImagingSettings(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettings * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1295 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension
#define SOAP_TYPE_tt__ImagingSettingsExtension (555)
/* Type tt__ImagingSettingsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingSettingsExtension': */
class SOAP_CMAC tt__ImagingSettingsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension); }
      public:
        /// Constructor with default initializations
        tt__ImagingSettingsExtension() : __any() { }
        /// Destructor
        virtual ~tt__ImagingSettingsExtension() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1297 */
#ifndef SOAP_TYPE_tt__Exposure
#define SOAP_TYPE_tt__Exposure (556)
/* Type tt__Exposure is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Exposure': */
class SOAP_CMAC tt__Exposure : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ExposureMode'
        enum tt__ExposureMode Mode;
        /// Required element 'tt:Priority' of XML schema type 'tt:ExposurePriority'
        enum tt__ExposurePriority Priority;
        /// Required element 'tt:Window' of XML schema type 'tt:Rectangle'
        tt__Rectangle *Window;
        /// Required element 'tt:MinExposureTime' of XML schema type 'xsd:float'
        float MinExposureTime;
        /// Required element 'tt:MaxExposureTime' of XML schema type 'xsd:float'
        float MaxExposureTime;
        /// Required element 'tt:MinGain' of XML schema type 'xsd:float'
        float MinGain;
        /// Required element 'tt:MaxGain' of XML schema type 'xsd:float'
        float MaxGain;
        /// Required element 'tt:MinIris' of XML schema type 'xsd:float'
        float MinIris;
        /// Required element 'tt:MaxIris' of XML schema type 'xsd:float'
        float MaxIris;
        /// Required element 'tt:ExposureTime' of XML schema type 'xsd:float'
        float ExposureTime;
        /// Required element 'tt:Gain' of XML schema type 'xsd:float'
        float Gain;
        /// Required element 'tt:Iris' of XML schema type 'xsd:float'
        float Iris;
      public:
        /// Return unique type id SOAP_TYPE_tt__Exposure
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Exposure; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Exposure, default initialized and not managed by a soap context
        virtual tt__Exposure *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Exposure); }
      public:
        /// Constructor with default initializations
        tt__Exposure() : Mode(), Priority(), Window(), MinExposureTime(), MaxExposureTime(), MinGain(), MaxGain(), MinIris(), MaxIris(), ExposureTime(), Gain(), Iris() { }
        /// Destructor
        virtual ~tt__Exposure() { }
        /// Friend allocator used by soap_new_tt__Exposure(struct soap*, int)
        friend SOAP_FMAC1 tt__Exposure * SOAP_FMAC2 soap_instantiate_tt__Exposure(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1299 */
#ifndef SOAP_TYPE_tt__WideDynamicRange
#define SOAP_TYPE_tt__WideDynamicRange (557)
/* Type tt__WideDynamicRange is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:WideDynamicRange': */
class SOAP_CMAC tt__WideDynamicRange : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WideDynamicMode'
        enum tt__WideDynamicMode Mode;
        /// Required element 'tt:Level' of XML schema type 'xsd:float'
        float Level;
      public:
        /// Return unique type id SOAP_TYPE_tt__WideDynamicRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WideDynamicRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WideDynamicRange, default initialized and not managed by a soap context
        virtual tt__WideDynamicRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WideDynamicRange); }
      public:
        /// Constructor with default initializations
        tt__WideDynamicRange() : Mode(), Level() { }
        /// Destructor
        virtual ~tt__WideDynamicRange() { }
        /// Friend allocator used by soap_new_tt__WideDynamicRange(struct soap*, int)
        friend SOAP_FMAC1 tt__WideDynamicRange * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1301 */
#ifndef SOAP_TYPE_tt__BacklightCompensation
#define SOAP_TYPE_tt__BacklightCompensation (558)
/* Type tt__BacklightCompensation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:BacklightCompensation': */
class SOAP_CMAC tt__BacklightCompensation : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:BacklightCompensationMode'
        enum tt__BacklightCompensationMode Mode;
        /// Required element 'tt:Level' of XML schema type 'xsd:float'
        float Level;
      public:
        /// Return unique type id SOAP_TYPE_tt__BacklightCompensation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BacklightCompensation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BacklightCompensation, default initialized and not managed by a soap context
        virtual tt__BacklightCompensation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BacklightCompensation); }
      public:
        /// Constructor with default initializations
        tt__BacklightCompensation() : Mode(), Level() { }
        /// Destructor
        virtual ~tt__BacklightCompensation() { }
        /// Friend allocator used by soap_new_tt__BacklightCompensation(struct soap*, int)
        friend SOAP_FMAC1 tt__BacklightCompensation * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1303 */
#ifndef SOAP_TYPE_tt__ImagingOptions
#define SOAP_TYPE_tt__ImagingOptions (559)
/* Type tt__ImagingOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingOptions': */
class SOAP_CMAC tt__ImagingOptions : public xsd__anyType {
      public:
        /// Required element 'tt:BacklightCompensation' of XML schema type 'tt:BacklightCompensationOptions'
        tt__BacklightCompensationOptions *BacklightCompensation;
        /// Required element 'tt:Brightness' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Brightness;
        /// Required element 'tt:ColorSaturation' of XML schema type 'tt:FloatRange'
        tt__FloatRange *ColorSaturation;
        /// Required element 'tt:Contrast' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Contrast;
        /// Required element 'tt:Exposure' of XML schema type 'tt:ExposureOptions'
        tt__ExposureOptions *Exposure;
        /// Required element 'tt:Focus' of XML schema type 'tt:FocusOptions'
        tt__FocusOptions *Focus;
        /// Required element 'tt:IrCutFilterModes' of XML schema type 'tt:IrCutFilterMode'
        std::vector<enum tt__IrCutFilterMode> IrCutFilterModes;
        /// Required element 'tt:Sharpness' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Sharpness;
        /// Required element 'tt:WideDynamicRange' of XML schema type 'tt:WideDynamicRangeOptions'
        tt__WideDynamicRangeOptions *WideDynamicRange;
        /// Required element 'tt:WhiteBalance' of XML schema type 'tt:WhiteBalanceOptions'
        tt__WhiteBalanceOptions *WhiteBalance;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions, default initialized and not managed by a soap context
        virtual tt__ImagingOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions); }
      public:
        /// Constructor with default initializations
        tt__ImagingOptions() : BacklightCompensation(), Brightness(), ColorSaturation(), Contrast(), Exposure(), Focus(), IrCutFilterModes(), Sharpness(), WideDynamicRange(), WhiteBalance(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ImagingOptions() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1305 */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions
#define SOAP_TYPE_tt__WideDynamicRangeOptions (560)
/* Type tt__WideDynamicRangeOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:WideDynamicRangeOptions': */
class SOAP_CMAC tt__WideDynamicRangeOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WideDynamicMode'
        std::vector<enum tt__WideDynamicMode> Mode;
        /// Required element 'tt:Level' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Level;
      public:
        /// Return unique type id SOAP_TYPE_tt__WideDynamicRangeOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WideDynamicRangeOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WideDynamicRangeOptions, default initialized and not managed by a soap context
        virtual tt__WideDynamicRangeOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WideDynamicRangeOptions); }
      public:
        /// Constructor with default initializations
        tt__WideDynamicRangeOptions() : Mode(), Level() { }
        /// Destructor
        virtual ~tt__WideDynamicRangeOptions() { }
        /// Friend allocator used by soap_new_tt__WideDynamicRangeOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__WideDynamicRangeOptions * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1307 */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions
#define SOAP_TYPE_tt__BacklightCompensationOptions (561)
/* Type tt__BacklightCompensationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:BacklightCompensationOptions': */
class SOAP_CMAC tt__BacklightCompensationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WideDynamicMode'
        std::vector<enum tt__WideDynamicMode> Mode;
        /// Required element 'tt:Level' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Level;
      public:
        /// Return unique type id SOAP_TYPE_tt__BacklightCompensationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BacklightCompensationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BacklightCompensationOptions, default initialized and not managed by a soap context
        virtual tt__BacklightCompensationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BacklightCompensationOptions); }
      public:
        /// Constructor with default initializations
        tt__BacklightCompensationOptions() : Mode(), Level() { }
        /// Destructor
        virtual ~tt__BacklightCompensationOptions() { }
        /// Friend allocator used by soap_new_tt__BacklightCompensationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__BacklightCompensationOptions * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1309 */
#ifndef SOAP_TYPE_tt__FocusOptions
#define SOAP_TYPE_tt__FocusOptions (562)
/* Type tt__FocusOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FocusOptions': */
class SOAP_CMAC tt__FocusOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:AutoFocusModes' of XML schema type 'tt:AutoFocusMode'
        std::vector<enum tt__AutoFocusMode> AutoFocusModes;
        /// Required element 'tt:DefaultSpeed' of XML schema type 'tt:FloatRange'
        tt__FloatRange *DefaultSpeed;
        /// Required element 'tt:NearLimit' of XML schema type 'tt:FloatRange'
        tt__FloatRange *NearLimit;
        /// Required element 'tt:FarLimit' of XML schema type 'tt:FloatRange'
        tt__FloatRange *FarLimit;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusOptions, default initialized and not managed by a soap context
        virtual tt__FocusOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusOptions); }
      public:
        /// Constructor with default initializations
        tt__FocusOptions() : AutoFocusModes(), DefaultSpeed(), NearLimit(), FarLimit() { }
        /// Destructor
        virtual ~tt__FocusOptions() { }
        /// Friend allocator used by soap_new_tt__FocusOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusOptions * SOAP_FMAC2 soap_instantiate_tt__FocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1311 */
#ifndef SOAP_TYPE_tt__ExposureOptions
#define SOAP_TYPE_tt__ExposureOptions (563)
/* Type tt__ExposureOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ExposureOptions': */
class SOAP_CMAC tt__ExposureOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ExposureMode'
        std::vector<enum tt__ExposureMode> Mode;
        /// Required element 'tt:Priority' of XML schema type 'tt:ExposurePriority'
        std::vector<enum tt__ExposurePriority> Priority;
        /// Required element 'tt:MinExposureTime' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MinExposureTime;
        /// Required element 'tt:MaxExposureTime' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MaxExposureTime;
        /// Required element 'tt:MinGain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MinGain;
        /// Required element 'tt:MaxGain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MaxGain;
        /// Required element 'tt:MinIris' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MinIris;
        /// Required element 'tt:MaxIris' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MaxIris;
        /// Required element 'tt:ExposureTime' of XML schema type 'tt:FloatRange'
        tt__FloatRange *ExposureTime;
        /// Required element 'tt:Gain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Gain;
        /// Required element 'tt:Iris' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Iris;
      public:
        /// Return unique type id SOAP_TYPE_tt__ExposureOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ExposureOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ExposureOptions, default initialized and not managed by a soap context
        virtual tt__ExposureOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ExposureOptions); }
      public:
        /// Constructor with default initializations
        tt__ExposureOptions() : Mode(), Priority(), MinExposureTime(), MaxExposureTime(), MinGain(), MaxGain(), MinIris(), MaxIris(), ExposureTime(), Gain(), Iris() { }
        /// Destructor
        virtual ~tt__ExposureOptions() { }
        /// Friend allocator used by soap_new_tt__ExposureOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ExposureOptions * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1313 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions
#define SOAP_TYPE_tt__WhiteBalanceOptions (564)
/* Type tt__WhiteBalanceOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:WhiteBalanceOptions': */
class SOAP_CMAC tt__WhiteBalanceOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WhiteBalanceMode'
        std::vector<enum tt__WhiteBalanceMode> Mode;
        /// Required element 'tt:YrGain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *YrGain;
        /// Required element 'tt:YbGain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *YbGain;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalanceOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalanceOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalanceOptions, default initialized and not managed by a soap context
        virtual tt__WhiteBalanceOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalanceOptions); }
      public:
        /// Constructor with default initializations
        tt__WhiteBalanceOptions() : Mode(), YrGain(), YbGain() { }
        /// Destructor
        virtual ~tt__WhiteBalanceOptions() { }
        /// Friend allocator used by soap_new_tt__WhiteBalanceOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalanceOptions * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1315 */
#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (565)
/* Type tt__FocusMove is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FocusMove': */
class SOAP_CMAC tt__FocusMove : public xsd__anyType {
      public:
        /// Optional element 'tt:Absolute' of XML schema type 'tt:AbsoluteFocus'
        tt__AbsoluteFocus *Absolute;
        /// Optional element 'tt:Relative' of XML schema type 'tt:RelativeFocus'
        tt__RelativeFocus *Relative;
        /// Optional element 'tt:Continuous' of XML schema type 'tt:ContinuousFocus'
        tt__ContinuousFocus *Continuous;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusMove
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusMove; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusMove, default initialized and not managed by a soap context
        virtual tt__FocusMove *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusMove); }
      public:
        /// Constructor with default initializations
        tt__FocusMove() : Absolute(), Relative(), Continuous() { }
        /// Destructor
        virtual ~tt__FocusMove() { }
        /// Friend allocator used by soap_new_tt__FocusMove(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusMove * SOAP_FMAC2 soap_instantiate_tt__FocusMove(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1317 */
#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (566)
/* Type tt__AbsoluteFocus is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AbsoluteFocus': */
class SOAP_CMAC tt__AbsoluteFocus : public xsd__anyType {
      public:
        /// Required element 'tt:Position' of XML schema type 'xsd:float'
        float Position;
        /// Optional element 'tt:Speed' of XML schema type 'xsd:float'
        float *Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__AbsoluteFocus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AbsoluteFocus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AbsoluteFocus, default initialized and not managed by a soap context
        virtual tt__AbsoluteFocus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AbsoluteFocus); }
      public:
        /// Constructor with default initializations
        tt__AbsoluteFocus() : Position(), Speed() { }
        /// Destructor
        virtual ~tt__AbsoluteFocus() { }
        /// Friend allocator used by soap_new_tt__AbsoluteFocus(struct soap*, int)
        friend SOAP_FMAC1 tt__AbsoluteFocus * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1319 */
#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (567)
/* Type tt__RelativeFocus is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RelativeFocus': */
class SOAP_CMAC tt__RelativeFocus : public xsd__anyType {
      public:
        /// Required element 'tt:Distance' of XML schema type 'xsd:float'
        float Distance;
        /// Optional element 'tt:Speed' of XML schema type 'xsd:float'
        float *Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelativeFocus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelativeFocus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelativeFocus, default initialized and not managed by a soap context
        virtual tt__RelativeFocus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelativeFocus); }
      public:
        /// Constructor with default initializations
        tt__RelativeFocus() : Distance(), Speed() { }
        /// Destructor
        virtual ~tt__RelativeFocus() { }
        /// Friend allocator used by soap_new_tt__RelativeFocus(struct soap*, int)
        friend SOAP_FMAC1 tt__RelativeFocus * SOAP_FMAC2 soap_instantiate_tt__RelativeFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1321 */
#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (568)
/* Type tt__ContinuousFocus is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ContinuousFocus': */
class SOAP_CMAC tt__ContinuousFocus : public xsd__anyType {
      public:
        /// Required element 'tt:Speed' of XML schema type 'xsd:float'
        float Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__ContinuousFocus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ContinuousFocus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ContinuousFocus, default initialized and not managed by a soap context
        virtual tt__ContinuousFocus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ContinuousFocus); }
      public:
        /// Constructor with default initializations
        tt__ContinuousFocus() : Speed() { }
        /// Destructor
        virtual ~tt__ContinuousFocus() { }
        /// Friend allocator used by soap_new_tt__ContinuousFocus(struct soap*, int)
        friend SOAP_FMAC1 tt__ContinuousFocus * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1323 */
#ifndef SOAP_TYPE_tt__MoveOptions
#define SOAP_TYPE_tt__MoveOptions (569)
/* Type tt__MoveOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MoveOptions': */
class SOAP_CMAC tt__MoveOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:Absolute' of XML schema type 'tt:AbsoluteFocusOptions'
        tt__AbsoluteFocusOptions *Absolute;
        /// Optional element 'tt:Relative' of XML schema type 'tt:RelativeFocusOptions'
        tt__RelativeFocusOptions *Relative;
        /// Optional element 'tt:Continuous' of XML schema type 'tt:ContinuousFocusOptions'
        tt__ContinuousFocusOptions *Continuous;
      public:
        /// Return unique type id SOAP_TYPE_tt__MoveOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MoveOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MoveOptions, default initialized and not managed by a soap context
        virtual tt__MoveOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MoveOptions); }
      public:
        /// Constructor with default initializations
        tt__MoveOptions() : Absolute(), Relative(), Continuous() { }
        /// Destructor
        virtual ~tt__MoveOptions() { }
        /// Friend allocator used by soap_new_tt__MoveOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__MoveOptions * SOAP_FMAC2 soap_instantiate_tt__MoveOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1325 */
#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (570)
/* Type tt__AbsoluteFocusOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AbsoluteFocusOptions': */
class SOAP_CMAC tt__AbsoluteFocusOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Position' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Position;
        /// Optional element 'tt:Speed' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__AbsoluteFocusOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AbsoluteFocusOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AbsoluteFocusOptions, default initialized and not managed by a soap context
        virtual tt__AbsoluteFocusOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AbsoluteFocusOptions); }
      public:
        /// Constructor with default initializations
        tt__AbsoluteFocusOptions() : Position(), Speed() { }
        /// Destructor
        virtual ~tt__AbsoluteFocusOptions() { }
        /// Friend allocator used by soap_new_tt__AbsoluteFocusOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__AbsoluteFocusOptions * SOAP_FMAC2 soap_instantiate_tt__AbsoluteFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1327 */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions
#define SOAP_TYPE_tt__RelativeFocusOptions (571)
/* Type tt__RelativeFocusOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RelativeFocusOptions': */
class SOAP_CMAC tt__RelativeFocusOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Distance' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Distance;
        /// Required element 'tt:Speed' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelativeFocusOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelativeFocusOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelativeFocusOptions, default initialized and not managed by a soap context
        virtual tt__RelativeFocusOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelativeFocusOptions); }
      public:
        /// Constructor with default initializations
        tt__RelativeFocusOptions() : Distance(), Speed() { }
        /// Destructor
        virtual ~tt__RelativeFocusOptions() { }
        /// Friend allocator used by soap_new_tt__RelativeFocusOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__RelativeFocusOptions * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1329 */
#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (572)
/* Type tt__ContinuousFocusOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ContinuousFocusOptions': */
class SOAP_CMAC tt__ContinuousFocusOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Speed' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__ContinuousFocusOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ContinuousFocusOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ContinuousFocusOptions, default initialized and not managed by a soap context
        virtual tt__ContinuousFocusOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ContinuousFocusOptions); }
      public:
        /// Constructor with default initializations
        tt__ContinuousFocusOptions() : Speed() { }
        /// Destructor
        virtual ~tt__ContinuousFocusOptions() { }
        /// Friend allocator used by soap_new_tt__ContinuousFocusOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ContinuousFocusOptions * SOAP_FMAC2 soap_instantiate_tt__ContinuousFocusOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1331 */
#ifndef SOAP_TYPE_tt__WhiteBalance
#define SOAP_TYPE_tt__WhiteBalance (573)
/* Type tt__WhiteBalance is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:WhiteBalance': */
class SOAP_CMAC tt__WhiteBalance : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WhiteBalanceMode'
        enum tt__WhiteBalanceMode Mode;
        /// Required element 'tt:CrGain' of XML schema type 'xsd:float'
        float CrGain;
        /// Required element 'tt:CbGain' of XML schema type 'xsd:float'
        float CbGain;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalance
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalance; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalance, default initialized and not managed by a soap context
        virtual tt__WhiteBalance *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalance); }
      public:
        /// Constructor with default initializations
        tt__WhiteBalance() : Mode(), CrGain(), CbGain(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__WhiteBalance() { }
        /// Friend allocator used by soap_new_tt__WhiteBalance(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalance * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1333 */
#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (574)
/* Type tt__ImagingStatus20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingStatus20': */
class SOAP_CMAC tt__ImagingStatus20 : public xsd__anyType {
      public:
        /// Optional element 'tt:FocusStatus20' of XML schema type 'tt:FocusStatus20'
        tt__FocusStatus20 *FocusStatus20;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingStatus20Extension'
        tt__ImagingStatus20Extension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingStatus20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingStatus20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingStatus20, default initialized and not managed by a soap context
        virtual tt__ImagingStatus20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingStatus20); }
      public:
        /// Constructor with default initializations
        tt__ImagingStatus20() : FocusStatus20(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ImagingStatus20() { }
        /// Friend allocator used by soap_new_tt__ImagingStatus20(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingStatus20 * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1335 */
#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (575)
/* Type tt__ImagingStatus20Extension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingStatus20Extension': */
class SOAP_CMAC tt__ImagingStatus20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingStatus20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingStatus20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingStatus20Extension, default initialized and not managed by a soap context
        virtual tt__ImagingStatus20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingStatus20Extension); }
      public:
        /// Constructor with default initializations
        tt__ImagingStatus20Extension() : __any() { }
        /// Destructor
        virtual ~tt__ImagingStatus20Extension() { }
        /// Friend allocator used by soap_new_tt__ImagingStatus20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1337 */
#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (576)
/* Type tt__FocusStatus20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FocusStatus20': */
class SOAP_CMAC tt__FocusStatus20 : public xsd__anyType {
      public:
        /// Required element 'tt:Position' of XML schema type 'xsd:float'
        float Position;
        /// Required element 'tt:MoveStatus' of XML schema type 'tt:MoveStatus'
        enum tt__MoveStatus MoveStatus;
        /// Optional element 'tt:Error' of XML schema type 'xsd:string'
        std::string *Error;
        /// Optional element 'tt:Extension' of XML schema type 'tt:FocusStatus20Extension'
        tt__FocusStatus20Extension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusStatus20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusStatus20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusStatus20, default initialized and not managed by a soap context
        virtual tt__FocusStatus20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusStatus20); }
      public:
        /// Constructor with default initializations
        tt__FocusStatus20() : Position(), MoveStatus(), Error(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__FocusStatus20() { }
        /// Friend allocator used by soap_new_tt__FocusStatus20(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusStatus20 * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1339 */
#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (577)
/* Type tt__FocusStatus20Extension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FocusStatus20Extension': */
class SOAP_CMAC tt__FocusStatus20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusStatus20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusStatus20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusStatus20Extension, default initialized and not managed by a soap context
        virtual tt__FocusStatus20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusStatus20Extension); }
      public:
        /// Constructor with default initializations
        tt__FocusStatus20Extension() : __any() { }
        /// Destructor
        virtual ~tt__FocusStatus20Extension() { }
        /// Friend allocator used by soap_new_tt__FocusStatus20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusStatus20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusStatus20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1341 */
#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (578)
/* Type tt__ImagingSettings20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingSettings20': */
class SOAP_CMAC tt__ImagingSettings20 : public xsd__anyType {
      public:
        /// Optional element 'tt:BacklightCompensation' of XML schema type 'tt:BacklightCompensation20'
        tt__BacklightCompensation20 *BacklightCompensation;
        /// Optional element 'tt:Brightness' of XML schema type 'xsd:float'
        float *Brightness;
        /// Optional element 'tt:ColorSaturation' of XML schema type 'xsd:float'
        float *ColorSaturation;
        /// Optional element 'tt:Contrast' of XML schema type 'xsd:float'
        float *Contrast;
        /// Optional element 'tt:Exposure' of XML schema type 'tt:Exposure20'
        tt__Exposure20 *Exposure;
        /// Optional element 'tt:Focus' of XML schema type 'tt:FocusConfiguration20'
        tt__FocusConfiguration20 *Focus;
        /// Optional element 'tt:IrCutFilter' of XML schema type 'tt:IrCutFilterMode'
        enum tt__IrCutFilterMode *IrCutFilter;
        /// Optional element 'tt:Sharpness' of XML schema type 'xsd:float'
        float *Sharpness;
        /// Optional element 'tt:WideDynamicRange' of XML schema type 'tt:WideDynamicRange20'
        tt__WideDynamicRange20 *WideDynamicRange;
        /// Optional element 'tt:WhiteBalance' of XML schema type 'tt:WhiteBalance20'
        tt__WhiteBalance20 *WhiteBalance;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingSettingsExtension20'
        tt__ImagingSettingsExtension20 *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettings20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettings20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettings20, default initialized and not managed by a soap context
        virtual tt__ImagingSettings20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettings20); }
      public:
        /// Constructor with default initializations
        tt__ImagingSettings20() : BacklightCompensation(), Brightness(), ColorSaturation(), Contrast(), Exposure(), Focus(), IrCutFilter(), Sharpness(), WideDynamicRange(), WhiteBalance(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ImagingSettings20() { }
        /// Friend allocator used by soap_new_tt__ImagingSettings20(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettings20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettings20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1343 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (579)
/* Type tt__ImagingSettingsExtension20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingSettingsExtension20': */
class SOAP_CMAC tt__ImagingSettingsExtension20 : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:ImageStabilization' of XML schema type 'tt:ImageStabilization'
        tt__ImageStabilization *ImageStabilization;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingSettingsExtension202'
        tt__ImagingSettingsExtension202 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension20, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension20); }
      public:
        /// Constructor with default initializations
        tt__ImagingSettingsExtension20() : __any(), ImageStabilization(), Extension() { }
        /// Destructor
        virtual ~tt__ImagingSettingsExtension20() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension20(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension20 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1345 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202
#define SOAP_TYPE_tt__ImagingSettingsExtension202 (580)
/* Type tt__ImagingSettingsExtension202 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingSettingsExtension202': */
class SOAP_CMAC tt__ImagingSettingsExtension202 : public xsd__anyType {
      public:
        /// Optional element 'tt:IrCutFilterAutoAdjustment' of XML schema type 'tt:IrCutFilterAutoAdjustment'
        std::vector<tt__IrCutFilterAutoAdjustment *> IrCutFilterAutoAdjustment;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingSettingsExtension203'
        tt__ImagingSettingsExtension203 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension202
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension202; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension202, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension202 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension202); }
      public:
        /// Constructor with default initializations
        tt__ImagingSettingsExtension202() : IrCutFilterAutoAdjustment(), Extension() { }
        /// Destructor
        virtual ~tt__ImagingSettingsExtension202() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension202(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension202 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension202(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1347 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension203
#define SOAP_TYPE_tt__ImagingSettingsExtension203 (581)
/* Type tt__ImagingSettingsExtension203 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingSettingsExtension203': */
class SOAP_CMAC tt__ImagingSettingsExtension203 : public xsd__anyType {
      public:
        /// Optional element 'tt:ToneCompensation' of XML schema type 'tt:ToneCompensation'
        tt__ToneCompensation *ToneCompensation;
        /// Optional element 'tt:Defogging' of XML schema type 'tt:Defogging'
        tt__Defogging *Defogging;
        /// Optional element 'tt:NoiseReduction' of XML schema type 'tt:NoiseReduction'
        tt__NoiseReduction *NoiseReduction;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingSettingsExtension204'
        tt__ImagingSettingsExtension204 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension203
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension203; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension203, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension203 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension203); }
      public:
        /// Constructor with default initializations
        tt__ImagingSettingsExtension203() : ToneCompensation(), Defogging(), NoiseReduction(), Extension() { }
        /// Destructor
        virtual ~tt__ImagingSettingsExtension203() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension203(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension203 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension203(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1349 */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension204
#define SOAP_TYPE_tt__ImagingSettingsExtension204 (582)
/* Type tt__ImagingSettingsExtension204 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingSettingsExtension204': */
class SOAP_CMAC tt__ImagingSettingsExtension204 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingSettingsExtension204
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingSettingsExtension204; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingSettingsExtension204, default initialized and not managed by a soap context
        virtual tt__ImagingSettingsExtension204 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingSettingsExtension204); }
      public:
        /// Constructor with default initializations
        tt__ImagingSettingsExtension204() : __any() { }
        /// Destructor
        virtual ~tt__ImagingSettingsExtension204() { }
        /// Friend allocator used by soap_new_tt__ImagingSettingsExtension204(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingSettingsExtension204 * SOAP_FMAC2 soap_instantiate_tt__ImagingSettingsExtension204(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1351 */
#ifndef SOAP_TYPE_tt__ImageStabilization
#define SOAP_TYPE_tt__ImageStabilization (583)
/* Type tt__ImageStabilization is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImageStabilization': */
class SOAP_CMAC tt__ImageStabilization : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ImageStabilizationMode'
        enum tt__ImageStabilizationMode Mode;
        /// Optional element 'tt:Level' of XML schema type 'xsd:float'
        float *Level;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImageStabilizationExtension'
        tt__ImageStabilizationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilization
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilization; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilization, default initialized and not managed by a soap context
        virtual tt__ImageStabilization *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilization); }
      public:
        /// Constructor with default initializations
        tt__ImageStabilization() : Mode(), Level(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ImageStabilization() { }
        /// Friend allocator used by soap_new_tt__ImageStabilization(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilization * SOAP_FMAC2 soap_instantiate_tt__ImageStabilization(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1353 */
#ifndef SOAP_TYPE_tt__ImageStabilizationExtension
#define SOAP_TYPE_tt__ImageStabilizationExtension (584)
/* Type tt__ImageStabilizationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImageStabilizationExtension': */
class SOAP_CMAC tt__ImageStabilizationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilizationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilizationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilizationExtension, default initialized and not managed by a soap context
        virtual tt__ImageStabilizationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilizationExtension); }
      public:
        /// Constructor with default initializations
        tt__ImageStabilizationExtension() : __any() { }
        /// Destructor
        virtual ~tt__ImageStabilizationExtension() { }
        /// Friend allocator used by soap_new_tt__ImageStabilizationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilizationExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1355 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustment
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustment (585)
/* Type tt__IrCutFilterAutoAdjustment is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IrCutFilterAutoAdjustment': */
class SOAP_CMAC tt__IrCutFilterAutoAdjustment : public xsd__anyType {
      public:
        /// Required element 'tt:BoundaryType' of XML schema type 'xsd:string'
        std::string BoundaryType;
        /// Optional element 'tt:BoundaryOffset' of XML schema type 'xsd:float'
        float *BoundaryOffset;
        /// Optional element 'tt:ResponseTime' of XML schema type 'xsd:duration'
        std::string *ResponseTime;
        /// Optional element 'tt:Extension' of XML schema type 'tt:IrCutFilterAutoAdjustmentExtension'
        tt__IrCutFilterAutoAdjustmentExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustment
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoAdjustment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoAdjustment, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoAdjustment *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoAdjustment); }
      public:
        /// Constructor with default initializations
        tt__IrCutFilterAutoAdjustment() : BoundaryType(), BoundaryOffset(), ResponseTime(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__IrCutFilterAutoAdjustment() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoAdjustment(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustment * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1357 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (586)
/* Type tt__IrCutFilterAutoAdjustmentExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IrCutFilterAutoAdjustmentExtension': */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoAdjustmentExtension, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoAdjustmentExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoAdjustmentExtension); }
      public:
        /// Constructor with default initializations
        tt__IrCutFilterAutoAdjustmentExtension() : __any() { }
        /// Destructor
        virtual ~tt__IrCutFilterAutoAdjustmentExtension() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentExtension * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1359 */
#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (587)
/* Type tt__WideDynamicRange20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:WideDynamicRange20': */
class SOAP_CMAC tt__WideDynamicRange20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WideDynamicMode'
        enum tt__WideDynamicMode Mode;
        /// Optional element 'tt:Level' of XML schema type 'xsd:float'
        float *Level;
      public:
        /// Return unique type id SOAP_TYPE_tt__WideDynamicRange20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WideDynamicRange20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WideDynamicRange20, default initialized and not managed by a soap context
        virtual tt__WideDynamicRange20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WideDynamicRange20); }
      public:
        /// Constructor with default initializations
        tt__WideDynamicRange20() : Mode(), Level() { }
        /// Destructor
        virtual ~tt__WideDynamicRange20() { }
        /// Friend allocator used by soap_new_tt__WideDynamicRange20(struct soap*, int)
        friend SOAP_FMAC1 tt__WideDynamicRange20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRange20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1361 */
#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (588)
/* Type tt__BacklightCompensation20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:BacklightCompensation20': */
class SOAP_CMAC tt__BacklightCompensation20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:BacklightCompensationMode'
        enum tt__BacklightCompensationMode Mode;
        /// Optional element 'tt:Level' of XML schema type 'xsd:float'
        float *Level;
      public:
        /// Return unique type id SOAP_TYPE_tt__BacklightCompensation20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BacklightCompensation20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BacklightCompensation20, default initialized and not managed by a soap context
        virtual tt__BacklightCompensation20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BacklightCompensation20); }
      public:
        /// Constructor with default initializations
        tt__BacklightCompensation20() : Mode(), Level() { }
        /// Destructor
        virtual ~tt__BacklightCompensation20() { }
        /// Friend allocator used by soap_new_tt__BacklightCompensation20(struct soap*, int)
        friend SOAP_FMAC1 tt__BacklightCompensation20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensation20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1363 */
#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (589)
/* Type tt__Exposure20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Exposure20': */
class SOAP_CMAC tt__Exposure20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ExposureMode'
        enum tt__ExposureMode Mode;
        /// Optional element 'tt:Priority' of XML schema type 'tt:ExposurePriority'
        enum tt__ExposurePriority *Priority;
        /// Optional element 'tt:Window' of XML schema type 'tt:Rectangle'
        tt__Rectangle *Window;
        /// Optional element 'tt:MinExposureTime' of XML schema type 'xsd:float'
        float *MinExposureTime;
        /// Optional element 'tt:MaxExposureTime' of XML schema type 'xsd:float'
        float *MaxExposureTime;
        /// Optional element 'tt:MinGain' of XML schema type 'xsd:float'
        float *MinGain;
        /// Optional element 'tt:MaxGain' of XML schema type 'xsd:float'
        float *MaxGain;
        /// Optional element 'tt:MinIris' of XML schema type 'xsd:float'
        float *MinIris;
        /// Optional element 'tt:MaxIris' of XML schema type 'xsd:float'
        float *MaxIris;
        /// Optional element 'tt:ExposureTime' of XML schema type 'xsd:float'
        float *ExposureTime;
        /// Optional element 'tt:Gain' of XML schema type 'xsd:float'
        float *Gain;
        /// Optional element 'tt:Iris' of XML schema type 'xsd:float'
        float *Iris;
      public:
        /// Return unique type id SOAP_TYPE_tt__Exposure20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Exposure20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Exposure20, default initialized and not managed by a soap context
        virtual tt__Exposure20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Exposure20); }
      public:
        /// Constructor with default initializations
        tt__Exposure20() : Mode(), Priority(), Window(), MinExposureTime(), MaxExposureTime(), MinGain(), MaxGain(), MinIris(), MaxIris(), ExposureTime(), Gain(), Iris() { }
        /// Destructor
        virtual ~tt__Exposure20() { }
        /// Friend allocator used by soap_new_tt__Exposure20(struct soap*, int)
        friend SOAP_FMAC1 tt__Exposure20 * SOAP_FMAC2 soap_instantiate_tt__Exposure20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1365 */
#ifndef SOAP_TYPE_tt__ToneCompensation
#define SOAP_TYPE_tt__ToneCompensation (590)
/* Type tt__ToneCompensation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ToneCompensation': */
class SOAP_CMAC tt__ToneCompensation : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'xsd:string'
        std::string Mode;
        /// Optional element 'tt:Level' of XML schema type 'xsd:float'
        float *Level;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ToneCompensationExtension'
        tt__ToneCompensationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ToneCompensation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ToneCompensation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ToneCompensation, default initialized and not managed by a soap context
        virtual tt__ToneCompensation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ToneCompensation); }
      public:
        /// Constructor with default initializations
        tt__ToneCompensation() : Mode(), Level(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ToneCompensation() { }
        /// Friend allocator used by soap_new_tt__ToneCompensation(struct soap*, int)
        friend SOAP_FMAC1 tt__ToneCompensation * SOAP_FMAC2 soap_instantiate_tt__ToneCompensation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1367 */
#ifndef SOAP_TYPE_tt__ToneCompensationExtension
#define SOAP_TYPE_tt__ToneCompensationExtension (591)
/* Type tt__ToneCompensationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ToneCompensationExtension': */
class SOAP_CMAC tt__ToneCompensationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ToneCompensationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ToneCompensationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ToneCompensationExtension, default initialized and not managed by a soap context
        virtual tt__ToneCompensationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ToneCompensationExtension); }
      public:
        /// Constructor with default initializations
        tt__ToneCompensationExtension() : __any() { }
        /// Destructor
        virtual ~tt__ToneCompensationExtension() { }
        /// Friend allocator used by soap_new_tt__ToneCompensationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ToneCompensationExtension * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1369 */
#ifndef SOAP_TYPE_tt__Defogging
#define SOAP_TYPE_tt__Defogging (592)
/* Type tt__Defogging is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Defogging': */
class SOAP_CMAC tt__Defogging : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'xsd:string'
        std::string Mode;
        /// Optional element 'tt:Level' of XML schema type 'xsd:float'
        float *Level;
        /// Optional element 'tt:Extension' of XML schema type 'tt:DefoggingExtension'
        tt__DefoggingExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Defogging
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Defogging; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Defogging, default initialized and not managed by a soap context
        virtual tt__Defogging *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Defogging); }
      public:
        /// Constructor with default initializations
        tt__Defogging() : Mode(), Level(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Defogging() { }
        /// Friend allocator used by soap_new_tt__Defogging(struct soap*, int)
        friend SOAP_FMAC1 tt__Defogging * SOAP_FMAC2 soap_instantiate_tt__Defogging(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1371 */
#ifndef SOAP_TYPE_tt__DefoggingExtension
#define SOAP_TYPE_tt__DefoggingExtension (593)
/* Type tt__DefoggingExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DefoggingExtension': */
class SOAP_CMAC tt__DefoggingExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__DefoggingExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DefoggingExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DefoggingExtension, default initialized and not managed by a soap context
        virtual tt__DefoggingExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DefoggingExtension); }
      public:
        /// Constructor with default initializations
        tt__DefoggingExtension() : __any() { }
        /// Destructor
        virtual ~tt__DefoggingExtension() { }
        /// Friend allocator used by soap_new_tt__DefoggingExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__DefoggingExtension * SOAP_FMAC2 soap_instantiate_tt__DefoggingExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1373 */
#ifndef SOAP_TYPE_tt__NoiseReduction
#define SOAP_TYPE_tt__NoiseReduction (594)
/* Type tt__NoiseReduction is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NoiseReduction': */
class SOAP_CMAC tt__NoiseReduction : public xsd__anyType {
      public:
        /// Required element 'tt:Level' of XML schema type 'xsd:float'
        float Level;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__NoiseReduction
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NoiseReduction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NoiseReduction, default initialized and not managed by a soap context
        virtual tt__NoiseReduction *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NoiseReduction); }
      public:
        /// Constructor with default initializations
        tt__NoiseReduction() : Level(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__NoiseReduction() { }
        /// Friend allocator used by soap_new_tt__NoiseReduction(struct soap*, int)
        friend SOAP_FMAC1 tt__NoiseReduction * SOAP_FMAC2 soap_instantiate_tt__NoiseReduction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1375 */
#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (595)
/* Type tt__ImagingOptions20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingOptions20': */
class SOAP_CMAC tt__ImagingOptions20 : public xsd__anyType {
      public:
        /// Optional element 'tt:BacklightCompensation' of XML schema type 'tt:BacklightCompensationOptions20'
        tt__BacklightCompensationOptions20 *BacklightCompensation;
        /// Optional element 'tt:Brightness' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Brightness;
        /// Optional element 'tt:ColorSaturation' of XML schema type 'tt:FloatRange'
        tt__FloatRange *ColorSaturation;
        /// Optional element 'tt:Contrast' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Contrast;
        /// Optional element 'tt:Exposure' of XML schema type 'tt:ExposureOptions20'
        tt__ExposureOptions20 *Exposure;
        /// Optional element 'tt:Focus' of XML schema type 'tt:FocusOptions20'
        tt__FocusOptions20 *Focus;
        /// Optional element 'tt:IrCutFilterModes' of XML schema type 'tt:IrCutFilterMode'
        std::vector<enum tt__IrCutFilterMode> IrCutFilterModes;
        /// Optional element 'tt:Sharpness' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Sharpness;
        /// Optional element 'tt:WideDynamicRange' of XML schema type 'tt:WideDynamicRangeOptions20'
        tt__WideDynamicRangeOptions20 *WideDynamicRange;
        /// Optional element 'tt:WhiteBalance' of XML schema type 'tt:WhiteBalanceOptions20'
        tt__WhiteBalanceOptions20 *WhiteBalance;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingOptions20Extension'
        tt__ImagingOptions20Extension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20); }
      public:
        /// Constructor with default initializations
        tt__ImagingOptions20() : BacklightCompensation(), Brightness(), ColorSaturation(), Contrast(), Exposure(), Focus(), IrCutFilterModes(), Sharpness(), WideDynamicRange(), WhiteBalance(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ImagingOptions20() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1377 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (596)
/* Type tt__ImagingOptions20Extension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingOptions20Extension': */
class SOAP_CMAC tt__ImagingOptions20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:ImageStabilization' of XML schema type 'tt:ImageStabilizationOptions'
        tt__ImageStabilizationOptions *ImageStabilization;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingOptions20Extension2'
        tt__ImagingOptions20Extension2 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20Extension, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20Extension); }
      public:
        /// Constructor with default initializations
        tt__ImagingOptions20Extension() : __any(), ImageStabilization(), Extension() { }
        /// Destructor
        virtual ~tt__ImagingOptions20Extension() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1379 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2
#define SOAP_TYPE_tt__ImagingOptions20Extension2 (597)
/* Type tt__ImagingOptions20Extension2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingOptions20Extension2': */
class SOAP_CMAC tt__ImagingOptions20Extension2 : public xsd__anyType {
      public:
        /// Optional element 'tt:IrCutFilterAutoAdjustment' of XML schema type 'tt:IrCutFilterAutoAdjustmentOptions'
        tt__IrCutFilterAutoAdjustmentOptions *IrCutFilterAutoAdjustment;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingOptions20Extension3'
        tt__ImagingOptions20Extension3 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20Extension2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20Extension2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20Extension2, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20Extension2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20Extension2); }
      public:
        /// Constructor with default initializations
        tt__ImagingOptions20Extension2() : IrCutFilterAutoAdjustment(), Extension() { }
        /// Destructor
        virtual ~tt__ImagingOptions20Extension2() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20Extension2(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20Extension2 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1381 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension3
#define SOAP_TYPE_tt__ImagingOptions20Extension3 (598)
/* Type tt__ImagingOptions20Extension3 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingOptions20Extension3': */
class SOAP_CMAC tt__ImagingOptions20Extension3 : public xsd__anyType {
      public:
        /// Optional element 'tt:ToneCompensationOptions' of XML schema type 'tt:ToneCompensationOptions'
        tt__ToneCompensationOptions *ToneCompensationOptions;
        /// Optional element 'tt:DefoggingOptions' of XML schema type 'tt:DefoggingOptions'
        tt__DefoggingOptions *DefoggingOptions;
        /// Optional element 'tt:NoiseReductionOptions' of XML schema type 'tt:NoiseReductionOptions'
        tt__NoiseReductionOptions *NoiseReductionOptions;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImagingOptions20Extension4'
        tt__ImagingOptions20Extension4 *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20Extension3
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20Extension3; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20Extension3, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20Extension3 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20Extension3); }
      public:
        /// Constructor with default initializations
        tt__ImagingOptions20Extension3() : ToneCompensationOptions(), DefoggingOptions(), NoiseReductionOptions(), Extension() { }
        /// Destructor
        virtual ~tt__ImagingOptions20Extension3() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20Extension3(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20Extension3 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension3(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1383 */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension4
#define SOAP_TYPE_tt__ImagingOptions20Extension4 (599)
/* Type tt__ImagingOptions20Extension4 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImagingOptions20Extension4': */
class SOAP_CMAC tt__ImagingOptions20Extension4 : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImagingOptions20Extension4
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImagingOptions20Extension4; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImagingOptions20Extension4, default initialized and not managed by a soap context
        virtual tt__ImagingOptions20Extension4 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImagingOptions20Extension4); }
      public:
        /// Constructor with default initializations
        tt__ImagingOptions20Extension4() : __any() { }
        /// Destructor
        virtual ~tt__ImagingOptions20Extension4() { }
        /// Friend allocator used by soap_new_tt__ImagingOptions20Extension4(struct soap*, int)
        friend SOAP_FMAC1 tt__ImagingOptions20Extension4 * SOAP_FMAC2 soap_instantiate_tt__ImagingOptions20Extension4(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1385 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptions
#define SOAP_TYPE_tt__ImageStabilizationOptions (600)
/* Type tt__ImageStabilizationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImageStabilizationOptions': */
class SOAP_CMAC tt__ImageStabilizationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ImageStabilizationMode'
        std::vector<enum tt__ImageStabilizationMode> Mode;
        /// Optional element 'tt:Level' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Level;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ImageStabilizationOptionsExtension'
        tt__ImageStabilizationOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilizationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilizationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilizationOptions, default initialized and not managed by a soap context
        virtual tt__ImageStabilizationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilizationOptions); }
      public:
        /// Constructor with default initializations
        tt__ImageStabilizationOptions() : Mode(), Level(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ImageStabilizationOptions() { }
        /// Friend allocator used by soap_new_tt__ImageStabilizationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilizationOptions * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1387 */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension (601)
/* Type tt__ImageStabilizationOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ImageStabilizationOptionsExtension': */
class SOAP_CMAC tt__ImageStabilizationOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ImageStabilizationOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ImageStabilizationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ImageStabilizationOptionsExtension, default initialized and not managed by a soap context
        virtual tt__ImageStabilizationOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ImageStabilizationOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__ImageStabilizationOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__ImageStabilizationOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__ImageStabilizationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ImageStabilizationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ImageStabilizationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1389 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (602)
/* Type tt__IrCutFilterAutoAdjustmentOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IrCutFilterAutoAdjustmentOptions': */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptions : public xsd__anyType {
      public:
        /// Required element 'tt:BoundaryType' of XML schema type 'xsd:string'
        std::vector<std::string> BoundaryType;
        /// Optional element 'tt:BoundaryOffset' of XML schema type 'xsd:boolean'
        bool *BoundaryOffset;
        /// Optional element 'tt:ResponseTimeRange' of XML schema type 'tt:DurationRange'
        tt__DurationRange *ResponseTimeRange;
        /// Optional element 'tt:Extension' of XML schema type 'tt:IrCutFilterAutoAdjustmentOptionsExtension'
        tt__IrCutFilterAutoAdjustmentOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoAdjustmentOptions, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoAdjustmentOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoAdjustmentOptions); }
      public:
        /// Constructor with default initializations
        tt__IrCutFilterAutoAdjustmentOptions() : BoundaryType(), BoundaryOffset(), ResponseTimeRange(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__IrCutFilterAutoAdjustmentOptions() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptions * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1391 */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (603)
/* Type tt__IrCutFilterAutoAdjustmentOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IrCutFilterAutoAdjustmentOptionsExtension': */
class SOAP_CMAC tt__IrCutFilterAutoAdjustmentOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IrCutFilterAutoAdjustmentOptionsExtension, default initialized and not managed by a soap context
        virtual tt__IrCutFilterAutoAdjustmentOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IrCutFilterAutoAdjustmentOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__IrCutFilterAutoAdjustmentOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__IrCutFilterAutoAdjustmentOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__IrCutFilterAutoAdjustmentOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__IrCutFilterAutoAdjustmentOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1393 */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (604)
/* Type tt__WideDynamicRangeOptions20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:WideDynamicRangeOptions20': */
class SOAP_CMAC tt__WideDynamicRangeOptions20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WideDynamicMode'
        std::vector<enum tt__WideDynamicMode> Mode;
        /// Optional element 'tt:Level' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Level;
      public:
        /// Return unique type id SOAP_TYPE_tt__WideDynamicRangeOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WideDynamicRangeOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WideDynamicRangeOptions20, default initialized and not managed by a soap context
        virtual tt__WideDynamicRangeOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WideDynamicRangeOptions20); }
      public:
        /// Constructor with default initializations
        tt__WideDynamicRangeOptions20() : Mode(), Level() { }
        /// Destructor
        virtual ~tt__WideDynamicRangeOptions20() { }
        /// Friend allocator used by soap_new_tt__WideDynamicRangeOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__WideDynamicRangeOptions20 * SOAP_FMAC2 soap_instantiate_tt__WideDynamicRangeOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1395 */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (605)
/* Type tt__BacklightCompensationOptions20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:BacklightCompensationOptions20': */
class SOAP_CMAC tt__BacklightCompensationOptions20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:BacklightCompensationMode'
        std::vector<enum tt__BacklightCompensationMode> Mode;
        /// Optional element 'tt:Level' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Level;
      public:
        /// Return unique type id SOAP_TYPE_tt__BacklightCompensationOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__BacklightCompensationOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__BacklightCompensationOptions20, default initialized and not managed by a soap context
        virtual tt__BacklightCompensationOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__BacklightCompensationOptions20); }
      public:
        /// Constructor with default initializations
        tt__BacklightCompensationOptions20() : Mode(), Level() { }
        /// Destructor
        virtual ~tt__BacklightCompensationOptions20() { }
        /// Friend allocator used by soap_new_tt__BacklightCompensationOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__BacklightCompensationOptions20 * SOAP_FMAC2 soap_instantiate_tt__BacklightCompensationOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1397 */
#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (606)
/* Type tt__ExposureOptions20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ExposureOptions20': */
class SOAP_CMAC tt__ExposureOptions20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ExposureMode'
        std::vector<enum tt__ExposureMode> Mode;
        /// Optional element 'tt:Priority' of XML schema type 'tt:ExposurePriority'
        std::vector<enum tt__ExposurePriority> Priority;
        /// Optional element 'tt:MinExposureTime' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MinExposureTime;
        /// Optional element 'tt:MaxExposureTime' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MaxExposureTime;
        /// Optional element 'tt:MinGain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MinGain;
        /// Optional element 'tt:MaxGain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MaxGain;
        /// Optional element 'tt:MinIris' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MinIris;
        /// Optional element 'tt:MaxIris' of XML schema type 'tt:FloatRange'
        tt__FloatRange *MaxIris;
        /// Optional element 'tt:ExposureTime' of XML schema type 'tt:FloatRange'
        tt__FloatRange *ExposureTime;
        /// Optional element 'tt:Gain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Gain;
        /// Optional element 'tt:Iris' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Iris;
      public:
        /// Return unique type id SOAP_TYPE_tt__ExposureOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ExposureOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ExposureOptions20, default initialized and not managed by a soap context
        virtual tt__ExposureOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ExposureOptions20); }
      public:
        /// Constructor with default initializations
        tt__ExposureOptions20() : Mode(), Priority(), MinExposureTime(), MaxExposureTime(), MinGain(), MaxGain(), MinIris(), MaxIris(), ExposureTime(), Gain(), Iris() { }
        /// Destructor
        virtual ~tt__ExposureOptions20() { }
        /// Friend allocator used by soap_new_tt__ExposureOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__ExposureOptions20 * SOAP_FMAC2 soap_instantiate_tt__ExposureOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1399 */
#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (607)
/* Type tt__MoveOptions20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MoveOptions20': */
class SOAP_CMAC tt__MoveOptions20 : public xsd__anyType {
      public:
        /// Optional element 'tt:Absolute' of XML schema type 'tt:AbsoluteFocusOptions'
        tt__AbsoluteFocusOptions *Absolute;
        /// Optional element 'tt:Relative' of XML schema type 'tt:RelativeFocusOptions20'
        tt__RelativeFocusOptions20 *Relative;
        /// Optional element 'tt:Continuous' of XML schema type 'tt:ContinuousFocusOptions'
        tt__ContinuousFocusOptions *Continuous;
      public:
        /// Return unique type id SOAP_TYPE_tt__MoveOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MoveOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MoveOptions20, default initialized and not managed by a soap context
        virtual tt__MoveOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MoveOptions20); }
      public:
        /// Constructor with default initializations
        tt__MoveOptions20() : Absolute(), Relative(), Continuous() { }
        /// Destructor
        virtual ~tt__MoveOptions20() { }
        /// Friend allocator used by soap_new_tt__MoveOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__MoveOptions20 * SOAP_FMAC2 soap_instantiate_tt__MoveOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1401 */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (608)
/* Type tt__RelativeFocusOptions20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RelativeFocusOptions20': */
class SOAP_CMAC tt__RelativeFocusOptions20 : public xsd__anyType {
      public:
        /// Required element 'tt:Distance' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Distance;
        /// Optional element 'tt:Speed' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Speed;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelativeFocusOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelativeFocusOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelativeFocusOptions20, default initialized and not managed by a soap context
        virtual tt__RelativeFocusOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelativeFocusOptions20); }
      public:
        /// Constructor with default initializations
        tt__RelativeFocusOptions20() : Distance(), Speed() { }
        /// Destructor
        virtual ~tt__RelativeFocusOptions20() { }
        /// Friend allocator used by soap_new_tt__RelativeFocusOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__RelativeFocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__RelativeFocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1403 */
#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (609)
/* Type tt__WhiteBalance20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:WhiteBalance20': */
class SOAP_CMAC tt__WhiteBalance20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WhiteBalanceMode'
        enum tt__WhiteBalanceMode Mode;
        /// Optional element 'tt:CrGain' of XML schema type 'xsd:float'
        float *CrGain;
        /// Optional element 'tt:CbGain' of XML schema type 'xsd:float'
        float *CbGain;
        /// Optional element 'tt:Extension' of XML schema type 'tt:WhiteBalance20Extension'
        tt__WhiteBalance20Extension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalance20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalance20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalance20, default initialized and not managed by a soap context
        virtual tt__WhiteBalance20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalance20); }
      public:
        /// Constructor with default initializations
        tt__WhiteBalance20() : Mode(), CrGain(), CbGain(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__WhiteBalance20() { }
        /// Friend allocator used by soap_new_tt__WhiteBalance20(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalance20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1405 */
#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (610)
/* Type tt__WhiteBalance20Extension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:WhiteBalance20Extension': */
class SOAP_CMAC tt__WhiteBalance20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalance20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalance20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalance20Extension, default initialized and not managed by a soap context
        virtual tt__WhiteBalance20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalance20Extension); }
      public:
        /// Constructor with default initializations
        tt__WhiteBalance20Extension() : __any() { }
        /// Destructor
        virtual ~tt__WhiteBalance20Extension() { }
        /// Friend allocator used by soap_new_tt__WhiteBalance20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalance20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalance20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1407 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (611)
/* Type tt__FocusConfiguration20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FocusConfiguration20': */
class SOAP_CMAC tt__FocusConfiguration20 : public xsd__anyType {
      public:
        /// Required element 'tt:AutoFocusMode' of XML schema type 'tt:AutoFocusMode'
        enum tt__AutoFocusMode AutoFocusMode;
        /// Optional element 'tt:DefaultSpeed' of XML schema type 'xsd:float'
        float *DefaultSpeed;
        /// Optional element 'tt:NearLimit' of XML schema type 'xsd:float'
        float *NearLimit;
        /// Optional element 'tt:FarLimit' of XML schema type 'xsd:float'
        float *FarLimit;
        /// Optional element 'tt:Extension' of XML schema type 'tt:FocusConfiguration20Extension'
        tt__FocusConfiguration20Extension *Extension;
        /// Optional attribute 'AFMode' of XML schema type 'tt:StringAttrList'
        std::string *AFMode;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusConfiguration20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusConfiguration20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusConfiguration20, default initialized and not managed by a soap context
        virtual tt__FocusConfiguration20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusConfiguration20); }
      public:
        /// Constructor with default initializations
        tt__FocusConfiguration20() : AutoFocusMode(), DefaultSpeed(), NearLimit(), FarLimit(), Extension(), AFMode(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__FocusConfiguration20() { }
        /// Friend allocator used by soap_new_tt__FocusConfiguration20(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusConfiguration20 * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1409 */
#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (612)
/* Type tt__FocusConfiguration20Extension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FocusConfiguration20Extension': */
class SOAP_CMAC tt__FocusConfiguration20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusConfiguration20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusConfiguration20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusConfiguration20Extension, default initialized and not managed by a soap context
        virtual tt__FocusConfiguration20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusConfiguration20Extension); }
      public:
        /// Constructor with default initializations
        tt__FocusConfiguration20Extension() : __any() { }
        /// Destructor
        virtual ~tt__FocusConfiguration20Extension() { }
        /// Friend allocator used by soap_new_tt__FocusConfiguration20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusConfiguration20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusConfiguration20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1411 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (613)
/* Type tt__WhiteBalanceOptions20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:WhiteBalanceOptions20': */
class SOAP_CMAC tt__WhiteBalanceOptions20 : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:WhiteBalanceMode'
        std::vector<enum tt__WhiteBalanceMode> Mode;
        /// Optional element 'tt:YrGain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *YrGain;
        /// Optional element 'tt:YbGain' of XML schema type 'tt:FloatRange'
        tt__FloatRange *YbGain;
        /// Optional element 'tt:Extension' of XML schema type 'tt:WhiteBalanceOptions20Extension'
        tt__WhiteBalanceOptions20Extension *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalanceOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalanceOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalanceOptions20, default initialized and not managed by a soap context
        virtual tt__WhiteBalanceOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalanceOptions20); }
      public:
        /// Constructor with default initializations
        tt__WhiteBalanceOptions20() : Mode(), YrGain(), YbGain(), Extension() { }
        /// Destructor
        virtual ~tt__WhiteBalanceOptions20() { }
        /// Friend allocator used by soap_new_tt__WhiteBalanceOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalanceOptions20 * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1413 */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (614)
/* Type tt__WhiteBalanceOptions20Extension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:WhiteBalanceOptions20Extension': */
class SOAP_CMAC tt__WhiteBalanceOptions20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__WhiteBalanceOptions20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__WhiteBalanceOptions20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__WhiteBalanceOptions20Extension, default initialized and not managed by a soap context
        virtual tt__WhiteBalanceOptions20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__WhiteBalanceOptions20Extension); }
      public:
        /// Constructor with default initializations
        tt__WhiteBalanceOptions20Extension() : __any() { }
        /// Destructor
        virtual ~tt__WhiteBalanceOptions20Extension() { }
        /// Friend allocator used by soap_new_tt__WhiteBalanceOptions20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__WhiteBalanceOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__WhiteBalanceOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1415 */
#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (615)
/* Type tt__FocusOptions20 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FocusOptions20': */
class SOAP_CMAC tt__FocusOptions20 : public xsd__anyType {
      public:
        /// Optional element 'tt:AutoFocusModes' of XML schema type 'tt:AutoFocusMode'
        std::vector<enum tt__AutoFocusMode> AutoFocusModes;
        /// Optional element 'tt:DefaultSpeed' of XML schema type 'tt:FloatRange'
        tt__FloatRange *DefaultSpeed;
        /// Optional element 'tt:NearLimit' of XML schema type 'tt:FloatRange'
        tt__FloatRange *NearLimit;
        /// Optional element 'tt:FarLimit' of XML schema type 'tt:FloatRange'
        tt__FloatRange *FarLimit;
        /// Optional element 'tt:Extension' of XML schema type 'tt:FocusOptions20Extension'
        tt__FocusOptions20Extension *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusOptions20
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusOptions20; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusOptions20, default initialized and not managed by a soap context
        virtual tt__FocusOptions20 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusOptions20); }
      public:
        /// Constructor with default initializations
        tt__FocusOptions20() : AutoFocusModes(), DefaultSpeed(), NearLimit(), FarLimit(), Extension() { }
        /// Destructor
        virtual ~tt__FocusOptions20() { }
        /// Friend allocator used by soap_new_tt__FocusOptions20(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusOptions20 * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1417 */
#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (616)
/* Type tt__FocusOptions20Extension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FocusOptions20Extension': */
class SOAP_CMAC tt__FocusOptions20Extension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional element 'tt:AFModes' of XML schema type 'tt:StringAttrList'
        std::string *AFModes;
      public:
        /// Return unique type id SOAP_TYPE_tt__FocusOptions20Extension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FocusOptions20Extension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FocusOptions20Extension, default initialized and not managed by a soap context
        virtual tt__FocusOptions20Extension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FocusOptions20Extension); }
      public:
        /// Constructor with default initializations
        tt__FocusOptions20Extension() : __any(), AFModes() { }
        /// Destructor
        virtual ~tt__FocusOptions20Extension() { }
        /// Friend allocator used by soap_new_tt__FocusOptions20Extension(struct soap*, int)
        friend SOAP_FMAC1 tt__FocusOptions20Extension * SOAP_FMAC2 soap_instantiate_tt__FocusOptions20Extension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1419 */
#ifndef SOAP_TYPE_tt__ToneCompensationOptions
#define SOAP_TYPE_tt__ToneCompensationOptions (617)
/* Type tt__ToneCompensationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ToneCompensationOptions': */
class SOAP_CMAC tt__ToneCompensationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'xsd:string'
        std::vector<std::string> Mode;
        /// Required element 'tt:Level' of XML schema type 'xsd:boolean'
        bool Level;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ToneCompensationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ToneCompensationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ToneCompensationOptions, default initialized and not managed by a soap context
        virtual tt__ToneCompensationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ToneCompensationOptions); }
      public:
        /// Constructor with default initializations
        tt__ToneCompensationOptions() : Mode(), Level(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ToneCompensationOptions() { }
        /// Friend allocator used by soap_new_tt__ToneCompensationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ToneCompensationOptions * SOAP_FMAC2 soap_instantiate_tt__ToneCompensationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1421 */
#ifndef SOAP_TYPE_tt__DefoggingOptions
#define SOAP_TYPE_tt__DefoggingOptions (618)
/* Type tt__DefoggingOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DefoggingOptions': */
class SOAP_CMAC tt__DefoggingOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'xsd:string'
        std::vector<std::string> Mode;
        /// Required element 'tt:Level' of XML schema type 'xsd:boolean'
        bool Level;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__DefoggingOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DefoggingOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DefoggingOptions, default initialized and not managed by a soap context
        virtual tt__DefoggingOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DefoggingOptions); }
      public:
        /// Constructor with default initializations
        tt__DefoggingOptions() : Mode(), Level(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__DefoggingOptions() { }
        /// Friend allocator used by soap_new_tt__DefoggingOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__DefoggingOptions * SOAP_FMAC2 soap_instantiate_tt__DefoggingOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1423 */
#ifndef SOAP_TYPE_tt__NoiseReductionOptions
#define SOAP_TYPE_tt__NoiseReductionOptions (619)
/* Type tt__NoiseReductionOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NoiseReductionOptions': */
class SOAP_CMAC tt__NoiseReductionOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Level' of XML schema type 'xsd:boolean'
        bool Level;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__NoiseReductionOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NoiseReductionOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NoiseReductionOptions, default initialized and not managed by a soap context
        virtual tt__NoiseReductionOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NoiseReductionOptions); }
      public:
        /// Constructor with default initializations
        tt__NoiseReductionOptions() : Level(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__NoiseReductionOptions() { }
        /// Friend allocator used by soap_new_tt__NoiseReductionOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__NoiseReductionOptions * SOAP_FMAC2 soap_instantiate_tt__NoiseReductionOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1425 */
#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (620)
/* complex XML schema type 'tt:MessageExtension': */
class SOAP_CMAC tt__MessageExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__MessageExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MessageExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MessageExtension, default initialized and not managed by a soap context
        virtual tt__MessageExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MessageExtension); }
      public:
        /// Constructor with default initializations
        tt__MessageExtension() : __any() { }
        /// Destructor
        virtual ~tt__MessageExtension() { }
        /// Friend allocator used by soap_new_tt__MessageExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__MessageExtension * SOAP_FMAC2 soap_instantiate_tt__MessageExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:19896 */
#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (1390)
/* complex XML schema type 'tt:ItemList-SimpleItem': */
class SOAP_CMAC _tt__ItemList_SimpleItem {
      public:
        /// Required attribute 'Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Required attribute 'Value' of XML schema type 'xsd:anySimpleType'
        std::string Value;
      public:
        /// Return unique type id SOAP_TYPE__tt__ItemList_SimpleItem
        virtual long soap_type(void) const { return SOAP_TYPE__tt__ItemList_SimpleItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__ItemList_SimpleItem, default initialized and not managed by a soap context
        virtual _tt__ItemList_SimpleItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__ItemList_SimpleItem); }
      public:
        /// Constructor with default initializations
        _tt__ItemList_SimpleItem() : Name(), Value() { }
        /// Destructor
        virtual ~_tt__ItemList_SimpleItem() { }
        /// Friend allocator used by soap_new__tt__ItemList_SimpleItem(struct soap*, int)
        friend SOAP_FMAC1 _tt__ItemList_SimpleItem * SOAP_FMAC2 soap_instantiate__tt__ItemList_SimpleItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:19928 */
#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (1392)
/* complex XML schema type 'tt:ItemList-ElementItem': */
class SOAP_CMAC _tt__ItemList_ElementItem {
      public:
        char *__any;
        /// Required attribute 'Name' of XML schema type 'xsd:string'
        std::string Name;
      public:
        /// Return unique type id SOAP_TYPE__tt__ItemList_ElementItem
        virtual long soap_type(void) const { return SOAP_TYPE__tt__ItemList_ElementItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__ItemList_ElementItem, default initialized and not managed by a soap context
        virtual _tt__ItemList_ElementItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__ItemList_ElementItem); }
      public:
        /// Constructor with default initializations
        _tt__ItemList_ElementItem() : __any(), Name() { }
        /// Destructor
        virtual ~_tt__ItemList_ElementItem() { }
        /// Friend allocator used by soap_new__tt__ItemList_ElementItem(struct soap*, int)
        friend SOAP_FMAC1 _tt__ItemList_ElementItem * SOAP_FMAC2 soap_instantiate__tt__ItemList_ElementItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1427 */
#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (621)
/* complex XML schema type 'tt:ItemList': */
class SOAP_CMAC tt__ItemList : public xsd__anyType {
      public:
        /// Optional element 'tt:SimpleItem' of XML schema type 'tt:ItemList-SimpleItem'
        std::vector<_tt__ItemList_SimpleItem> SimpleItem;
        /// Optional element 'tt:ElementItem' of XML schema type 'tt:ItemList-ElementItem'
        std::vector<_tt__ItemList_ElementItem> ElementItem;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ItemListExtension'
        tt__ItemListExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ItemList
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ItemList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ItemList, default initialized and not managed by a soap context
        virtual tt__ItemList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ItemList); }
      public:
        /// Constructor with default initializations
        tt__ItemList() : SimpleItem(), ElementItem(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ItemList() { }
        /// Friend allocator used by soap_new_tt__ItemList(struct soap*, int)
        friend SOAP_FMAC1 tt__ItemList * SOAP_FMAC2 soap_instantiate_tt__ItemList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1429 */
#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (622)
/* complex XML schema type 'tt:ItemListExtension': */
class SOAP_CMAC tt__ItemListExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ItemListExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ItemListExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ItemListExtension, default initialized and not managed by a soap context
        virtual tt__ItemListExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ItemListExtension); }
      public:
        /// Constructor with default initializations
        tt__ItemListExtension() : __any() { }
        /// Destructor
        virtual ~tt__ItemListExtension() { }
        /// Friend allocator used by soap_new_tt__ItemListExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ItemListExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1431 */
#ifndef SOAP_TYPE_tt__MessageDescription
#define SOAP_TYPE_tt__MessageDescription (623)
/* Type tt__MessageDescription is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MessageDescription': */
class SOAP_CMAC tt__MessageDescription : public xsd__anyType {
      public:
        /// Optional element 'tt:Source' of XML schema type 'tt:ItemListDescription'
        tt__ItemListDescription *Source;
        /// Optional element 'tt:Key' of XML schema type 'tt:ItemListDescription'
        tt__ItemListDescription *Key;
        /// Optional element 'tt:Data' of XML schema type 'tt:ItemListDescription'
        tt__ItemListDescription *Data;
        /// Optional element 'tt:Extension' of XML schema type 'tt:MessageDescriptionExtension'
        tt__MessageDescriptionExtension *Extension;
        /// Optional attribute 'IsProperty' of XML schema type 'xsd:boolean'
        bool *IsProperty;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MessageDescription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MessageDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MessageDescription, default initialized and not managed by a soap context
        virtual tt__MessageDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MessageDescription); }
      public:
        /// Constructor with default initializations
        tt__MessageDescription() : Source(), Key(), Data(), Extension(), IsProperty(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MessageDescription() { }
        /// Friend allocator used by soap_new_tt__MessageDescription(struct soap*, int)
        friend SOAP_FMAC1 tt__MessageDescription * SOAP_FMAC2 soap_instantiate_tt__MessageDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1433 */
#ifndef SOAP_TYPE_tt__MessageDescriptionExtension
#define SOAP_TYPE_tt__MessageDescriptionExtension (624)
/* complex XML schema type 'tt:MessageDescriptionExtension': */
class SOAP_CMAC tt__MessageDescriptionExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__MessageDescriptionExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MessageDescriptionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MessageDescriptionExtension, default initialized and not managed by a soap context
        virtual tt__MessageDescriptionExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MessageDescriptionExtension); }
      public:
        /// Constructor with default initializations
        tt__MessageDescriptionExtension() : __any() { }
        /// Destructor
        virtual ~tt__MessageDescriptionExtension() { }
        /// Friend allocator used by soap_new_tt__MessageDescriptionExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__MessageDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__MessageDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20094 */
#ifndef SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (1397)
/* complex XML schema type 'tt:ItemListDescription-SimpleItemDescription': */
class SOAP_CMAC _tt__ItemListDescription_SimpleItemDescription {
      public:
        /// Required attribute 'Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Required attribute 'Type' of XML schema type 'xsd:QName'
        std::string Type;
      public:
        /// Return unique type id SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription
        virtual long soap_type(void) const { return SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__ItemListDescription_SimpleItemDescription, default initialized and not managed by a soap context
        virtual _tt__ItemListDescription_SimpleItemDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__ItemListDescription_SimpleItemDescription); }
      public:
        /// Constructor with default initializations
        _tt__ItemListDescription_SimpleItemDescription() : Name(), Type() { }
        /// Destructor
        virtual ~_tt__ItemListDescription_SimpleItemDescription() { }
        /// Friend allocator used by soap_new__tt__ItemListDescription_SimpleItemDescription(struct soap*, int)
        friend SOAP_FMAC1 _tt__ItemListDescription_SimpleItemDescription * SOAP_FMAC2 soap_instantiate__tt__ItemListDescription_SimpleItemDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20122 */
#ifndef SOAP_TYPE__tt__ItemListDescription_ElementItemDescription
#define SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (1399)
/* complex XML schema type 'tt:ItemListDescription-ElementItemDescription': */
class SOAP_CMAC _tt__ItemListDescription_ElementItemDescription {
      public:
        /// Required attribute 'Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Required attribute 'Type' of XML schema type 'xsd:QName'
        std::string Type;
      public:
        /// Return unique type id SOAP_TYPE__tt__ItemListDescription_ElementItemDescription
        virtual long soap_type(void) const { return SOAP_TYPE__tt__ItemListDescription_ElementItemDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__ItemListDescription_ElementItemDescription, default initialized and not managed by a soap context
        virtual _tt__ItemListDescription_ElementItemDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__ItemListDescription_ElementItemDescription); }
      public:
        /// Constructor with default initializations
        _tt__ItemListDescription_ElementItemDescription() : Name(), Type() { }
        /// Destructor
        virtual ~_tt__ItemListDescription_ElementItemDescription() { }
        /// Friend allocator used by soap_new__tt__ItemListDescription_ElementItemDescription(struct soap*, int)
        friend SOAP_FMAC1 _tt__ItemListDescription_ElementItemDescription * SOAP_FMAC2 soap_instantiate__tt__ItemListDescription_ElementItemDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1435 */
#ifndef SOAP_TYPE_tt__ItemListDescription
#define SOAP_TYPE_tt__ItemListDescription (625)
/* complex XML schema type 'tt:ItemListDescription': */
class SOAP_CMAC tt__ItemListDescription : public xsd__anyType {
      public:
        /// Optional element 'tt:SimpleItemDescription' of XML schema type 'tt:ItemListDescription-SimpleItemDescription'
        std::vector<_tt__ItemListDescription_SimpleItemDescription> SimpleItemDescription;
        /// Optional element 'tt:ElementItemDescription' of XML schema type 'tt:ItemListDescription-ElementItemDescription'
        std::vector<_tt__ItemListDescription_ElementItemDescription> ElementItemDescription;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ItemListDescriptionExtension'
        tt__ItemListDescriptionExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ItemListDescription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ItemListDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ItemListDescription, default initialized and not managed by a soap context
        virtual tt__ItemListDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ItemListDescription); }
      public:
        /// Constructor with default initializations
        tt__ItemListDescription() : SimpleItemDescription(), ElementItemDescription(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ItemListDescription() { }
        /// Friend allocator used by soap_new_tt__ItemListDescription(struct soap*, int)
        friend SOAP_FMAC1 tt__ItemListDescription * SOAP_FMAC2 soap_instantiate_tt__ItemListDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1437 */
#ifndef SOAP_TYPE_tt__ItemListDescriptionExtension
#define SOAP_TYPE_tt__ItemListDescriptionExtension (626)
/* complex XML schema type 'tt:ItemListDescriptionExtension': */
class SOAP_CMAC tt__ItemListDescriptionExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ItemListDescriptionExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ItemListDescriptionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ItemListDescriptionExtension, default initialized and not managed by a soap context
        virtual tt__ItemListDescriptionExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ItemListDescriptionExtension); }
      public:
        /// Constructor with default initializations
        tt__ItemListDescriptionExtension() : __any() { }
        /// Destructor
        virtual ~tt__ItemListDescriptionExtension() { }
        /// Friend allocator used by soap_new_tt__ItemListDescriptionExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ItemListDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__ItemListDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1439 */
#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (627)
/* Type tt__Polyline is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Polyline': */
class SOAP_CMAC tt__Polyline : public xsd__anyType {
      public:
        /// Required element 'tt:Point' of XML schema type 'tt:Vector'
        std::vector<tt__Vector *> Point;
      public:
        /// Return unique type id SOAP_TYPE_tt__Polyline
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Polyline; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Polyline, default initialized and not managed by a soap context
        virtual tt__Polyline *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Polyline); }
      public:
        /// Constructor with default initializations
        tt__Polyline() : Point() { }
        /// Destructor
        virtual ~tt__Polyline() { }
        /// Friend allocator used by soap_new_tt__Polyline(struct soap*, int)
        friend SOAP_FMAC1 tt__Polyline * SOAP_FMAC2 soap_instantiate_tt__Polyline(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1441 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (628)
/* Type tt__AnalyticsEngineConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsEngineConfiguration': */
class SOAP_CMAC tt__AnalyticsEngineConfiguration : public xsd__anyType {
      public:
        /// Optional element 'tt:AnalyticsModule' of XML schema type 'tt:Config'
        std::vector<tt__Config *> AnalyticsModule;
        /// Optional element 'tt:Extension' of XML schema type 'tt:AnalyticsEngineConfigurationExtension'
        tt__AnalyticsEngineConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsEngineConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsEngineConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsEngineConfiguration, default initialized and not managed by a soap context
        virtual tt__AnalyticsEngineConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsEngineConfiguration); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsEngineConfiguration() : AnalyticsModule(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AnalyticsEngineConfiguration() { }
        /// Friend allocator used by soap_new_tt__AnalyticsEngineConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1443 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (629)
/* Type tt__AnalyticsEngineConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsEngineConfigurationExtension': */
class SOAP_CMAC tt__AnalyticsEngineConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsEngineConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__AnalyticsEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsEngineConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsEngineConfigurationExtension() : __any() { }
        /// Destructor
        virtual ~tt__AnalyticsEngineConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__AnalyticsEngineConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1445 */
#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (630)
/* Type tt__RuleEngineConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RuleEngineConfiguration': */
class SOAP_CMAC tt__RuleEngineConfiguration : public xsd__anyType {
      public:
        /// Optional element 'tt:Rule' of XML schema type 'tt:Config'
        std::vector<tt__Config *> Rule;
        /// Optional element 'tt:Extension' of XML schema type 'tt:RuleEngineConfigurationExtension'
        tt__RuleEngineConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RuleEngineConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RuleEngineConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RuleEngineConfiguration, default initialized and not managed by a soap context
        virtual tt__RuleEngineConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RuleEngineConfiguration); }
      public:
        /// Constructor with default initializations
        tt__RuleEngineConfiguration() : Rule(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RuleEngineConfiguration() { }
        /// Friend allocator used by soap_new_tt__RuleEngineConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__RuleEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1447 */
#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (631)
/* Type tt__RuleEngineConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RuleEngineConfigurationExtension': */
class SOAP_CMAC tt__RuleEngineConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__RuleEngineConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RuleEngineConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RuleEngineConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__RuleEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RuleEngineConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__RuleEngineConfigurationExtension() : __any() { }
        /// Destructor
        virtual ~tt__RuleEngineConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__RuleEngineConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RuleEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RuleEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1449 */
#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (632)
/* Type tt__Config is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Config': */
class SOAP_CMAC tt__Config : public xsd__anyType {
      public:
        /// Required element 'tt:Parameters' of XML schema type 'tt:ItemList'
        tt__ItemList *Parameters;
        /// Required attribute 'Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Required attribute 'Type' of XML schema type 'xsd:QName'
        std::string Type;
      public:
        /// Return unique type id SOAP_TYPE_tt__Config
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Config; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Config, default initialized and not managed by a soap context
        virtual tt__Config *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Config); }
      public:
        /// Constructor with default initializations
        tt__Config() : Parameters(), Name(), Type() { }
        /// Destructor
        virtual ~tt__Config() { }
        /// Friend allocator used by soap_new_tt__Config(struct soap*, int)
        friend SOAP_FMAC1 tt__Config * SOAP_FMAC2 soap_instantiate_tt__Config(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:20373 */
#ifndef SOAP_TYPE__tt__ConfigDescription_Messages
#define SOAP_TYPE__tt__ConfigDescription_Messages (1409)
/* complex XML schema type 'tt:ConfigDescription-Messages': */
class SOAP_CMAC _tt__ConfigDescription_Messages {
      public:
        /// Optional element 'tt:Source' of XML schema type 'tt:ItemListDescription'
        tt__ItemListDescription *Source;
        /// Optional element 'tt:Key' of XML schema type 'tt:ItemListDescription'
        tt__ItemListDescription *Key;
        /// Optional element 'tt:Data' of XML schema type 'tt:ItemListDescription'
        tt__ItemListDescription *Data;
        /// Optional element 'tt:Extension' of XML schema type 'tt:MessageDescriptionExtension'
        tt__MessageDescriptionExtension *Extension;
        /// Optional attribute 'IsProperty' of XML schema type 'xsd:boolean'
        bool *IsProperty;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Required element 'tt:ParentTopic' of XML schema type 'xsd:string'
        std::string ParentTopic;
      public:
        /// Return unique type id SOAP_TYPE__tt__ConfigDescription_Messages
        virtual long soap_type(void) const { return SOAP_TYPE__tt__ConfigDescription_Messages; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__ConfigDescription_Messages, default initialized and not managed by a soap context
        virtual _tt__ConfigDescription_Messages *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__ConfigDescription_Messages); }
      public:
        /// Constructor with default initializations
        _tt__ConfigDescription_Messages() : Source(), Key(), Data(), Extension(), IsProperty(), __anyAttribute(), ParentTopic() { }
        /// Destructor
        virtual ~_tt__ConfigDescription_Messages() { }
        /// Friend allocator used by soap_new__tt__ConfigDescription_Messages(struct soap*, int)
        friend SOAP_FMAC1 _tt__ConfigDescription_Messages * SOAP_FMAC2 soap_instantiate__tt__ConfigDescription_Messages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1451 */
#ifndef SOAP_TYPE_tt__ConfigDescription
#define SOAP_TYPE_tt__ConfigDescription (633)
/* Type tt__ConfigDescription is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ConfigDescription': */
class SOAP_CMAC tt__ConfigDescription : public xsd__anyType {
      public:
        /// Required element 'tt:Parameters' of XML schema type 'tt:ItemListDescription'
        tt__ItemListDescription *Parameters;
        /// Optional element 'tt:Messages' of XML schema type 'tt:ConfigDescription-Messages'
        std::vector<_tt__ConfigDescription_Messages> Messages;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ConfigDescriptionExtension'
        tt__ConfigDescriptionExtension *Extension;
        /// Required attribute 'Name' of XML schema type 'xsd:QName'
        std::string Name;
        /// Optional attribute 'fixed' of XML schema type 'xsd:boolean'
        bool *fixed;
        /// Optional attribute 'maxInstances' of XML schema type 'xsd:integer'
        std::string *maxInstances;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ConfigDescription
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ConfigDescription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ConfigDescription, default initialized and not managed by a soap context
        virtual tt__ConfigDescription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ConfigDescription); }
      public:
        /// Constructor with default initializations
        tt__ConfigDescription() : Parameters(), Messages(), Extension(), Name(), fixed(), maxInstances(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ConfigDescription() { }
        /// Friend allocator used by soap_new_tt__ConfigDescription(struct soap*, int)
        friend SOAP_FMAC1 tt__ConfigDescription * SOAP_FMAC2 soap_instantiate_tt__ConfigDescription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1453 */
#ifndef SOAP_TYPE_tt__ConfigDescriptionExtension
#define SOAP_TYPE_tt__ConfigDescriptionExtension (634)
/* Type tt__ConfigDescriptionExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ConfigDescriptionExtension': */
class SOAP_CMAC tt__ConfigDescriptionExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__ConfigDescriptionExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ConfigDescriptionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ConfigDescriptionExtension, default initialized and not managed by a soap context
        virtual tt__ConfigDescriptionExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ConfigDescriptionExtension); }
      public:
        /// Constructor with default initializations
        tt__ConfigDescriptionExtension() : __any() { }
        /// Destructor
        virtual ~tt__ConfigDescriptionExtension() { }
        /// Friend allocator used by soap_new_tt__ConfigDescriptionExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ConfigDescriptionExtension * SOAP_FMAC2 soap_instantiate_tt__ConfigDescriptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1455 */
#ifndef SOAP_TYPE_tt__SupportedRules
#define SOAP_TYPE_tt__SupportedRules (635)
/* Type tt__SupportedRules is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SupportedRules': */
class SOAP_CMAC tt__SupportedRules : public xsd__anyType {
      public:
        /// Optional element 'tt:RuleContentSchemaLocation' of XML schema type 'xsd:anyURI'
        std::vector<std::string> RuleContentSchemaLocation;
        /// Optional element 'tt:RuleDescription' of XML schema type 'tt:ConfigDescription'
        std::vector<tt__ConfigDescription *> RuleDescription;
        /// Optional element 'tt:Extension' of XML schema type 'tt:SupportedRulesExtension'
        tt__SupportedRulesExtension *Extension;
        /// Optional attribute 'Limit' of XML schema type 'xsd:int'
        int *Limit;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__SupportedRules
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SupportedRules; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SupportedRules, default initialized and not managed by a soap context
        virtual tt__SupportedRules *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SupportedRules); }
      public:
        /// Constructor with default initializations
        tt__SupportedRules() : RuleContentSchemaLocation(), RuleDescription(), Extension(), Limit(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__SupportedRules() { }
        /// Friend allocator used by soap_new_tt__SupportedRules(struct soap*, int)
        friend SOAP_FMAC1 tt__SupportedRules * SOAP_FMAC2 soap_instantiate_tt__SupportedRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1457 */
#ifndef SOAP_TYPE_tt__SupportedRulesExtension
#define SOAP_TYPE_tt__SupportedRulesExtension (636)
/* Type tt__SupportedRulesExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SupportedRulesExtension': */
class SOAP_CMAC tt__SupportedRulesExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__SupportedRulesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SupportedRulesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SupportedRulesExtension, default initialized and not managed by a soap context
        virtual tt__SupportedRulesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SupportedRulesExtension); }
      public:
        /// Constructor with default initializations
        tt__SupportedRulesExtension() : __any() { }
        /// Destructor
        virtual ~tt__SupportedRulesExtension() { }
        /// Friend allocator used by soap_new_tt__SupportedRulesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__SupportedRulesExtension * SOAP_FMAC2 soap_instantiate_tt__SupportedRulesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1459 */
#ifndef SOAP_TYPE_tt__SupportedAnalyticsModules
#define SOAP_TYPE_tt__SupportedAnalyticsModules (637)
/* Type tt__SupportedAnalyticsModules is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SupportedAnalyticsModules': */
class SOAP_CMAC tt__SupportedAnalyticsModules : public xsd__anyType {
      public:
        /// Optional element 'tt:AnalyticsModuleContentSchemaLocation' of XML schema type 'xsd:anyURI'
        std::vector<std::string> AnalyticsModuleContentSchemaLocation;
        /// Optional element 'tt:AnalyticsModuleDescription' of XML schema type 'tt:ConfigDescription'
        std::vector<tt__ConfigDescription *> AnalyticsModuleDescription;
        /// Optional element 'tt:Extension' of XML schema type 'tt:SupportedAnalyticsModulesExtension'
        tt__SupportedAnalyticsModulesExtension *Extension;
        /// Optional attribute 'Limit' of XML schema type 'xsd:int'
        int *Limit;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__SupportedAnalyticsModules
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SupportedAnalyticsModules; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SupportedAnalyticsModules, default initialized and not managed by a soap context
        virtual tt__SupportedAnalyticsModules *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SupportedAnalyticsModules); }
      public:
        /// Constructor with default initializations
        tt__SupportedAnalyticsModules() : AnalyticsModuleContentSchemaLocation(), AnalyticsModuleDescription(), Extension(), Limit(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__SupportedAnalyticsModules() { }
        /// Friend allocator used by soap_new_tt__SupportedAnalyticsModules(struct soap*, int)
        friend SOAP_FMAC1 tt__SupportedAnalyticsModules * SOAP_FMAC2 soap_instantiate_tt__SupportedAnalyticsModules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1461 */
#ifndef SOAP_TYPE_tt__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (638)
/* Type tt__SupportedAnalyticsModulesExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SupportedAnalyticsModulesExtension': */
class SOAP_CMAC tt__SupportedAnalyticsModulesExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__SupportedAnalyticsModulesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SupportedAnalyticsModulesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SupportedAnalyticsModulesExtension, default initialized and not managed by a soap context
        virtual tt__SupportedAnalyticsModulesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SupportedAnalyticsModulesExtension); }
      public:
        /// Constructor with default initializations
        tt__SupportedAnalyticsModulesExtension() : __any() { }
        /// Destructor
        virtual ~tt__SupportedAnalyticsModulesExtension() { }
        /// Friend allocator used by soap_new_tt__SupportedAnalyticsModulesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__SupportedAnalyticsModulesExtension * SOAP_FMAC2 soap_instantiate_tt__SupportedAnalyticsModulesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1463 */
#ifndef SOAP_TYPE_tt__PolylineArray
#define SOAP_TYPE_tt__PolylineArray (639)
/* Type tt__PolylineArray is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PolylineArray': */
class SOAP_CMAC tt__PolylineArray : public xsd__anyType {
      public:
        /// Required element 'tt:Segment' of XML schema type 'tt:Polyline'
        std::vector<tt__Polyline *> Segment;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PolylineArrayExtension'
        tt__PolylineArrayExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PolylineArray
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PolylineArray; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PolylineArray, default initialized and not managed by a soap context
        virtual tt__PolylineArray *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PolylineArray); }
      public:
        /// Constructor with default initializations
        tt__PolylineArray() : Segment(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PolylineArray() { }
        /// Friend allocator used by soap_new_tt__PolylineArray(struct soap*, int)
        friend SOAP_FMAC1 tt__PolylineArray * SOAP_FMAC2 soap_instantiate_tt__PolylineArray(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1465 */
#ifndef SOAP_TYPE_tt__PolylineArrayExtension
#define SOAP_TYPE_tt__PolylineArrayExtension (640)
/* Type tt__PolylineArrayExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PolylineArrayExtension': */
class SOAP_CMAC tt__PolylineArrayExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PolylineArrayExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PolylineArrayExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PolylineArrayExtension, default initialized and not managed by a soap context
        virtual tt__PolylineArrayExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PolylineArrayExtension); }
      public:
        /// Constructor with default initializations
        tt__PolylineArrayExtension() : __any() { }
        /// Destructor
        virtual ~tt__PolylineArrayExtension() { }
        /// Friend allocator used by soap_new_tt__PolylineArrayExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PolylineArrayExtension * SOAP_FMAC2 soap_instantiate_tt__PolylineArrayExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1467 */
#ifndef SOAP_TYPE_tt__PolylineArrayConfiguration
#define SOAP_TYPE_tt__PolylineArrayConfiguration (641)
/* Type tt__PolylineArrayConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PolylineArrayConfiguration': */
class SOAP_CMAC tt__PolylineArrayConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:PolylineArray' of XML schema type 'tt:PolylineArray'
        tt__PolylineArray *PolylineArray;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PolylineArrayConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PolylineArrayConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PolylineArrayConfiguration, default initialized and not managed by a soap context
        virtual tt__PolylineArrayConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PolylineArrayConfiguration); }
      public:
        /// Constructor with default initializations
        tt__PolylineArrayConfiguration() : PolylineArray(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PolylineArrayConfiguration() { }
        /// Friend allocator used by soap_new_tt__PolylineArrayConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__PolylineArrayConfiguration * SOAP_FMAC2 soap_instantiate_tt__PolylineArrayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1469 */
#ifndef SOAP_TYPE_tt__MotionExpression
#define SOAP_TYPE_tt__MotionExpression (642)
/* Type tt__MotionExpression is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MotionExpression': */
class SOAP_CMAC tt__MotionExpression : public xsd__anyType {
      public:
        /// Required element 'tt:Expression' of XML schema type 'xsd:string'
        std::string Expression;
        std::vector<char *> __any;
        /// Optional attribute 'Type' of XML schema type 'xsd:string'
        std::string *Type;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MotionExpression
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MotionExpression; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MotionExpression, default initialized and not managed by a soap context
        virtual tt__MotionExpression *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MotionExpression); }
      public:
        /// Constructor with default initializations
        tt__MotionExpression() : Expression(), __any(), Type(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MotionExpression() { }
        /// Friend allocator used by soap_new_tt__MotionExpression(struct soap*, int)
        friend SOAP_FMAC1 tt__MotionExpression * SOAP_FMAC2 soap_instantiate_tt__MotionExpression(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1471 */
#ifndef SOAP_TYPE_tt__MotionExpressionConfiguration
#define SOAP_TYPE_tt__MotionExpressionConfiguration (643)
/* Type tt__MotionExpressionConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MotionExpressionConfiguration': */
class SOAP_CMAC tt__MotionExpressionConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:MotionExpression' of XML schema type 'tt:MotionExpression'
        tt__MotionExpression *MotionExpression;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MotionExpressionConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MotionExpressionConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MotionExpressionConfiguration, default initialized and not managed by a soap context
        virtual tt__MotionExpressionConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MotionExpressionConfiguration); }
      public:
        /// Constructor with default initializations
        tt__MotionExpressionConfiguration() : MotionExpression(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MotionExpressionConfiguration() { }
        /// Friend allocator used by soap_new_tt__MotionExpressionConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__MotionExpressionConfiguration * SOAP_FMAC2 soap_instantiate_tt__MotionExpressionConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1473 */
#ifndef SOAP_TYPE_tt__CellLayout
#define SOAP_TYPE_tt__CellLayout (644)
/* Type tt__CellLayout is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:CellLayout': */
class SOAP_CMAC tt__CellLayout : public xsd__anyType {
      public:
        /// Required element 'tt:Transformation' of XML schema type 'tt:Transformation'
        tt__Transformation *Transformation;
        std::vector<char *> __any;
        /// Required attribute 'Columns' of XML schema type 'xsd:integer'
        std::string Columns;
        /// Required attribute 'Rows' of XML schema type 'xsd:integer'
        std::string Rows;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__CellLayout
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CellLayout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CellLayout, default initialized and not managed by a soap context
        virtual tt__CellLayout *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CellLayout); }
      public:
        /// Constructor with default initializations
        tt__CellLayout() : Transformation(), __any(), Columns(), Rows(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__CellLayout() { }
        /// Friend allocator used by soap_new_tt__CellLayout(struct soap*, int)
        friend SOAP_FMAC1 tt__CellLayout * SOAP_FMAC2 soap_instantiate_tt__CellLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1475 */
#ifndef SOAP_TYPE_tt__PaneConfiguration
#define SOAP_TYPE_tt__PaneConfiguration (645)
/* Type tt__PaneConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PaneConfiguration': */
class SOAP_CMAC tt__PaneConfiguration : public xsd__anyType {
      public:
        /// Optional element 'tt:PaneName' of XML schema type 'xsd:string'
        std::string *PaneName;
        /// Optional element 'tt:AudioOutputToken' of XML schema type 'tt:ReferenceToken'
        std::string *AudioOutputToken;
        /// Optional element 'tt:AudioSourceToken' of XML schema type 'tt:ReferenceToken'
        std::string *AudioSourceToken;
        /// Optional element 'tt:AudioEncoderConfiguration' of XML schema type 'tt:AudioEncoderConfiguration'
        tt__AudioEncoderConfiguration *AudioEncoderConfiguration;
        /// Optional element 'tt:ReceiverToken' of XML schema type 'tt:ReferenceToken'
        std::string *ReceiverToken;
        /// Required element 'tt:Token' of XML schema type 'tt:ReferenceToken'
        std::string Token;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PaneConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PaneConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PaneConfiguration, default initialized and not managed by a soap context
        virtual tt__PaneConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PaneConfiguration); }
      public:
        /// Constructor with default initializations
        tt__PaneConfiguration() : PaneName(), AudioOutputToken(), AudioSourceToken(), AudioEncoderConfiguration(), ReceiverToken(), Token(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PaneConfiguration() { }
        /// Friend allocator used by soap_new_tt__PaneConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__PaneConfiguration * SOAP_FMAC2 soap_instantiate_tt__PaneConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1477 */
#ifndef SOAP_TYPE_tt__PaneLayout
#define SOAP_TYPE_tt__PaneLayout (646)
/* Type tt__PaneLayout is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PaneLayout': */
class SOAP_CMAC tt__PaneLayout : public xsd__anyType {
      public:
        /// Required element 'tt:Pane' of XML schema type 'tt:ReferenceToken'
        std::string Pane;
        /// Required element 'tt:Area' of XML schema type 'tt:Rectangle'
        tt__Rectangle *Area;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PaneLayout
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PaneLayout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PaneLayout, default initialized and not managed by a soap context
        virtual tt__PaneLayout *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PaneLayout); }
      public:
        /// Constructor with default initializations
        tt__PaneLayout() : Pane(), Area(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PaneLayout() { }
        /// Friend allocator used by soap_new_tt__PaneLayout(struct soap*, int)
        friend SOAP_FMAC1 tt__PaneLayout * SOAP_FMAC2 soap_instantiate_tt__PaneLayout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1479 */
#ifndef SOAP_TYPE_tt__Layout
#define SOAP_TYPE_tt__Layout (647)
/* Type tt__Layout is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Layout': */
class SOAP_CMAC tt__Layout : public xsd__anyType {
      public:
        /// Required element 'tt:PaneLayout' of XML schema type 'tt:PaneLayout'
        std::vector<tt__PaneLayout *> PaneLayout;
        /// Optional element 'tt:Extension' of XML schema type 'tt:LayoutExtension'
        tt__LayoutExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Layout
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Layout; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Layout, default initialized and not managed by a soap context
        virtual tt__Layout *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Layout); }
      public:
        /// Constructor with default initializations
        tt__Layout() : PaneLayout(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Layout() { }
        /// Friend allocator used by soap_new_tt__Layout(struct soap*, int)
        friend SOAP_FMAC1 tt__Layout * SOAP_FMAC2 soap_instantiate_tt__Layout(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1481 */
#ifndef SOAP_TYPE_tt__LayoutExtension
#define SOAP_TYPE_tt__LayoutExtension (648)
/* Type tt__LayoutExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:LayoutExtension': */
class SOAP_CMAC tt__LayoutExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__LayoutExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LayoutExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LayoutExtension, default initialized and not managed by a soap context
        virtual tt__LayoutExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LayoutExtension); }
      public:
        /// Constructor with default initializations
        tt__LayoutExtension() : __any() { }
        /// Destructor
        virtual ~tt__LayoutExtension() { }
        /// Friend allocator used by soap_new_tt__LayoutExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__LayoutExtension * SOAP_FMAC2 soap_instantiate_tt__LayoutExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1483 */
#ifndef SOAP_TYPE_tt__CodingCapabilities
#define SOAP_TYPE_tt__CodingCapabilities (649)
/* Type tt__CodingCapabilities is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:CodingCapabilities': */
class SOAP_CMAC tt__CodingCapabilities : public xsd__anyType {
      public:
        /// Optional element 'tt:AudioEncodingCapabilities' of XML schema type 'tt:AudioEncoderConfigurationOptions'
        tt__AudioEncoderConfigurationOptions *AudioEncodingCapabilities;
        /// Optional element 'tt:AudioDecodingCapabilities' of XML schema type 'tt:AudioDecoderConfigurationOptions'
        tt__AudioDecoderConfigurationOptions *AudioDecodingCapabilities;
        /// Required element 'tt:VideoDecodingCapabilities' of XML schema type 'tt:VideoDecoderConfigurationOptions'
        tt__VideoDecoderConfigurationOptions *VideoDecodingCapabilities;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__CodingCapabilities
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CodingCapabilities; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CodingCapabilities, default initialized and not managed by a soap context
        virtual tt__CodingCapabilities *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CodingCapabilities); }
      public:
        /// Constructor with default initializations
        tt__CodingCapabilities() : AudioEncodingCapabilities(), AudioDecodingCapabilities(), VideoDecodingCapabilities(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__CodingCapabilities() { }
        /// Friend allocator used by soap_new_tt__CodingCapabilities(struct soap*, int)
        friend SOAP_FMAC1 tt__CodingCapabilities * SOAP_FMAC2 soap_instantiate_tt__CodingCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1485 */
#ifndef SOAP_TYPE_tt__LayoutOptions
#define SOAP_TYPE_tt__LayoutOptions (650)
/* Type tt__LayoutOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:LayoutOptions': */
class SOAP_CMAC tt__LayoutOptions : public xsd__anyType {
      public:
        /// Required element 'tt:PaneLayoutOptions' of XML schema type 'tt:PaneLayoutOptions'
        std::vector<tt__PaneLayoutOptions *> PaneLayoutOptions;
        /// Optional element 'tt:Extension' of XML schema type 'tt:LayoutOptionsExtension'
        tt__LayoutOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__LayoutOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LayoutOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LayoutOptions, default initialized and not managed by a soap context
        virtual tt__LayoutOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LayoutOptions); }
      public:
        /// Constructor with default initializations
        tt__LayoutOptions() : PaneLayoutOptions(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__LayoutOptions() { }
        /// Friend allocator used by soap_new_tt__LayoutOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__LayoutOptions * SOAP_FMAC2 soap_instantiate_tt__LayoutOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1487 */
#ifndef SOAP_TYPE_tt__LayoutOptionsExtension
#define SOAP_TYPE_tt__LayoutOptionsExtension (651)
/* Type tt__LayoutOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:LayoutOptionsExtension': */
class SOAP_CMAC tt__LayoutOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__LayoutOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LayoutOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LayoutOptionsExtension, default initialized and not managed by a soap context
        virtual tt__LayoutOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LayoutOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__LayoutOptionsExtension() : __any() { }
        /// Destructor
        virtual ~tt__LayoutOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__LayoutOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__LayoutOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__LayoutOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1489 */
#ifndef SOAP_TYPE_tt__PaneLayoutOptions
#define SOAP_TYPE_tt__PaneLayoutOptions (652)
/* Type tt__PaneLayoutOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PaneLayoutOptions': */
class SOAP_CMAC tt__PaneLayoutOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Area' of XML schema type 'tt:Rectangle'
        std::vector<tt__Rectangle *> Area;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PaneOptionExtension'
        tt__PaneOptionExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PaneLayoutOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PaneLayoutOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PaneLayoutOptions, default initialized and not managed by a soap context
        virtual tt__PaneLayoutOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PaneLayoutOptions); }
      public:
        /// Constructor with default initializations
        tt__PaneLayoutOptions() : Area(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PaneLayoutOptions() { }
        /// Friend allocator used by soap_new_tt__PaneLayoutOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PaneLayoutOptions * SOAP_FMAC2 soap_instantiate_tt__PaneLayoutOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1491 */
#ifndef SOAP_TYPE_tt__PaneOptionExtension
#define SOAP_TYPE_tt__PaneOptionExtension (653)
/* Type tt__PaneOptionExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PaneOptionExtension': */
class SOAP_CMAC tt__PaneOptionExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__PaneOptionExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PaneOptionExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PaneOptionExtension, default initialized and not managed by a soap context
        virtual tt__PaneOptionExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PaneOptionExtension); }
      public:
        /// Constructor with default initializations
        tt__PaneOptionExtension() : __any() { }
        /// Destructor
        virtual ~tt__PaneOptionExtension() { }
        /// Friend allocator used by soap_new_tt__PaneOptionExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__PaneOptionExtension * SOAP_FMAC2 soap_instantiate_tt__PaneOptionExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1493 */
#ifndef SOAP_TYPE_tt__Receiver
#define SOAP_TYPE_tt__Receiver (654)
/* Type tt__Receiver is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Receiver': */
class SOAP_CMAC tt__Receiver : public xsd__anyType {
      public:
        /// Required element 'tt:Token' of XML schema type 'tt:ReferenceToken'
        std::string Token;
        /// Required element 'tt:Configuration' of XML schema type 'tt:ReceiverConfiguration'
        tt__ReceiverConfiguration *Configuration;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Receiver
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Receiver; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Receiver, default initialized and not managed by a soap context
        virtual tt__Receiver *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Receiver); }
      public:
        /// Constructor with default initializations
        tt__Receiver() : Token(), Configuration(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Receiver() { }
        /// Friend allocator used by soap_new_tt__Receiver(struct soap*, int)
        friend SOAP_FMAC1 tt__Receiver * SOAP_FMAC2 soap_instantiate_tt__Receiver(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1495 */
#ifndef SOAP_TYPE_tt__ReceiverConfiguration
#define SOAP_TYPE_tt__ReceiverConfiguration (655)
/* Type tt__ReceiverConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ReceiverConfiguration': */
class SOAP_CMAC tt__ReceiverConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:Mode' of XML schema type 'tt:ReceiverMode'
        enum tt__ReceiverMode Mode;
        /// Required element 'tt:MediaUri' of XML schema type 'xsd:anyURI'
        std::string MediaUri;
        /// Required element 'tt:StreamSetup' of XML schema type 'tt:StreamSetup'
        tt__StreamSetup *StreamSetup;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReceiverConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReceiverConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReceiverConfiguration, default initialized and not managed by a soap context
        virtual tt__ReceiverConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReceiverConfiguration); }
      public:
        /// Constructor with default initializations
        tt__ReceiverConfiguration() : Mode(), MediaUri(), StreamSetup(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ReceiverConfiguration() { }
        /// Friend allocator used by soap_new_tt__ReceiverConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__ReceiverConfiguration * SOAP_FMAC2 soap_instantiate_tt__ReceiverConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1497 */
#ifndef SOAP_TYPE_tt__ReceiverStateInformation
#define SOAP_TYPE_tt__ReceiverStateInformation (656)
/* Type tt__ReceiverStateInformation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ReceiverStateInformation': */
class SOAP_CMAC tt__ReceiverStateInformation : public xsd__anyType {
      public:
        /// Required element 'tt:State' of XML schema type 'tt:ReceiverState'
        enum tt__ReceiverState State;
        /// Required element 'tt:AutoCreated' of XML schema type 'xsd:boolean'
        bool AutoCreated;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReceiverStateInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReceiverStateInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReceiverStateInformation, default initialized and not managed by a soap context
        virtual tt__ReceiverStateInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReceiverStateInformation); }
      public:
        /// Constructor with default initializations
        tt__ReceiverStateInformation() : State(), AutoCreated(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ReceiverStateInformation() { }
        /// Friend allocator used by soap_new_tt__ReceiverStateInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__ReceiverStateInformation * SOAP_FMAC2 soap_instantiate_tt__ReceiverStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1499 */
#ifndef SOAP_TYPE_tt__SourceReference
#define SOAP_TYPE_tt__SourceReference (657)
/* Type tt__SourceReference is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SourceReference': */
class SOAP_CMAC tt__SourceReference : public xsd__anyType {
      public:
        /// Required element 'tt:Token' of XML schema type 'tt:ReferenceToken'
        std::string Token;
        std::vector<char *> __any;
        /// Optional attribute 'Type' of XML schema type 'xsd:anyURI'
        std::string Type;	///< initialized with default value = "http://www.onvif.org/ver10/schema/Receiver"
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__SourceReference
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SourceReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SourceReference, default initialized and not managed by a soap context
        virtual tt__SourceReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SourceReference); }
      public:
        /// Constructor with default initializations
        tt__SourceReference() : Token(), __any(), Type("http://www.onvif.org/ver10/schema/Receiver"), __anyAttribute() { }
        /// Destructor
        virtual ~tt__SourceReference() { }
        /// Friend allocator used by soap_new_tt__SourceReference(struct soap*, int)
        friend SOAP_FMAC1 tt__SourceReference * SOAP_FMAC2 soap_instantiate_tt__SourceReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1501 */
#ifndef SOAP_TYPE_tt__DateTimeRange
#define SOAP_TYPE_tt__DateTimeRange (658)
/* Type tt__DateTimeRange is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DateTimeRange': */
class SOAP_CMAC tt__DateTimeRange : public xsd__anyType {
      public:
        /// Required element 'tt:From' of XML schema type 'xsd:dateTime'
        time_t From;
        /// Required element 'tt:Until' of XML schema type 'xsd:dateTime'
        time_t Until;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__DateTimeRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DateTimeRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DateTimeRange, default initialized and not managed by a soap context
        virtual tt__DateTimeRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DateTimeRange); }
      public:
        /// Constructor with default initializations
        tt__DateTimeRange() : From(), Until(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__DateTimeRange() { }
        /// Friend allocator used by soap_new_tt__DateTimeRange(struct soap*, int)
        friend SOAP_FMAC1 tt__DateTimeRange * SOAP_FMAC2 soap_instantiate_tt__DateTimeRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1503 */
#ifndef SOAP_TYPE_tt__RecordingSummary
#define SOAP_TYPE_tt__RecordingSummary (659)
/* Type tt__RecordingSummary is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingSummary': */
class SOAP_CMAC tt__RecordingSummary : public xsd__anyType {
      public:
        /// Required element 'tt:DataFrom' of XML schema type 'xsd:dateTime'
        time_t DataFrom;
        /// Required element 'tt:DataUntil' of XML schema type 'xsd:dateTime'
        time_t DataUntil;
        /// Required element 'tt:NumberRecordings' of XML schema type 'xsd:int'
        int NumberRecordings;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingSummary
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingSummary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingSummary, default initialized and not managed by a soap context
        virtual tt__RecordingSummary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingSummary); }
      public:
        /// Constructor with default initializations
        tt__RecordingSummary() : DataFrom(), DataUntil(), NumberRecordings(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingSummary() { }
        /// Friend allocator used by soap_new_tt__RecordingSummary(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingSummary * SOAP_FMAC2 soap_instantiate_tt__RecordingSummary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1505 */
#ifndef SOAP_TYPE_tt__SearchScope
#define SOAP_TYPE_tt__SearchScope (660)
/* Type tt__SearchScope is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SearchScope': */
class SOAP_CMAC tt__SearchScope : public xsd__anyType {
      public:
        /// Optional element 'tt:IncludedSources' of XML schema type 'tt:SourceReference'
        std::vector<tt__SourceReference *> IncludedSources;
        /// Optional element 'tt:IncludedRecordings' of XML schema type 'tt:RecordingReference'
        std::vector<std::string> IncludedRecordings;
        /// Optional element 'tt:RecordingInformationFilter' of XML schema type 'tt:XPathExpression'
        std::string *RecordingInformationFilter;
        /// Optional element 'tt:Extension' of XML schema type 'tt:SearchScopeExtension'
        tt__SearchScopeExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__SearchScope
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SearchScope; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SearchScope, default initialized and not managed by a soap context
        virtual tt__SearchScope *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SearchScope); }
      public:
        /// Constructor with default initializations
        tt__SearchScope() : IncludedSources(), IncludedRecordings(), RecordingInformationFilter(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__SearchScope() { }
        /// Friend allocator used by soap_new_tt__SearchScope(struct soap*, int)
        friend SOAP_FMAC1 tt__SearchScope * SOAP_FMAC2 soap_instantiate_tt__SearchScope(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1507 */
#ifndef SOAP_TYPE_tt__SearchScopeExtension
#define SOAP_TYPE_tt__SearchScopeExtension (661)
/* Type tt__SearchScopeExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SearchScopeExtension': */
class SOAP_CMAC tt__SearchScopeExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__SearchScopeExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SearchScopeExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SearchScopeExtension, default initialized and not managed by a soap context
        virtual tt__SearchScopeExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SearchScopeExtension); }
      public:
        /// Constructor with default initializations
        tt__SearchScopeExtension() : __any() { }
        /// Destructor
        virtual ~tt__SearchScopeExtension() { }
        /// Friend allocator used by soap_new_tt__SearchScopeExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__SearchScopeExtension * SOAP_FMAC2 soap_instantiate_tt__SearchScopeExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1511 */
#ifndef SOAP_TYPE_tt__PTZPositionFilter
#define SOAP_TYPE_tt__PTZPositionFilter (663)
/* Type tt__PTZPositionFilter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZPositionFilter': */
class SOAP_CMAC tt__PTZPositionFilter : public xsd__anyType {
      public:
        /// Required element 'tt:MinPosition' of XML schema type 'tt:PTZVector'
        tt__PTZVector *MinPosition;
        /// Required element 'tt:MaxPosition' of XML schema type 'tt:PTZVector'
        tt__PTZVector *MaxPosition;
        /// Required element 'tt:EnterOrExit' of XML schema type 'xsd:boolean'
        bool EnterOrExit;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZPositionFilter
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZPositionFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZPositionFilter, default initialized and not managed by a soap context
        virtual tt__PTZPositionFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZPositionFilter); }
      public:
        /// Constructor with default initializations
        tt__PTZPositionFilter() : MinPosition(), MaxPosition(), EnterOrExit(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZPositionFilter() { }
        /// Friend allocator used by soap_new_tt__PTZPositionFilter(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZPositionFilter * SOAP_FMAC2 soap_instantiate_tt__PTZPositionFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1513 */
#ifndef SOAP_TYPE_tt__MetadataFilter
#define SOAP_TYPE_tt__MetadataFilter (664)
/* Type tt__MetadataFilter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MetadataFilter': */
class SOAP_CMAC tt__MetadataFilter : public xsd__anyType {
      public:
        /// Required element 'tt:MetadataStreamFilter' of XML schema type 'tt:XPathExpression'
        std::string MetadataStreamFilter;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataFilter
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataFilter, default initialized and not managed by a soap context
        virtual tt__MetadataFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataFilter); }
      public:
        /// Constructor with default initializations
        tt__MetadataFilter() : MetadataStreamFilter(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MetadataFilter() { }
        /// Friend allocator used by soap_new_tt__MetadataFilter(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataFilter * SOAP_FMAC2 soap_instantiate_tt__MetadataFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1515 */
#ifndef SOAP_TYPE_tt__FindRecordingResultList
#define SOAP_TYPE_tt__FindRecordingResultList (665)
/* Type tt__FindRecordingResultList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FindRecordingResultList': */
class SOAP_CMAC tt__FindRecordingResultList : public xsd__anyType {
      public:
        /// Required element 'tt:SearchState' of XML schema type 'tt:SearchState'
        enum tt__SearchState SearchState;
        /// Optional element 'tt:RecordingInformation' of XML schema type 'tt:RecordingInformation'
        std::vector<tt__RecordingInformation *> RecordingInformation;
      public:
        /// Return unique type id SOAP_TYPE_tt__FindRecordingResultList
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FindRecordingResultList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FindRecordingResultList, default initialized and not managed by a soap context
        virtual tt__FindRecordingResultList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FindRecordingResultList); }
      public:
        /// Constructor with default initializations
        tt__FindRecordingResultList() : SearchState(), RecordingInformation() { }
        /// Destructor
        virtual ~tt__FindRecordingResultList() { }
        /// Friend allocator used by soap_new_tt__FindRecordingResultList(struct soap*, int)
        friend SOAP_FMAC1 tt__FindRecordingResultList * SOAP_FMAC2 soap_instantiate_tt__FindRecordingResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1517 */
#ifndef SOAP_TYPE_tt__FindEventResultList
#define SOAP_TYPE_tt__FindEventResultList (666)
/* Type tt__FindEventResultList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FindEventResultList': */
class SOAP_CMAC tt__FindEventResultList : public xsd__anyType {
      public:
        /// Required element 'tt:SearchState' of XML schema type 'tt:SearchState'
        enum tt__SearchState SearchState;
        /// Optional element 'tt:Result' of XML schema type 'tt:FindEventResult'
        std::vector<tt__FindEventResult *> Result;
      public:
        /// Return unique type id SOAP_TYPE_tt__FindEventResultList
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FindEventResultList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FindEventResultList, default initialized and not managed by a soap context
        virtual tt__FindEventResultList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FindEventResultList); }
      public:
        /// Constructor with default initializations
        tt__FindEventResultList() : SearchState(), Result() { }
        /// Destructor
        virtual ~tt__FindEventResultList() { }
        /// Friend allocator used by soap_new_tt__FindEventResultList(struct soap*, int)
        friend SOAP_FMAC1 tt__FindEventResultList * SOAP_FMAC2 soap_instantiate_tt__FindEventResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1519 */
#ifndef SOAP_TYPE_tt__FindEventResult
#define SOAP_TYPE_tt__FindEventResult (667)
/* Type tt__FindEventResult is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FindEventResult': */
class SOAP_CMAC tt__FindEventResult : public xsd__anyType {
      public:
        /// Required element 'tt:RecordingToken' of XML schema type 'tt:RecordingReference'
        std::string RecordingToken;
        /// Required element 'tt:TrackToken' of XML schema type 'tt:TrackReference'
        std::string TrackToken;
        /// Required element 'tt:Time' of XML schema type 'xsd:dateTime'
        time_t Time;
        /// Required element 'tt:Event' of XML schema type 'wsnt:NotificationMessageHolderType'
        wsnt__NotificationMessageHolderType *Event;
        /// Required element 'tt:StartStateEvent' of XML schema type 'xsd:boolean'
        bool StartStateEvent;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__FindEventResult
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FindEventResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FindEventResult, default initialized and not managed by a soap context
        virtual tt__FindEventResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FindEventResult); }
      public:
        /// Constructor with default initializations
        tt__FindEventResult() : RecordingToken(), TrackToken(), Time(), Event(), StartStateEvent(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__FindEventResult() { }
        /// Friend allocator used by soap_new_tt__FindEventResult(struct soap*, int)
        friend SOAP_FMAC1 tt__FindEventResult * SOAP_FMAC2 soap_instantiate_tt__FindEventResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1521 */
#ifndef SOAP_TYPE_tt__FindPTZPositionResultList
#define SOAP_TYPE_tt__FindPTZPositionResultList (668)
/* Type tt__FindPTZPositionResultList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FindPTZPositionResultList': */
class SOAP_CMAC tt__FindPTZPositionResultList : public xsd__anyType {
      public:
        /// Required element 'tt:SearchState' of XML schema type 'tt:SearchState'
        enum tt__SearchState SearchState;
        /// Optional element 'tt:Result' of XML schema type 'tt:FindPTZPositionResult'
        std::vector<tt__FindPTZPositionResult *> Result;
      public:
        /// Return unique type id SOAP_TYPE_tt__FindPTZPositionResultList
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FindPTZPositionResultList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FindPTZPositionResultList, default initialized and not managed by a soap context
        virtual tt__FindPTZPositionResultList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FindPTZPositionResultList); }
      public:
        /// Constructor with default initializations
        tt__FindPTZPositionResultList() : SearchState(), Result() { }
        /// Destructor
        virtual ~tt__FindPTZPositionResultList() { }
        /// Friend allocator used by soap_new_tt__FindPTZPositionResultList(struct soap*, int)
        friend SOAP_FMAC1 tt__FindPTZPositionResultList * SOAP_FMAC2 soap_instantiate_tt__FindPTZPositionResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1523 */
#ifndef SOAP_TYPE_tt__FindPTZPositionResult
#define SOAP_TYPE_tt__FindPTZPositionResult (669)
/* Type tt__FindPTZPositionResult is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FindPTZPositionResult': */
class SOAP_CMAC tt__FindPTZPositionResult : public xsd__anyType {
      public:
        /// Required element 'tt:RecordingToken' of XML schema type 'tt:RecordingReference'
        std::string RecordingToken;
        /// Required element 'tt:TrackToken' of XML schema type 'tt:TrackReference'
        std::string TrackToken;
        /// Required element 'tt:Time' of XML schema type 'xsd:dateTime'
        time_t Time;
        /// Required element 'tt:Position' of XML schema type 'tt:PTZVector'
        tt__PTZVector *Position;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__FindPTZPositionResult
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FindPTZPositionResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FindPTZPositionResult, default initialized and not managed by a soap context
        virtual tt__FindPTZPositionResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FindPTZPositionResult); }
      public:
        /// Constructor with default initializations
        tt__FindPTZPositionResult() : RecordingToken(), TrackToken(), Time(), Position(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__FindPTZPositionResult() { }
        /// Friend allocator used by soap_new_tt__FindPTZPositionResult(struct soap*, int)
        friend SOAP_FMAC1 tt__FindPTZPositionResult * SOAP_FMAC2 soap_instantiate_tt__FindPTZPositionResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1525 */
#ifndef SOAP_TYPE_tt__FindMetadataResultList
#define SOAP_TYPE_tt__FindMetadataResultList (670)
/* Type tt__FindMetadataResultList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FindMetadataResultList': */
class SOAP_CMAC tt__FindMetadataResultList : public xsd__anyType {
      public:
        /// Required element 'tt:SearchState' of XML schema type 'tt:SearchState'
        enum tt__SearchState SearchState;
        /// Optional element 'tt:Result' of XML schema type 'tt:FindMetadataResult'
        std::vector<tt__FindMetadataResult *> Result;
      public:
        /// Return unique type id SOAP_TYPE_tt__FindMetadataResultList
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FindMetadataResultList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FindMetadataResultList, default initialized and not managed by a soap context
        virtual tt__FindMetadataResultList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FindMetadataResultList); }
      public:
        /// Constructor with default initializations
        tt__FindMetadataResultList() : SearchState(), Result() { }
        /// Destructor
        virtual ~tt__FindMetadataResultList() { }
        /// Friend allocator used by soap_new_tt__FindMetadataResultList(struct soap*, int)
        friend SOAP_FMAC1 tt__FindMetadataResultList * SOAP_FMAC2 soap_instantiate_tt__FindMetadataResultList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1527 */
#ifndef SOAP_TYPE_tt__FindMetadataResult
#define SOAP_TYPE_tt__FindMetadataResult (671)
/* Type tt__FindMetadataResult is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FindMetadataResult': */
class SOAP_CMAC tt__FindMetadataResult : public xsd__anyType {
      public:
        /// Required element 'tt:RecordingToken' of XML schema type 'tt:RecordingReference'
        std::string RecordingToken;
        /// Required element 'tt:TrackToken' of XML schema type 'tt:TrackReference'
        std::string TrackToken;
        /// Required element 'tt:Time' of XML schema type 'xsd:dateTime'
        time_t Time;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__FindMetadataResult
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FindMetadataResult; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FindMetadataResult, default initialized and not managed by a soap context
        virtual tt__FindMetadataResult *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FindMetadataResult); }
      public:
        /// Constructor with default initializations
        tt__FindMetadataResult() : RecordingToken(), TrackToken(), Time(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__FindMetadataResult() { }
        /// Friend allocator used by soap_new_tt__FindMetadataResult(struct soap*, int)
        friend SOAP_FMAC1 tt__FindMetadataResult * SOAP_FMAC2 soap_instantiate_tt__FindMetadataResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1529 */
#ifndef SOAP_TYPE_tt__RecordingInformation
#define SOAP_TYPE_tt__RecordingInformation (672)
/* Type tt__RecordingInformation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingInformation': */
class SOAP_CMAC tt__RecordingInformation : public xsd__anyType {
      public:
        /// Required element 'tt:RecordingToken' of XML schema type 'tt:RecordingReference'
        std::string RecordingToken;
        /// Required element 'tt:Source' of XML schema type 'tt:RecordingSourceInformation'
        tt__RecordingSourceInformation *Source;
        /// Optional element 'tt:EarliestRecording' of XML schema type 'xsd:dateTime'
        time_t *EarliestRecording;
        /// Optional element 'tt:LatestRecording' of XML schema type 'xsd:dateTime'
        time_t *LatestRecording;
        /// Required element 'tt:Content' of XML schema type 'tt:Description'
        std::string Content;
        /// Optional element 'tt:Track' of XML schema type 'tt:TrackInformation'
        std::vector<tt__TrackInformation *> Track;
        /// Required element 'tt:RecordingStatus' of XML schema type 'tt:RecordingStatus'
        enum tt__RecordingStatus RecordingStatus;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingInformation, default initialized and not managed by a soap context
        virtual tt__RecordingInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingInformation); }
      public:
        /// Constructor with default initializations
        tt__RecordingInformation() : RecordingToken(), Source(), EarliestRecording(), LatestRecording(), Content(), Track(), RecordingStatus(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingInformation() { }
        /// Friend allocator used by soap_new_tt__RecordingInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1531 */
#ifndef SOAP_TYPE_tt__RecordingSourceInformation
#define SOAP_TYPE_tt__RecordingSourceInformation (673)
/* Type tt__RecordingSourceInformation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingSourceInformation': */
class SOAP_CMAC tt__RecordingSourceInformation : public xsd__anyType {
      public:
        /// Required element 'tt:SourceId' of XML schema type 'xsd:anyURI'
        std::string SourceId;
        /// Required element 'tt:Name' of XML schema type 'tt:Name'
        std::string Name;
        /// Required element 'tt:Location' of XML schema type 'tt:Description'
        std::string Location;
        /// Required element 'tt:Description' of XML schema type 'tt:Description'
        std::string Description;
        /// Required element 'tt:Address' of XML schema type 'xsd:anyURI'
        std::string Address;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingSourceInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingSourceInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingSourceInformation, default initialized and not managed by a soap context
        virtual tt__RecordingSourceInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingSourceInformation); }
      public:
        /// Constructor with default initializations
        tt__RecordingSourceInformation() : SourceId(), Name(), Location(), Description(), Address(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingSourceInformation() { }
        /// Friend allocator used by soap_new_tt__RecordingSourceInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingSourceInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingSourceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1533 */
#ifndef SOAP_TYPE_tt__TrackInformation
#define SOAP_TYPE_tt__TrackInformation (674)
/* Type tt__TrackInformation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:TrackInformation': */
class SOAP_CMAC tt__TrackInformation : public xsd__anyType {
      public:
        /// Required element 'tt:TrackToken' of XML schema type 'tt:TrackReference'
        std::string TrackToken;
        /// Required element 'tt:TrackType' of XML schema type 'tt:TrackType'
        enum tt__TrackType TrackType;
        /// Required element 'tt:Description' of XML schema type 'tt:Description'
        std::string Description;
        /// Required element 'tt:DataFrom' of XML schema type 'xsd:dateTime'
        time_t DataFrom;
        /// Required element 'tt:DataTo' of XML schema type 'xsd:dateTime'
        time_t DataTo;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__TrackInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__TrackInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__TrackInformation, default initialized and not managed by a soap context
        virtual tt__TrackInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__TrackInformation); }
      public:
        /// Constructor with default initializations
        tt__TrackInformation() : TrackToken(), TrackType(), Description(), DataFrom(), DataTo(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__TrackInformation() { }
        /// Friend allocator used by soap_new_tt__TrackInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__TrackInformation * SOAP_FMAC2 soap_instantiate_tt__TrackInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1535 */
#ifndef SOAP_TYPE_tt__MediaAttributes
#define SOAP_TYPE_tt__MediaAttributes (675)
/* Type tt__MediaAttributes is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MediaAttributes': */
class SOAP_CMAC tt__MediaAttributes : public xsd__anyType {
      public:
        /// Required element 'tt:RecordingToken' of XML schema type 'tt:RecordingReference'
        std::string RecordingToken;
        /// Optional element 'tt:TrackAttributes' of XML schema type 'tt:TrackAttributes'
        std::vector<tt__TrackAttributes *> TrackAttributes;
        /// Required element 'tt:From' of XML schema type 'xsd:dateTime'
        time_t From;
        /// Required element 'tt:Until' of XML schema type 'xsd:dateTime'
        time_t Until;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MediaAttributes
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MediaAttributes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MediaAttributes, default initialized and not managed by a soap context
        virtual tt__MediaAttributes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MediaAttributes); }
      public:
        /// Constructor with default initializations
        tt__MediaAttributes() : RecordingToken(), TrackAttributes(), From(), Until(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MediaAttributes() { }
        /// Friend allocator used by soap_new_tt__MediaAttributes(struct soap*, int)
        friend SOAP_FMAC1 tt__MediaAttributes * SOAP_FMAC2 soap_instantiate_tt__MediaAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1537 */
#ifndef SOAP_TYPE_tt__TrackAttributes
#define SOAP_TYPE_tt__TrackAttributes (676)
/* Type tt__TrackAttributes is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:TrackAttributes': */
class SOAP_CMAC tt__TrackAttributes : public xsd__anyType {
      public:
        /// Required element 'tt:TrackInformation' of XML schema type 'tt:TrackInformation'
        tt__TrackInformation *TrackInformation;
        /// Optional element 'tt:VideoAttributes' of XML schema type 'tt:VideoAttributes'
        tt__VideoAttributes *VideoAttributes;
        /// Optional element 'tt:AudioAttributes' of XML schema type 'tt:AudioAttributes'
        tt__AudioAttributes *AudioAttributes;
        /// Optional element 'tt:MetadataAttributes' of XML schema type 'tt:MetadataAttributes'
        tt__MetadataAttributes *MetadataAttributes;
        /// Optional element 'tt:Extension' of XML schema type 'tt:TrackAttributesExtension'
        tt__TrackAttributesExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__TrackAttributes
        virtual long soap_type(void) const { return SOAP_TYPE_tt__TrackAttributes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__TrackAttributes, default initialized and not managed by a soap context
        virtual tt__TrackAttributes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__TrackAttributes); }
      public:
        /// Constructor with default initializations
        tt__TrackAttributes() : TrackInformation(), VideoAttributes(), AudioAttributes(), MetadataAttributes(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__TrackAttributes() { }
        /// Friend allocator used by soap_new_tt__TrackAttributes(struct soap*, int)
        friend SOAP_FMAC1 tt__TrackAttributes * SOAP_FMAC2 soap_instantiate_tt__TrackAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1539 */
#ifndef SOAP_TYPE_tt__TrackAttributesExtension
#define SOAP_TYPE_tt__TrackAttributesExtension (677)
/* Type tt__TrackAttributesExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:TrackAttributesExtension': */
class SOAP_CMAC tt__TrackAttributesExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__TrackAttributesExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__TrackAttributesExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__TrackAttributesExtension, default initialized and not managed by a soap context
        virtual tt__TrackAttributesExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__TrackAttributesExtension); }
      public:
        /// Constructor with default initializations
        tt__TrackAttributesExtension() : __any() { }
        /// Destructor
        virtual ~tt__TrackAttributesExtension() { }
        /// Friend allocator used by soap_new_tt__TrackAttributesExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__TrackAttributesExtension * SOAP_FMAC2 soap_instantiate_tt__TrackAttributesExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1541 */
#ifndef SOAP_TYPE_tt__VideoAttributes
#define SOAP_TYPE_tt__VideoAttributes (678)
/* Type tt__VideoAttributes is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoAttributes': */
class SOAP_CMAC tt__VideoAttributes : public xsd__anyType {
      public:
        /// Optional element 'tt:Bitrate' of XML schema type 'xsd:int'
        int *Bitrate;
        /// Required element 'tt:Width' of XML schema type 'xsd:int'
        int Width;
        /// Required element 'tt:Height' of XML schema type 'xsd:int'
        int Height;
        /// Required element 'tt:Encoding' of XML schema type 'xsd:string'
        std::string Encoding;
        /// Required element 'tt:Framerate' of XML schema type 'xsd:float'
        float Framerate;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoAttributes
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoAttributes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoAttributes, default initialized and not managed by a soap context
        virtual tt__VideoAttributes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoAttributes); }
      public:
        /// Constructor with default initializations
        tt__VideoAttributes() : Bitrate(), Width(), Height(), Encoding(), Framerate(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoAttributes() { }
        /// Friend allocator used by soap_new_tt__VideoAttributes(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoAttributes * SOAP_FMAC2 soap_instantiate_tt__VideoAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1543 */
#ifndef SOAP_TYPE_tt__AudioAttributes
#define SOAP_TYPE_tt__AudioAttributes (679)
/* Type tt__AudioAttributes is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioAttributes': */
class SOAP_CMAC tt__AudioAttributes : public xsd__anyType {
      public:
        /// Optional element 'tt:Bitrate' of XML schema type 'xsd:int'
        int *Bitrate;
        /// Required element 'tt:Encoding' of XML schema type 'xsd:string'
        std::string Encoding;
        /// Required element 'tt:Samplerate' of XML schema type 'xsd:int'
        int Samplerate;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioAttributes
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioAttributes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioAttributes, default initialized and not managed by a soap context
        virtual tt__AudioAttributes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioAttributes); }
      public:
        /// Constructor with default initializations
        tt__AudioAttributes() : Bitrate(), Encoding(), Samplerate(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioAttributes() { }
        /// Friend allocator used by soap_new_tt__AudioAttributes(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioAttributes * SOAP_FMAC2 soap_instantiate_tt__AudioAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1545 */
#ifndef SOAP_TYPE_tt__MetadataAttributes
#define SOAP_TYPE_tt__MetadataAttributes (680)
/* Type tt__MetadataAttributes is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MetadataAttributes': */
class SOAP_CMAC tt__MetadataAttributes : public xsd__anyType {
      public:
        /// Required element 'tt:CanContainPTZ' of XML schema type 'xsd:boolean'
        bool CanContainPTZ;
        /// Required element 'tt:CanContainAnalytics' of XML schema type 'xsd:boolean'
        bool CanContainAnalytics;
        /// Required element 'tt:CanContainNotifications' of XML schema type 'xsd:boolean'
        bool CanContainNotifications;
        std::vector<char *> __any;
        /// Optional attribute 'PtzSpaces' of XML schema type 'tt:StringAttrList'
        std::string *PtzSpaces;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataAttributes
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataAttributes; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataAttributes, default initialized and not managed by a soap context
        virtual tt__MetadataAttributes *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataAttributes); }
      public:
        /// Constructor with default initializations
        tt__MetadataAttributes() : CanContainPTZ(), CanContainAnalytics(), CanContainNotifications(), __any(), PtzSpaces(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MetadataAttributes() { }
        /// Friend allocator used by soap_new_tt__MetadataAttributes(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataAttributes * SOAP_FMAC2 soap_instantiate_tt__MetadataAttributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1547 */
#ifndef SOAP_TYPE_tt__RecordingConfiguration
#define SOAP_TYPE_tt__RecordingConfiguration (681)
/* Type tt__RecordingConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingConfiguration': */
class SOAP_CMAC tt__RecordingConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:Source' of XML schema type 'tt:RecordingSourceInformation'
        tt__RecordingSourceInformation *Source;
        /// Required element 'tt:Content' of XML schema type 'tt:Description'
        std::string Content;
        /// Required element 'tt:MaximumRetentionTime' of XML schema type 'xsd:duration'
        std::string MaximumRetentionTime;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingConfiguration, default initialized and not managed by a soap context
        virtual tt__RecordingConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingConfiguration); }
      public:
        /// Constructor with default initializations
        tt__RecordingConfiguration() : Source(), Content(), MaximumRetentionTime(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingConfiguration() { }
        /// Friend allocator used by soap_new_tt__RecordingConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingConfiguration * SOAP_FMAC2 soap_instantiate_tt__RecordingConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1549 */
#ifndef SOAP_TYPE_tt__TrackConfiguration
#define SOAP_TYPE_tt__TrackConfiguration (682)
/* Type tt__TrackConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:TrackConfiguration': */
class SOAP_CMAC tt__TrackConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:TrackType' of XML schema type 'tt:TrackType'
        enum tt__TrackType TrackType;
        /// Required element 'tt:Description' of XML schema type 'tt:Description'
        std::string Description;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__TrackConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__TrackConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__TrackConfiguration, default initialized and not managed by a soap context
        virtual tt__TrackConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__TrackConfiguration); }
      public:
        /// Constructor with default initializations
        tt__TrackConfiguration() : TrackType(), Description(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__TrackConfiguration() { }
        /// Friend allocator used by soap_new_tt__TrackConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__TrackConfiguration * SOAP_FMAC2 soap_instantiate_tt__TrackConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1551 */
#ifndef SOAP_TYPE_tt__GetRecordingsResponseItem
#define SOAP_TYPE_tt__GetRecordingsResponseItem (683)
/* Type tt__GetRecordingsResponseItem is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:GetRecordingsResponseItem': */
class SOAP_CMAC tt__GetRecordingsResponseItem : public xsd__anyType {
      public:
        /// Required element 'tt:RecordingToken' of XML schema type 'tt:RecordingReference'
        std::string RecordingToken;
        /// Required element 'tt:Configuration' of XML schema type 'tt:RecordingConfiguration'
        tt__RecordingConfiguration *Configuration;
        /// Required element 'tt:Tracks' of XML schema type 'tt:GetTracksResponseList'
        tt__GetTracksResponseList *Tracks;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__GetRecordingsResponseItem
        virtual long soap_type(void) const { return SOAP_TYPE_tt__GetRecordingsResponseItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__GetRecordingsResponseItem, default initialized and not managed by a soap context
        virtual tt__GetRecordingsResponseItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__GetRecordingsResponseItem); }
      public:
        /// Constructor with default initializations
        tt__GetRecordingsResponseItem() : RecordingToken(), Configuration(), Tracks(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__GetRecordingsResponseItem() { }
        /// Friend allocator used by soap_new_tt__GetRecordingsResponseItem(struct soap*, int)
        friend SOAP_FMAC1 tt__GetRecordingsResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetRecordingsResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1553 */
#ifndef SOAP_TYPE_tt__GetTracksResponseList
#define SOAP_TYPE_tt__GetTracksResponseList (684)
/* Type tt__GetTracksResponseList is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:GetTracksResponseList': */
class SOAP_CMAC tt__GetTracksResponseList : public xsd__anyType {
      public:
        /// Optional element 'tt:Track' of XML schema type 'tt:GetTracksResponseItem'
        std::vector<tt__GetTracksResponseItem *> Track;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__GetTracksResponseList
        virtual long soap_type(void) const { return SOAP_TYPE_tt__GetTracksResponseList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__GetTracksResponseList, default initialized and not managed by a soap context
        virtual tt__GetTracksResponseList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__GetTracksResponseList); }
      public:
        /// Constructor with default initializations
        tt__GetTracksResponseList() : Track(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__GetTracksResponseList() { }
        /// Friend allocator used by soap_new_tt__GetTracksResponseList(struct soap*, int)
        friend SOAP_FMAC1 tt__GetTracksResponseList * SOAP_FMAC2 soap_instantiate_tt__GetTracksResponseList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1555 */
#ifndef SOAP_TYPE_tt__GetTracksResponseItem
#define SOAP_TYPE_tt__GetTracksResponseItem (685)
/* Type tt__GetTracksResponseItem is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:GetTracksResponseItem': */
class SOAP_CMAC tt__GetTracksResponseItem : public xsd__anyType {
      public:
        /// Required element 'tt:TrackToken' of XML schema type 'tt:TrackReference'
        std::string TrackToken;
        /// Required element 'tt:Configuration' of XML schema type 'tt:TrackConfiguration'
        tt__TrackConfiguration *Configuration;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__GetTracksResponseItem
        virtual long soap_type(void) const { return SOAP_TYPE_tt__GetTracksResponseItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__GetTracksResponseItem, default initialized and not managed by a soap context
        virtual tt__GetTracksResponseItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__GetTracksResponseItem); }
      public:
        /// Constructor with default initializations
        tt__GetTracksResponseItem() : TrackToken(), Configuration(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__GetTracksResponseItem() { }
        /// Friend allocator used by soap_new_tt__GetTracksResponseItem(struct soap*, int)
        friend SOAP_FMAC1 tt__GetTracksResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetTracksResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1557 */
#ifndef SOAP_TYPE_tt__RecordingJobConfiguration
#define SOAP_TYPE_tt__RecordingJobConfiguration (686)
/* Type tt__RecordingJobConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingJobConfiguration': */
class SOAP_CMAC tt__RecordingJobConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:RecordingToken' of XML schema type 'tt:RecordingReference'
        std::string RecordingToken;
        /// Required element 'tt:Mode' of XML schema type 'tt:RecordingJobMode'
        std::string Mode;
        /// Required element 'tt:Priority' of XML schema type 'xsd:int'
        int Priority;
        /// Optional element 'tt:Source' of XML schema type 'tt:RecordingJobSource'
        std::vector<tt__RecordingJobSource *> Source;
        /// Optional element 'tt:Extension' of XML schema type 'tt:RecordingJobConfigurationExtension'
        tt__RecordingJobConfigurationExtension *Extension;
        /// Optional element 'tt:EventFilter' of XML schema type 'tt:RecordingEventFilter'
        tt__RecordingEventFilter *EventFilter;
        std::vector<char *> __any;
        /// Optional attribute 'ScheduleToken' of XML schema type 'xsd:string'
        std::string *ScheduleToken;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobConfiguration, default initialized and not managed by a soap context
        virtual tt__RecordingJobConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobConfiguration); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobConfiguration() : RecordingToken(), Mode(), Priority(), Source(), Extension(), EventFilter(), __any(), ScheduleToken(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingJobConfiguration() { }
        /// Friend allocator used by soap_new_tt__RecordingJobConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobConfiguration * SOAP_FMAC2 soap_instantiate_tt__RecordingJobConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:22689 */
#ifndef SOAP_TYPE__tt__RecordingEventFilter_Filter
#define SOAP_TYPE__tt__RecordingEventFilter_Filter (1468)
/* complex XML schema type 'tt:RecordingEventFilter-Filter': */
class SOAP_CMAC _tt__RecordingEventFilter_Filter {
      public:
        /// Required element 'tt:Topic' of XML schema type 'xsd:string'
        std::string Topic;
        /// Optional element 'tt:Source' of XML schema type 'xsd:string'
        std::string *Source;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE__tt__RecordingEventFilter_Filter
        virtual long soap_type(void) const { return SOAP_TYPE__tt__RecordingEventFilter_Filter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__RecordingEventFilter_Filter, default initialized and not managed by a soap context
        virtual _tt__RecordingEventFilter_Filter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__RecordingEventFilter_Filter); }
      public:
        /// Constructor with default initializations
        _tt__RecordingEventFilter_Filter() : Topic(), Source(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~_tt__RecordingEventFilter_Filter() { }
        /// Friend allocator used by soap_new__tt__RecordingEventFilter_Filter(struct soap*, int)
        friend SOAP_FMAC1 _tt__RecordingEventFilter_Filter * SOAP_FMAC2 soap_instantiate__tt__RecordingEventFilter_Filter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1559 */
#ifndef SOAP_TYPE_tt__RecordingEventFilter
#define SOAP_TYPE_tt__RecordingEventFilter (687)
/* Type tt__RecordingEventFilter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingEventFilter': */
class SOAP_CMAC tt__RecordingEventFilter : public xsd__anyType {
      public:
        /// Required element 'tt:Filter' of XML schema type 'tt:RecordingEventFilter-Filter'
        std::vector<_tt__RecordingEventFilter_Filter> Filter;
        /// Optional element 'tt:Before' of XML schema type 'xsd:duration'
        std::string *Before;
        /// Optional element 'tt:After' of XML schema type 'xsd:duration'
        std::string *After;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingEventFilter
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingEventFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingEventFilter, default initialized and not managed by a soap context
        virtual tt__RecordingEventFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingEventFilter); }
      public:
        /// Constructor with default initializations
        tt__RecordingEventFilter() : Filter(), Before(), After(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingEventFilter() { }
        /// Friend allocator used by soap_new_tt__RecordingEventFilter(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingEventFilter * SOAP_FMAC2 soap_instantiate_tt__RecordingEventFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1561 */
#ifndef SOAP_TYPE_tt__RecordingJobConfigurationExtension
#define SOAP_TYPE_tt__RecordingJobConfigurationExtension (688)
/* Type tt__RecordingJobConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingJobConfigurationExtension': */
class SOAP_CMAC tt__RecordingJobConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__RecordingJobConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobConfigurationExtension() : __any() { }
        /// Destructor
        virtual ~tt__RecordingJobConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__RecordingJobConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1563 */
#ifndef SOAP_TYPE_tt__RecordingJobSource
#define SOAP_TYPE_tt__RecordingJobSource (689)
/* Type tt__RecordingJobSource is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingJobSource': */
class SOAP_CMAC tt__RecordingJobSource : public xsd__anyType {
      public:
        /// Optional element 'tt:SourceToken' of XML schema type 'tt:SourceReference'
        tt__SourceReference *SourceToken;
        /// Optional element 'tt:AutoCreateReceiver' of XML schema type 'xsd:boolean'
        bool *AutoCreateReceiver;
        /// Optional element 'tt:Tracks' of XML schema type 'tt:RecordingJobTrack'
        std::vector<tt__RecordingJobTrack *> Tracks;
        /// Optional element 'tt:Extension' of XML schema type 'tt:RecordingJobSourceExtension'
        tt__RecordingJobSourceExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobSource
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobSource, default initialized and not managed by a soap context
        virtual tt__RecordingJobSource *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobSource); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobSource() : SourceToken(), AutoCreateReceiver(), Tracks(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingJobSource() { }
        /// Friend allocator used by soap_new_tt__RecordingJobSource(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobSource * SOAP_FMAC2 soap_instantiate_tt__RecordingJobSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1565 */
#ifndef SOAP_TYPE_tt__RecordingJobSourceExtension
#define SOAP_TYPE_tt__RecordingJobSourceExtension (690)
/* Type tt__RecordingJobSourceExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingJobSourceExtension': */
class SOAP_CMAC tt__RecordingJobSourceExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobSourceExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobSourceExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobSourceExtension, default initialized and not managed by a soap context
        virtual tt__RecordingJobSourceExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobSourceExtension); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobSourceExtension() : __any() { }
        /// Destructor
        virtual ~tt__RecordingJobSourceExtension() { }
        /// Friend allocator used by soap_new_tt__RecordingJobSourceExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobSourceExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobSourceExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1567 */
#ifndef SOAP_TYPE_tt__RecordingJobTrack
#define SOAP_TYPE_tt__RecordingJobTrack (691)
/* Type tt__RecordingJobTrack is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingJobTrack': */
class SOAP_CMAC tt__RecordingJobTrack : public xsd__anyType {
      public:
        /// Required element 'tt:SourceTag' of XML schema type 'xsd:string'
        std::string SourceTag;
        /// Required element 'tt:Destination' of XML schema type 'tt:TrackReference'
        std::string Destination;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobTrack
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobTrack; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobTrack, default initialized and not managed by a soap context
        virtual tt__RecordingJobTrack *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobTrack); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobTrack() : SourceTag(), Destination(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingJobTrack() { }
        /// Friend allocator used by soap_new_tt__RecordingJobTrack(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobTrack * SOAP_FMAC2 soap_instantiate_tt__RecordingJobTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1569 */
#ifndef SOAP_TYPE_tt__RecordingJobStateInformation
#define SOAP_TYPE_tt__RecordingJobStateInformation (692)
/* Type tt__RecordingJobStateInformation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingJobStateInformation': */
class SOAP_CMAC tt__RecordingJobStateInformation : public xsd__anyType {
      public:
        /// Required element 'tt:RecordingToken' of XML schema type 'tt:RecordingReference'
        std::string RecordingToken;
        /// Required element 'tt:State' of XML schema type 'tt:RecordingJobState'
        std::string State;
        /// Optional element 'tt:Sources' of XML schema type 'tt:RecordingJobStateSource'
        std::vector<tt__RecordingJobStateSource *> Sources;
        /// Optional element 'tt:Extension' of XML schema type 'tt:RecordingJobStateInformationExtension'
        tt__RecordingJobStateInformationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobStateInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobStateInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobStateInformation, default initialized and not managed by a soap context
        virtual tt__RecordingJobStateInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobStateInformation); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobStateInformation() : RecordingToken(), State(), Sources(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingJobStateInformation() { }
        /// Friend allocator used by soap_new_tt__RecordingJobStateInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobStateInformation * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1571 */
#ifndef SOAP_TYPE_tt__RecordingJobStateInformationExtension
#define SOAP_TYPE_tt__RecordingJobStateInformationExtension (693)
/* Type tt__RecordingJobStateInformationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingJobStateInformationExtension': */
class SOAP_CMAC tt__RecordingJobStateInformationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobStateInformationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobStateInformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobStateInformationExtension, default initialized and not managed by a soap context
        virtual tt__RecordingJobStateInformationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobStateInformationExtension); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobStateInformationExtension() : __any() { }
        /// Destructor
        virtual ~tt__RecordingJobStateInformationExtension() { }
        /// Friend allocator used by soap_new_tt__RecordingJobStateInformationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobStateInformationExtension * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateInformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1573 */
#ifndef SOAP_TYPE_tt__RecordingJobStateSource
#define SOAP_TYPE_tt__RecordingJobStateSource (694)
/* Type tt__RecordingJobStateSource is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingJobStateSource': */
class SOAP_CMAC tt__RecordingJobStateSource : public xsd__anyType {
      public:
        /// Required element 'tt:SourceToken' of XML schema type 'tt:SourceReference'
        tt__SourceReference *SourceToken;
        /// Required element 'tt:State' of XML schema type 'tt:RecordingJobState'
        std::string State;
        /// Required element 'tt:Tracks' of XML schema type 'tt:RecordingJobStateTracks'
        tt__RecordingJobStateTracks *Tracks;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobStateSource
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobStateSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobStateSource, default initialized and not managed by a soap context
        virtual tt__RecordingJobStateSource *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobStateSource); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobStateSource() : SourceToken(), State(), Tracks(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingJobStateSource() { }
        /// Friend allocator used by soap_new_tt__RecordingJobStateSource(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobStateSource * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1575 */
#ifndef SOAP_TYPE_tt__RecordingJobStateTracks
#define SOAP_TYPE_tt__RecordingJobStateTracks (695)
/* Type tt__RecordingJobStateTracks is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingJobStateTracks': */
class SOAP_CMAC tt__RecordingJobStateTracks : public xsd__anyType {
      public:
        /// Optional element 'tt:Track' of XML schema type 'tt:RecordingJobStateTrack'
        std::vector<tt__RecordingJobStateTrack *> Track;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobStateTracks
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobStateTracks; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobStateTracks, default initialized and not managed by a soap context
        virtual tt__RecordingJobStateTracks *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobStateTracks); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobStateTracks() : Track(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingJobStateTracks() { }
        /// Friend allocator used by soap_new_tt__RecordingJobStateTracks(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobStateTracks * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateTracks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1577 */
#ifndef SOAP_TYPE_tt__RecordingJobStateTrack
#define SOAP_TYPE_tt__RecordingJobStateTrack (696)
/* Type tt__RecordingJobStateTrack is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RecordingJobStateTrack': */
class SOAP_CMAC tt__RecordingJobStateTrack : public xsd__anyType {
      public:
        /// Required element 'tt:SourceTag' of XML schema type 'xsd:string'
        std::string SourceTag;
        /// Required element 'tt:Destination' of XML schema type 'tt:TrackReference'
        std::string Destination;
        /// Optional element 'tt:Error' of XML schema type 'xsd:string'
        std::string *Error;
        /// Required element 'tt:State' of XML schema type 'tt:RecordingJobState'
        std::string State;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RecordingJobStateTrack
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RecordingJobStateTrack; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RecordingJobStateTrack, default initialized and not managed by a soap context
        virtual tt__RecordingJobStateTrack *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RecordingJobStateTrack); }
      public:
        /// Constructor with default initializations
        tt__RecordingJobStateTrack() : SourceTag(), Destination(), Error(), State(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RecordingJobStateTrack() { }
        /// Friend allocator used by soap_new_tt__RecordingJobStateTrack(struct soap*, int)
        friend SOAP_FMAC1 tt__RecordingJobStateTrack * SOAP_FMAC2 soap_instantiate_tt__RecordingJobStateTrack(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1579 */
#ifndef SOAP_TYPE_tt__GetRecordingJobsResponseItem
#define SOAP_TYPE_tt__GetRecordingJobsResponseItem (697)
/* Type tt__GetRecordingJobsResponseItem is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:GetRecordingJobsResponseItem': */
class SOAP_CMAC tt__GetRecordingJobsResponseItem : public xsd__anyType {
      public:
        /// Required element 'tt:JobToken' of XML schema type 'tt:RecordingJobReference'
        std::string JobToken;
        /// Required element 'tt:JobConfiguration' of XML schema type 'tt:RecordingJobConfiguration'
        tt__RecordingJobConfiguration *JobConfiguration;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__GetRecordingJobsResponseItem
        virtual long soap_type(void) const { return SOAP_TYPE_tt__GetRecordingJobsResponseItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__GetRecordingJobsResponseItem, default initialized and not managed by a soap context
        virtual tt__GetRecordingJobsResponseItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__GetRecordingJobsResponseItem); }
      public:
        /// Constructor with default initializations
        tt__GetRecordingJobsResponseItem() : JobToken(), JobConfiguration(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__GetRecordingJobsResponseItem() { }
        /// Friend allocator used by soap_new_tt__GetRecordingJobsResponseItem(struct soap*, int)
        friend SOAP_FMAC1 tt__GetRecordingJobsResponseItem * SOAP_FMAC2 soap_instantiate_tt__GetRecordingJobsResponseItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1581 */
#ifndef SOAP_TYPE_tt__ReplayConfiguration
#define SOAP_TYPE_tt__ReplayConfiguration (698)
/* Type tt__ReplayConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ReplayConfiguration': */
class SOAP_CMAC tt__ReplayConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:SessionTimeout' of XML schema type 'xsd:duration'
        std::string SessionTimeout;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ReplayConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ReplayConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ReplayConfiguration, default initialized and not managed by a soap context
        virtual tt__ReplayConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ReplayConfiguration); }
      public:
        /// Constructor with default initializations
        tt__ReplayConfiguration() : SessionTimeout(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ReplayConfiguration() { }
        /// Friend allocator used by soap_new_tt__ReplayConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__ReplayConfiguration * SOAP_FMAC2 soap_instantiate_tt__ReplayConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1585 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration (700)
/* Type tt__AnalyticsDeviceEngineConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsDeviceEngineConfiguration': */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:EngineConfiguration' of XML schema type 'tt:EngineConfiguration'
        std::vector<tt__EngineConfiguration *> EngineConfiguration;
        /// Optional element 'tt:Extension' of XML schema type 'tt:AnalyticsDeviceEngineConfigurationExtension'
        tt__AnalyticsDeviceEngineConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsDeviceEngineConfiguration, default initialized and not managed by a soap context
        virtual tt__AnalyticsDeviceEngineConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsDeviceEngineConfiguration); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsDeviceEngineConfiguration() : EngineConfiguration(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AnalyticsDeviceEngineConfiguration() { }
        /// Friend allocator used by soap_new_tt__AnalyticsDeviceEngineConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsDeviceEngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceEngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1587 */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension (701)
/* Type tt__AnalyticsDeviceEngineConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsDeviceEngineConfigurationExtension': */
class SOAP_CMAC tt__AnalyticsDeviceEngineConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsDeviceEngineConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__AnalyticsDeviceEngineConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsDeviceEngineConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsDeviceEngineConfigurationExtension() : __any() { }
        /// Destructor
        virtual ~tt__AnalyticsDeviceEngineConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsDeviceEngineConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsDeviceEngineConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1589 */
#ifndef SOAP_TYPE_tt__EngineConfiguration
#define SOAP_TYPE_tt__EngineConfiguration (702)
/* Type tt__EngineConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:EngineConfiguration': */
class SOAP_CMAC tt__EngineConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:VideoAnalyticsConfiguration' of XML schema type 'tt:VideoAnalyticsConfiguration'
        tt__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;
        /// Required element 'tt:AnalyticsEngineInputInfo' of XML schema type 'tt:AnalyticsEngineInputInfo'
        tt__AnalyticsEngineInputInfo *AnalyticsEngineInputInfo;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__EngineConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EngineConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EngineConfiguration, default initialized and not managed by a soap context
        virtual tt__EngineConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EngineConfiguration); }
      public:
        /// Constructor with default initializations
        tt__EngineConfiguration() : VideoAnalyticsConfiguration(), AnalyticsEngineInputInfo(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__EngineConfiguration() { }
        /// Friend allocator used by soap_new_tt__EngineConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__EngineConfiguration * SOAP_FMAC2 soap_instantiate_tt__EngineConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1591 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfo
#define SOAP_TYPE_tt__AnalyticsEngineInputInfo (703)
/* Type tt__AnalyticsEngineInputInfo is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsEngineInputInfo': */
class SOAP_CMAC tt__AnalyticsEngineInputInfo : public xsd__anyType {
      public:
        /// Optional element 'tt:InputInfo' of XML schema type 'tt:Config'
        tt__Config *InputInfo;
        /// Optional element 'tt:Extension' of XML schema type 'tt:AnalyticsEngineInputInfoExtension'
        tt__AnalyticsEngineInputInfoExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsEngineInputInfo
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsEngineInputInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsEngineInputInfo, default initialized and not managed by a soap context
        virtual tt__AnalyticsEngineInputInfo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsEngineInputInfo); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsEngineInputInfo() : InputInfo(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AnalyticsEngineInputInfo() { }
        /// Friend allocator used by soap_new_tt__AnalyticsEngineInputInfo(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsEngineInputInfo * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInputInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1593 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension (704)
/* Type tt__AnalyticsEngineInputInfoExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsEngineInputInfoExtension': */
class SOAP_CMAC tt__AnalyticsEngineInputInfoExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsEngineInputInfoExtension, default initialized and not managed by a soap context
        virtual tt__AnalyticsEngineInputInfoExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsEngineInputInfoExtension); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsEngineInputInfoExtension() : __any() { }
        /// Destructor
        virtual ~tt__AnalyticsEngineInputInfoExtension() { }
        /// Friend allocator used by soap_new_tt__AnalyticsEngineInputInfoExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsEngineInputInfoExtension * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInputInfoExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1597 */
#ifndef SOAP_TYPE_tt__SourceIdentification
#define SOAP_TYPE_tt__SourceIdentification (706)
/* Type tt__SourceIdentification is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SourceIdentification': */
class SOAP_CMAC tt__SourceIdentification : public xsd__anyType {
      public:
        /// Required element 'tt:Name' of XML schema type 'xsd:string'
        std::string Name;
        /// Required element 'tt:Token' of XML schema type 'tt:ReferenceToken'
        std::vector<std::string> Token;
        /// Optional element 'tt:Extension' of XML schema type 'tt:SourceIdentificationExtension'
        tt__SourceIdentificationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__SourceIdentification
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SourceIdentification; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SourceIdentification, default initialized and not managed by a soap context
        virtual tt__SourceIdentification *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SourceIdentification); }
      public:
        /// Constructor with default initializations
        tt__SourceIdentification() : Name(), Token(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__SourceIdentification() { }
        /// Friend allocator used by soap_new_tt__SourceIdentification(struct soap*, int)
        friend SOAP_FMAC1 tt__SourceIdentification * SOAP_FMAC2 soap_instantiate_tt__SourceIdentification(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1599 */
#ifndef SOAP_TYPE_tt__SourceIdentificationExtension
#define SOAP_TYPE_tt__SourceIdentificationExtension (707)
/* Type tt__SourceIdentificationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:SourceIdentificationExtension': */
class SOAP_CMAC tt__SourceIdentificationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__SourceIdentificationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__SourceIdentificationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__SourceIdentificationExtension, default initialized and not managed by a soap context
        virtual tt__SourceIdentificationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__SourceIdentificationExtension); }
      public:
        /// Constructor with default initializations
        tt__SourceIdentificationExtension() : __any() { }
        /// Destructor
        virtual ~tt__SourceIdentificationExtension() { }
        /// Friend allocator used by soap_new_tt__SourceIdentificationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__SourceIdentificationExtension * SOAP_FMAC2 soap_instantiate_tt__SourceIdentificationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1601 */
#ifndef SOAP_TYPE_tt__MetadataInput
#define SOAP_TYPE_tt__MetadataInput (708)
/* Type tt__MetadataInput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MetadataInput': */
class SOAP_CMAC tt__MetadataInput : public xsd__anyType {
      public:
        /// Optional element 'tt:MetadataConfig' of XML schema type 'tt:Config'
        std::vector<tt__Config *> MetadataConfig;
        /// Optional element 'tt:Extension' of XML schema type 'tt:MetadataInputExtension'
        tt__MetadataInputExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataInput
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataInput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataInput, default initialized and not managed by a soap context
        virtual tt__MetadataInput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataInput); }
      public:
        /// Constructor with default initializations
        tt__MetadataInput() : MetadataConfig(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MetadataInput() { }
        /// Friend allocator used by soap_new_tt__MetadataInput(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataInput * SOAP_FMAC2 soap_instantiate_tt__MetadataInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1603 */
#ifndef SOAP_TYPE_tt__MetadataInputExtension
#define SOAP_TYPE_tt__MetadataInputExtension (709)
/* Type tt__MetadataInputExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MetadataInputExtension': */
class SOAP_CMAC tt__MetadataInputExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataInputExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataInputExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataInputExtension, default initialized and not managed by a soap context
        virtual tt__MetadataInputExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataInputExtension); }
      public:
        /// Constructor with default initializations
        tt__MetadataInputExtension() : __any() { }
        /// Destructor
        virtual ~tt__MetadataInputExtension() { }
        /// Friend allocator used by soap_new_tt__MetadataInputExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataInputExtension * SOAP_FMAC2 soap_instantiate_tt__MetadataInputExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1607 */
#ifndef SOAP_TYPE_tt__AnalyticsStateInformation
#define SOAP_TYPE_tt__AnalyticsStateInformation (711)
/* Type tt__AnalyticsStateInformation is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsStateInformation': */
class SOAP_CMAC tt__AnalyticsStateInformation : public xsd__anyType {
      public:
        /// Required element 'tt:AnalyticsEngineControlToken' of XML schema type 'tt:ReferenceToken'
        std::string AnalyticsEngineControlToken;
        /// Required element 'tt:State' of XML schema type 'tt:AnalyticsState'
        tt__AnalyticsState *State;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsStateInformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsStateInformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsStateInformation, default initialized and not managed by a soap context
        virtual tt__AnalyticsStateInformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsStateInformation); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsStateInformation() : AnalyticsEngineControlToken(), State(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AnalyticsStateInformation() { }
        /// Friend allocator used by soap_new_tt__AnalyticsStateInformation(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsStateInformation * SOAP_FMAC2 soap_instantiate_tt__AnalyticsStateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1609 */
#ifndef SOAP_TYPE_tt__AnalyticsState
#define SOAP_TYPE_tt__AnalyticsState (712)
/* Type tt__AnalyticsState is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsState': */
class SOAP_CMAC tt__AnalyticsState : public xsd__anyType {
      public:
        /// Optional element 'tt:Error' of XML schema type 'xsd:string'
        std::string *Error;
        /// Required element 'tt:State' of XML schema type 'xsd:string'
        std::string State;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsState
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsState; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsState, default initialized and not managed by a soap context
        virtual tt__AnalyticsState *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsState); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsState() : Error(), State(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AnalyticsState() { }
        /// Friend allocator used by soap_new_tt__AnalyticsState(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsState * SOAP_FMAC2 soap_instantiate_tt__AnalyticsState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1611 */
#ifndef SOAP_TYPE_tt__ActionEngineEventPayload
#define SOAP_TYPE_tt__ActionEngineEventPayload (713)
/* Type tt__ActionEngineEventPayload is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ActionEngineEventPayload': */
class SOAP_CMAC tt__ActionEngineEventPayload : public xsd__anyType {
      public:
        /// Optional element 'tt:RequestInfo' of XML schema type 'SOAP-ENV:Envelope'
        struct SOAP_ENV__Envelope *RequestInfo;
        /// Optional element 'tt:ResponseInfo' of XML schema type 'SOAP-ENV:Envelope'
        struct SOAP_ENV__Envelope *ResponseInfo;
        /// Optional element 'tt:Fault' of XML schema type 'SOAP-ENV:Fault'
        struct SOAP_ENV__Fault *Fault;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ActionEngineEventPayloadExtension'
        tt__ActionEngineEventPayloadExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ActionEngineEventPayload
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ActionEngineEventPayload; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ActionEngineEventPayload, default initialized and not managed by a soap context
        virtual tt__ActionEngineEventPayload *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ActionEngineEventPayload); }
      public:
        /// Constructor with default initializations
        tt__ActionEngineEventPayload() : RequestInfo(), ResponseInfo(), Fault(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ActionEngineEventPayload() { }
        /// Friend allocator used by soap_new_tt__ActionEngineEventPayload(struct soap*, int)
        friend SOAP_FMAC1 tt__ActionEngineEventPayload * SOAP_FMAC2 soap_instantiate_tt__ActionEngineEventPayload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1613 */
#ifndef SOAP_TYPE_tt__ActionEngineEventPayloadExtension
#define SOAP_TYPE_tt__ActionEngineEventPayloadExtension (714)
/* Type tt__ActionEngineEventPayloadExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ActionEngineEventPayloadExtension': */
class SOAP_CMAC tt__ActionEngineEventPayloadExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ActionEngineEventPayloadExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ActionEngineEventPayloadExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ActionEngineEventPayloadExtension, default initialized and not managed by a soap context
        virtual tt__ActionEngineEventPayloadExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ActionEngineEventPayloadExtension); }
      public:
        /// Constructor with default initializations
        tt__ActionEngineEventPayloadExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ActionEngineEventPayloadExtension() { }
        /// Friend allocator used by soap_new_tt__ActionEngineEventPayloadExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ActionEngineEventPayloadExtension * SOAP_FMAC2 soap_instantiate_tt__ActionEngineEventPayloadExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1615 */
#ifndef SOAP_TYPE_tt__AudioClassCandidate
#define SOAP_TYPE_tt__AudioClassCandidate (715)
/* Type tt__AudioClassCandidate is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioClassCandidate': */
class SOAP_CMAC tt__AudioClassCandidate : public xsd__anyType {
      public:
        /// Required element 'tt:Type' of XML schema type 'tt:AudioClassType'
        enum tt__AudioClassType Type;
        /// Required element 'tt:Likelihood' of XML schema type 'xsd:float'
        float Likelihood;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioClassCandidate
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioClassCandidate; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioClassCandidate, default initialized and not managed by a soap context
        virtual tt__AudioClassCandidate *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioClassCandidate); }
      public:
        /// Constructor with default initializations
        tt__AudioClassCandidate() : Type(), Likelihood(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioClassCandidate() { }
        /// Friend allocator used by soap_new_tt__AudioClassCandidate(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioClassCandidate * SOAP_FMAC2 soap_instantiate_tt__AudioClassCandidate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1617 */
#ifndef SOAP_TYPE_tt__AudioClassDescriptor
#define SOAP_TYPE_tt__AudioClassDescriptor (716)
/* Type tt__AudioClassDescriptor is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioClassDescriptor': */
class SOAP_CMAC tt__AudioClassDescriptor : public xsd__anyType {
      public:
        /// Optional element 'tt:ClassCandidate' of XML schema type 'tt:AudioClassCandidate'
        std::vector<tt__AudioClassCandidate *> ClassCandidate;
        /// Optional element 'tt:Extension' of XML schema type 'tt:AudioClassDescriptorExtension'
        tt__AudioClassDescriptorExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioClassDescriptor
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioClassDescriptor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioClassDescriptor, default initialized and not managed by a soap context
        virtual tt__AudioClassDescriptor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioClassDescriptor); }
      public:
        /// Constructor with default initializations
        tt__AudioClassDescriptor() : ClassCandidate(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioClassDescriptor() { }
        /// Friend allocator used by soap_new_tt__AudioClassDescriptor(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioClassDescriptor * SOAP_FMAC2 soap_instantiate_tt__AudioClassDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1619 */
#ifndef SOAP_TYPE_tt__AudioClassDescriptorExtension
#define SOAP_TYPE_tt__AudioClassDescriptorExtension (717)
/* Type tt__AudioClassDescriptorExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioClassDescriptorExtension': */
class SOAP_CMAC tt__AudioClassDescriptorExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioClassDescriptorExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioClassDescriptorExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioClassDescriptorExtension, default initialized and not managed by a soap context
        virtual tt__AudioClassDescriptorExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioClassDescriptorExtension); }
      public:
        /// Constructor with default initializations
        tt__AudioClassDescriptorExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioClassDescriptorExtension() { }
        /// Friend allocator used by soap_new_tt__AudioClassDescriptorExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioClassDescriptorExtension * SOAP_FMAC2 soap_instantiate_tt__AudioClassDescriptorExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1621 */
#ifndef SOAP_TYPE_tt__ActiveConnection
#define SOAP_TYPE_tt__ActiveConnection (718)
/* Type tt__ActiveConnection is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ActiveConnection': */
class SOAP_CMAC tt__ActiveConnection : public xsd__anyType {
      public:
        /// Required element 'tt:CurrentBitrate' of XML schema type 'xsd:float'
        float CurrentBitrate;
        /// Required element 'tt:CurrentFps' of XML schema type 'xsd:float'
        float CurrentFps;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ActiveConnection
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ActiveConnection; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ActiveConnection, default initialized and not managed by a soap context
        virtual tt__ActiveConnection *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ActiveConnection); }
      public:
        /// Constructor with default initializations
        tt__ActiveConnection() : CurrentBitrate(), CurrentFps(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ActiveConnection() { }
        /// Friend allocator used by soap_new_tt__ActiveConnection(struct soap*, int)
        friend SOAP_FMAC1 tt__ActiveConnection * SOAP_FMAC2 soap_instantiate_tt__ActiveConnection(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1623 */
#ifndef SOAP_TYPE_tt__ProfileStatus
#define SOAP_TYPE_tt__ProfileStatus (719)
/* Type tt__ProfileStatus is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ProfileStatus': */
class SOAP_CMAC tt__ProfileStatus : public xsd__anyType {
      public:
        /// Optional element 'tt:ActiveConnections' of XML schema type 'tt:ActiveConnection'
        std::vector<tt__ActiveConnection *> ActiveConnections;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ProfileStatusExtension'
        tt__ProfileStatusExtension *Extension;
      public:
        /// Return unique type id SOAP_TYPE_tt__ProfileStatus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ProfileStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ProfileStatus, default initialized and not managed by a soap context
        virtual tt__ProfileStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ProfileStatus); }
      public:
        /// Constructor with default initializations
        tt__ProfileStatus() : ActiveConnections(), Extension() { }
        /// Destructor
        virtual ~tt__ProfileStatus() { }
        /// Friend allocator used by soap_new_tt__ProfileStatus(struct soap*, int)
        friend SOAP_FMAC1 tt__ProfileStatus * SOAP_FMAC2 soap_instantiate_tt__ProfileStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1625 */
#ifndef SOAP_TYPE_tt__ProfileStatusExtension
#define SOAP_TYPE_tt__ProfileStatusExtension (720)
/* Type tt__ProfileStatusExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ProfileStatusExtension': */
class SOAP_CMAC tt__ProfileStatusExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ProfileStatusExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ProfileStatusExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ProfileStatusExtension, default initialized and not managed by a soap context
        virtual tt__ProfileStatusExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ProfileStatusExtension); }
      public:
        /// Constructor with default initializations
        tt__ProfileStatusExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ProfileStatusExtension() { }
        /// Friend allocator used by soap_new_tt__ProfileStatusExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ProfileStatusExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileStatusExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1629 */
#ifndef SOAP_TYPE_tt__OSDPosConfiguration
#define SOAP_TYPE_tt__OSDPosConfiguration (722)
/* Type tt__OSDPosConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDPosConfiguration': */
class SOAP_CMAC tt__OSDPosConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:Type' of XML schema type 'xsd:string'
        std::string Type;
        /// Optional element 'tt:Pos' of XML schema type 'tt:Vector'
        tt__Vector *Pos;
        /// Optional element 'tt:Extension' of XML schema type 'tt:OSDPosConfigurationExtension'
        tt__OSDPosConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDPosConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDPosConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDPosConfiguration, default initialized and not managed by a soap context
        virtual tt__OSDPosConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDPosConfiguration); }
      public:
        /// Constructor with default initializations
        tt__OSDPosConfiguration() : Type(), Pos(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDPosConfiguration() { }
        /// Friend allocator used by soap_new_tt__OSDPosConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDPosConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDPosConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1631 */
#ifndef SOAP_TYPE_tt__OSDPosConfigurationExtension
#define SOAP_TYPE_tt__OSDPosConfigurationExtension (723)
/* Type tt__OSDPosConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDPosConfigurationExtension': */
class SOAP_CMAC tt__OSDPosConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDPosConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDPosConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDPosConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__OSDPosConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDPosConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__OSDPosConfigurationExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDPosConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__OSDPosConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDPosConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDPosConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1633 */
#ifndef SOAP_TYPE_tt__OSDColor
#define SOAP_TYPE_tt__OSDColor (724)
/* Type tt__OSDColor is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDColor': */
class SOAP_CMAC tt__OSDColor : public xsd__anyType {
      public:
        /// Required element 'tt:Color' of XML schema type 'tt:Color'
        tt__Color *Color;
        /// Optional attribute 'Transparent' of XML schema type 'xsd:int'
        int *Transparent;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDColor
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDColor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDColor, default initialized and not managed by a soap context
        virtual tt__OSDColor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDColor); }
      public:
        /// Constructor with default initializations
        tt__OSDColor() : Color(), Transparent(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDColor() { }
        /// Friend allocator used by soap_new_tt__OSDColor(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDColor * SOAP_FMAC2 soap_instantiate_tt__OSDColor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1635 */
#ifndef SOAP_TYPE_tt__OSDTextConfiguration
#define SOAP_TYPE_tt__OSDTextConfiguration (725)
/* Type tt__OSDTextConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDTextConfiguration': */
class SOAP_CMAC tt__OSDTextConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:Type' of XML schema type 'xsd:string'
        std::string Type;
        /// Optional element 'tt:DateFormat' of XML schema type 'xsd:string'
        std::string *DateFormat;
        /// Optional element 'tt:TimeFormat' of XML schema type 'xsd:string'
        std::string *TimeFormat;
        /// Optional element 'tt:FontSize' of XML schema type 'xsd:int'
        int *FontSize;
        /// Optional element 'tt:FontColor' of XML schema type 'tt:OSDColor'
        tt__OSDColor *FontColor;
        /// Optional element 'tt:BackgroundColor' of XML schema type 'tt:OSDColor'
        tt__OSDColor *BackgroundColor;
        /// Optional element 'tt:PlainText' of XML schema type 'xsd:string'
        std::string *PlainText;
        /// Optional element 'tt:Extension' of XML schema type 'tt:OSDTextConfigurationExtension'
        tt__OSDTextConfigurationExtension *Extension;
        /// Optional attribute 'IsPersistentText' of XML schema type 'xsd:boolean'
        bool *IsPersistentText;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDTextConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDTextConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDTextConfiguration, default initialized and not managed by a soap context
        virtual tt__OSDTextConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDTextConfiguration); }
      public:
        /// Constructor with default initializations
        tt__OSDTextConfiguration() : Type(), DateFormat(), TimeFormat(), FontSize(), FontColor(), BackgroundColor(), PlainText(), Extension(), IsPersistentText(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDTextConfiguration() { }
        /// Friend allocator used by soap_new_tt__OSDTextConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDTextConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDTextConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1637 */
#ifndef SOAP_TYPE_tt__OSDTextConfigurationExtension
#define SOAP_TYPE_tt__OSDTextConfigurationExtension (726)
/* Type tt__OSDTextConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDTextConfigurationExtension': */
class SOAP_CMAC tt__OSDTextConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDTextConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDTextConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDTextConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__OSDTextConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDTextConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__OSDTextConfigurationExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDTextConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__OSDTextConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDTextConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDTextConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1639 */
#ifndef SOAP_TYPE_tt__OSDImgConfiguration
#define SOAP_TYPE_tt__OSDImgConfiguration (727)
/* Type tt__OSDImgConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDImgConfiguration': */
class SOAP_CMAC tt__OSDImgConfiguration : public xsd__anyType {
      public:
        /// Required element 'tt:ImgPath' of XML schema type 'xsd:anyURI'
        std::string ImgPath;
        /// Optional element 'tt:Extension' of XML schema type 'tt:OSDImgConfigurationExtension'
        tt__OSDImgConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDImgConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDImgConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDImgConfiguration, default initialized and not managed by a soap context
        virtual tt__OSDImgConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDImgConfiguration); }
      public:
        /// Constructor with default initializations
        tt__OSDImgConfiguration() : ImgPath(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDImgConfiguration() { }
        /// Friend allocator used by soap_new_tt__OSDImgConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDImgConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDImgConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1641 */
#ifndef SOAP_TYPE_tt__OSDImgConfigurationExtension
#define SOAP_TYPE_tt__OSDImgConfigurationExtension (728)
/* Type tt__OSDImgConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDImgConfigurationExtension': */
class SOAP_CMAC tt__OSDImgConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDImgConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDImgConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDImgConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__OSDImgConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDImgConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__OSDImgConfigurationExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDImgConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__OSDImgConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDImgConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDImgConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1643 */
#ifndef SOAP_TYPE_tt__ColorspaceRange
#define SOAP_TYPE_tt__ColorspaceRange (729)
/* Type tt__ColorspaceRange is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ColorspaceRange': */
class SOAP_CMAC tt__ColorspaceRange : public xsd__anyType {
      public:
        /// Required element 'tt:X' of XML schema type 'tt:FloatRange'
        tt__FloatRange *X;
        /// Required element 'tt:Y' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Y;
        /// Required element 'tt:Z' of XML schema type 'tt:FloatRange'
        tt__FloatRange *Z;
        /// Required element 'tt:Colorspace' of XML schema type 'xsd:anyURI'
        std::string Colorspace;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ColorspaceRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ColorspaceRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ColorspaceRange, default initialized and not managed by a soap context
        virtual tt__ColorspaceRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ColorspaceRange); }
      public:
        /// Constructor with default initializations
        tt__ColorspaceRange() : X(), Y(), Z(), Colorspace(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ColorspaceRange() { }
        /// Friend allocator used by soap_new_tt__ColorspaceRange(struct soap*, int)
        friend SOAP_FMAC1 tt__ColorspaceRange * SOAP_FMAC2 soap_instantiate_tt__ColorspaceRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:24098 */
#ifndef SOAP_TYPE__tt__union_ColorOptions
#define SOAP_TYPE__tt__union_ColorOptions (1502)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _tt__union_ColorOptions
{
        #define SOAP_UNION__tt__union_ColorOptions_ColorList	(1)	/**< union variant selector value for member ColorList */
        std::vector<tt__Color *> *ColorList;
        #define SOAP_UNION__tt__union_ColorOptions_ColorspaceRange	(2)	/**< union variant selector value for member ColorspaceRange */
        std::vector<tt__ColorspaceRange *> *ColorspaceRange;
};
#endif

/* onvif.h:1645 */
#ifndef SOAP_TYPE_tt__ColorOptions
#define SOAP_TYPE_tt__ColorOptions (730)
/* Type tt__ColorOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ColorOptions': */
class SOAP_CMAC tt__ColorOptions : public xsd__anyType {
      public:
        /// Union with union _tt__union_ColorOptions variant selector __union_ColorOptions set to one of: SOAP_UNION__tt__union_ColorOptions_ColorList SOAP_UNION__tt__union_ColorOptions_ColorspaceRange
        int __union_ColorOptions;
        union _tt__union_ColorOptions union_ColorOptions;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ColorOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ColorOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ColorOptions, default initialized and not managed by a soap context
        virtual tt__ColorOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ColorOptions); }
      public:
        /// Constructor with default initializations
        tt__ColorOptions() : __union_ColorOptions(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ColorOptions() { }
        /// Friend allocator used by soap_new_tt__ColorOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__ColorOptions * SOAP_FMAC2 soap_instantiate_tt__ColorOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1647 */
#ifndef SOAP_TYPE_tt__OSDColorOptions
#define SOAP_TYPE_tt__OSDColorOptions (731)
/* Type tt__OSDColorOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDColorOptions': */
class SOAP_CMAC tt__OSDColorOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:Color' of XML schema type 'tt:ColorOptions'
        tt__ColorOptions *Color;
        /// Optional element 'tt:Transparent' of XML schema type 'tt:IntRange'
        tt__IntRange *Transparent;
        /// Optional element 'tt:Extension' of XML schema type 'tt:OSDColorOptionsExtension'
        tt__OSDColorOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDColorOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDColorOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDColorOptions, default initialized and not managed by a soap context
        virtual tt__OSDColorOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDColorOptions); }
      public:
        /// Constructor with default initializations
        tt__OSDColorOptions() : Color(), Transparent(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDColorOptions() { }
        /// Friend allocator used by soap_new_tt__OSDColorOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDColorOptions * SOAP_FMAC2 soap_instantiate_tt__OSDColorOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1649 */
#ifndef SOAP_TYPE_tt__OSDColorOptionsExtension
#define SOAP_TYPE_tt__OSDColorOptionsExtension (732)
/* Type tt__OSDColorOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDColorOptionsExtension': */
class SOAP_CMAC tt__OSDColorOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDColorOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDColorOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDColorOptionsExtension, default initialized and not managed by a soap context
        virtual tt__OSDColorOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDColorOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__OSDColorOptionsExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDColorOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__OSDColorOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDColorOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDColorOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1651 */
#ifndef SOAP_TYPE_tt__OSDTextOptions
#define SOAP_TYPE_tt__OSDTextOptions (733)
/* Type tt__OSDTextOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDTextOptions': */
class SOAP_CMAC tt__OSDTextOptions : public xsd__anyType {
      public:
        /// Required element 'tt:Type' of XML schema type 'xsd:string'
        std::vector<std::string> Type;
        /// Optional element 'tt:FontSizeRange' of XML schema type 'tt:IntRange'
        tt__IntRange *FontSizeRange;
        /// Optional element 'tt:DateFormat' of XML schema type 'xsd:string'
        std::vector<std::string> DateFormat;
        /// Optional element 'tt:TimeFormat' of XML schema type 'xsd:string'
        std::vector<std::string> TimeFormat;
        /// Optional element 'tt:FontColor' of XML schema type 'tt:OSDColorOptions'
        tt__OSDColorOptions *FontColor;
        /// Optional element 'tt:BackgroundColor' of XML schema type 'tt:OSDColorOptions'
        tt__OSDColorOptions *BackgroundColor;
        /// Optional element 'tt:Extension' of XML schema type 'tt:OSDTextOptionsExtension'
        tt__OSDTextOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDTextOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDTextOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDTextOptions, default initialized and not managed by a soap context
        virtual tt__OSDTextOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDTextOptions); }
      public:
        /// Constructor with default initializations
        tt__OSDTextOptions() : Type(), FontSizeRange(), DateFormat(), TimeFormat(), FontColor(), BackgroundColor(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDTextOptions() { }
        /// Friend allocator used by soap_new_tt__OSDTextOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDTextOptions * SOAP_FMAC2 soap_instantiate_tt__OSDTextOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1653 */
#ifndef SOAP_TYPE_tt__OSDTextOptionsExtension
#define SOAP_TYPE_tt__OSDTextOptionsExtension (734)
/* Type tt__OSDTextOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDTextOptionsExtension': */
class SOAP_CMAC tt__OSDTextOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDTextOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDTextOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDTextOptionsExtension, default initialized and not managed by a soap context
        virtual tt__OSDTextOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDTextOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__OSDTextOptionsExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDTextOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__OSDTextOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDTextOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDTextOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1655 */
#ifndef SOAP_TYPE_tt__OSDImgOptions
#define SOAP_TYPE_tt__OSDImgOptions (735)
/* Type tt__OSDImgOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDImgOptions': */
class SOAP_CMAC tt__OSDImgOptions : public xsd__anyType {
      public:
        /// Required element 'tt:ImagePath' of XML schema type 'xsd:anyURI'
        std::vector<std::string> ImagePath;
        /// Optional element 'tt:Extension' of XML schema type 'tt:OSDImgOptionsExtension'
        tt__OSDImgOptionsExtension *Extension;
        /// Optional attribute 'FormatsSupported' of XML schema type 'tt:StringAttrList'
        std::string *FormatsSupported;
        /// Optional attribute 'MaxSize' of XML schema type 'xsd:int'
        int *MaxSize;
        /// Optional attribute 'MaxWidth' of XML schema type 'xsd:int'
        int *MaxWidth;
        /// Optional attribute 'MaxHeight' of XML schema type 'xsd:int'
        int *MaxHeight;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDImgOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDImgOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDImgOptions, default initialized and not managed by a soap context
        virtual tt__OSDImgOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDImgOptions); }
      public:
        /// Constructor with default initializations
        tt__OSDImgOptions() : ImagePath(), Extension(), FormatsSupported(), MaxSize(), MaxWidth(), MaxHeight(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDImgOptions() { }
        /// Friend allocator used by soap_new_tt__OSDImgOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDImgOptions * SOAP_FMAC2 soap_instantiate_tt__OSDImgOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1657 */
#ifndef SOAP_TYPE_tt__OSDImgOptionsExtension
#define SOAP_TYPE_tt__OSDImgOptionsExtension (736)
/* Type tt__OSDImgOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDImgOptionsExtension': */
class SOAP_CMAC tt__OSDImgOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDImgOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDImgOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDImgOptionsExtension, default initialized and not managed by a soap context
        virtual tt__OSDImgOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDImgOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__OSDImgOptionsExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDImgOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__OSDImgOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDImgOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDImgOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1661 */
#ifndef SOAP_TYPE_tt__OSDConfigurationExtension
#define SOAP_TYPE_tt__OSDConfigurationExtension (738)
/* Type tt__OSDConfigurationExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDConfigurationExtension': */
class SOAP_CMAC tt__OSDConfigurationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDConfigurationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDConfigurationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDConfigurationExtension, default initialized and not managed by a soap context
        virtual tt__OSDConfigurationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDConfigurationExtension); }
      public:
        /// Constructor with default initializations
        tt__OSDConfigurationExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDConfigurationExtension() { }
        /// Friend allocator used by soap_new_tt__OSDConfigurationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1663 */
#ifndef SOAP_TYPE_tt__MaximumNumberOfOSDs
#define SOAP_TYPE_tt__MaximumNumberOfOSDs (739)
/* Type tt__MaximumNumberOfOSDs is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tt:MaximumNumberOfOSDs': */
class SOAP_CMAC tt__MaximumNumberOfOSDs : public xsd__anyType {
      public:
        /// Required attribute 'Total' of XML schema type 'xsd:int'
        int Total;
        /// Optional attribute 'Image' of XML schema type 'xsd:int'
        int *Image;
        /// Optional attribute 'PlainText' of XML schema type 'xsd:int'
        int *PlainText;
        /// Optional attribute 'Date' of XML schema type 'xsd:int'
        int *Date;
        /// Optional attribute 'Time' of XML schema type 'xsd:int'
        int *Time;
        /// Optional attribute 'DateAndTime' of XML schema type 'xsd:int'
        int *DateAndTime;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MaximumNumberOfOSDs
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MaximumNumberOfOSDs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MaximumNumberOfOSDs, default initialized and not managed by a soap context
        virtual tt__MaximumNumberOfOSDs *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MaximumNumberOfOSDs); }
      public:
        /// Constructor with default initializations
        tt__MaximumNumberOfOSDs() : Total(), Image(), PlainText(), Date(), Time(), DateAndTime(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MaximumNumberOfOSDs() { }
        /// Friend allocator used by soap_new_tt__MaximumNumberOfOSDs(struct soap*, int)
        friend SOAP_FMAC1 tt__MaximumNumberOfOSDs * SOAP_FMAC2 soap_instantiate_tt__MaximumNumberOfOSDs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1665 */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptions
#define SOAP_TYPE_tt__OSDConfigurationOptions (740)
/* Type tt__OSDConfigurationOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDConfigurationOptions': */
class SOAP_CMAC tt__OSDConfigurationOptions : public xsd__anyType {
      public:
        /// Required element 'tt:MaximumNumberOfOSDs' of XML schema type 'tt:MaximumNumberOfOSDs'
        tt__MaximumNumberOfOSDs *MaximumNumberOfOSDs;
        /// Required element 'tt:Type' of XML schema type 'tt:OSDType'
        std::vector<enum tt__OSDType> Type;
        /// Required element 'tt:PositionOption' of XML schema type 'xsd:string'
        std::vector<std::string> PositionOption;
        /// Optional element 'tt:TextOption' of XML schema type 'tt:OSDTextOptions'
        tt__OSDTextOptions *TextOption;
        /// Optional element 'tt:ImageOption' of XML schema type 'tt:OSDImgOptions'
        tt__OSDImgOptions *ImageOption;
        /// Optional element 'tt:Extension' of XML schema type 'tt:OSDConfigurationOptionsExtension'
        tt__OSDConfigurationOptionsExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDConfigurationOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDConfigurationOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDConfigurationOptions, default initialized and not managed by a soap context
        virtual tt__OSDConfigurationOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDConfigurationOptions); }
      public:
        /// Constructor with default initializations
        tt__OSDConfigurationOptions() : MaximumNumberOfOSDs(), Type(), PositionOption(), TextOption(), ImageOption(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDConfigurationOptions() { }
        /// Friend allocator used by soap_new_tt__OSDConfigurationOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1667 */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptionsExtension
#define SOAP_TYPE_tt__OSDConfigurationOptionsExtension (741)
/* Type tt__OSDConfigurationOptionsExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDConfigurationOptionsExtension': */
class SOAP_CMAC tt__OSDConfigurationOptionsExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDConfigurationOptionsExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDConfigurationOptionsExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDConfigurationOptionsExtension, default initialized and not managed by a soap context
        virtual tt__OSDConfigurationOptionsExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDConfigurationOptionsExtension); }
      public:
        /// Constructor with default initializations
        tt__OSDConfigurationOptionsExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDConfigurationOptionsExtension() { }
        /// Friend allocator used by soap_new_tt__OSDConfigurationOptionsExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__OSDConfigurationOptionsExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1669 */
#ifndef SOAP_TYPE_tt__FileProgress
#define SOAP_TYPE_tt__FileProgress (742)
/* Type tt__FileProgress is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:FileProgress': */
class SOAP_CMAC tt__FileProgress : public xsd__anyType {
      public:
        /// Required element 'tt:FileName' of XML schema type 'xsd:string'
        std::string FileName;
        /// Required element 'tt:Progress' of XML schema type 'xsd:float'
        float Progress;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__FileProgress
        virtual long soap_type(void) const { return SOAP_TYPE_tt__FileProgress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__FileProgress, default initialized and not managed by a soap context
        virtual tt__FileProgress *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__FileProgress); }
      public:
        /// Constructor with default initializations
        tt__FileProgress() : FileName(), Progress(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__FileProgress() { }
        /// Friend allocator used by soap_new_tt__FileProgress(struct soap*, int)
        friend SOAP_FMAC1 tt__FileProgress * SOAP_FMAC2 soap_instantiate_tt__FileProgress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1671 */
#ifndef SOAP_TYPE_tt__ArrayOfFileProgress
#define SOAP_TYPE_tt__ArrayOfFileProgress (743)
/* Type tt__ArrayOfFileProgress is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ArrayOfFileProgress': */
class SOAP_CMAC tt__ArrayOfFileProgress : public xsd__anyType {
      public:
        /// Optional element 'tt:FileProgress' of XML schema type 'tt:FileProgress'
        std::vector<tt__FileProgress *> FileProgress;
        /// Optional element 'tt:Extension' of XML schema type 'tt:ArrayOfFileProgressExtension'
        tt__ArrayOfFileProgressExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ArrayOfFileProgress
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ArrayOfFileProgress; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ArrayOfFileProgress, default initialized and not managed by a soap context
        virtual tt__ArrayOfFileProgress *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ArrayOfFileProgress); }
      public:
        /// Constructor with default initializations
        tt__ArrayOfFileProgress() : FileProgress(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ArrayOfFileProgress() { }
        /// Friend allocator used by soap_new_tt__ArrayOfFileProgress(struct soap*, int)
        friend SOAP_FMAC1 tt__ArrayOfFileProgress * SOAP_FMAC2 soap_instantiate_tt__ArrayOfFileProgress(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1673 */
#ifndef SOAP_TYPE_tt__ArrayOfFileProgressExtension
#define SOAP_TYPE_tt__ArrayOfFileProgressExtension (744)
/* Type tt__ArrayOfFileProgressExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ArrayOfFileProgressExtension': */
class SOAP_CMAC tt__ArrayOfFileProgressExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ArrayOfFileProgressExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ArrayOfFileProgressExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ArrayOfFileProgressExtension, default initialized and not managed by a soap context
        virtual tt__ArrayOfFileProgressExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ArrayOfFileProgressExtension); }
      public:
        /// Constructor with default initializations
        tt__ArrayOfFileProgressExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ArrayOfFileProgressExtension() { }
        /// Friend allocator used by soap_new_tt__ArrayOfFileProgressExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__ArrayOfFileProgressExtension * SOAP_FMAC2 soap_instantiate_tt__ArrayOfFileProgressExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1675 */
#ifndef SOAP_TYPE_tt__StorageReferencePath
#define SOAP_TYPE_tt__StorageReferencePath (745)
/* Type tt__StorageReferencePath is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:StorageReferencePath': */
class SOAP_CMAC tt__StorageReferencePath : public xsd__anyType {
      public:
        /// Required element 'tt:StorageToken' of XML schema type 'tt:ReferenceToken'
        std::string StorageToken;
        /// Optional element 'tt:RelativePath' of XML schema type 'xsd:string'
        std::string *RelativePath;
        /// Optional element 'tt:Extension' of XML schema type 'tt:StorageReferencePathExtension'
        tt__StorageReferencePathExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__StorageReferencePath
        virtual long soap_type(void) const { return SOAP_TYPE_tt__StorageReferencePath; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__StorageReferencePath, default initialized and not managed by a soap context
        virtual tt__StorageReferencePath *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__StorageReferencePath); }
      public:
        /// Constructor with default initializations
        tt__StorageReferencePath() : StorageToken(), RelativePath(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__StorageReferencePath() { }
        /// Friend allocator used by soap_new_tt__StorageReferencePath(struct soap*, int)
        friend SOAP_FMAC1 tt__StorageReferencePath * SOAP_FMAC2 soap_instantiate_tt__StorageReferencePath(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1677 */
#ifndef SOAP_TYPE_tt__StorageReferencePathExtension
#define SOAP_TYPE_tt__StorageReferencePathExtension (746)
/* Type tt__StorageReferencePathExtension is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:StorageReferencePathExtension': */
class SOAP_CMAC tt__StorageReferencePathExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__StorageReferencePathExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__StorageReferencePathExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__StorageReferencePathExtension, default initialized and not managed by a soap context
        virtual tt__StorageReferencePathExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__StorageReferencePathExtension); }
      public:
        /// Constructor with default initializations
        tt__StorageReferencePathExtension() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__StorageReferencePathExtension() { }
        /// Friend allocator used by soap_new_tt__StorageReferencePathExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__StorageReferencePathExtension * SOAP_FMAC2 soap_instantiate_tt__StorageReferencePathExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1679 */
#ifndef SOAP_TYPE_tt__PolygonOptions
#define SOAP_TYPE_tt__PolygonOptions (747)
/* Type tt__PolygonOptions is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PolygonOptions': */
class SOAP_CMAC tt__PolygonOptions : public xsd__anyType {
      public:
        /// Optional element 'tt:RectangleOnly' of XML schema type 'xsd:boolean'
        bool *RectangleOnly;
        /// Optional element 'tt:VertexLimits' of XML schema type 'tt:IntRange'
        tt__IntRange *VertexLimits;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PolygonOptions
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PolygonOptions; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PolygonOptions, default initialized and not managed by a soap context
        virtual tt__PolygonOptions *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PolygonOptions); }
      public:
        /// Constructor with default initializations
        tt__PolygonOptions() : RectangleOnly(), VertexLimits(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PolygonOptions() { }
        /// Friend allocator used by soap_new_tt__PolygonOptions(struct soap*, int)
        friend SOAP_FMAC1 tt__PolygonOptions * SOAP_FMAC2 soap_instantiate_tt__PolygonOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1681 */
#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (748)
/* Type tt__IntRange is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:IntRange': */
class SOAP_CMAC tt__IntRange : public xsd__anyType {
      public:
        /// Required element 'tt:Min' of XML schema type 'xsd:int'
        int Min;
        /// Required element 'tt:Max' of XML schema type 'xsd:int'
        int Max;
      public:
        /// Return unique type id SOAP_TYPE_tt__IntRange
        virtual long soap_type(void) const { return SOAP_TYPE_tt__IntRange; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__IntRange, default initialized and not managed by a soap context
        virtual tt__IntRange *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__IntRange); }
      public:
        /// Constructor with default initializations
        tt__IntRange() : Min(), Max() { }
        /// Destructor
        virtual ~tt__IntRange() { }
        /// Friend allocator used by soap_new_tt__IntRange(struct soap*, int)
        friend SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 soap_instantiate_tt__IntRange(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1683 */
#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (749)
/* Type tt__Vector2D is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tt:Vector2D': */
class SOAP_CMAC tt__Vector2D : public xsd__anyType {
      public:
        /// Required attribute 'x' of XML schema type 'xsd:float'
        float x;
        /// Required attribute 'y' of XML schema type 'xsd:float'
        float y;
        /// Optional attribute 'space' of XML schema type 'xsd:anyURI'
        std::string *space;
      public:
        /// Return unique type id SOAP_TYPE_tt__Vector2D
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Vector2D; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Vector2D, default initialized and not managed by a soap context
        virtual tt__Vector2D *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Vector2D); }
      public:
        /// Constructor with default initializations
        tt__Vector2D() : x(), y(), space() { }
        /// Destructor
        virtual ~tt__Vector2D() { }
        /// Friend allocator used by soap_new_tt__Vector2D(struct soap*, int)
        friend SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 soap_instantiate_tt__Vector2D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1685 */
#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (750)
/* Type tt__Vector1D is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tt:Vector1D': */
class SOAP_CMAC tt__Vector1D : public xsd__anyType {
      public:
        /// Required attribute 'x' of XML schema type 'xsd:float'
        float x;
        /// Optional attribute 'space' of XML schema type 'xsd:anyURI'
        std::string *space;
      public:
        /// Return unique type id SOAP_TYPE_tt__Vector1D
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Vector1D; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Vector1D, default initialized and not managed by a soap context
        virtual tt__Vector1D *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Vector1D); }
      public:
        /// Constructor with default initializations
        tt__Vector1D() : x(), space() { }
        /// Destructor
        virtual ~tt__Vector1D() { }
        /// Friend allocator used by soap_new_tt__Vector1D(struct soap*, int)
        friend SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 soap_instantiate_tt__Vector1D(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1687 */
#ifndef SOAP_TYPE_tt__PTZVector
#define SOAP_TYPE_tt__PTZVector (751)
/* Type tt__PTZVector is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZVector': */
class SOAP_CMAC tt__PTZVector : public xsd__anyType {
      public:
        /// Optional element 'tt:PanTilt' of XML schema type 'tt:Vector2D'
        tt__Vector2D *PanTilt;
        /// Optional element 'tt:Zoom' of XML schema type 'tt:Vector1D'
        tt__Vector1D *Zoom;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZVector
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZVector; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZVector, default initialized and not managed by a soap context
        virtual tt__PTZVector *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZVector); }
      public:
        /// Constructor with default initializations
        tt__PTZVector() : PanTilt(), Zoom() { }
        /// Destructor
        virtual ~tt__PTZVector() { }
        /// Friend allocator used by soap_new_tt__PTZVector(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZVector * SOAP_FMAC2 soap_instantiate_tt__PTZVector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1689 */
#ifndef SOAP_TYPE_tt__PTZStatus
#define SOAP_TYPE_tt__PTZStatus (752)
/* Type tt__PTZStatus is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZStatus': */
class SOAP_CMAC tt__PTZStatus : public xsd__anyType {
      public:
        /// Optional element 'tt:Position' of XML schema type 'tt:PTZVector'
        tt__PTZVector *Position;
        /// Optional element 'tt:MoveStatus' of XML schema type 'tt:PTZMoveStatus'
        tt__PTZMoveStatus *MoveStatus;
        /// Optional element 'tt:Error' of XML schema type 'xsd:string'
        std::string *Error;
        /// Required element 'tt:UtcTime' of XML schema type 'xsd:dateTime'
        time_t UtcTime;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZStatus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZStatus, default initialized and not managed by a soap context
        virtual tt__PTZStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZStatus); }
      public:
        /// Constructor with default initializations
        tt__PTZStatus() : Position(), MoveStatus(), Error(), UtcTime(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZStatus() { }
        /// Friend allocator used by soap_new_tt__PTZStatus(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZStatus * SOAP_FMAC2 soap_instantiate_tt__PTZStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1691 */
#ifndef SOAP_TYPE_tt__PTZMoveStatus
#define SOAP_TYPE_tt__PTZMoveStatus (753)
/* Type tt__PTZMoveStatus is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZMoveStatus': */
class SOAP_CMAC tt__PTZMoveStatus : public xsd__anyType {
      public:
        /// Optional element 'tt:PanTilt' of XML schema type 'tt:MoveStatus'
        enum tt__MoveStatus *PanTilt;
        /// Optional element 'tt:Zoom' of XML schema type 'tt:MoveStatus'
        enum tt__MoveStatus *Zoom;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZMoveStatus
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZMoveStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZMoveStatus, default initialized and not managed by a soap context
        virtual tt__PTZMoveStatus *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZMoveStatus); }
      public:
        /// Constructor with default initializations
        tt__PTZMoveStatus() : PanTilt(), Zoom() { }
        /// Destructor
        virtual ~tt__PTZMoveStatus() { }
        /// Friend allocator used by soap_new_tt__PTZMoveStatus(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZMoveStatus * SOAP_FMAC2 soap_instantiate_tt__PTZMoveStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1693 */
#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (754)
/* simple XML schema type 'tt:Vector': */
class SOAP_CMAC tt__Vector : public xsd__anyType {
      public:
        /// Optional attribute 'x' of XML schema type 'xsd:float'
        float *x;
        /// Optional attribute 'y' of XML schema type 'xsd:float'
        float *y;
      public:
        /// Return unique type id SOAP_TYPE_tt__Vector
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Vector; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Vector, default initialized and not managed by a soap context
        virtual tt__Vector *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Vector); }
      public:
        /// Constructor with default initializations
        tt__Vector() : x(), y() { }
        /// Destructor
        virtual ~tt__Vector() { }
        /// Friend allocator used by soap_new_tt__Vector(struct soap*, int)
        friend SOAP_FMAC1 tt__Vector * SOAP_FMAC2 soap_instantiate_tt__Vector(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1695 */
#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (755)
/* Type tt__Rectangle is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tt:Rectangle': */
class SOAP_CMAC tt__Rectangle : public xsd__anyType {
      public:
        /// Optional attribute 'bottom' of XML schema type 'xsd:float'
        float *bottom;
        /// Optional attribute 'top' of XML schema type 'xsd:float'
        float *top;
        /// Optional attribute 'right' of XML schema type 'xsd:float'
        float *right;
        /// Optional attribute 'left' of XML schema type 'xsd:float'
        float *left;
      public:
        /// Return unique type id SOAP_TYPE_tt__Rectangle
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Rectangle; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Rectangle, default initialized and not managed by a soap context
        virtual tt__Rectangle *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Rectangle); }
      public:
        /// Constructor with default initializations
        tt__Rectangle() : bottom(), top(), right(), left() { }
        /// Destructor
        virtual ~tt__Rectangle() { }
        /// Friend allocator used by soap_new_tt__Rectangle(struct soap*, int)
        friend SOAP_FMAC1 tt__Rectangle * SOAP_FMAC2 soap_instantiate_tt__Rectangle(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1697 */
#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (756)
/* Type tt__Polygon is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Polygon': */
class SOAP_CMAC tt__Polygon : public xsd__anyType {
      public:
        /// Required element 'tt:Point' of XML schema type 'tt:Vector'
        std::vector<tt__Vector *> Point;
      public:
        /// Return unique type id SOAP_TYPE_tt__Polygon
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Polygon; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Polygon, default initialized and not managed by a soap context
        virtual tt__Polygon *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Polygon); }
      public:
        /// Constructor with default initializations
        tt__Polygon() : Point() { }
        /// Destructor
        virtual ~tt__Polygon() { }
        /// Friend allocator used by soap_new_tt__Polygon(struct soap*, int)
        friend SOAP_FMAC1 tt__Polygon * SOAP_FMAC2 soap_instantiate_tt__Polygon(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1699 */
#ifndef SOAP_TYPE_tt__Color
#define SOAP_TYPE_tt__Color (757)
/* simple XML schema type 'tt:Color': */
class SOAP_CMAC tt__Color : public xsd__anyType {
      public:
        /// Required attribute 'X' of XML schema type 'xsd:float'
        float X;
        /// Required attribute 'Y' of XML schema type 'xsd:float'
        float Y;
        /// Required attribute 'Z' of XML schema type 'xsd:float'
        float Z;
        /// Optional attribute 'Colorspace' of XML schema type 'xsd:anyURI'
        std::string *Colorspace;
        /// Optional attribute 'Likelihood' of XML schema type 'xsd:float'
        float *Likelihood;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Color
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Color; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Color, default initialized and not managed by a soap context
        virtual tt__Color *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Color); }
      public:
        /// Constructor with default initializations
        tt__Color() : X(), Y(), Z(), Colorspace(), Likelihood(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Color() { }
        /// Friend allocator used by soap_new_tt__Color(struct soap*, int)
        friend SOAP_FMAC1 tt__Color * SOAP_FMAC2 soap_instantiate_tt__Color(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1701 */
#ifndef SOAP_TYPE_tt__ColorCovariance
#define SOAP_TYPE_tt__ColorCovariance (758)
/* simple XML schema type 'tt:ColorCovariance': */
class SOAP_CMAC tt__ColorCovariance : public xsd__anyType {
      public:
        /// Required attribute 'XX' of XML schema type 'xsd:float'
        float XX;
        /// Required attribute 'YY' of XML schema type 'xsd:float'
        float YY;
        /// Required attribute 'ZZ' of XML schema type 'xsd:float'
        float ZZ;
        /// Optional attribute 'XY' of XML schema type 'xsd:float'
        float *XY;
        /// Optional attribute 'XZ' of XML schema type 'xsd:float'
        float *XZ;
        /// Optional attribute 'YZ' of XML schema type 'xsd:float'
        float *YZ;
        /// Optional attribute 'Colorspace' of XML schema type 'xsd:anyURI'
        std::string *Colorspace;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ColorCovariance
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ColorCovariance; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ColorCovariance, default initialized and not managed by a soap context
        virtual tt__ColorCovariance *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ColorCovariance); }
      public:
        /// Constructor with default initializations
        tt__ColorCovariance() : XX(), YY(), ZZ(), XY(), XZ(), YZ(), Colorspace(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ColorCovariance() { }
        /// Friend allocator used by soap_new_tt__ColorCovariance(struct soap*, int)
        friend SOAP_FMAC1 tt__ColorCovariance * SOAP_FMAC2 soap_instantiate_tt__ColorCovariance(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:25137 */
#ifndef SOAP_TYPE__tt__ColorDescriptor_ColorCluster
#define SOAP_TYPE__tt__ColorDescriptor_ColorCluster (1524)
/* complex XML schema type 'tt:ColorDescriptor-ColorCluster': */
class SOAP_CMAC _tt__ColorDescriptor_ColorCluster {
      public:
        /// Required element 'tt:Color' of XML schema type 'tt:Color'
        tt__Color *Color;
        /// Optional element 'tt:Weight' of XML schema type 'xsd:float'
        float *Weight;
        /// Optional element 'tt:Covariance' of XML schema type 'tt:ColorCovariance'
        tt__ColorCovariance *Covariance;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE__tt__ColorDescriptor_ColorCluster
        virtual long soap_type(void) const { return SOAP_TYPE__tt__ColorDescriptor_ColorCluster; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__ColorDescriptor_ColorCluster, default initialized and not managed by a soap context
        virtual _tt__ColorDescriptor_ColorCluster *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__ColorDescriptor_ColorCluster); }
      public:
        /// Constructor with default initializations
        _tt__ColorDescriptor_ColorCluster() : Color(), Weight(), Covariance(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~_tt__ColorDescriptor_ColorCluster() { }
        /// Friend allocator used by soap_new__tt__ColorDescriptor_ColorCluster(struct soap*, int)
        friend SOAP_FMAC1 _tt__ColorDescriptor_ColorCluster * SOAP_FMAC2 soap_instantiate__tt__ColorDescriptor_ColorCluster(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1703 */
#ifndef SOAP_TYPE_tt__ColorDescriptor
#define SOAP_TYPE_tt__ColorDescriptor (759)
/* Type tt__ColorDescriptor is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:ColorDescriptor': */
class SOAP_CMAC tt__ColorDescriptor : public xsd__anyType {
      public:
        /// Optional element 'tt:ColorCluster' of XML schema type 'tt:ColorDescriptor-ColorCluster'
        std::vector<_tt__ColorDescriptor_ColorCluster> ColorCluster;
        /// Optional element 'tt:Extension' of XML schema type 'xsd:anyType'
        xsd__anyType *Extension;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__ColorDescriptor
        virtual long soap_type(void) const { return SOAP_TYPE_tt__ColorDescriptor; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__ColorDescriptor, default initialized and not managed by a soap context
        virtual tt__ColorDescriptor *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__ColorDescriptor); }
      public:
        /// Constructor with default initializations
        tt__ColorDescriptor() : ColorCluster(), Extension(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__ColorDescriptor() { }
        /// Friend allocator used by soap_new_tt__ColorDescriptor(struct soap*, int)
        friend SOAP_FMAC1 tt__ColorDescriptor * SOAP_FMAC2 soap_instantiate_tt__ColorDescriptor(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1705 */
#ifndef SOAP_TYPE_tt__Transformation
#define SOAP_TYPE_tt__Transformation (760)
/* complex XML schema type 'tt:Transformation': */
class SOAP_CMAC tt__Transformation : public xsd__anyType {
      public:
        /// Optional element 'tt:Translate' of XML schema type 'tt:Vector'
        tt__Vector *Translate;
        /// Optional element 'tt:Scale' of XML schema type 'tt:Vector'
        tt__Vector *Scale;
        /// Optional element 'tt:Extension' of XML schema type 'tt:TransformationExtension'
        tt__TransformationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Transformation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Transformation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Transformation, default initialized and not managed by a soap context
        virtual tt__Transformation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Transformation); }
      public:
        /// Constructor with default initializations
        tt__Transformation() : Translate(), Scale(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Transformation() { }
        /// Friend allocator used by soap_new_tt__Transformation(struct soap*, int)
        friend SOAP_FMAC1 tt__Transformation * SOAP_FMAC2 soap_instantiate_tt__Transformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1707 */
#ifndef SOAP_TYPE_tt__TransformationExtension
#define SOAP_TYPE_tt__TransformationExtension (761)
/* complex XML schema type 'tt:TransformationExtension': */
class SOAP_CMAC tt__TransformationExtension : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_tt__TransformationExtension
        virtual long soap_type(void) const { return SOAP_TYPE_tt__TransformationExtension; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__TransformationExtension, default initialized and not managed by a soap context
        virtual tt__TransformationExtension *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__TransformationExtension); }
      public:
        /// Constructor with default initializations
        tt__TransformationExtension() : __any() { }
        /// Destructor
        virtual ~tt__TransformationExtension() { }
        /// Friend allocator used by soap_new_tt__TransformationExtension(struct soap*, int)
        friend SOAP_FMAC1 tt__TransformationExtension * SOAP_FMAC2 soap_instantiate_tt__TransformationExtension(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1709 */
#ifndef SOAP_TYPE_tt__GeoLocation
#define SOAP_TYPE_tt__GeoLocation (762)
/* complex XML schema type 'tt:GeoLocation': */
class SOAP_CMAC tt__GeoLocation : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute 'lon' of XML schema type 'xsd:double'
        double *lon;
        /// Optional attribute 'lat' of XML schema type 'xsd:double'
        double *lat;
        /// Optional attribute 'elevation' of XML schema type 'xsd:float'
        float *elevation;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__GeoLocation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__GeoLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__GeoLocation, default initialized and not managed by a soap context
        virtual tt__GeoLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__GeoLocation); }
      public:
        /// Constructor with default initializations
        tt__GeoLocation() : __any(), lon(), lat(), elevation(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__GeoLocation() { }
        /// Friend allocator used by soap_new_tt__GeoLocation(struct soap*, int)
        friend SOAP_FMAC1 tt__GeoLocation * SOAP_FMAC2 soap_instantiate_tt__GeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1711 */
#ifndef SOAP_TYPE_tt__GeoOrientation
#define SOAP_TYPE_tt__GeoOrientation (763)
/* complex XML schema type 'tt:GeoOrientation': */
class SOAP_CMAC tt__GeoOrientation : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute 'roll' of XML schema type 'xsd:float'
        float *roll;
        /// Optional attribute 'pitch' of XML schema type 'xsd:float'
        float *pitch;
        /// Optional attribute 'yaw' of XML schema type 'xsd:float'
        float *yaw;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__GeoOrientation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__GeoOrientation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__GeoOrientation, default initialized and not managed by a soap context
        virtual tt__GeoOrientation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__GeoOrientation); }
      public:
        /// Constructor with default initializations
        tt__GeoOrientation() : __any(), roll(), pitch(), yaw(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__GeoOrientation() { }
        /// Friend allocator used by soap_new_tt__GeoOrientation(struct soap*, int)
        friend SOAP_FMAC1 tt__GeoOrientation * SOAP_FMAC2 soap_instantiate_tt__GeoOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1713 */
#ifndef SOAP_TYPE_tt__LocalLocation
#define SOAP_TYPE_tt__LocalLocation (764)
/* complex XML schema type 'tt:LocalLocation': */
class SOAP_CMAC tt__LocalLocation : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute 'x' of XML schema type 'xsd:float'
        float *x;
        /// Optional attribute 'y' of XML schema type 'xsd:float'
        float *y;
        /// Optional attribute 'z' of XML schema type 'xsd:float'
        float *z;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__LocalLocation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LocalLocation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LocalLocation, default initialized and not managed by a soap context
        virtual tt__LocalLocation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LocalLocation); }
      public:
        /// Constructor with default initializations
        tt__LocalLocation() : __any(), x(), y(), z(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__LocalLocation() { }
        /// Friend allocator used by soap_new_tt__LocalLocation(struct soap*, int)
        friend SOAP_FMAC1 tt__LocalLocation * SOAP_FMAC2 soap_instantiate_tt__LocalLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1715 */
#ifndef SOAP_TYPE_tt__LocalOrientation
#define SOAP_TYPE_tt__LocalOrientation (765)
/* complex XML schema type 'tt:LocalOrientation': */
class SOAP_CMAC tt__LocalOrientation : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Optional attribute 'pan' of XML schema type 'xsd:float'
        float *pan;
        /// Optional attribute 'tilt' of XML schema type 'xsd:float'
        float *tilt;
        /// Optional attribute 'roll' of XML schema type 'xsd:float'
        float *roll;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__LocalOrientation
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LocalOrientation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LocalOrientation, default initialized and not managed by a soap context
        virtual tt__LocalOrientation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LocalOrientation); }
      public:
        /// Constructor with default initializations
        tt__LocalOrientation() : __any(), pan(), tilt(), roll(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__LocalOrientation() { }
        /// Friend allocator used by soap_new_tt__LocalOrientation(struct soap*, int)
        friend SOAP_FMAC1 tt__LocalOrientation * SOAP_FMAC2 soap_instantiate_tt__LocalOrientation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1717 */
#ifndef SOAP_TYPE_tt__LocationEntity
#define SOAP_TYPE_tt__LocationEntity (766)
/* complex XML schema type 'tt:LocationEntity': */
class SOAP_CMAC tt__LocationEntity : public xsd__anyType {
      public:
        /// Optional element 'tt:GeoLocation' of XML schema type 'tt:GeoLocation'
        tt__GeoLocation *GeoLocation;
        /// Optional element 'tt:GeoOrientation' of XML schema type 'tt:GeoOrientation'
        tt__GeoOrientation *GeoOrientation;
        /// Optional element 'tt:LocalLocation' of XML schema type 'tt:LocalLocation'
        tt__LocalLocation *LocalLocation;
        /// Optional element 'tt:LocalOrientation' of XML schema type 'tt:LocalOrientation'
        tt__LocalOrientation *LocalOrientation;
        /// Optional attribute 'Entity' of XML schema type 'xsd:string'
        std::string *Entity;
        /// Optional attribute 'Token' of XML schema type 'tt:ReferenceToken'
        std::string *Token;
        /// Optional attribute 'Fixed' of XML schema type 'xsd:boolean'
        bool *Fixed;
        /// Optional attribute 'GeoSource' of XML schema type 'xsd:anyURI'
        std::string *GeoSource;
        /// Optional attribute 'AutoGeo' of XML schema type 'xsd:boolean'
        bool *AutoGeo;
      public:
        /// Return unique type id SOAP_TYPE_tt__LocationEntity
        virtual long soap_type(void) const { return SOAP_TYPE_tt__LocationEntity; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__LocationEntity, default initialized and not managed by a soap context
        virtual tt__LocationEntity *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__LocationEntity); }
      public:
        /// Constructor with default initializations
        tt__LocationEntity() : GeoLocation(), GeoOrientation(), LocalLocation(), LocalOrientation(), Entity(), Token(), Fixed(), GeoSource(), AutoGeo() { }
        /// Destructor
        virtual ~tt__LocationEntity() { }
        /// Friend allocator used by soap_new_tt__LocationEntity(struct soap*, int)
        friend SOAP_FMAC1 tt__LocationEntity * SOAP_FMAC2 soap_instantiate_tt__LocationEntity(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1719 */
#ifndef SOAP_TYPE__tt__StringItems
#define SOAP_TYPE__tt__StringItems (767)
/* complex XML schema type 'tt:StringItems': */
class SOAP_CMAC _tt__StringItems {
      public:
        /// Required element 'tt:Item' of XML schema type 'xsd:string'
        std::vector<std::string> Item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tt__StringItems
        virtual long soap_type(void) const { return SOAP_TYPE__tt__StringItems; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__StringItems, default initialized and not managed by a soap context
        virtual _tt__StringItems *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__StringItems); }
      public:
        /// Constructor with default initializations
        _tt__StringItems() : Item(), soap() { }
        /// Destructor
        virtual ~_tt__StringItems() { }
        /// Friend allocator used by soap_new__tt__StringItems(struct soap*, int)
        friend SOAP_FMAC1 _tt__StringItems * SOAP_FMAC2 soap_instantiate__tt__StringItems(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1721 */
#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (768)
/* complex XML schema type 'tt:Message': */
class SOAP_CMAC _tt__Message {
      public:
        /// Optional element 'tt:Source' of XML schema type 'tt:ItemList'
        tt__ItemList *Source;
        /// Optional element 'tt:Key' of XML schema type 'tt:ItemList'
        tt__ItemList *Key;
        /// Optional element 'tt:Data' of XML schema type 'tt:ItemList'
        tt__ItemList *Data;
        /// Optional element 'tt:Extension' of XML schema type 'tt:MessageExtension'
        tt__MessageExtension *Extension;
        /// Required attribute 'UtcTime' of XML schema type 'xsd:dateTime'
        time_t UtcTime;
        /// Optional attribute 'PropertyOperation' of XML schema type 'tt:PropertyOperation'
        enum tt__PropertyOperation *PropertyOperation;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__tt__Message
        virtual long soap_type(void) const { return SOAP_TYPE__tt__Message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _tt__Message, default initialized and not managed by a soap context
        virtual _tt__Message *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_tt__Message); }
      public:
        /// Constructor with default initializations
        _tt__Message() : Source(), Key(), Data(), Extension(), UtcTime(), PropertyOperation(), __anyAttribute(), soap() { }
        /// Destructor
        virtual ~_tt__Message() { }
        /// Friend allocator used by soap_new__tt__Message(struct soap*, int)
        friend SOAP_FMAC1 _tt__Message * SOAP_FMAC2 soap_instantiate__tt__Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1723 */
#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (769)
/* complex XML schema type 'wsnt:QueryExpressionType': */
class SOAP_CMAC wsnt__QueryExpressionType : public xsd__anyType {
      public:
        char *__any;
        /// Required attribute 'Dialect' of XML schema type 'xsd:anyURI'
        std::string Dialect;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__QueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__QueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__QueryExpressionType, default initialized and not managed by a soap context
        virtual wsnt__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__QueryExpressionType); }
      public:
        /// Constructor with default initializations
        wsnt__QueryExpressionType() : __any(), Dialect(), __mixed() { }
        /// Destructor
        virtual ~wsnt__QueryExpressionType() { }
        /// Friend allocator used by soap_new_wsnt__QueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1725 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (770)
/* complex XML schema type 'wsnt:TopicExpressionType': */
class SOAP_CMAC wsnt__TopicExpressionType : public xsd__anyType {
      public:
        char *__any;
        /// Required attribute 'Dialect' of XML schema type 'xsd:anyURI'
        std::string Dialect;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__TopicExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__TopicExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__TopicExpressionType, default initialized and not managed by a soap context
        virtual wsnt__TopicExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__TopicExpressionType); }
      public:
        /// Constructor with default initializations
        wsnt__TopicExpressionType() : __any(), Dialect(), __anyAttribute(), __mixed() { }
        /// Destructor
        virtual ~wsnt__TopicExpressionType() { }
        /// Friend allocator used by soap_new_wsnt__TopicExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__TopicExpressionType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1727 */
#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (771)
/* complex XML schema type 'wsnt:FilterType': */
class SOAP_CMAC wsnt__FilterType : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__FilterType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__FilterType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__FilterType, default initialized and not managed by a soap context
        virtual wsnt__FilterType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__FilterType); }
      public:
        /// Constructor with default initializations
        wsnt__FilterType() : __any() { }
        /// Destructor
        virtual ~wsnt__FilterType() { }
        /// Friend allocator used by soap_new_wsnt__FilterType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__FilterType * SOAP_FMAC2 soap_instantiate_wsnt__FilterType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1729 */
#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (772)
/* complex XML schema type 'wsnt:SubscriptionPolicyType': */
class SOAP_CMAC wsnt__SubscriptionPolicyType : public xsd__anyType {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__SubscriptionPolicyType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__SubscriptionPolicyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__SubscriptionPolicyType, default initialized and not managed by a soap context
        virtual wsnt__SubscriptionPolicyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__SubscriptionPolicyType); }
      public:
        /// Constructor with default initializations
        wsnt__SubscriptionPolicyType() : __any() { }
        /// Destructor
        virtual ~wsnt__SubscriptionPolicyType() { }
        /// Friend allocator used by soap_new_wsnt__SubscriptionPolicyType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__SubscriptionPolicyType * SOAP_FMAC2 soap_instantiate_wsnt__SubscriptionPolicyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:25724 */
#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (1538)
/* complex XML schema type 'wsnt:NotificationMessageHolderType-Message': */
class SOAP_CMAC _wsnt__NotificationMessageHolderType_Message {
      public:
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__NotificationMessageHolderType_Message; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__NotificationMessageHolderType_Message, default initialized and not managed by a soap context
        virtual _wsnt__NotificationMessageHolderType_Message *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__NotificationMessageHolderType_Message); }
      public:
        /// Constructor with default initializations
        _wsnt__NotificationMessageHolderType_Message() : __any() { }
        /// Destructor
        virtual ~_wsnt__NotificationMessageHolderType_Message() { }
        /// Friend allocator used by soap_new__wsnt__NotificationMessageHolderType_Message(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__NotificationMessageHolderType_Message * SOAP_FMAC2 soap_instantiate__wsnt__NotificationMessageHolderType_Message(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1731 */
#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (773)
/* complex XML schema type 'wsnt:NotificationMessageHolderType': */
class SOAP_CMAC wsnt__NotificationMessageHolderType : public xsd__anyType {
      public:
        /// Optional element 'wsnt:SubscriptionReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType *SubscriptionReference;
        /// Optional element 'wsnt:Topic' of XML schema type 'wsnt:TopicExpressionType'
        wsnt__TopicExpressionType *Topic;
        /// Optional element 'wsnt:ProducerReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType *ProducerReference;
        /// Required element 'wsnt:Message' of XML schema type 'wsnt:NotificationMessageHolderType-Message'
        _wsnt__NotificationMessageHolderType_Message Message;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__NotificationMessageHolderType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__NotificationMessageHolderType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__NotificationMessageHolderType, default initialized and not managed by a soap context
        virtual wsnt__NotificationMessageHolderType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__NotificationMessageHolderType); }
      public:
        /// Constructor with default initializations
        wsnt__NotificationMessageHolderType() : SubscriptionReference(), Topic(), ProducerReference(), Message() { }
        /// Destructor
        virtual ~wsnt__NotificationMessageHolderType() { }
        /// Friend allocator used by soap_new_wsnt__NotificationMessageHolderType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__NotificationMessageHolderType * SOAP_FMAC2 soap_instantiate_wsnt__NotificationMessageHolderType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1773 */
#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (794)
/* complex XML schema type 'wsnt:NotificationProducerRP': */
class SOAP_CMAC _wsnt__NotificationProducerRP {
      public:
        /// Optional element 'wsnt:TopicExpression' of XML schema type 'wsnt:TopicExpressionType'
        std::vector<wsnt__TopicExpressionType *> TopicExpression;
        /// Optional element 'wsnt:FixedTopicSet' of XML schema type 'xsd:boolean'
        bool *FixedTopicSet;	///< optional with default value = (bool)1
        /// Optional element 'wsnt:TopicExpressionDialect' of XML schema type 'xsd:anyURI'
        std::vector<std::string> TopicExpressionDialect;
        /// Optional element 'wstop:TopicSet' of XML schema type 'wstop:TopicSetType'
        wstop__TopicSetType *wstop__TopicSet;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__NotificationProducerRP
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__NotificationProducerRP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__NotificationProducerRP, default initialized and not managed by a soap context
        virtual _wsnt__NotificationProducerRP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__NotificationProducerRP); }
      public:
        /// Constructor with default initializations
        _wsnt__NotificationProducerRP() : TopicExpression(), FixedTopicSet(), TopicExpressionDialect(), wstop__TopicSet(), soap() { }
        /// Destructor
        virtual ~_wsnt__NotificationProducerRP() { }
        /// Friend allocator used by soap_new__wsnt__NotificationProducerRP(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__NotificationProducerRP * SOAP_FMAC2 soap_instantiate__wsnt__NotificationProducerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1775 */
#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (795)
/* complex XML schema type 'wsnt:SubscriptionManagerRP': */
class SOAP_CMAC _wsnt__SubscriptionManagerRP {
      public:
        /// Required element 'wsnt:ConsumerReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType ConsumerReference;
        /// Optional element 'wsnt:Filter' of XML schema type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'wsnt:SubscriptionPolicy' of XML schema type 'wsnt:SubscriptionPolicyType'
        wsnt__SubscriptionPolicyType *SubscriptionPolicy;
        /// Optional element 'wsnt:CreationTime' of XML schema type 'xsd:dateTime'
        time_t *CreationTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__SubscriptionManagerRP
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__SubscriptionManagerRP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__SubscriptionManagerRP, default initialized and not managed by a soap context
        virtual _wsnt__SubscriptionManagerRP *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__SubscriptionManagerRP); }
      public:
        /// Constructor with default initializations
        _wsnt__SubscriptionManagerRP() : ConsumerReference(), Filter(), SubscriptionPolicy(), CreationTime(), soap() { }
        /// Destructor
        virtual ~_wsnt__SubscriptionManagerRP() { }
        /// Friend allocator used by soap_new__wsnt__SubscriptionManagerRP(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__SubscriptionManagerRP * SOAP_FMAC2 soap_instantiate__wsnt__SubscriptionManagerRP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1777 */
#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (796)
/* complex XML schema type 'wsnt:Notify': */
class SOAP_CMAC _wsnt__Notify {
      public:
        /// Required element 'wsnt:NotificationMessage' of XML schema type 'wsnt:NotificationMessageHolderType'
        std::vector<wsnt__NotificationMessageHolderType *> NotificationMessage;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Notify
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Notify; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Notify, default initialized and not managed by a soap context
        virtual _wsnt__Notify *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Notify); }
      public:
        /// Constructor with default initializations
        _wsnt__Notify() : NotificationMessage(), __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__Notify() { }
        /// Friend allocator used by soap_new__wsnt__Notify(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Notify * SOAP_FMAC2 soap_instantiate__wsnt__Notify(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1779 */
#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (797)
/* complex XML schema type 'wsnt:UseRaw': */
class SOAP_CMAC _wsnt__UseRaw {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__UseRaw
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__UseRaw; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__UseRaw, default initialized and not managed by a soap context
        virtual _wsnt__UseRaw *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__UseRaw); }
      public:
        /// Constructor with default initializations
        _wsnt__UseRaw() : soap() { }
        /// Destructor
        virtual ~_wsnt__UseRaw() { }
        /// Friend allocator used by soap_new__wsnt__UseRaw(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__UseRaw * SOAP_FMAC2 soap_instantiate__wsnt__UseRaw(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:25875 */
#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (1544)
/* complex XML schema type 'wsnt:Subscribe-SubscriptionPolicy': */
class SOAP_CMAC _wsnt__Subscribe_SubscriptionPolicy {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Subscribe_SubscriptionPolicy, default initialized and not managed by a soap context
        virtual _wsnt__Subscribe_SubscriptionPolicy *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Subscribe_SubscriptionPolicy); }
      public:
        /// Constructor with default initializations
        _wsnt__Subscribe_SubscriptionPolicy() : __any() { }
        /// Destructor
        virtual ~_wsnt__Subscribe_SubscriptionPolicy() { }
        /// Friend allocator used by soap_new__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Subscribe_SubscriptionPolicy * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1781 */
#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (798)
/* complex XML schema type 'wsnt:Subscribe': */
class SOAP_CMAC _wsnt__Subscribe {
      public:
        /// Required element 'wsnt:ConsumerReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType ConsumerReference;
        /// Optional element 'wsnt:Filter' of XML schema type 'wsnt:FilterType'
        wsnt__FilterType *Filter;
        /// Optional element 'wsnt:InitialTerminationTime' of XML schema type 'wsnt:AbsoluteOrRelativeTimeType'
        std::string *InitialTerminationTime;
        /// Optional element 'wsnt:SubscriptionPolicy' of XML schema type 'wsnt:Subscribe-SubscriptionPolicy'
        _wsnt__Subscribe_SubscriptionPolicy *SubscriptionPolicy;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Subscribe
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Subscribe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Subscribe, default initialized and not managed by a soap context
        virtual _wsnt__Subscribe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Subscribe); }
      public:
        /// Constructor with default initializations
        _wsnt__Subscribe() : ConsumerReference(), Filter(), InitialTerminationTime(), SubscriptionPolicy(), __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__Subscribe() { }
        /// Friend allocator used by soap_new__wsnt__Subscribe(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Subscribe * SOAP_FMAC2 soap_instantiate__wsnt__Subscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1783 */
#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (799)
/* complex XML schema type 'wsnt:SubscribeResponse': */
class SOAP_CMAC _wsnt__SubscribeResponse {
      public:
        /// Required element 'wsnt:SubscriptionReference' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType SubscriptionReference;
        /// Optional element 'wsnt:CurrentTime' of XML schema type 'xsd:dateTime'
        time_t *CurrentTime;
        /// Optional element 'wsnt:TerminationTime' of XML schema type 'xsd:dateTime'
        time_t *TerminationTime;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__SubscribeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__SubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__SubscribeResponse, default initialized and not managed by a soap context
        virtual _wsnt__SubscribeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__SubscribeResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__SubscribeResponse() : SubscriptionReference(), CurrentTime(), TerminationTime(), __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__SubscribeResponse() { }
        /// Friend allocator used by soap_new__wsnt__SubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__SubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__SubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1785 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (800)
/* complex XML schema type 'wsnt:GetCurrentMessage': */
class SOAP_CMAC _wsnt__GetCurrentMessage {
      public:
        /// Required element 'wsnt:Topic' of XML schema type 'wsnt:TopicExpressionType'
        wsnt__TopicExpressionType *Topic;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetCurrentMessage
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetCurrentMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetCurrentMessage, default initialized and not managed by a soap context
        virtual _wsnt__GetCurrentMessage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetCurrentMessage); }
      public:
        /// Constructor with default initializations
        _wsnt__GetCurrentMessage() : Topic(), __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__GetCurrentMessage() { }
        /// Friend allocator used by soap_new__wsnt__GetCurrentMessage(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetCurrentMessage * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1787 */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (801)
/* complex XML schema type 'wsnt:GetCurrentMessageResponse': */
class SOAP_CMAC _wsnt__GetCurrentMessageResponse {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetCurrentMessageResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetCurrentMessageResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetCurrentMessageResponse, default initialized and not managed by a soap context
        virtual _wsnt__GetCurrentMessageResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetCurrentMessageResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__GetCurrentMessageResponse() : __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__GetCurrentMessageResponse() { }
        /// Friend allocator used by soap_new__wsnt__GetCurrentMessageResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetCurrentMessageResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetCurrentMessageResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1789 */
#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (802)
/* complex XML schema type 'wsnt:GetMessages': */
class SOAP_CMAC _wsnt__GetMessages {
      public:
        /// Optional element 'wsnt:MaximumNumber' of XML schema type 'xsd:nonNegativeInteger'
        std::string *MaximumNumber;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetMessages
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetMessages; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetMessages, default initialized and not managed by a soap context
        virtual _wsnt__GetMessages *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetMessages); }
      public:
        /// Constructor with default initializations
        _wsnt__GetMessages() : MaximumNumber(), __any(), __anyAttribute(), soap() { }
        /// Destructor
        virtual ~_wsnt__GetMessages() { }
        /// Friend allocator used by soap_new__wsnt__GetMessages(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetMessages * SOAP_FMAC2 soap_instantiate__wsnt__GetMessages(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1791 */
#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (803)
/* complex XML schema type 'wsnt:GetMessagesResponse': */
class SOAP_CMAC _wsnt__GetMessagesResponse {
      public:
        /// Optional element 'wsnt:NotificationMessage' of XML schema type 'wsnt:NotificationMessageHolderType'
        std::vector<wsnt__NotificationMessageHolderType *> NotificationMessage;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__GetMessagesResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__GetMessagesResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__GetMessagesResponse, default initialized and not managed by a soap context
        virtual _wsnt__GetMessagesResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__GetMessagesResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__GetMessagesResponse() : NotificationMessage(), __any(), __anyAttribute(), soap() { }
        /// Destructor
        virtual ~_wsnt__GetMessagesResponse() { }
        /// Friend allocator used by soap_new__wsnt__GetMessagesResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__GetMessagesResponse * SOAP_FMAC2 soap_instantiate__wsnt__GetMessagesResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1793 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (804)
/* complex XML schema type 'wsnt:DestroyPullPoint': */
class SOAP_CMAC _wsnt__DestroyPullPoint {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__DestroyPullPoint
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__DestroyPullPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__DestroyPullPoint, default initialized and not managed by a soap context
        virtual _wsnt__DestroyPullPoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__DestroyPullPoint); }
      public:
        /// Constructor with default initializations
        _wsnt__DestroyPullPoint() : __any(), __anyAttribute(), soap() { }
        /// Destructor
        virtual ~_wsnt__DestroyPullPoint() { }
        /// Friend allocator used by soap_new__wsnt__DestroyPullPoint(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__DestroyPullPoint * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1795 */
#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (805)
/* complex XML schema type 'wsnt:DestroyPullPointResponse': */
class SOAP_CMAC _wsnt__DestroyPullPointResponse {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__DestroyPullPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__DestroyPullPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__DestroyPullPointResponse, default initialized and not managed by a soap context
        virtual _wsnt__DestroyPullPointResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__DestroyPullPointResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__DestroyPullPointResponse() : __any(), __anyAttribute(), soap() { }
        /// Destructor
        virtual ~_wsnt__DestroyPullPointResponse() { }
        /// Friend allocator used by soap_new__wsnt__DestroyPullPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__DestroyPullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__DestroyPullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1797 */
#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (806)
/* complex XML schema type 'wsnt:CreatePullPoint': */
class SOAP_CMAC _wsnt__CreatePullPoint {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__CreatePullPoint
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__CreatePullPoint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__CreatePullPoint, default initialized and not managed by a soap context
        virtual _wsnt__CreatePullPoint *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__CreatePullPoint); }
      public:
        /// Constructor with default initializations
        _wsnt__CreatePullPoint() : __any(), __anyAttribute(), soap() { }
        /// Destructor
        virtual ~_wsnt__CreatePullPoint() { }
        /// Friend allocator used by soap_new__wsnt__CreatePullPoint(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__CreatePullPoint * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPoint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1799 */
#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (807)
/* complex XML schema type 'wsnt:CreatePullPointResponse': */
class SOAP_CMAC _wsnt__CreatePullPointResponse {
      public:
        /// Required element 'wsnt:PullPoint' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType PullPoint;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__CreatePullPointResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__CreatePullPointResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__CreatePullPointResponse, default initialized and not managed by a soap context
        virtual _wsnt__CreatePullPointResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__CreatePullPointResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__CreatePullPointResponse() : PullPoint(), __any(), __anyAttribute(), soap() { }
        /// Destructor
        virtual ~_wsnt__CreatePullPointResponse() { }
        /// Friend allocator used by soap_new__wsnt__CreatePullPointResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__CreatePullPointResponse * SOAP_FMAC2 soap_instantiate__wsnt__CreatePullPointResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1801 */
#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (808)
/* complex XML schema type 'wsnt:Renew': */
class SOAP_CMAC _wsnt__Renew {
      public:
        /// Required nillable (xsi:nil when NULL) element 'wsnt:TerminationTime' of XML schema type 'wsnt:AbsoluteOrRelativeTimeType'
        std::string *TerminationTime;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Renew
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Renew; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Renew, default initialized and not managed by a soap context
        virtual _wsnt__Renew *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Renew); }
      public:
        /// Constructor with default initializations
        _wsnt__Renew() : TerminationTime(), __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__Renew() { }
        /// Friend allocator used by soap_new__wsnt__Renew(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Renew * SOAP_FMAC2 soap_instantiate__wsnt__Renew(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1803 */
#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (809)
/* complex XML schema type 'wsnt:RenewResponse': */
class SOAP_CMAC _wsnt__RenewResponse {
      public:
        /// Required element 'wsnt:TerminationTime' of XML schema type 'xsd:dateTime'
        time_t TerminationTime;
        /// Optional element 'wsnt:CurrentTime' of XML schema type 'xsd:dateTime'
        time_t *CurrentTime;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__RenewResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__RenewResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__RenewResponse, default initialized and not managed by a soap context
        virtual _wsnt__RenewResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__RenewResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__RenewResponse() : TerminationTime(), CurrentTime(), __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__RenewResponse() { }
        /// Friend allocator used by soap_new__wsnt__RenewResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__RenewResponse * SOAP_FMAC2 soap_instantiate__wsnt__RenewResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1805 */
#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (810)
/* complex XML schema type 'wsnt:Unsubscribe': */
class SOAP_CMAC _wsnt__Unsubscribe {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__Unsubscribe
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__Unsubscribe; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__Unsubscribe, default initialized and not managed by a soap context
        virtual _wsnt__Unsubscribe *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__Unsubscribe); }
      public:
        /// Constructor with default initializations
        _wsnt__Unsubscribe() : __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__Unsubscribe() { }
        /// Friend allocator used by soap_new__wsnt__Unsubscribe(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__Unsubscribe * SOAP_FMAC2 soap_instantiate__wsnt__Unsubscribe(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1807 */
#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (811)
/* complex XML schema type 'wsnt:UnsubscribeResponse': */
class SOAP_CMAC _wsnt__UnsubscribeResponse {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__UnsubscribeResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__UnsubscribeResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__UnsubscribeResponse, default initialized and not managed by a soap context
        virtual _wsnt__UnsubscribeResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__UnsubscribeResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__UnsubscribeResponse() : __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__UnsubscribeResponse() { }
        /// Friend allocator used by soap_new__wsnt__UnsubscribeResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__UnsubscribeResponse * SOAP_FMAC2 soap_instantiate__wsnt__UnsubscribeResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1809 */
#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (812)
/* complex XML schema type 'wsnt:PauseSubscription': */
class SOAP_CMAC _wsnt__PauseSubscription {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__PauseSubscription
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__PauseSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__PauseSubscription, default initialized and not managed by a soap context
        virtual _wsnt__PauseSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__PauseSubscription); }
      public:
        /// Constructor with default initializations
        _wsnt__PauseSubscription() : __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__PauseSubscription() { }
        /// Friend allocator used by soap_new__wsnt__PauseSubscription(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__PauseSubscription * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1811 */
#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (813)
/* complex XML schema type 'wsnt:PauseSubscriptionResponse': */
class SOAP_CMAC _wsnt__PauseSubscriptionResponse {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__PauseSubscriptionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__PauseSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__PauseSubscriptionResponse, default initialized and not managed by a soap context
        virtual _wsnt__PauseSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__PauseSubscriptionResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__PauseSubscriptionResponse() : __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__PauseSubscriptionResponse() { }
        /// Friend allocator used by soap_new__wsnt__PauseSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__PauseSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__PauseSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1813 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (814)
/* complex XML schema type 'wsnt:ResumeSubscription': */
class SOAP_CMAC _wsnt__ResumeSubscription {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__ResumeSubscription
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__ResumeSubscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__ResumeSubscription, default initialized and not managed by a soap context
        virtual _wsnt__ResumeSubscription *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__ResumeSubscription); }
      public:
        /// Constructor with default initializations
        _wsnt__ResumeSubscription() : __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__ResumeSubscription() { }
        /// Friend allocator used by soap_new__wsnt__ResumeSubscription(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__ResumeSubscription * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1815 */
#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (815)
/* complex XML schema type 'wsnt:ResumeSubscriptionResponse': */
class SOAP_CMAC _wsnt__ResumeSubscriptionResponse {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__wsnt__ResumeSubscriptionResponse
        virtual long soap_type(void) const { return SOAP_TYPE__wsnt__ResumeSubscriptionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsnt__ResumeSubscriptionResponse, default initialized and not managed by a soap context
        virtual _wsnt__ResumeSubscriptionResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsnt__ResumeSubscriptionResponse); }
      public:
        /// Constructor with default initializations
        _wsnt__ResumeSubscriptionResponse() : __any(), soap() { }
        /// Destructor
        virtual ~_wsnt__ResumeSubscriptionResponse() { }
        /// Friend allocator used by soap_new__wsnt__ResumeSubscriptionResponse(struct soap*, int)
        friend SOAP_FMAC1 _wsnt__ResumeSubscriptionResponse * SOAP_FMAC2 soap_instantiate__wsnt__ResumeSubscriptionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:26498 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (1547)
/* complex XML schema type 'wsrfbf:BaseFaultType-ErrorCode': */
class SOAP_CMAC _wsrfbf__BaseFaultType_ErrorCode {
      public:
        /// Required attribute 'dialect' of XML schema type 'xsd:anyURI'
        std::string dialect;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
        virtual long soap_type(void) const { return SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsrfbf__BaseFaultType_ErrorCode, default initialized and not managed by a soap context
        virtual _wsrfbf__BaseFaultType_ErrorCode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsrfbf__BaseFaultType_ErrorCode); }
      public:
        /// Constructor with default initializations
        _wsrfbf__BaseFaultType_ErrorCode() : dialect(), __mixed() { }
        /// Destructor
        virtual ~_wsrfbf__BaseFaultType_ErrorCode() { }
        /// Friend allocator used by soap_new__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int)
        friend SOAP_FMAC1 _wsrfbf__BaseFaultType_ErrorCode * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:26521 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (1549)
/* simple XML schema type 'wsrfbf:BaseFaultType-Description': */
class SOAP_CMAC _wsrfbf__BaseFaultType_Description {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Optional attribute 'xml:lang' of XML schema type 'xml:lang'
        std::string *xml__lang;
      public:
        /// Return unique type id SOAP_TYPE__wsrfbf__BaseFaultType_Description
        virtual long soap_type(void) const { return SOAP_TYPE__wsrfbf__BaseFaultType_Description; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsrfbf__BaseFaultType_Description, default initialized and not managed by a soap context
        virtual _wsrfbf__BaseFaultType_Description *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsrfbf__BaseFaultType_Description); }
      public:
        /// Constructor with default initializations
        _wsrfbf__BaseFaultType_Description() : __item(), xml__lang() { }
        /// Destructor
        virtual ~_wsrfbf__BaseFaultType_Description() { }
        /// Friend allocator used by soap_new__wsrfbf__BaseFaultType_Description(struct soap*, int)
        friend SOAP_FMAC1 _wsrfbf__BaseFaultType_Description * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_Description(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:26539 */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (1552)
/* complex XML schema type 'wsrfbf:BaseFaultType-FaultCause': */
class SOAP_CMAC _wsrfbf__BaseFaultType_FaultCause {
      public:
        char *__any;
      public:
        /// Return unique type id SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
        virtual long soap_type(void) const { return SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wsrfbf__BaseFaultType_FaultCause, default initialized and not managed by a soap context
        virtual _wsrfbf__BaseFaultType_FaultCause *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wsrfbf__BaseFaultType_FaultCause); }
      public:
        /// Constructor with default initializations
        _wsrfbf__BaseFaultType_FaultCause() : __any() { }
        /// Destructor
        virtual ~_wsrfbf__BaseFaultType_FaultCause() { }
        /// Friend allocator used by soap_new__wsrfbf__BaseFaultType_FaultCause(struct soap*, int)
        friend SOAP_FMAC1 _wsrfbf__BaseFaultType_FaultCause * SOAP_FMAC2 soap_instantiate__wsrfbf__BaseFaultType_FaultCause(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1817 */
#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (816)
/* complex XML schema type 'wsrfbf:BaseFaultType': */
class SOAP_CMAC wsrfbf__BaseFaultType : public xsd__anyType {
      public:
        std::vector<char *> __any;
        /// Required element 'wsrfbf:Timestamp' of XML schema type 'xsd:dateTime'
        time_t Timestamp;
        /// Optional element 'wsrfbf:Originator' of XML schema type 'wsa5:EndpointReferenceType'
        struct wsa5__EndpointReferenceType *Originator;
        /// Optional element 'wsrfbf:ErrorCode' of XML schema type 'wsrfbf:BaseFaultType-ErrorCode'
        _wsrfbf__BaseFaultType_ErrorCode *ErrorCode;
        /// Optional element 'wsrfbf:Description' of XML schema type 'wsrfbf:BaseFaultType-Description'
        std::vector<_wsrfbf__BaseFaultType_Description> Description;
        /// Optional element 'wsrfbf:FaultCause' of XML schema type 'wsrfbf:BaseFaultType-FaultCause'
        _wsrfbf__BaseFaultType_FaultCause *FaultCause;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_wsrfbf__BaseFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsrfbf__BaseFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsrfbf__BaseFaultType, default initialized and not managed by a soap context
        virtual wsrfbf__BaseFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsrfbf__BaseFaultType); }
      public:
        /// Constructor with default initializations
        wsrfbf__BaseFaultType() : __any(), Timestamp(), Originator(), ErrorCode(), Description(), FaultCause(), __anyAttribute() { }
        /// Destructor
        virtual ~wsrfbf__BaseFaultType() { }
        /// Friend allocator used by soap_new_wsrfbf__BaseFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsrfbf__BaseFaultType * SOAP_FMAC2 soap_instantiate_wsrfbf__BaseFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1819 */
#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (817)
/* complex XML schema type 'wstop:Documentation': */
class SOAP_CMAC wstop__Documentation : public xsd__anyType {
      public:
        std::vector<char *> __any;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wstop__Documentation
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__Documentation; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__Documentation, default initialized and not managed by a soap context
        virtual wstop__Documentation *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__Documentation); }
      public:
        /// Constructor with default initializations
        wstop__Documentation() : __any(), __mixed() { }
        /// Destructor
        virtual ~wstop__Documentation() { }
        /// Friend allocator used by soap_new_wstop__Documentation(struct soap*, int)
        friend SOAP_FMAC1 wstop__Documentation * SOAP_FMAC2 soap_instantiate_wstop__Documentation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1821 */
#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (818)
/* complex XML schema type 'wstop:ExtensibleDocumented': */
class SOAP_CMAC wstop__ExtensibleDocumented : public xsd__anyType {
      public:
        /// Optional element 'wstop:documentation' of XML schema type 'wstop:Documentation'
        wstop__Documentation *documentation;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_wstop__ExtensibleDocumented
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__ExtensibleDocumented; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__ExtensibleDocumented, default initialized and not managed by a soap context
        virtual wstop__ExtensibleDocumented *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__ExtensibleDocumented); }
      public:
        /// Constructor with default initializations
        wstop__ExtensibleDocumented() : documentation(), __anyAttribute() { }
        /// Destructor
        virtual ~wstop__ExtensibleDocumented() { }
        /// Friend allocator used by soap_new_wstop__ExtensibleDocumented(struct soap*, int)
        friend SOAP_FMAC1 wstop__ExtensibleDocumented * SOAP_FMAC2 soap_instantiate_wstop__ExtensibleDocumented(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1823 */
#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (819)
/* complex XML schema type 'wstop:QueryExpressionType': */
class SOAP_CMAC wstop__QueryExpressionType : public xsd__anyType {
      public:
        char *__any;
        /// Required attribute 'Dialect' of XML schema type 'xsd:anyURI'
        std::string Dialect;
        char *__mixed;
      public:
        /// Return unique type id SOAP_TYPE_wstop__QueryExpressionType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__QueryExpressionType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__QueryExpressionType, default initialized and not managed by a soap context
        virtual wstop__QueryExpressionType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__QueryExpressionType); }
      public:
        /// Constructor with default initializations
        wstop__QueryExpressionType() : __any(), Dialect(), __mixed() { }
        /// Destructor
        virtual ~wstop__QueryExpressionType() { }
        /// Friend allocator used by soap_new_wstop__QueryExpressionType(struct soap*, int)
        friend SOAP_FMAC1 wstop__QueryExpressionType * SOAP_FMAC2 soap_instantiate_wstop__QueryExpressionType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:393 */
#ifndef SOAP_TYPE_tds__StorageConfiguration
#define SOAP_TYPE_tds__StorageConfiguration (104)
/* Type tds__StorageConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tds:StorageConfiguration': */
class SOAP_CMAC tds__StorageConfiguration : public tt__DeviceEntity {
      public:
        /// Required element 'tds:Data' of XML schema type 'tds:StorageConfigurationData'
        tds__StorageConfigurationData *Data;
      public:
        /// Return unique type id SOAP_TYPE_tds__StorageConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tds__StorageConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tds__StorageConfiguration, default initialized and not managed by a soap context
        virtual tds__StorageConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tds__StorageConfiguration); }
      public:
        /// Constructor with default initializations
        tds__StorageConfiguration() : Data() { }
        /// Destructor
        virtual ~tds__StorageConfiguration() { }
        /// Friend allocator used by soap_new_tds__StorageConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tds__StorageConfiguration * SOAP_FMAC2 soap_instantiate_tds__StorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:807 */
#ifndef SOAP_TYPE_tt__VideoSource
#define SOAP_TYPE_tt__VideoSource (311)
/* Type tt__VideoSource is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoSource': */
class SOAP_CMAC tt__VideoSource : public tt__DeviceEntity {
      public:
        /// Required element 'tt:Framerate' of XML schema type 'xsd:float'
        float Framerate;
        /// Required element 'tt:Resolution' of XML schema type 'tt:VideoResolution'
        tt__VideoResolution *Resolution;
        /// Optional element 'tt:Imaging' of XML schema type 'tt:ImagingSettings'
        tt__ImagingSettings *Imaging;
        /// Optional element 'tt:Extension' of XML schema type 'tt:VideoSourceExtension'
        tt__VideoSourceExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSource
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSource, default initialized and not managed by a soap context
        virtual tt__VideoSource *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSource); }
      public:
        /// Constructor with default initializations
        tt__VideoSource() : Framerate(), Resolution(), Imaging(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoSource() { }
        /// Friend allocator used by soap_new_tt__VideoSource(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSource * SOAP_FMAC2 soap_instantiate_tt__VideoSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:813 */
#ifndef SOAP_TYPE_tt__AudioSource
#define SOAP_TYPE_tt__AudioSource (314)
/* Type tt__AudioSource is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioSource': */
class SOAP_CMAC tt__AudioSource : public tt__DeviceEntity {
      public:
        /// Required element 'tt:Channels' of XML schema type 'xsd:int'
        int Channels;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioSource
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioSource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioSource, default initialized and not managed by a soap context
        virtual tt__AudioSource *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioSource); }
      public:
        /// Constructor with default initializations
        tt__AudioSource() : Channels(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioSource() { }
        /// Friend allocator used by soap_new_tt__AudioSource(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioSource * SOAP_FMAC2 soap_instantiate_tt__AudioSource(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:823 */
#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (319)
/* Type tt__VideoSourceConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoSourceConfiguration': */
class SOAP_CMAC tt__VideoSourceConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:SourceToken' of XML schema type 'tt:ReferenceToken'
        std::string SourceToken;
        /// Required element 'tt:Bounds' of XML schema type 'tt:IntRectangle'
        tt__IntRectangle *Bounds;
        std::vector<char *> __any;
        /// Optional element 'tt:Extension' of XML schema type 'tt:VideoSourceConfigurationExtension'
        tt__VideoSourceConfigurationExtension *Extension;
        /// Optional attribute 'ViewMode' of XML schema type 'xsd:string'
        std::string *ViewMode;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoSourceConfiguration, default initialized and not managed by a soap context
        virtual tt__VideoSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoSourceConfiguration); }
      public:
        /// Constructor with default initializations
        tt__VideoSourceConfiguration() : SourceToken(), Bounds(), __any(), Extension(), ViewMode(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoSourceConfiguration() { }
        /// Friend allocator used by soap_new_tt__VideoSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:851 */
#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (333)
/* Type tt__VideoEncoderConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoEncoderConfiguration': */
class SOAP_CMAC tt__VideoEncoderConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:Encoding' of XML schema type 'tt:VideoEncoding'
        enum tt__VideoEncoding Encoding;
        /// Required element 'tt:Resolution' of XML schema type 'tt:VideoResolution'
        tt__VideoResolution *Resolution;
        /// Required element 'tt:Quality' of XML schema type 'xsd:float'
        float Quality;
        /// Optional element 'tt:RateControl' of XML schema type 'tt:VideoRateControl'
        tt__VideoRateControl *RateControl;
        /// Optional element 'tt:MPEG4' of XML schema type 'tt:Mpeg4Configuration'
        tt__Mpeg4Configuration *MPEG4;
        /// Optional element 'tt:H264' of XML schema type 'tt:H264Configuration'
        tt__H264Configuration *H264;
        /// Required element 'tt:Multicast' of XML schema type 'tt:MulticastConfiguration'
        tt__MulticastConfiguration *Multicast;
        /// Required element 'tt:SessionTimeout' of XML schema type 'xsd:duration'
        std::string SessionTimeout;
        std::vector<char *> __any;
        /// Optional attribute 'GuaranteedFrameRate' of XML schema type 'xsd:boolean'
        bool *GuaranteedFrameRate;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoderConfiguration, default initialized and not managed by a soap context
        virtual tt__VideoEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoderConfiguration); }
      public:
        /// Constructor with default initializations
        tt__VideoEncoderConfiguration() : Encoding(), Resolution(), Quality(), RateControl(), MPEG4(), H264(), Multicast(), SessionTimeout(), __any(), GuaranteedFrameRate(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoEncoderConfiguration() { }
        /// Friend allocator used by soap_new_tt__VideoEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:869 */
#ifndef SOAP_TYPE_tt__JpegOptions2
#define SOAP_TYPE_tt__JpegOptions2 (342)
/* Type tt__JpegOptions2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:JpegOptions2': */
class SOAP_CMAC tt__JpegOptions2 : public tt__JpegOptions {
      public:
        /// Required element 'tt:BitrateRange' of XML schema type 'tt:IntRange'
        tt__IntRange *BitrateRange;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__JpegOptions2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__JpegOptions2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__JpegOptions2, default initialized and not managed by a soap context
        virtual tt__JpegOptions2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__JpegOptions2); }
      public:
        /// Constructor with default initializations
        tt__JpegOptions2() : BitrateRange(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__JpegOptions2() { }
        /// Friend allocator used by soap_new_tt__JpegOptions2(struct soap*, int)
        friend SOAP_FMAC1 tt__JpegOptions2 * SOAP_FMAC2 soap_instantiate_tt__JpegOptions2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:873 */
#ifndef SOAP_TYPE_tt__Mpeg4Options2
#define SOAP_TYPE_tt__Mpeg4Options2 (344)
/* Type tt__Mpeg4Options2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:Mpeg4Options2': */
class SOAP_CMAC tt__Mpeg4Options2 : public tt__Mpeg4Options {
      public:
        /// Required element 'tt:BitrateRange' of XML schema type 'tt:IntRange'
        tt__IntRange *BitrateRange;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__Mpeg4Options2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__Mpeg4Options2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__Mpeg4Options2, default initialized and not managed by a soap context
        virtual tt__Mpeg4Options2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__Mpeg4Options2); }
      public:
        /// Constructor with default initializations
        tt__Mpeg4Options2() : BitrateRange(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__Mpeg4Options2() { }
        /// Friend allocator used by soap_new_tt__Mpeg4Options2(struct soap*, int)
        friend SOAP_FMAC1 tt__Mpeg4Options2 * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:877 */
#ifndef SOAP_TYPE_tt__H264Options2
#define SOAP_TYPE_tt__H264Options2 (346)
/* Type tt__H264Options2 is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:H264Options2': */
class SOAP_CMAC tt__H264Options2 : public tt__H264Options {
      public:
        /// Required element 'tt:BitrateRange' of XML schema type 'tt:IntRange'
        tt__IntRange *BitrateRange;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__H264Options2
        virtual long soap_type(void) const { return SOAP_TYPE_tt__H264Options2; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__H264Options2, default initialized and not managed by a soap context
        virtual tt__H264Options2 *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__H264Options2); }
      public:
        /// Constructor with default initializations
        tt__H264Options2() : BitrateRange(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__H264Options2() { }
        /// Friend allocator used by soap_new_tt__H264Options2(struct soap*, int)
        friend SOAP_FMAC1 tt__H264Options2 * SOAP_FMAC2 soap_instantiate_tt__H264Options2(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:879 */
#ifndef SOAP_TYPE_tt__VideoEncoder2Configuration
#define SOAP_TYPE_tt__VideoEncoder2Configuration (347)
/* Type tt__VideoEncoder2Configuration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoEncoder2Configuration': */
class SOAP_CMAC tt__VideoEncoder2Configuration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:Encoding' of XML schema type 'xsd:string'
        std::string Encoding;
        /// Required element 'tt:Resolution' of XML schema type 'tt:VideoResolution2'
        tt__VideoResolution2 *Resolution;
        /// Optional element 'tt:RateControl' of XML schema type 'tt:VideoRateControl2'
        tt__VideoRateControl2 *RateControl;
        /// Optional element 'tt:Multicast' of XML schema type 'tt:MulticastConfiguration'
        tt__MulticastConfiguration *Multicast;
        /// Required element 'tt:Quality' of XML schema type 'xsd:float'
        float Quality;
        std::vector<char *> __any;
        /// Optional attribute 'GovLength' of XML schema type 'xsd:int'
        int *GovLength;
        /// Optional attribute 'Profile' of XML schema type 'xsd:string'
        std::string *Profile;
        /// Optional attribute 'GuaranteedFrameRate' of XML schema type 'xsd:boolean'
        bool *GuaranteedFrameRate;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoEncoder2Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoEncoder2Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoEncoder2Configuration, default initialized and not managed by a soap context
        virtual tt__VideoEncoder2Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoEncoder2Configuration); }
      public:
        /// Constructor with default initializations
        tt__VideoEncoder2Configuration() : Encoding(), Resolution(), RateControl(), Multicast(), Quality(), __any(), GovLength(), Profile(), GuaranteedFrameRate(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoEncoder2Configuration() { }
        /// Friend allocator used by soap_new_tt__VideoEncoder2Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoEncoder2Configuration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoder2Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:887 */
#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (351)
/* Type tt__AudioSourceConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioSourceConfiguration': */
class SOAP_CMAC tt__AudioSourceConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:SourceToken' of XML schema type 'tt:ReferenceToken'
        std::string SourceToken;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioSourceConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioSourceConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioSourceConfiguration, default initialized and not managed by a soap context
        virtual tt__AudioSourceConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioSourceConfiguration); }
      public:
        /// Constructor with default initializations
        tt__AudioSourceConfiguration() : SourceToken(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioSourceConfiguration() { }
        /// Friend allocator used by soap_new_tt__AudioSourceConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:893 */
#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (354)
/* Type tt__AudioEncoderConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioEncoderConfiguration': */
class SOAP_CMAC tt__AudioEncoderConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:Encoding' of XML schema type 'tt:AudioEncoding'
        enum tt__AudioEncoding Encoding;
        /// Required element 'tt:Bitrate' of XML schema type 'xsd:int'
        int Bitrate;
        /// Required element 'tt:SampleRate' of XML schema type 'xsd:int'
        int SampleRate;
        /// Required element 'tt:Multicast' of XML schema type 'tt:MulticastConfiguration'
        tt__MulticastConfiguration *Multicast;
        /// Required element 'tt:SessionTimeout' of XML schema type 'xsd:duration'
        std::string SessionTimeout;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioEncoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioEncoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioEncoderConfiguration, default initialized and not managed by a soap context
        virtual tt__AudioEncoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioEncoderConfiguration); }
      public:
        /// Constructor with default initializations
        tt__AudioEncoderConfiguration() : Encoding(), Bitrate(), SampleRate(), Multicast(), SessionTimeout(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioEncoderConfiguration() { }
        /// Friend allocator used by soap_new_tt__AudioEncoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:899 */
#ifndef SOAP_TYPE_tt__AudioEncoder2Configuration
#define SOAP_TYPE_tt__AudioEncoder2Configuration (357)
/* Type tt__AudioEncoder2Configuration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioEncoder2Configuration': */
class SOAP_CMAC tt__AudioEncoder2Configuration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:Encoding' of XML schema type 'xsd:string'
        std::string Encoding;
        /// Optional element 'tt:Multicast' of XML schema type 'tt:MulticastConfiguration'
        tt__MulticastConfiguration *Multicast;
        /// Required element 'tt:Bitrate' of XML schema type 'xsd:int'
        int Bitrate;
        /// Required element 'tt:SampleRate' of XML schema type 'xsd:int'
        int SampleRate;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioEncoder2Configuration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioEncoder2Configuration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioEncoder2Configuration, default initialized and not managed by a soap context
        virtual tt__AudioEncoder2Configuration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioEncoder2Configuration); }
      public:
        /// Constructor with default initializations
        tt__AudioEncoder2Configuration() : Encoding(), Multicast(), Bitrate(), SampleRate(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioEncoder2Configuration() { }
        /// Friend allocator used by soap_new_tt__AudioEncoder2Configuration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioEncoder2Configuration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoder2Configuration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:903 */
#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (359)
/* Type tt__VideoAnalyticsConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoAnalyticsConfiguration': */
class SOAP_CMAC tt__VideoAnalyticsConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:AnalyticsEngineConfiguration' of XML schema type 'tt:AnalyticsEngineConfiguration'
        tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;
        /// Required element 'tt:RuleEngineConfiguration' of XML schema type 'tt:RuleEngineConfiguration'
        tt__RuleEngineConfiguration *RuleEngineConfiguration;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoAnalyticsConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoAnalyticsConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoAnalyticsConfiguration, default initialized and not managed by a soap context
        virtual tt__VideoAnalyticsConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoAnalyticsConfiguration); }
      public:
        /// Constructor with default initializations
        tt__VideoAnalyticsConfiguration() : AnalyticsEngineConfiguration(), RuleEngineConfiguration(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoAnalyticsConfiguration() { }
        /// Friend allocator used by soap_new_tt__VideoAnalyticsConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:905 */
#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (360)
/* Type tt__MetadataConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:MetadataConfiguration': */
class SOAP_CMAC tt__MetadataConfiguration : public tt__ConfigurationEntity {
      public:
        /// Optional element 'tt:PTZStatus' of XML schema type 'tt:PTZFilter'
        tt__PTZFilter *PTZStatus;
        /// Optional element 'tt:Events' of XML schema type 'tt:EventSubscription'
        tt__EventSubscription *Events;
        /// Optional element 'tt:Analytics' of XML schema type 'xsd:boolean'
        bool *Analytics;
        /// Required element 'tt:Multicast' of XML schema type 'tt:MulticastConfiguration'
        tt__MulticastConfiguration *Multicast;
        /// Required element 'tt:SessionTimeout' of XML schema type 'xsd:duration'
        std::string SessionTimeout;
        std::vector<char *> __any;
        /// Optional element 'tt:AnalyticsEngineConfiguration' of XML schema type 'tt:AnalyticsEngineConfiguration'
        tt__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;
        /// Optional element 'tt:Extension' of XML schema type 'tt:MetadataConfigurationExtension'
        tt__MetadataConfigurationExtension *Extension;
        /// Optional attribute 'CompressionType' of XML schema type 'xsd:string'
        std::string *CompressionType;
        /// Optional attribute 'GeoLocation' of XML schema type 'xsd:boolean'
        bool *GeoLocation;
        /// Optional attribute 'ShapePolygon' of XML schema type 'xsd:boolean'
        bool *ShapePolygon;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__MetadataConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__MetadataConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__MetadataConfiguration, default initialized and not managed by a soap context
        virtual tt__MetadataConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__MetadataConfiguration); }
      public:
        /// Constructor with default initializations
        tt__MetadataConfiguration() : PTZStatus(), Events(), Analytics(), Multicast(), SessionTimeout(), __any(), AnalyticsEngineConfiguration(), Extension(), CompressionType(), GeoLocation(), ShapePolygon(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__MetadataConfiguration() { }
        /// Friend allocator used by soap_new_tt__MetadataConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__MetadataConfiguration * SOAP_FMAC2 soap_instantiate_tt__MetadataConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:923 */
#ifndef SOAP_TYPE_tt__VideoOutput
#define SOAP_TYPE_tt__VideoOutput (369)
/* Type tt__VideoOutput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoOutput': */
class SOAP_CMAC tt__VideoOutput : public tt__DeviceEntity {
      public:
        /// Required element 'tt:Layout' of XML schema type 'tt:Layout'
        tt__Layout *Layout;
        /// Optional element 'tt:Resolution' of XML schema type 'tt:VideoResolution'
        tt__VideoResolution *Resolution;
        /// Optional element 'tt:RefreshRate' of XML schema type 'xsd:float'
        float *RefreshRate;
        /// Optional element 'tt:AspectRatio' of XML schema type 'xsd:float'
        float *AspectRatio;
        /// Optional element 'tt:Extension' of XML schema type 'tt:VideoOutputExtension'
        tt__VideoOutputExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoOutput
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoOutput, default initialized and not managed by a soap context
        virtual tt__VideoOutput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoOutput); }
      public:
        /// Constructor with default initializations
        tt__VideoOutput() : Layout(), Resolution(), RefreshRate(), AspectRatio(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoOutput() { }
        /// Friend allocator used by soap_new_tt__VideoOutput(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoOutput * SOAP_FMAC2 soap_instantiate_tt__VideoOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:927 */
#ifndef SOAP_TYPE_tt__VideoOutputConfiguration
#define SOAP_TYPE_tt__VideoOutputConfiguration (371)
/* Type tt__VideoOutputConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:VideoOutputConfiguration': */
class SOAP_CMAC tt__VideoOutputConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:OutputToken' of XML schema type 'tt:ReferenceToken'
        std::string OutputToken;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__VideoOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__VideoOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__VideoOutputConfiguration, default initialized and not managed by a soap context
        virtual tt__VideoOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__VideoOutputConfiguration); }
      public:
        /// Constructor with default initializations
        tt__VideoOutputConfiguration() : OutputToken(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__VideoOutputConfiguration() { }
        /// Friend allocator used by soap_new_tt__VideoOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__VideoOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:941 */
#ifndef SOAP_TYPE_tt__AudioOutput
#define SOAP_TYPE_tt__AudioOutput (378)
/* Type tt__AudioOutput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioOutput': */
class SOAP_CMAC tt__AudioOutput : public tt__DeviceEntity {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioOutput
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioOutput, default initialized and not managed by a soap context
        virtual tt__AudioOutput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioOutput); }
      public:
        /// Constructor with default initializations
        tt__AudioOutput() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioOutput() { }
        /// Friend allocator used by soap_new_tt__AudioOutput(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioOutput * SOAP_FMAC2 soap_instantiate_tt__AudioOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:943 */
#ifndef SOAP_TYPE_tt__AudioOutputConfiguration
#define SOAP_TYPE_tt__AudioOutputConfiguration (379)
/* Type tt__AudioOutputConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioOutputConfiguration': */
class SOAP_CMAC tt__AudioOutputConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:OutputToken' of XML schema type 'tt:ReferenceToken'
        std::string OutputToken;
        /// Optional element 'tt:SendPrimacy' of XML schema type 'xsd:anyURI'
        std::string *SendPrimacy;
        /// Required element 'tt:OutputLevel' of XML schema type 'xsd:int'
        int OutputLevel;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioOutputConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioOutputConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioOutputConfiguration, default initialized and not managed by a soap context
        virtual tt__AudioOutputConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioOutputConfiguration); }
      public:
        /// Constructor with default initializations
        tt__AudioOutputConfiguration() : OutputToken(), SendPrimacy(), OutputLevel(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioOutputConfiguration() { }
        /// Friend allocator used by soap_new_tt__AudioOutputConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioOutputConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioOutputConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:947 */
#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration
#define SOAP_TYPE_tt__AudioDecoderConfiguration (381)
/* Type tt__AudioDecoderConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AudioDecoderConfiguration': */
class SOAP_CMAC tt__AudioDecoderConfiguration : public tt__ConfigurationEntity {
      public:
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AudioDecoderConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AudioDecoderConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AudioDecoderConfiguration, default initialized and not managed by a soap context
        virtual tt__AudioDecoderConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AudioDecoderConfiguration); }
      public:
        /// Constructor with default initializations
        tt__AudioDecoderConfiguration() : __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AudioDecoderConfiguration() { }
        /// Friend allocator used by soap_new_tt__AudioDecoderConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__AudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioDecoderConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:969 */
#ifndef SOAP_TYPE_tt__NetworkInterface
#define SOAP_TYPE_tt__NetworkInterface (392)
/* Type tt__NetworkInterface is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:NetworkInterface': */
class SOAP_CMAC tt__NetworkInterface : public tt__DeviceEntity {
      public:
        /// Required element 'tt:Enabled' of XML schema type 'xsd:boolean'
        bool Enabled;
        /// Optional element 'tt:Info' of XML schema type 'tt:NetworkInterfaceInfo'
        tt__NetworkInterfaceInfo *Info;
        /// Optional element 'tt:Link' of XML schema type 'tt:NetworkInterfaceLink'
        tt__NetworkInterfaceLink *Link;
        /// Optional element 'tt:IPv4' of XML schema type 'tt:IPv4NetworkInterface'
        tt__IPv4NetworkInterface *IPv4;
        /// Optional element 'tt:IPv6' of XML schema type 'tt:IPv6NetworkInterface'
        tt__IPv6NetworkInterface *IPv6;
        /// Optional element 'tt:Extension' of XML schema type 'tt:NetworkInterfaceExtension'
        tt__NetworkInterfaceExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__NetworkInterface
        virtual long soap_type(void) const { return SOAP_TYPE_tt__NetworkInterface; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__NetworkInterface, default initialized and not managed by a soap context
        virtual tt__NetworkInterface *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__NetworkInterface); }
      public:
        /// Constructor with default initializations
        tt__NetworkInterface() : Enabled(), Info(), Link(), IPv4(), IPv6(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__NetworkInterface() { }
        /// Friend allocator used by soap_new_tt__NetworkInterface(struct soap*, int)
        friend SOAP_FMAC1 tt__NetworkInterface * SOAP_FMAC2 soap_instantiate_tt__NetworkInterface(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1177 */
#ifndef SOAP_TYPE_tt__CertificateUsage
#define SOAP_TYPE_tt__CertificateUsage (496)
/* Type tt__CertificateUsage is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tt:CertificateUsage': */
class SOAP_CMAC tt__CertificateUsage : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        std::string __item;
        /// Required attribute 'Critical' of XML schema type 'xsd:boolean'
        bool Critical;
      public:
        /// Return unique type id SOAP_TYPE_tt__CertificateUsage
        virtual long soap_type(void) const { return SOAP_TYPE_tt__CertificateUsage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__CertificateUsage, default initialized and not managed by a soap context
        virtual tt__CertificateUsage *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__CertificateUsage); }
      public:
        /// Constructor with default initializations
        tt__CertificateUsage() : __item(), Critical() { }
        /// Destructor
        virtual ~tt__CertificateUsage() { }
        /// Friend allocator used by soap_new_tt__CertificateUsage(struct soap*, int)
        friend SOAP_FMAC1 tt__CertificateUsage * SOAP_FMAC2 soap_instantiate_tt__CertificateUsage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1195 */
#ifndef SOAP_TYPE_tt__RelayOutput
#define SOAP_TYPE_tt__RelayOutput (505)
/* Type tt__RelayOutput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:RelayOutput': */
class SOAP_CMAC tt__RelayOutput : public tt__DeviceEntity {
      public:
        /// Required element 'tt:Properties' of XML schema type 'tt:RelayOutputSettings'
        tt__RelayOutputSettings *Properties;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__RelayOutput
        virtual long soap_type(void) const { return SOAP_TYPE_tt__RelayOutput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__RelayOutput, default initialized and not managed by a soap context
        virtual tt__RelayOutput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__RelayOutput); }
      public:
        /// Constructor with default initializations
        tt__RelayOutput() : Properties(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__RelayOutput() { }
        /// Friend allocator used by soap_new_tt__RelayOutput(struct soap*, int)
        friend SOAP_FMAC1 tt__RelayOutput * SOAP_FMAC2 soap_instantiate_tt__RelayOutput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1197 */
#ifndef SOAP_TYPE_tt__DigitalInput
#define SOAP_TYPE_tt__DigitalInput (506)
/* Type tt__DigitalInput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:DigitalInput': */
class SOAP_CMAC tt__DigitalInput : public tt__DeviceEntity {
      public:
        std::vector<char *> __any;
        /// Optional attribute 'IdleState' of XML schema type 'tt:DigitalIdleState'
        enum tt__DigitalIdleState *IdleState;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__DigitalInput
        virtual long soap_type(void) const { return SOAP_TYPE_tt__DigitalInput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__DigitalInput, default initialized and not managed by a soap context
        virtual tt__DigitalInput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__DigitalInput); }
      public:
        /// Constructor with default initializations
        tt__DigitalInput() : __any(), IdleState(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__DigitalInput() { }
        /// Friend allocator used by soap_new_tt__DigitalInput(struct soap*, int)
        friend SOAP_FMAC1 tt__DigitalInput * SOAP_FMAC2 soap_instantiate_tt__DigitalInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1199 */
#ifndef SOAP_TYPE_tt__PTZNode
#define SOAP_TYPE_tt__PTZNode (507)
/* Type tt__PTZNode is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZNode': */
class SOAP_CMAC tt__PTZNode : public tt__DeviceEntity {
      public:
        /// Optional element 'tt:Name' of XML schema type 'tt:Name'
        std::string *Name;
        /// Required element 'tt:SupportedPTZSpaces' of XML schema type 'tt:PTZSpaces'
        tt__PTZSpaces *SupportedPTZSpaces;
        /// Required element 'tt:MaximumNumberOfPresets' of XML schema type 'xsd:int'
        int MaximumNumberOfPresets;
        /// Required element 'tt:HomeSupported' of XML schema type 'xsd:boolean'
        bool HomeSupported;
        /// Optional element 'tt:AuxiliaryCommands' of XML schema type 'tt:AuxiliaryData'
        std::vector<std::string> AuxiliaryCommands;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZNodeExtension'
        tt__PTZNodeExtension *Extension;
        /// Optional attribute 'FixedHomePosition' of XML schema type 'xsd:boolean'
        bool *FixedHomePosition;
        /// Optional attribute 'GeoMove' of XML schema type 'xsd:boolean'
        bool *GeoMove;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZNode
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZNode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZNode, default initialized and not managed by a soap context
        virtual tt__PTZNode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZNode); }
      public:
        /// Constructor with default initializations
        tt__PTZNode() : Name(), SupportedPTZSpaces(), MaximumNumberOfPresets(), HomeSupported(), AuxiliaryCommands(), Extension(), FixedHomePosition(), GeoMove(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZNode() { }
        /// Friend allocator used by soap_new_tt__PTZNode(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZNode * SOAP_FMAC2 soap_instantiate_tt__PTZNode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1209 */
#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (512)
/* Type tt__PTZConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:PTZConfiguration': */
class SOAP_CMAC tt__PTZConfiguration : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:NodeToken' of XML schema type 'tt:ReferenceToken'
        std::string NodeToken;
        /// Optional element 'tt:DefaultAbsolutePantTiltPositionSpace' of XML schema type 'xsd:anyURI'
        std::string *DefaultAbsolutePantTiltPositionSpace;
        /// Optional element 'tt:DefaultAbsoluteZoomPositionSpace' of XML schema type 'xsd:anyURI'
        std::string *DefaultAbsoluteZoomPositionSpace;
        /// Optional element 'tt:DefaultRelativePanTiltTranslationSpace' of XML schema type 'xsd:anyURI'
        std::string *DefaultRelativePanTiltTranslationSpace;
        /// Optional element 'tt:DefaultRelativeZoomTranslationSpace' of XML schema type 'xsd:anyURI'
        std::string *DefaultRelativeZoomTranslationSpace;
        /// Optional element 'tt:DefaultContinuousPanTiltVelocitySpace' of XML schema type 'xsd:anyURI'
        std::string *DefaultContinuousPanTiltVelocitySpace;
        /// Optional element 'tt:DefaultContinuousZoomVelocitySpace' of XML schema type 'xsd:anyURI'
        std::string *DefaultContinuousZoomVelocitySpace;
        /// Optional element 'tt:DefaultPTZSpeed' of XML schema type 'tt:PTZSpeed'
        tt__PTZSpeed *DefaultPTZSpeed;
        /// Optional element 'tt:DefaultPTZTimeout' of XML schema type 'xsd:duration'
        std::string *DefaultPTZTimeout;
        /// Optional element 'tt:PanTiltLimits' of XML schema type 'tt:PanTiltLimits'
        tt__PanTiltLimits *PanTiltLimits;
        /// Optional element 'tt:ZoomLimits' of XML schema type 'tt:ZoomLimits'
        tt__ZoomLimits *ZoomLimits;
        /// Optional element 'tt:Extension' of XML schema type 'tt:PTZConfigurationExtension'
        tt__PTZConfigurationExtension *Extension;
        /// Optional attribute 'MoveRamp' of XML schema type 'xsd:int'
        int *MoveRamp;
        /// Optional attribute 'PresetRamp' of XML schema type 'xsd:int'
        int *PresetRamp;
        /// Optional attribute 'PresetTourRamp' of XML schema type 'xsd:int'
        int *PresetTourRamp;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__PTZConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__PTZConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__PTZConfiguration, default initialized and not managed by a soap context
        virtual tt__PTZConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__PTZConfiguration); }
      public:
        /// Constructor with default initializations
        tt__PTZConfiguration() : NodeToken(), DefaultAbsolutePantTiltPositionSpace(), DefaultAbsoluteZoomPositionSpace(), DefaultRelativePanTiltTranslationSpace(), DefaultRelativeZoomTranslationSpace(), DefaultContinuousPanTiltVelocitySpace(), DefaultContinuousZoomVelocitySpace(), DefaultPTZSpeed(), DefaultPTZTimeout(), PanTiltLimits(), ZoomLimits(), Extension(), MoveRamp(), PresetRamp(), PresetTourRamp(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__PTZConfiguration() { }
        /// Friend allocator used by soap_new_tt__PTZConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 soap_instantiate_tt__PTZConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1509 */
#ifndef SOAP_TYPE_tt__EventFilter
#define SOAP_TYPE_tt__EventFilter (662)
/* Type tt__EventFilter is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:EventFilter': */
class SOAP_CMAC tt__EventFilter : public wsnt__FilterType {
      public:
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__EventFilter
        virtual long soap_type(void) const { return SOAP_TYPE_tt__EventFilter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__EventFilter, default initialized and not managed by a soap context
        virtual tt__EventFilter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__EventFilter); }
      public:
        /// Constructor with default initializations
        tt__EventFilter() : __anyAttribute() { }
        /// Destructor
        virtual ~tt__EventFilter() { }
        /// Friend allocator used by soap_new_tt__EventFilter(struct soap*, int)
        friend SOAP_FMAC1 tt__EventFilter * SOAP_FMAC2 soap_instantiate_tt__EventFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1583 */
#ifndef SOAP_TYPE_tt__AnalyticsEngine
#define SOAP_TYPE_tt__AnalyticsEngine (699)
/* Type tt__AnalyticsEngine is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsEngine': */
class SOAP_CMAC tt__AnalyticsEngine : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:AnalyticsEngineConfiguration' of XML schema type 'tt:AnalyticsDeviceEngineConfiguration'
        tt__AnalyticsDeviceEngineConfiguration *AnalyticsEngineConfiguration;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsEngine
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsEngine; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsEngine, default initialized and not managed by a soap context
        virtual tt__AnalyticsEngine *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsEngine); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsEngine() : AnalyticsEngineConfiguration(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AnalyticsEngine() { }
        /// Friend allocator used by soap_new_tt__AnalyticsEngine(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsEngine * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngine(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1595 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInput
#define SOAP_TYPE_tt__AnalyticsEngineInput (705)
/* Type tt__AnalyticsEngineInput is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsEngineInput': */
class SOAP_CMAC tt__AnalyticsEngineInput : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:SourceIdentification' of XML schema type 'tt:SourceIdentification'
        tt__SourceIdentification *SourceIdentification;
        /// Required element 'tt:VideoInput' of XML schema type 'tt:VideoEncoderConfiguration'
        tt__VideoEncoderConfiguration *VideoInput;
        /// Required element 'tt:MetadataInput' of XML schema type 'tt:MetadataInput'
        tt__MetadataInput *MetadataInput;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsEngineInput
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsEngineInput; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsEngineInput, default initialized and not managed by a soap context
        virtual tt__AnalyticsEngineInput *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsEngineInput); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsEngineInput() : SourceIdentification(), VideoInput(), MetadataInput(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AnalyticsEngineInput() { }
        /// Friend allocator used by soap_new_tt__AnalyticsEngineInput(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsEngineInput * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineInput(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1605 */
#ifndef SOAP_TYPE_tt__AnalyticsEngineControl
#define SOAP_TYPE_tt__AnalyticsEngineControl (710)
/* Type tt__AnalyticsEngineControl is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:AnalyticsEngineControl': */
class SOAP_CMAC tt__AnalyticsEngineControl : public tt__ConfigurationEntity {
      public:
        /// Required element 'tt:EngineToken' of XML schema type 'tt:ReferenceToken'
        std::string EngineToken;
        /// Required element 'tt:EngineConfigToken' of XML schema type 'tt:ReferenceToken'
        std::string EngineConfigToken;
        /// Required element 'tt:InputToken' of XML schema type 'tt:ReferenceToken'
        std::vector<std::string> InputToken;
        /// Required element 'tt:ReceiverToken' of XML schema type 'tt:ReferenceToken'
        std::vector<std::string> ReceiverToken;
        /// Optional element 'tt:Multicast' of XML schema type 'tt:MulticastConfiguration'
        tt__MulticastConfiguration *Multicast;
        /// Required element 'tt:Subscription' of XML schema type 'tt:Config'
        tt__Config *Subscription;
        /// Required element 'tt:Mode' of XML schema type 'tt:ModeOfOperation'
        enum tt__ModeOfOperation Mode;
        std::vector<char *> __any;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__AnalyticsEngineControl
        virtual long soap_type(void) const { return SOAP_TYPE_tt__AnalyticsEngineControl; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__AnalyticsEngineControl, default initialized and not managed by a soap context
        virtual tt__AnalyticsEngineControl *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__AnalyticsEngineControl); }
      public:
        /// Constructor with default initializations
        tt__AnalyticsEngineControl() : EngineToken(), EngineConfigToken(), InputToken(), ReceiverToken(), Multicast(), Subscription(), Mode(), __any(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__AnalyticsEngineControl() { }
        /// Friend allocator used by soap_new_tt__AnalyticsEngineControl(struct soap*, int)
        friend SOAP_FMAC1 tt__AnalyticsEngineControl * SOAP_FMAC2 soap_instantiate_tt__AnalyticsEngineControl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1659 */
#ifndef SOAP_TYPE_tt__OSDConfiguration
#define SOAP_TYPE_tt__OSDConfiguration (737)
/* Type tt__OSDConfiguration is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'tt:OSDConfiguration': */
class SOAP_CMAC tt__OSDConfiguration : public tt__DeviceEntity {
      public:
        /// Required element 'tt:VideoSourceConfigurationToken' of XML schema type 'tt:OSDReference'
        tt__OSDReference *VideoSourceConfigurationToken;
        /// Required element 'tt:Type' of XML schema type 'tt:OSDType'
        enum tt__OSDType Type;
        /// Required element 'tt:Position' of XML schema type 'tt:OSDPosConfiguration'
        tt__OSDPosConfiguration *Position;
        /// Optional element 'tt:TextString' of XML schema type 'tt:OSDTextConfiguration'
        tt__OSDTextConfiguration *TextString;
        /// Optional element 'tt:Image' of XML schema type 'tt:OSDImgConfiguration'
        tt__OSDImgConfiguration *Image;
        /// Optional element 'tt:Extension' of XML schema type 'tt:OSDConfigurationExtension'
        tt__OSDConfigurationExtension *Extension;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDConfiguration
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDConfiguration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDConfiguration, default initialized and not managed by a soap context
        virtual tt__OSDConfiguration *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDConfiguration); }
      public:
        /// Constructor with default initializations
        tt__OSDConfiguration() : VideoSourceConfigurationToken(), Type(), Position(), TextString(), Image(), Extension(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDConfiguration() { }
        /// Friend allocator used by soap_new_tt__OSDConfiguration(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDConfiguration * SOAP_FMAC2 soap_instantiate_tt__OSDConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1733 */
#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (774)
/* complex XML schema type 'wsnt:SubscribeCreationFailedFaultType': */
class SOAP_CMAC wsnt__SubscribeCreationFailedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__SubscribeCreationFailedFaultType, default initialized and not managed by a soap context
        virtual wsnt__SubscribeCreationFailedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__SubscribeCreationFailedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__SubscribeCreationFailedFaultType() { }
        /// Destructor
        virtual ~wsnt__SubscribeCreationFailedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__SubscribeCreationFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__SubscribeCreationFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1735 */
#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (775)
/* complex XML schema type 'wsnt:InvalidFilterFaultType': */
class SOAP_CMAC wsnt__InvalidFilterFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsnt:UnknownFilter' of XML schema type 'xsd:QName'
        std::vector<std::string> UnknownFilter;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidFilterFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidFilterFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidFilterFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidFilterFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidFilterFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__InvalidFilterFaultType() : UnknownFilter() { }
        /// Destructor
        virtual ~wsnt__InvalidFilterFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidFilterFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidFilterFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidFilterFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1737 */
#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (776)
/* complex XML schema type 'wsnt:TopicExpressionDialectUnknownFaultType': */
class SOAP_CMAC wsnt__TopicExpressionDialectUnknownFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__TopicExpressionDialectUnknownFaultType, default initialized and not managed by a soap context
        virtual wsnt__TopicExpressionDialectUnknownFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__TopicExpressionDialectUnknownFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__TopicExpressionDialectUnknownFaultType() { }
        /// Destructor
        virtual ~wsnt__TopicExpressionDialectUnknownFaultType() { }
        /// Friend allocator used by soap_new_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicExpressionDialectUnknownFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1739 */
#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (777)
/* complex XML schema type 'wsnt:InvalidTopicExpressionFaultType': */
class SOAP_CMAC wsnt__InvalidTopicExpressionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidTopicExpressionFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidTopicExpressionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidTopicExpressionFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__InvalidTopicExpressionFaultType() { }
        /// Destructor
        virtual ~wsnt__InvalidTopicExpressionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidTopicExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidTopicExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1741 */
#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (778)
/* complex XML schema type 'wsnt:TopicNotSupportedFaultType': */
class SOAP_CMAC wsnt__TopicNotSupportedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__TopicNotSupportedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__TopicNotSupportedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__TopicNotSupportedFaultType, default initialized and not managed by a soap context
        virtual wsnt__TopicNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__TopicNotSupportedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__TopicNotSupportedFaultType() { }
        /// Destructor
        virtual ~wsnt__TopicNotSupportedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__TopicNotSupportedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__TopicNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__TopicNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1743 */
#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (779)
/* complex XML schema type 'wsnt:MultipleTopicsSpecifiedFaultType': */
class SOAP_CMAC wsnt__MultipleTopicsSpecifiedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__MultipleTopicsSpecifiedFaultType, default initialized and not managed by a soap context
        virtual wsnt__MultipleTopicsSpecifiedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__MultipleTopicsSpecifiedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__MultipleTopicsSpecifiedFaultType() { }
        /// Destructor
        virtual ~wsnt__MultipleTopicsSpecifiedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__MultipleTopicsSpecifiedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__MultipleTopicsSpecifiedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1745 */
#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (780)
/* complex XML schema type 'wsnt:InvalidProducerPropertiesExpressionFaultType': */
class SOAP_CMAC wsnt__InvalidProducerPropertiesExpressionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidProducerPropertiesExpressionFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidProducerPropertiesExpressionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidProducerPropertiesExpressionFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__InvalidProducerPropertiesExpressionFaultType() { }
        /// Destructor
        virtual ~wsnt__InvalidProducerPropertiesExpressionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidProducerPropertiesExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidProducerPropertiesExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1747 */
#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (781)
/* complex XML schema type 'wsnt:InvalidMessageContentExpressionFaultType': */
class SOAP_CMAC wsnt__InvalidMessageContentExpressionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__InvalidMessageContentExpressionFaultType, default initialized and not managed by a soap context
        virtual wsnt__InvalidMessageContentExpressionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__InvalidMessageContentExpressionFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__InvalidMessageContentExpressionFaultType() { }
        /// Destructor
        virtual ~wsnt__InvalidMessageContentExpressionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__InvalidMessageContentExpressionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__InvalidMessageContentExpressionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1749 */
#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (782)
/* complex XML schema type 'wsnt:UnrecognizedPolicyRequestFaultType': */
class SOAP_CMAC wsnt__UnrecognizedPolicyRequestFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Optional element 'wsnt:UnrecognizedPolicy' of XML schema type 'xsd:QName'
        std::vector<std::string> UnrecognizedPolicy;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnrecognizedPolicyRequestFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnrecognizedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnrecognizedPolicyRequestFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnrecognizedPolicyRequestFaultType() : UnrecognizedPolicy() { }
        /// Destructor
        virtual ~wsnt__UnrecognizedPolicyRequestFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnrecognizedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnrecognizedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1751 */
#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (783)
/* complex XML schema type 'wsnt:UnsupportedPolicyRequestFaultType': */
class SOAP_CMAC wsnt__UnsupportedPolicyRequestFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Optional element 'wsnt:UnsupportedPolicy' of XML schema type 'xsd:QName'
        std::vector<std::string> UnsupportedPolicy;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnsupportedPolicyRequestFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnsupportedPolicyRequestFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnsupportedPolicyRequestFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnsupportedPolicyRequestFaultType() : UnsupportedPolicy() { }
        /// Destructor
        virtual ~wsnt__UnsupportedPolicyRequestFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnsupportedPolicyRequestFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnsupportedPolicyRequestFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1753 */
#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (784)
/* complex XML schema type 'wsnt:NotifyMessageNotSupportedFaultType': */
class SOAP_CMAC wsnt__NotifyMessageNotSupportedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__NotifyMessageNotSupportedFaultType, default initialized and not managed by a soap context
        virtual wsnt__NotifyMessageNotSupportedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__NotifyMessageNotSupportedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__NotifyMessageNotSupportedFaultType() { }
        /// Destructor
        virtual ~wsnt__NotifyMessageNotSupportedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__NotifyMessageNotSupportedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NotifyMessageNotSupportedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1755 */
#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (785)
/* complex XML schema type 'wsnt:UnacceptableInitialTerminationTimeFaultType': */
class SOAP_CMAC wsnt__UnacceptableInitialTerminationTimeFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsnt:MinimumTime' of XML schema type 'xsd:dateTime'
        time_t MinimumTime;
        /// Optional element 'wsnt:MaximumTime' of XML schema type 'xsd:dateTime'
        time_t *MaximumTime;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnacceptableInitialTerminationTimeFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnacceptableInitialTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnacceptableInitialTerminationTimeFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnacceptableInitialTerminationTimeFaultType() : MinimumTime(), MaximumTime() { }
        /// Destructor
        virtual ~wsnt__UnacceptableInitialTerminationTimeFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnacceptableInitialTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableInitialTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1757 */
#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (786)
/* complex XML schema type 'wsnt:NoCurrentMessageOnTopicFaultType': */
class SOAP_CMAC wsnt__NoCurrentMessageOnTopicFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__NoCurrentMessageOnTopicFaultType, default initialized and not managed by a soap context
        virtual wsnt__NoCurrentMessageOnTopicFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__NoCurrentMessageOnTopicFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__NoCurrentMessageOnTopicFaultType() { }
        /// Destructor
        virtual ~wsnt__NoCurrentMessageOnTopicFaultType() { }
        /// Friend allocator used by soap_new_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__NoCurrentMessageOnTopicFaultType * SOAP_FMAC2 soap_instantiate_wsnt__NoCurrentMessageOnTopicFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1759 */
#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (787)
/* complex XML schema type 'wsnt:UnableToGetMessagesFaultType': */
class SOAP_CMAC wsnt__UnableToGetMessagesFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToGetMessagesFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToGetMessagesFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToGetMessagesFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToGetMessagesFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnableToGetMessagesFaultType() { }
        /// Destructor
        virtual ~wsnt__UnableToGetMessagesFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToGetMessagesFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToGetMessagesFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToGetMessagesFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1761 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (788)
/* complex XML schema type 'wsnt:UnableToDestroyPullPointFaultType': */
class SOAP_CMAC wsnt__UnableToDestroyPullPointFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToDestroyPullPointFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToDestroyPullPointFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToDestroyPullPointFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnableToDestroyPullPointFaultType() { }
        /// Destructor
        virtual ~wsnt__UnableToDestroyPullPointFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToDestroyPullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroyPullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1763 */
#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (789)
/* complex XML schema type 'wsnt:UnableToCreatePullPointFaultType': */
class SOAP_CMAC wsnt__UnableToCreatePullPointFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToCreatePullPointFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToCreatePullPointFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToCreatePullPointFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnableToCreatePullPointFaultType() { }
        /// Destructor
        virtual ~wsnt__UnableToCreatePullPointFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToCreatePullPointFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToCreatePullPointFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToCreatePullPointFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1765 */
#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (790)
/* complex XML schema type 'wsnt:UnacceptableTerminationTimeFaultType': */
class SOAP_CMAC wsnt__UnacceptableTerminationTimeFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Required element 'wsnt:MinimumTime' of XML schema type 'xsd:dateTime'
        time_t MinimumTime;
        /// Optional element 'wsnt:MaximumTime' of XML schema type 'xsd:dateTime'
        time_t *MaximumTime;
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnacceptableTerminationTimeFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnacceptableTerminationTimeFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnacceptableTerminationTimeFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnacceptableTerminationTimeFaultType() : MinimumTime(), MaximumTime() { }
        /// Destructor
        virtual ~wsnt__UnacceptableTerminationTimeFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnacceptableTerminationTimeFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnacceptableTerminationTimeFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1767 */
#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (791)
/* complex XML schema type 'wsnt:UnableToDestroySubscriptionFaultType': */
class SOAP_CMAC wsnt__UnableToDestroySubscriptionFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__UnableToDestroySubscriptionFaultType, default initialized and not managed by a soap context
        virtual wsnt__UnableToDestroySubscriptionFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__UnableToDestroySubscriptionFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__UnableToDestroySubscriptionFaultType() { }
        /// Destructor
        virtual ~wsnt__UnableToDestroySubscriptionFaultType() { }
        /// Friend allocator used by soap_new_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__UnableToDestroySubscriptionFaultType * SOAP_FMAC2 soap_instantiate_wsnt__UnableToDestroySubscriptionFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1769 */
#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (792)
/* complex XML schema type 'wsnt:PauseFailedFaultType': */
class SOAP_CMAC wsnt__PauseFailedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__PauseFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__PauseFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__PauseFailedFaultType, default initialized and not managed by a soap context
        virtual wsnt__PauseFailedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__PauseFailedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__PauseFailedFaultType() { }
        /// Destructor
        virtual ~wsnt__PauseFailedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__PauseFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__PauseFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__PauseFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1771 */
#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (793)
/* complex XML schema type 'wsnt:ResumeFailedFaultType': */
class SOAP_CMAC wsnt__ResumeFailedFaultType : public wsrfbf__BaseFaultType {
      public:
        /// Return unique type id SOAP_TYPE_wsnt__ResumeFailedFaultType
        virtual long soap_type(void) const { return SOAP_TYPE_wsnt__ResumeFailedFaultType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wsnt__ResumeFailedFaultType, default initialized and not managed by a soap context
        virtual wsnt__ResumeFailedFaultType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wsnt__ResumeFailedFaultType); }
      public:
        /// Constructor with default initializations
        wsnt__ResumeFailedFaultType() { }
        /// Destructor
        virtual ~wsnt__ResumeFailedFaultType() { }
        /// Friend allocator used by soap_new_wsnt__ResumeFailedFaultType(struct soap*, int)
        friend SOAP_FMAC1 wsnt__ResumeFailedFaultType * SOAP_FMAC2 soap_instantiate_wsnt__ResumeFailedFaultType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:30635 */
#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (1590)
/* complex XML schema type 'wstop:TopicNamespaceType-Topic': */
class SOAP_CMAC _wstop__TopicNamespaceType_Topic {
      public:
        /// Optional element 'wstop:documentation' of XML schema type 'wstop:Documentation'
        wstop__Documentation *documentation;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
        /// Optional element 'wstop:MessagePattern' of XML schema type 'wstop:QueryExpressionType'
        wstop__QueryExpressionType *MessagePattern;
        /// Optional element 'wstop:Topic' of XML schema type 'wstop:TopicType'
        std::vector<wstop__TopicType *> Topic;
        std::vector<char *> __any;
        /// Required attribute 'name' of XML schema type 'xsd:NCName'
        std::string name;
        /// Optional attribute 'messageTypes' of XML schema type 'xsd:QName'
        std::string *messageTypes;
        /// Optional attribute 'final' of XML schema type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
        /// Optional attribute 'parent' of XML schema type 'wstop:ConcreteTopicExpression'
        std::string *parent;
      public:
        /// Return unique type id SOAP_TYPE__wstop__TopicNamespaceType_Topic
        virtual long soap_type(void) const { return SOAP_TYPE__wstop__TopicNamespaceType_Topic; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _wstop__TopicNamespaceType_Topic, default initialized and not managed by a soap context
        virtual _wstop__TopicNamespaceType_Topic *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_wstop__TopicNamespaceType_Topic); }
      public:
        /// Constructor with default initializations
        _wstop__TopicNamespaceType_Topic() : documentation(), __anyAttribute(), MessagePattern(), Topic(), __any(), name(), messageTypes(), final_((bool)0), parent() { }
        /// Destructor
        virtual ~_wstop__TopicNamespaceType_Topic() { }
        /// Friend allocator used by soap_new__wstop__TopicNamespaceType_Topic(struct soap*, int)
        friend SOAP_FMAC1 _wstop__TopicNamespaceType_Topic * SOAP_FMAC2 soap_instantiate__wstop__TopicNamespaceType_Topic(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1825 */
#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (820)
/* complex XML schema type 'wstop:TopicNamespaceType': */
class SOAP_CMAC wstop__TopicNamespaceType : public wstop__ExtensibleDocumented {
      public:
        /// Optional element 'wstop:Topic' of XML schema type 'wstop:TopicNamespaceType-Topic'
        std::vector<_wstop__TopicNamespaceType_Topic> Topic;
        std::vector<char *> __any;
        /// Optional attribute 'name' of XML schema type 'xsd:NCName'
        std::string *name;
        /// Required attribute 'targetNamespace' of XML schema type 'xsd:anyURI'
        std::string targetNamespace;
        /// Optional attribute 'final' of XML schema type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_wstop__TopicNamespaceType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__TopicNamespaceType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__TopicNamespaceType, default initialized and not managed by a soap context
        virtual wstop__TopicNamespaceType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__TopicNamespaceType); }
      public:
        /// Constructor with default initializations
        wstop__TopicNamespaceType() : Topic(), __any(), name(), targetNamespace(), final_((bool)0) { }
        /// Destructor
        virtual ~wstop__TopicNamespaceType() { }
        /// Friend allocator used by soap_new_wstop__TopicNamespaceType(struct soap*, int)
        friend SOAP_FMAC1 wstop__TopicNamespaceType * SOAP_FMAC2 soap_instantiate_wstop__TopicNamespaceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1827 */
#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (821)
/* Type wstop__TopicType is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XML schema type 'wstop:TopicType': */
class SOAP_CMAC wstop__TopicType : public wstop__ExtensibleDocumented {
      public:
        /// Optional element 'wstop:MessagePattern' of XML schema type 'wstop:QueryExpressionType'
        wstop__QueryExpressionType *MessagePattern;
        /// Optional element 'wstop:Topic' of XML schema type 'wstop:TopicType'
        std::vector<wstop__TopicType *> Topic;
        std::vector<char *> __any;
        /// Required attribute 'name' of XML schema type 'xsd:NCName'
        std::string name;
        /// Optional attribute 'messageTypes' of XML schema type 'xsd:QName'
        std::string *messageTypes;
        /// Optional attribute 'final' of XML schema type 'xsd:boolean'
        bool final_;	///< initialized with default value = (bool)0
      public:
        /// Return unique type id SOAP_TYPE_wstop__TopicType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__TopicType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__TopicType, default initialized and not managed by a soap context
        virtual wstop__TopicType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__TopicType); }
      public:
        /// Constructor with default initializations
        wstop__TopicType() : MessagePattern(), Topic(), __any(), name(), messageTypes(), final_((bool)0) { }
        /// Destructor
        virtual ~wstop__TopicType() { }
        /// Friend allocator used by soap_new_wstop__TopicType(struct soap*, int)
        friend SOAP_FMAC1 wstop__TopicType * SOAP_FMAC2 soap_instantiate_wstop__TopicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1829 */
#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (822)
/* complex XML schema type 'wstop:TopicSetType': */
class SOAP_CMAC wstop__TopicSetType : public wstop__ExtensibleDocumented {
      public:
        std::vector<char *> __any;
      public:
        /// Return unique type id SOAP_TYPE_wstop__TopicSetType
        virtual long soap_type(void) const { return SOAP_TYPE_wstop__TopicSetType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type wstop__TopicSetType, default initialized and not managed by a soap context
        virtual wstop__TopicSetType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(wstop__TopicSetType); }
      public:
        /// Constructor with default initializations
        wstop__TopicSetType() : __any() { }
        /// Destructor
        virtual ~wstop__TopicSetType() { }
        /// Friend allocator used by soap_new_wstop__TopicSetType(struct soap*, int)
        friend SOAP_FMAC1 wstop__TopicSetType * SOAP_FMAC2 soap_instantiate_wstop__TopicSetType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:1627 */
#ifndef SOAP_TYPE_tt__OSDReference
#define SOAP_TYPE_tt__OSDReference (721)
/* Type tt__OSDReference is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* simple XML schema type 'tt:OSDReference': */
class SOAP_CMAC tt__OSDReference : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'tt:ReferenceToken' wrapped by this struct
        std::string __item;
        /// Optional attribute '-anyAttribute' of XML schema type 'xsd:anyType'
        char *__anyAttribute;
      public:
        /// Return unique type id SOAP_TYPE_tt__OSDReference
        virtual long soap_type(void) const { return SOAP_TYPE_tt__OSDReference; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type tt__OSDReference, default initialized and not managed by a soap context
        virtual tt__OSDReference *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(tt__OSDReference); }
      public:
        /// Constructor with default initializations
        tt__OSDReference() : __item(), __anyAttribute() { }
        /// Destructor
        virtual ~tt__OSDReference() { }
        /// Friend allocator used by soap_new_tt__OSDReference(struct soap*, int)
        friend SOAP_FMAC1 tt__OSDReference * SOAP_FMAC2 soap_instantiate_tt__OSDReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31370 */
#ifndef SOAP_TYPE___tds__GetServices
#define SOAP_TYPE___tds__GetServices (1601)
/* Wrapper: */
struct SOAP_CMAC __tds__GetServices {
      public:
        /** Optional element 'tds:GetServices' of XML schema type 'tds:GetServices' */
        _tds__GetServices *tds__GetServices;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetServices */
        long soap_type() const { return SOAP_TYPE___tds__GetServices; }
        /** Constructor with member initializations */
        __tds__GetServices() : tds__GetServices() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetServices * SOAP_FMAC2 soap_instantiate___tds__GetServices(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31439 */
#ifndef SOAP_TYPE___tds__GetServiceCapabilities
#define SOAP_TYPE___tds__GetServiceCapabilities (1605)
/* Wrapper: */
struct SOAP_CMAC __tds__GetServiceCapabilities {
      public:
        /** Optional element 'tds:GetServiceCapabilities' of XML schema type 'tds:GetServiceCapabilities' */
        _tds__GetServiceCapabilities *tds__GetServiceCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetServiceCapabilities */
        long soap_type() const { return SOAP_TYPE___tds__GetServiceCapabilities; }
        /** Constructor with member initializations */
        __tds__GetServiceCapabilities() : tds__GetServiceCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetServiceCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31507 */
#ifndef SOAP_TYPE___tds__GetDeviceInformation
#define SOAP_TYPE___tds__GetDeviceInformation (1609)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDeviceInformation {
      public:
        /** Optional element 'tds:GetDeviceInformation' of XML schema type 'tds:GetDeviceInformation' */
        _tds__GetDeviceInformation *tds__GetDeviceInformation;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDeviceInformation */
        long soap_type() const { return SOAP_TYPE___tds__GetDeviceInformation; }
        /** Constructor with member initializations */
        __tds__GetDeviceInformation() : tds__GetDeviceInformation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate___tds__GetDeviceInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31589 */
#ifndef SOAP_TYPE___tds__SetSystemDateAndTime
#define SOAP_TYPE___tds__SetSystemDateAndTime (1613)
/* Wrapper: */
struct SOAP_CMAC __tds__SetSystemDateAndTime {
      public:
        /** Optional element 'tds:SetSystemDateAndTime' of XML schema type 'tds:SetSystemDateAndTime' */
        _tds__SetSystemDateAndTime *tds__SetSystemDateAndTime;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetSystemDateAndTime */
        long soap_type() const { return SOAP_TYPE___tds__SetSystemDateAndTime; }
        /** Constructor with member initializations */
        __tds__SetSystemDateAndTime() : tds__SetSystemDateAndTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__SetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31663 */
#ifndef SOAP_TYPE___tds__GetSystemDateAndTime
#define SOAP_TYPE___tds__GetSystemDateAndTime (1617)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemDateAndTime {
      public:
        /** Optional element 'tds:GetSystemDateAndTime' of XML schema type 'tds:GetSystemDateAndTime' */
        _tds__GetSystemDateAndTime *tds__GetSystemDateAndTime;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemDateAndTime */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemDateAndTime; }
        /** Constructor with member initializations */
        __tds__GetSystemDateAndTime() : tds__GetSystemDateAndTime() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__GetSystemDateAndTime(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31731 */
#ifndef SOAP_TYPE___tds__SetSystemFactoryDefault
#define SOAP_TYPE___tds__SetSystemFactoryDefault (1621)
/* Wrapper: */
struct SOAP_CMAC __tds__SetSystemFactoryDefault {
      public:
        /** Optional element 'tds:SetSystemFactoryDefault' of XML schema type 'tds:SetSystemFactoryDefault' */
        _tds__SetSystemFactoryDefault *tds__SetSystemFactoryDefault;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetSystemFactoryDefault */
        long soap_type() const { return SOAP_TYPE___tds__SetSystemFactoryDefault; }
        /** Constructor with member initializations */
        __tds__SetSystemFactoryDefault() : tds__SetSystemFactoryDefault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate___tds__SetSystemFactoryDefault(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31805 */
#ifndef SOAP_TYPE___tds__UpgradeSystemFirmware
#define SOAP_TYPE___tds__UpgradeSystemFirmware (1625)
/* Wrapper: */
struct SOAP_CMAC __tds__UpgradeSystemFirmware {
      public:
        /** Optional element 'tds:UpgradeSystemFirmware' of XML schema type 'tds:UpgradeSystemFirmware' */
        _tds__UpgradeSystemFirmware *tds__UpgradeSystemFirmware;
      public:
        /** Return unique type id SOAP_TYPE___tds__UpgradeSystemFirmware */
        long soap_type() const { return SOAP_TYPE___tds__UpgradeSystemFirmware; }
        /** Constructor with member initializations */
        __tds__UpgradeSystemFirmware() : tds__UpgradeSystemFirmware() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate___tds__UpgradeSystemFirmware(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31873 */
#ifndef SOAP_TYPE___tds__SystemReboot
#define SOAP_TYPE___tds__SystemReboot (1629)
/* Wrapper: */
struct SOAP_CMAC __tds__SystemReboot {
      public:
        /** Optional element 'tds:SystemReboot' of XML schema type 'tds:SystemReboot' */
        _tds__SystemReboot *tds__SystemReboot;
      public:
        /** Return unique type id SOAP_TYPE___tds__SystemReboot */
        long soap_type() const { return SOAP_TYPE___tds__SystemReboot; }
        /** Constructor with member initializations */
        __tds__SystemReboot() : tds__SystemReboot() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SystemReboot * SOAP_FMAC2 soap_instantiate___tds__SystemReboot(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:31949 */
#ifndef SOAP_TYPE___tds__RestoreSystem
#define SOAP_TYPE___tds__RestoreSystem (1633)
/* Wrapper: */
struct SOAP_CMAC __tds__RestoreSystem {
      public:
        /** Optional element 'tds:RestoreSystem' of XML schema type 'tds:RestoreSystem' */
        _tds__RestoreSystem *tds__RestoreSystem;
      public:
        /** Return unique type id SOAP_TYPE___tds__RestoreSystem */
        long soap_type() const { return SOAP_TYPE___tds__RestoreSystem; }
        /** Constructor with member initializations */
        __tds__RestoreSystem() : tds__RestoreSystem() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__RestoreSystem * SOAP_FMAC2 soap_instantiate___tds__RestoreSystem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32024 */
#ifndef SOAP_TYPE___tds__GetSystemBackup
#define SOAP_TYPE___tds__GetSystemBackup (1637)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemBackup {
      public:
        /** Optional element 'tds:GetSystemBackup' of XML schema type 'tds:GetSystemBackup' */
        _tds__GetSystemBackup *tds__GetSystemBackup;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemBackup */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemBackup; }
        /** Constructor with member initializations */
        __tds__GetSystemBackup() : tds__GetSystemBackup() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate___tds__GetSystemBackup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32093 */
#ifndef SOAP_TYPE___tds__GetSystemLog
#define SOAP_TYPE___tds__GetSystemLog (1641)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemLog {
      public:
        /** Optional element 'tds:GetSystemLog' of XML schema type 'tds:GetSystemLog' */
        _tds__GetSystemLog *tds__GetSystemLog;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemLog */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemLog; }
        /** Constructor with member initializations */
        __tds__GetSystemLog() : tds__GetSystemLog() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemLog * SOAP_FMAC2 soap_instantiate___tds__GetSystemLog(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32161 */
#ifndef SOAP_TYPE___tds__GetSystemSupportInformation
#define SOAP_TYPE___tds__GetSystemSupportInformation (1645)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemSupportInformation {
      public:
        /** Optional element 'tds:GetSystemSupportInformation' of XML schema type 'tds:GetSystemSupportInformation' */
        _tds__GetSystemSupportInformation *tds__GetSystemSupportInformation;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemSupportInformation */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemSupportInformation; }
        /** Constructor with member initializations */
        __tds__GetSystemSupportInformation() : tds__GetSystemSupportInformation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate___tds__GetSystemSupportInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32244 */
#ifndef SOAP_TYPE___tds__GetScopes
#define SOAP_TYPE___tds__GetScopes (1649)
/* Wrapper: */
struct SOAP_CMAC __tds__GetScopes {
      public:
        /** Optional element 'tds:GetScopes' of XML schema type 'tds:GetScopes' */
        _tds__GetScopes *tds__GetScopes;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetScopes */
        long soap_type() const { return SOAP_TYPE___tds__GetScopes; }
        /** Constructor with member initializations */
        __tds__GetScopes() : tds__GetScopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetScopes * SOAP_FMAC2 soap_instantiate___tds__GetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32320 */
#ifndef SOAP_TYPE___tds__SetScopes
#define SOAP_TYPE___tds__SetScopes (1653)
/* Wrapper: */
struct SOAP_CMAC __tds__SetScopes {
      public:
        /** Optional element 'tds:SetScopes' of XML schema type 'tds:SetScopes' */
        _tds__SetScopes *tds__SetScopes;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetScopes */
        long soap_type() const { return SOAP_TYPE___tds__SetScopes; }
        /** Constructor with member initializations */
        __tds__SetScopes() : tds__SetScopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetScopes * SOAP_FMAC2 soap_instantiate___tds__SetScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32392 */
#ifndef SOAP_TYPE___tds__AddScopes
#define SOAP_TYPE___tds__AddScopes (1657)
/* Wrapper: */
struct SOAP_CMAC __tds__AddScopes {
      public:
        /** Optional element 'tds:AddScopes' of XML schema type 'tds:AddScopes' */
        _tds__AddScopes *tds__AddScopes;
      public:
        /** Return unique type id SOAP_TYPE___tds__AddScopes */
        long soap_type() const { return SOAP_TYPE___tds__AddScopes; }
        /** Constructor with member initializations */
        __tds__AddScopes() : tds__AddScopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__AddScopes * SOAP_FMAC2 soap_instantiate___tds__AddScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32466 */
#ifndef SOAP_TYPE___tds__RemoveScopes
#define SOAP_TYPE___tds__RemoveScopes (1661)
/* Wrapper: */
struct SOAP_CMAC __tds__RemoveScopes {
      public:
        /** Optional element 'tds:RemoveScopes' of XML schema type 'tds:RemoveScopes' */
        _tds__RemoveScopes *tds__RemoveScopes;
      public:
        /** Return unique type id SOAP_TYPE___tds__RemoveScopes */
        long soap_type() const { return SOAP_TYPE___tds__RemoveScopes; }
        /** Constructor with member initializations */
        __tds__RemoveScopes() : tds__RemoveScopes() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__RemoveScopes * SOAP_FMAC2 soap_instantiate___tds__RemoveScopes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32538 */
#ifndef SOAP_TYPE___tds__GetDiscoveryMode
#define SOAP_TYPE___tds__GetDiscoveryMode (1665)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDiscoveryMode {
      public:
        /** Optional element 'tds:GetDiscoveryMode' of XML schema type 'tds:GetDiscoveryMode' */
        _tds__GetDiscoveryMode *tds__GetDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDiscoveryMode */
        long soap_type() const { return SOAP_TYPE___tds__GetDiscoveryMode; }
        /** Constructor with member initializations */
        __tds__GetDiscoveryMode() : tds__GetDiscoveryMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32611 */
#ifndef SOAP_TYPE___tds__SetDiscoveryMode
#define SOAP_TYPE___tds__SetDiscoveryMode (1669)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDiscoveryMode {
      public:
        /** Optional element 'tds:SetDiscoveryMode' of XML schema type 'tds:SetDiscoveryMode' */
        _tds__SetDiscoveryMode *tds__SetDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDiscoveryMode */
        long soap_type() const { return SOAP_TYPE___tds__SetDiscoveryMode; }
        /** Constructor with member initializations */
        __tds__SetDiscoveryMode() : tds__SetDiscoveryMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32685 */
#ifndef SOAP_TYPE___tds__GetRemoteDiscoveryMode
#define SOAP_TYPE___tds__GetRemoteDiscoveryMode (1673)
/* Wrapper: */
struct SOAP_CMAC __tds__GetRemoteDiscoveryMode {
      public:
        /** Optional element 'tds:GetRemoteDiscoveryMode' of XML schema type 'tds:GetRemoteDiscoveryMode' */
        _tds__GetRemoteDiscoveryMode *tds__GetRemoteDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetRemoteDiscoveryMode */
        long soap_type() const { return SOAP_TYPE___tds__GetRemoteDiscoveryMode; }
        /** Constructor with member initializations */
        __tds__GetRemoteDiscoveryMode() : tds__GetRemoteDiscoveryMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32759 */
#ifndef SOAP_TYPE___tds__SetRemoteDiscoveryMode
#define SOAP_TYPE___tds__SetRemoteDiscoveryMode (1677)
/* Wrapper: */
struct SOAP_CMAC __tds__SetRemoteDiscoveryMode {
      public:
        /** Optional element 'tds:SetRemoteDiscoveryMode' of XML schema type 'tds:SetRemoteDiscoveryMode' */
        _tds__SetRemoteDiscoveryMode *tds__SetRemoteDiscoveryMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetRemoteDiscoveryMode */
        long soap_type() const { return SOAP_TYPE___tds__SetRemoteDiscoveryMode; }
        /** Constructor with member initializations */
        __tds__SetRemoteDiscoveryMode() : tds__SetRemoteDiscoveryMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetRemoteDiscoveryMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32831 */
#ifndef SOAP_TYPE___tds__GetDPAddresses
#define SOAP_TYPE___tds__GetDPAddresses (1681)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDPAddresses {
      public:
        /** Optional element 'tds:GetDPAddresses' of XML schema type 'tds:GetDPAddresses' */
        _tds__GetDPAddresses *tds__GetDPAddresses;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDPAddresses */
        long soap_type() const { return SOAP_TYPE___tds__GetDPAddresses; }
        /** Constructor with member initializations */
        __tds__GetDPAddresses() : tds__GetDPAddresses() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__GetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32905 */
#ifndef SOAP_TYPE___tds__GetEndpointReference
#define SOAP_TYPE___tds__GetEndpointReference (1685)
/* Wrapper: */
struct SOAP_CMAC __tds__GetEndpointReference {
      public:
        /** Optional element 'tds:GetEndpointReference' of XML schema type 'tds:GetEndpointReference' */
        _tds__GetEndpointReference *tds__GetEndpointReference;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetEndpointReference */
        long soap_type() const { return SOAP_TYPE___tds__GetEndpointReference; }
        /** Constructor with member initializations */
        __tds__GetEndpointReference() : tds__GetEndpointReference() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate___tds__GetEndpointReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:32979 */
#ifndef SOAP_TYPE___tds__GetRemoteUser
#define SOAP_TYPE___tds__GetRemoteUser (1689)
/* Wrapper: */
struct SOAP_CMAC __tds__GetRemoteUser {
      public:
        /** Optional element 'tds:GetRemoteUser' of XML schema type 'tds:GetRemoteUser' */
        _tds__GetRemoteUser *tds__GetRemoteUser;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetRemoteUser */
        long soap_type() const { return SOAP_TYPE___tds__GetRemoteUser; }
        /** Constructor with member initializations */
        __tds__GetRemoteUser() : tds__GetRemoteUser() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__GetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33058 */
#ifndef SOAP_TYPE___tds__SetRemoteUser
#define SOAP_TYPE___tds__SetRemoteUser (1693)
/* Wrapper: */
struct SOAP_CMAC __tds__SetRemoteUser {
      public:
        /** Optional element 'tds:SetRemoteUser' of XML schema type 'tds:SetRemoteUser' */
        _tds__SetRemoteUser *tds__SetRemoteUser;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetRemoteUser */
        long soap_type() const { return SOAP_TYPE___tds__SetRemoteUser; }
        /** Constructor with member initializations */
        __tds__SetRemoteUser() : tds__SetRemoteUser() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__SetRemoteUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33130 */
#ifndef SOAP_TYPE___tds__GetUsers
#define SOAP_TYPE___tds__GetUsers (1697)
/* Wrapper: */
struct SOAP_CMAC __tds__GetUsers {
      public:
        /** Optional element 'tds:GetUsers' of XML schema type 'tds:GetUsers' */
        _tds__GetUsers *tds__GetUsers;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetUsers */
        long soap_type() const { return SOAP_TYPE___tds__GetUsers; }
        /** Constructor with member initializations */
        __tds__GetUsers() : tds__GetUsers() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetUsers * SOAP_FMAC2 soap_instantiate___tds__GetUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33210 */
#ifndef SOAP_TYPE___tds__CreateUsers
#define SOAP_TYPE___tds__CreateUsers (1701)
/* Wrapper: */
struct SOAP_CMAC __tds__CreateUsers {
      public:
        /** Optional element 'tds:CreateUsers' of XML schema type 'tds:CreateUsers' */
        _tds__CreateUsers *tds__CreateUsers;
      public:
        /** Return unique type id SOAP_TYPE___tds__CreateUsers */
        long soap_type() const { return SOAP_TYPE___tds__CreateUsers; }
        /** Constructor with member initializations */
        __tds__CreateUsers() : tds__CreateUsers() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__CreateUsers * SOAP_FMAC2 soap_instantiate___tds__CreateUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33285 */
#ifndef SOAP_TYPE___tds__DeleteUsers
#define SOAP_TYPE___tds__DeleteUsers (1705)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteUsers {
      public:
        /** Optional element 'tds:DeleteUsers' of XML schema type 'tds:DeleteUsers' */
        _tds__DeleteUsers *tds__DeleteUsers;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteUsers */
        long soap_type() const { return SOAP_TYPE___tds__DeleteUsers; }
        /** Constructor with member initializations */
        __tds__DeleteUsers() : tds__DeleteUsers() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteUsers * SOAP_FMAC2 soap_instantiate___tds__DeleteUsers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33358 */
#ifndef SOAP_TYPE___tds__SetUser
#define SOAP_TYPE___tds__SetUser (1709)
/* Wrapper: */
struct SOAP_CMAC __tds__SetUser {
      public:
        /** Optional element 'tds:SetUser' of XML schema type 'tds:SetUser' */
        _tds__SetUser *tds__SetUser;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetUser */
        long soap_type() const { return SOAP_TYPE___tds__SetUser; }
        /** Constructor with member initializations */
        __tds__SetUser() : tds__SetUser() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetUser * SOAP_FMAC2 soap_instantiate___tds__SetUser(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33427 */
#ifndef SOAP_TYPE___tds__GetWsdlUrl
#define SOAP_TYPE___tds__GetWsdlUrl (1713)
/* Wrapper: */
struct SOAP_CMAC __tds__GetWsdlUrl {
      public:
        /** Optional element 'tds:GetWsdlUrl' of XML schema type 'tds:GetWsdlUrl' */
        _tds__GetWsdlUrl *tds__GetWsdlUrl;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetWsdlUrl */
        long soap_type() const { return SOAP_TYPE___tds__GetWsdlUrl; }
        /** Constructor with member initializations */
        __tds__GetWsdlUrl() : tds__GetWsdlUrl() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate___tds__GetWsdlUrl(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33496 */
#ifndef SOAP_TYPE___tds__GetPasswordComplexityOptions
#define SOAP_TYPE___tds__GetPasswordComplexityOptions (1717)
/* Wrapper: */
struct SOAP_CMAC __tds__GetPasswordComplexityOptions {
      public:
        /** Optional element 'tds:GetPasswordComplexityOptions' of XML schema type 'tds:GetPasswordComplexityOptions' */
        _tds__GetPasswordComplexityOptions *tds__GetPasswordComplexityOptions;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetPasswordComplexityOptions */
        long soap_type() const { return SOAP_TYPE___tds__GetPasswordComplexityOptions; }
        /** Constructor with member initializations */
        __tds__GetPasswordComplexityOptions() : tds__GetPasswordComplexityOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetPasswordComplexityOptions * SOAP_FMAC2 soap_instantiate___tds__GetPasswordComplexityOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33564 */
#ifndef SOAP_TYPE___tds__GetPasswordComplexityConfiguration
#define SOAP_TYPE___tds__GetPasswordComplexityConfiguration (1721)
/* Wrapper: */
struct SOAP_CMAC __tds__GetPasswordComplexityConfiguration {
      public:
        /** Optional element 'tds:GetPasswordComplexityConfiguration' of XML schema type 'tds:GetPasswordComplexityConfiguration' */
        _tds__GetPasswordComplexityConfiguration *tds__GetPasswordComplexityConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetPasswordComplexityConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__GetPasswordComplexityConfiguration; }
        /** Constructor with member initializations */
        __tds__GetPasswordComplexityConfiguration() : tds__GetPasswordComplexityConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetPasswordComplexityConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetPasswordComplexityConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33632 */
#ifndef SOAP_TYPE___tds__SetPasswordComplexityConfiguration
#define SOAP_TYPE___tds__SetPasswordComplexityConfiguration (1725)
/* Wrapper: */
struct SOAP_CMAC __tds__SetPasswordComplexityConfiguration {
      public:
        /** Optional element 'tds:SetPasswordComplexityConfiguration' of XML schema type 'tds:SetPasswordComplexityConfiguration' */
        _tds__SetPasswordComplexityConfiguration *tds__SetPasswordComplexityConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetPasswordComplexityConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__SetPasswordComplexityConfiguration; }
        /** Constructor with member initializations */
        __tds__SetPasswordComplexityConfiguration() : tds__SetPasswordComplexityConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetPasswordComplexityConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetPasswordComplexityConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33700 */
#ifndef SOAP_TYPE___tds__GetPasswordHistoryConfiguration
#define SOAP_TYPE___tds__GetPasswordHistoryConfiguration (1729)
/* Wrapper: */
struct SOAP_CMAC __tds__GetPasswordHistoryConfiguration {
      public:
        /** Optional element 'tds:GetPasswordHistoryConfiguration' of XML schema type 'tds:GetPasswordHistoryConfiguration' */
        _tds__GetPasswordHistoryConfiguration *tds__GetPasswordHistoryConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetPasswordHistoryConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__GetPasswordHistoryConfiguration; }
        /** Constructor with member initializations */
        __tds__GetPasswordHistoryConfiguration() : tds__GetPasswordHistoryConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetPasswordHistoryConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetPasswordHistoryConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33768 */
#ifndef SOAP_TYPE___tds__SetPasswordHistoryConfiguration
#define SOAP_TYPE___tds__SetPasswordHistoryConfiguration (1733)
/* Wrapper: */
struct SOAP_CMAC __tds__SetPasswordHistoryConfiguration {
      public:
        /** Optional element 'tds:SetPasswordHistoryConfiguration' of XML schema type 'tds:SetPasswordHistoryConfiguration' */
        _tds__SetPasswordHistoryConfiguration *tds__SetPasswordHistoryConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetPasswordHistoryConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__SetPasswordHistoryConfiguration; }
        /** Constructor with member initializations */
        __tds__SetPasswordHistoryConfiguration() : tds__SetPasswordHistoryConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetPasswordHistoryConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetPasswordHistoryConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33837 */
#ifndef SOAP_TYPE___tds__GetAuthFailureWarningOptions
#define SOAP_TYPE___tds__GetAuthFailureWarningOptions (1737)
/* Wrapper: */
struct SOAP_CMAC __tds__GetAuthFailureWarningOptions {
      public:
        /** Optional element 'tds:GetAuthFailureWarningOptions' of XML schema type 'tds:GetAuthFailureWarningOptions' */
        _tds__GetAuthFailureWarningOptions *tds__GetAuthFailureWarningOptions;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetAuthFailureWarningOptions */
        long soap_type() const { return SOAP_TYPE___tds__GetAuthFailureWarningOptions; }
        /** Constructor with member initializations */
        __tds__GetAuthFailureWarningOptions() : tds__GetAuthFailureWarningOptions() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetAuthFailureWarningOptions * SOAP_FMAC2 soap_instantiate___tds__GetAuthFailureWarningOptions(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33906 */
#ifndef SOAP_TYPE___tds__GetAuthFailureWarningConfiguration
#define SOAP_TYPE___tds__GetAuthFailureWarningConfiguration (1741)
/* Wrapper: */
struct SOAP_CMAC __tds__GetAuthFailureWarningConfiguration {
      public:
        /** Optional element 'tds:GetAuthFailureWarningConfiguration' of XML schema type 'tds:GetAuthFailureWarningConfiguration' */
        _tds__GetAuthFailureWarningConfiguration *tds__GetAuthFailureWarningConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetAuthFailureWarningConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__GetAuthFailureWarningConfiguration; }
        /** Constructor with member initializations */
        __tds__GetAuthFailureWarningConfiguration() : tds__GetAuthFailureWarningConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetAuthFailureWarningConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:33974 */
#ifndef SOAP_TYPE___tds__SetAuthFailureWarningConfiguration
#define SOAP_TYPE___tds__SetAuthFailureWarningConfiguration (1745)
/* Wrapper: */
struct SOAP_CMAC __tds__SetAuthFailureWarningConfiguration {
      public:
        /** Optional element 'tds:SetAuthFailureWarningConfiguration' of XML schema type 'tds:SetAuthFailureWarningConfiguration' */
        _tds__SetAuthFailureWarningConfiguration *tds__SetAuthFailureWarningConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetAuthFailureWarningConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__SetAuthFailureWarningConfiguration; }
        /** Constructor with member initializations */
        __tds__SetAuthFailureWarningConfiguration() : tds__SetAuthFailureWarningConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetAuthFailureWarningConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetAuthFailureWarningConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34044 */
#ifndef SOAP_TYPE___tds__GetCapabilities
#define SOAP_TYPE___tds__GetCapabilities (1749)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCapabilities {
      public:
        /** Optional element 'tds:GetCapabilities' of XML schema type 'tds:GetCapabilities' */
        _tds__GetCapabilities *tds__GetCapabilities;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCapabilities */
        long soap_type() const { return SOAP_TYPE___tds__GetCapabilities; }
        /** Constructor with member initializations */
        __tds__GetCapabilities() : tds__GetCapabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetCapabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34117 */
#ifndef SOAP_TYPE___tds__SetDPAddresses
#define SOAP_TYPE___tds__SetDPAddresses (1753)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDPAddresses {
      public:
        /** Optional element 'tds:SetDPAddresses' of XML schema type 'tds:SetDPAddresses' */
        _tds__SetDPAddresses *tds__SetDPAddresses;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDPAddresses */
        long soap_type() const { return SOAP_TYPE___tds__SetDPAddresses; }
        /** Constructor with member initializations */
        __tds__SetDPAddresses() : tds__SetDPAddresses() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__SetDPAddresses(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34188 */
#ifndef SOAP_TYPE___tds__GetHostname
#define SOAP_TYPE___tds__GetHostname (1757)
/* Wrapper: */
struct SOAP_CMAC __tds__GetHostname {
      public:
        /** Optional element 'tds:GetHostname' of XML schema type 'tds:GetHostname' */
        _tds__GetHostname *tds__GetHostname;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetHostname */
        long soap_type() const { return SOAP_TYPE___tds__GetHostname; }
        /** Constructor with member initializations */
        __tds__GetHostname() : tds__GetHostname() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetHostname * SOAP_FMAC2 soap_instantiate___tds__GetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34263 */
#ifndef SOAP_TYPE___tds__SetHostname
#define SOAP_TYPE___tds__SetHostname (1761)
/* Wrapper: */
struct SOAP_CMAC __tds__SetHostname {
      public:
        /** Optional element 'tds:SetHostname' of XML schema type 'tds:SetHostname' */
        _tds__SetHostname *tds__SetHostname;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetHostname */
        long soap_type() const { return SOAP_TYPE___tds__SetHostname; }
        /** Constructor with member initializations */
        __tds__SetHostname() : tds__SetHostname() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetHostname * SOAP_FMAC2 soap_instantiate___tds__SetHostname(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34331 */
#ifndef SOAP_TYPE___tds__SetHostnameFromDHCP
#define SOAP_TYPE___tds__SetHostnameFromDHCP (1765)
/* Wrapper: */
struct SOAP_CMAC __tds__SetHostnameFromDHCP {
      public:
        /** Optional element 'tds:SetHostnameFromDHCP' of XML schema type 'tds:SetHostnameFromDHCP' */
        _tds__SetHostnameFromDHCP *tds__SetHostnameFromDHCP;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetHostnameFromDHCP */
        long soap_type() const { return SOAP_TYPE___tds__SetHostnameFromDHCP; }
        /** Constructor with member initializations */
        __tds__SetHostnameFromDHCP() : tds__SetHostnameFromDHCP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate___tds__SetHostnameFromDHCP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34401 */
#ifndef SOAP_TYPE___tds__GetDNS
#define SOAP_TYPE___tds__GetDNS (1769)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDNS {
      public:
        /** Optional element 'tds:GetDNS' of XML schema type 'tds:GetDNS' */
        _tds__GetDNS *tds__GetDNS;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDNS */
        long soap_type() const { return SOAP_TYPE___tds__GetDNS; }
        /** Constructor with member initializations */
        __tds__GetDNS() : tds__GetDNS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDNS * SOAP_FMAC2 soap_instantiate___tds__GetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34471 */
#ifndef SOAP_TYPE___tds__SetDNS
#define SOAP_TYPE___tds__SetDNS (1773)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDNS {
      public:
        /** Optional element 'tds:SetDNS' of XML schema type 'tds:SetDNS' */
        _tds__SetDNS *tds__SetDNS;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDNS */
        long soap_type() const { return SOAP_TYPE___tds__SetDNS; }
        /** Constructor with member initializations */
        __tds__SetDNS() : tds__SetDNS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDNS * SOAP_FMAC2 soap_instantiate___tds__SetDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34542 */
#ifndef SOAP_TYPE___tds__GetNTP
#define SOAP_TYPE___tds__GetNTP (1777)
/* Wrapper: */
struct SOAP_CMAC __tds__GetNTP {
      public:
        /** Optional element 'tds:GetNTP' of XML schema type 'tds:GetNTP' */
        _tds__GetNTP *tds__GetNTP;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetNTP */
        long soap_type() const { return SOAP_TYPE___tds__GetNTP; }
        /** Constructor with member initializations */
        __tds__GetNTP() : tds__GetNTP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetNTP * SOAP_FMAC2 soap_instantiate___tds__GetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34620 */
#ifndef SOAP_TYPE___tds__SetNTP
#define SOAP_TYPE___tds__SetNTP (1781)
/* Wrapper: */
struct SOAP_CMAC __tds__SetNTP {
      public:
        /** Optional element 'tds:SetNTP' of XML schema type 'tds:SetNTP' */
        _tds__SetNTP *tds__SetNTP;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetNTP */
        long soap_type() const { return SOAP_TYPE___tds__SetNTP; }
        /** Constructor with member initializations */
        __tds__SetNTP() : tds__SetNTP() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetNTP * SOAP_FMAC2 soap_instantiate___tds__SetNTP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34692 */
#ifndef SOAP_TYPE___tds__GetDynamicDNS
#define SOAP_TYPE___tds__GetDynamicDNS (1785)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDynamicDNS {
      public:
        /** Optional element 'tds:GetDynamicDNS' of XML schema type 'tds:GetDynamicDNS' */
        _tds__GetDynamicDNS *tds__GetDynamicDNS;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDynamicDNS */
        long soap_type() const { return SOAP_TYPE___tds__GetDynamicDNS; }
        /** Constructor with member initializations */
        __tds__GetDynamicDNS() : tds__GetDynamicDNS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__GetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34764 */
#ifndef SOAP_TYPE___tds__SetDynamicDNS
#define SOAP_TYPE___tds__SetDynamicDNS (1789)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDynamicDNS {
      public:
        /** Optional element 'tds:SetDynamicDNS' of XML schema type 'tds:SetDynamicDNS' */
        _tds__SetDynamicDNS *tds__SetDynamicDNS;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDynamicDNS */
        long soap_type() const { return SOAP_TYPE___tds__SetDynamicDNS; }
        /** Constructor with member initializations */
        __tds__SetDynamicDNS() : tds__SetDynamicDNS() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__SetDynamicDNS(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34836 */
#ifndef SOAP_TYPE___tds__GetNetworkInterfaces
#define SOAP_TYPE___tds__GetNetworkInterfaces (1793)
/* Wrapper: */
struct SOAP_CMAC __tds__GetNetworkInterfaces {
      public:
        /** Optional element 'tds:GetNetworkInterfaces' of XML schema type 'tds:GetNetworkInterfaces' */
        _tds__GetNetworkInterfaces *tds__GetNetworkInterfaces;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetNetworkInterfaces */
        long soap_type() const { return SOAP_TYPE___tds__GetNetworkInterfaces; }
        /** Constructor with member initializations */
        __tds__GetNetworkInterfaces() : tds__GetNetworkInterfaces() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__GetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34913 */
#ifndef SOAP_TYPE___tds__SetNetworkInterfaces
#define SOAP_TYPE___tds__SetNetworkInterfaces (1797)
/* Wrapper: */
struct SOAP_CMAC __tds__SetNetworkInterfaces {
      public:
        /** Optional element 'tds:SetNetworkInterfaces' of XML schema type 'tds:SetNetworkInterfaces' */
        _tds__SetNetworkInterfaces *tds__SetNetworkInterfaces;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetNetworkInterfaces */
        long soap_type() const { return SOAP_TYPE___tds__SetNetworkInterfaces; }
        /** Constructor with member initializations */
        __tds__SetNetworkInterfaces() : tds__SetNetworkInterfaces() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__SetNetworkInterfaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:34984 */
#ifndef SOAP_TYPE___tds__GetNetworkProtocols
#define SOAP_TYPE___tds__GetNetworkProtocols (1801)
/* Wrapper: */
struct SOAP_CMAC __tds__GetNetworkProtocols {
      public:
        /** Optional element 'tds:GetNetworkProtocols' of XML schema type 'tds:GetNetworkProtocols' */
        _tds__GetNetworkProtocols *tds__GetNetworkProtocols;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetNetworkProtocols */
        long soap_type() const { return SOAP_TYPE___tds__GetNetworkProtocols; }
        /** Constructor with member initializations */
        __tds__GetNetworkProtocols() : tds__GetNetworkProtocols() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__GetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35055 */
#ifndef SOAP_TYPE___tds__SetNetworkProtocols
#define SOAP_TYPE___tds__SetNetworkProtocols (1805)
/* Wrapper: */
struct SOAP_CMAC __tds__SetNetworkProtocols {
      public:
        /** Optional element 'tds:SetNetworkProtocols' of XML schema type 'tds:SetNetworkProtocols' */
        _tds__SetNetworkProtocols *tds__SetNetworkProtocols;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetNetworkProtocols */
        long soap_type() const { return SOAP_TYPE___tds__SetNetworkProtocols; }
        /** Constructor with member initializations */
        __tds__SetNetworkProtocols() : tds__SetNetworkProtocols() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__SetNetworkProtocols(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35126 */
#ifndef SOAP_TYPE___tds__GetNetworkDefaultGateway
#define SOAP_TYPE___tds__GetNetworkDefaultGateway (1809)
/* Wrapper: */
struct SOAP_CMAC __tds__GetNetworkDefaultGateway {
      public:
        /** Optional element 'tds:GetNetworkDefaultGateway' of XML schema type 'tds:GetNetworkDefaultGateway' */
        _tds__GetNetworkDefaultGateway *tds__GetNetworkDefaultGateway;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetNetworkDefaultGateway */
        long soap_type() const { return SOAP_TYPE___tds__GetNetworkDefaultGateway; }
        /** Constructor with member initializations */
        __tds__GetNetworkDefaultGateway() : tds__GetNetworkDefaultGateway() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__GetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35196 */
#ifndef SOAP_TYPE___tds__SetNetworkDefaultGateway
#define SOAP_TYPE___tds__SetNetworkDefaultGateway (1813)
/* Wrapper: */
struct SOAP_CMAC __tds__SetNetworkDefaultGateway {
      public:
        /** Optional element 'tds:SetNetworkDefaultGateway' of XML schema type 'tds:SetNetworkDefaultGateway' */
        _tds__SetNetworkDefaultGateway *tds__SetNetworkDefaultGateway;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetNetworkDefaultGateway */
        long soap_type() const { return SOAP_TYPE___tds__SetNetworkDefaultGateway; }
        /** Constructor with member initializations */
        __tds__SetNetworkDefaultGateway() : tds__SetNetworkDefaultGateway() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__SetNetworkDefaultGateway(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35271 */
#ifndef SOAP_TYPE___tds__GetZeroConfiguration
#define SOAP_TYPE___tds__GetZeroConfiguration (1817)
/* Wrapper: */
struct SOAP_CMAC __tds__GetZeroConfiguration {
      public:
        /** Optional element 'tds:GetZeroConfiguration' of XML schema type 'tds:GetZeroConfiguration' */
        _tds__GetZeroConfiguration *tds__GetZeroConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetZeroConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__GetZeroConfiguration; }
        /** Constructor with member initializations */
        __tds__GetZeroConfiguration() : tds__GetZeroConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35340 */
#ifndef SOAP_TYPE___tds__SetZeroConfiguration
#define SOAP_TYPE___tds__SetZeroConfiguration (1821)
/* Wrapper: */
struct SOAP_CMAC __tds__SetZeroConfiguration {
      public:
        /** Optional element 'tds:SetZeroConfiguration' of XML schema type 'tds:SetZeroConfiguration' */
        _tds__SetZeroConfiguration *tds__SetZeroConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetZeroConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__SetZeroConfiguration; }
        /** Constructor with member initializations */
        __tds__SetZeroConfiguration() : tds__SetZeroConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetZeroConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35412 */
#ifndef SOAP_TYPE___tds__GetIPAddressFilter
#define SOAP_TYPE___tds__GetIPAddressFilter (1825)
/* Wrapper: */
struct SOAP_CMAC __tds__GetIPAddressFilter {
      public:
        /** Optional element 'tds:GetIPAddressFilter' of XML schema type 'tds:GetIPAddressFilter' */
        _tds__GetIPAddressFilter *tds__GetIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetIPAddressFilter */
        long soap_type() const { return SOAP_TYPE___tds__GetIPAddressFilter; }
        /** Constructor with member initializations */
        __tds__GetIPAddressFilter() : tds__GetIPAddressFilter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__GetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35486 */
#ifndef SOAP_TYPE___tds__SetIPAddressFilter
#define SOAP_TYPE___tds__SetIPAddressFilter (1829)
/* Wrapper: */
struct SOAP_CMAC __tds__SetIPAddressFilter {
      public:
        /** Optional element 'tds:SetIPAddressFilter' of XML schema type 'tds:SetIPAddressFilter' */
        _tds__SetIPAddressFilter *tds__SetIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetIPAddressFilter */
        long soap_type() const { return SOAP_TYPE___tds__SetIPAddressFilter; }
        /** Constructor with member initializations */
        __tds__SetIPAddressFilter() : tds__SetIPAddressFilter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__SetIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35559 */
#ifndef SOAP_TYPE___tds__AddIPAddressFilter
#define SOAP_TYPE___tds__AddIPAddressFilter (1833)
/* Wrapper: */
struct SOAP_CMAC __tds__AddIPAddressFilter {
      public:
        /** Optional element 'tds:AddIPAddressFilter' of XML schema type 'tds:AddIPAddressFilter' */
        _tds__AddIPAddressFilter *tds__AddIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___tds__AddIPAddressFilter */
        long soap_type() const { return SOAP_TYPE___tds__AddIPAddressFilter; }
        /** Constructor with member initializations */
        __tds__AddIPAddressFilter() : tds__AddIPAddressFilter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__AddIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35632 */
#ifndef SOAP_TYPE___tds__RemoveIPAddressFilter
#define SOAP_TYPE___tds__RemoveIPAddressFilter (1837)
/* Wrapper: */
struct SOAP_CMAC __tds__RemoveIPAddressFilter {
      public:
        /** Optional element 'tds:RemoveIPAddressFilter' of XML schema type 'tds:RemoveIPAddressFilter' */
        _tds__RemoveIPAddressFilter *tds__RemoveIPAddressFilter;
      public:
        /** Return unique type id SOAP_TYPE___tds__RemoveIPAddressFilter */
        long soap_type() const { return SOAP_TYPE___tds__RemoveIPAddressFilter; }
        /** Constructor with member initializations */
        __tds__RemoveIPAddressFilter() : tds__RemoveIPAddressFilter() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__RemoveIPAddressFilter(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35714 */
#ifndef SOAP_TYPE___tds__GetAccessPolicy
#define SOAP_TYPE___tds__GetAccessPolicy (1841)
/* Wrapper: */
struct SOAP_CMAC __tds__GetAccessPolicy {
      public:
        /** Optional element 'tds:GetAccessPolicy' of XML schema type 'tds:GetAccessPolicy' */
        _tds__GetAccessPolicy *tds__GetAccessPolicy;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetAccessPolicy */
        long soap_type() const { return SOAP_TYPE___tds__GetAccessPolicy; }
        /** Constructor with member initializations */
        __tds__GetAccessPolicy() : tds__GetAccessPolicy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__GetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35787 */
#ifndef SOAP_TYPE___tds__SetAccessPolicy
#define SOAP_TYPE___tds__SetAccessPolicy (1845)
/* Wrapper: */
struct SOAP_CMAC __tds__SetAccessPolicy {
      public:
        /** Optional element 'tds:SetAccessPolicy' of XML schema type 'tds:SetAccessPolicy' */
        _tds__SetAccessPolicy *tds__SetAccessPolicy;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetAccessPolicy */
        long soap_type() const { return SOAP_TYPE___tds__SetAccessPolicy; }
        /** Constructor with member initializations */
        __tds__SetAccessPolicy() : tds__SetAccessPolicy() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__SetAccessPolicy(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35854 */
#ifndef SOAP_TYPE___tds__CreateCertificate
#define SOAP_TYPE___tds__CreateCertificate (1849)
/* Wrapper: */
struct SOAP_CMAC __tds__CreateCertificate {
      public:
        /** Optional element 'tds:CreateCertificate' of XML schema type 'tds:CreateCertificate' */
        _tds__CreateCertificate *tds__CreateCertificate;
      public:
        /** Return unique type id SOAP_TYPE___tds__CreateCertificate */
        long soap_type() const { return SOAP_TYPE___tds__CreateCertificate; }
        /** Constructor with member initializations */
        __tds__CreateCertificate() : tds__CreateCertificate() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__CreateCertificate * SOAP_FMAC2 soap_instantiate___tds__CreateCertificate(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35921 */
#ifndef SOAP_TYPE___tds__GetCertificates
#define SOAP_TYPE___tds__GetCertificates (1853)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCertificates {
      public:
        /** Optional element 'tds:GetCertificates' of XML schema type 'tds:GetCertificates' */
        _tds__GetCertificates *tds__GetCertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCertificates */
        long soap_type() const { return SOAP_TYPE___tds__GetCertificates; }
        /** Constructor with member initializations */
        __tds__GetCertificates() : tds__GetCertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCertificates * SOAP_FMAC2 soap_instantiate___tds__GetCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:35988 */
#ifndef SOAP_TYPE___tds__GetCertificatesStatus
#define SOAP_TYPE___tds__GetCertificatesStatus (1857)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCertificatesStatus {
      public:
        /** Optional element 'tds:GetCertificatesStatus' of XML schema type 'tds:GetCertificatesStatus' */
        _tds__GetCertificatesStatus *tds__GetCertificatesStatus;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCertificatesStatus */
        long soap_type() const { return SOAP_TYPE___tds__GetCertificatesStatus; }
        /** Constructor with member initializations */
        __tds__GetCertificatesStatus() : tds__GetCertificatesStatus() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__GetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36055 */
#ifndef SOAP_TYPE___tds__SetCertificatesStatus
#define SOAP_TYPE___tds__SetCertificatesStatus (1861)
/* Wrapper: */
struct SOAP_CMAC __tds__SetCertificatesStatus {
      public:
        /** Optional element 'tds:SetCertificatesStatus' of XML schema type 'tds:SetCertificatesStatus' */
        _tds__SetCertificatesStatus *tds__SetCertificatesStatus;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetCertificatesStatus */
        long soap_type() const { return SOAP_TYPE___tds__SetCertificatesStatus; }
        /** Constructor with member initializations */
        __tds__SetCertificatesStatus() : tds__SetCertificatesStatus() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__SetCertificatesStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36122 */
#ifndef SOAP_TYPE___tds__DeleteCertificates
#define SOAP_TYPE___tds__DeleteCertificates (1865)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteCertificates {
      public:
        /** Optional element 'tds:DeleteCertificates' of XML schema type 'tds:DeleteCertificates' */
        _tds__DeleteCertificates *tds__DeleteCertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteCertificates */
        long soap_type() const { return SOAP_TYPE___tds__DeleteCertificates; }
        /** Constructor with member initializations */
        __tds__DeleteCertificates() : tds__DeleteCertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate___tds__DeleteCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36189 */
#ifndef SOAP_TYPE___tds__GetPkcs10Request
#define SOAP_TYPE___tds__GetPkcs10Request (1869)
/* Wrapper: */
struct SOAP_CMAC __tds__GetPkcs10Request {
      public:
        /** Optional element 'tds:GetPkcs10Request' of XML schema type 'tds:GetPkcs10Request' */
        _tds__GetPkcs10Request *tds__GetPkcs10Request;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetPkcs10Request */
        long soap_type() const { return SOAP_TYPE___tds__GetPkcs10Request; }
        /** Constructor with member initializations */
        __tds__GetPkcs10Request() : tds__GetPkcs10Request() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate___tds__GetPkcs10Request(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36256 */
#ifndef SOAP_TYPE___tds__LoadCertificates
#define SOAP_TYPE___tds__LoadCertificates (1873)
/* Wrapper: */
struct SOAP_CMAC __tds__LoadCertificates {
      public:
        /** Optional element 'tds:LoadCertificates' of XML schema type 'tds:LoadCertificates' */
        _tds__LoadCertificates *tds__LoadCertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__LoadCertificates */
        long soap_type() const { return SOAP_TYPE___tds__LoadCertificates; }
        /** Constructor with member initializations */
        __tds__LoadCertificates() : tds__LoadCertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__LoadCertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36323 */
#ifndef SOAP_TYPE___tds__GetClientCertificateMode
#define SOAP_TYPE___tds__GetClientCertificateMode (1877)
/* Wrapper: */
struct SOAP_CMAC __tds__GetClientCertificateMode {
      public:
        /** Optional element 'tds:GetClientCertificateMode' of XML schema type 'tds:GetClientCertificateMode' */
        _tds__GetClientCertificateMode *tds__GetClientCertificateMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetClientCertificateMode */
        long soap_type() const { return SOAP_TYPE___tds__GetClientCertificateMode; }
        /** Constructor with member initializations */
        __tds__GetClientCertificateMode() : tds__GetClientCertificateMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__GetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36390 */
#ifndef SOAP_TYPE___tds__SetClientCertificateMode
#define SOAP_TYPE___tds__SetClientCertificateMode (1881)
/* Wrapper: */
struct SOAP_CMAC __tds__SetClientCertificateMode {
      public:
        /** Optional element 'tds:SetClientCertificateMode' of XML schema type 'tds:SetClientCertificateMode' */
        _tds__SetClientCertificateMode *tds__SetClientCertificateMode;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetClientCertificateMode */
        long soap_type() const { return SOAP_TYPE___tds__SetClientCertificateMode; }
        /** Constructor with member initializations */
        __tds__SetClientCertificateMode() : tds__SetClientCertificateMode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__SetClientCertificateMode(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36460 */
#ifndef SOAP_TYPE___tds__GetRelayOutputs
#define SOAP_TYPE___tds__GetRelayOutputs (1885)
/* Wrapper: */
struct SOAP_CMAC __tds__GetRelayOutputs {
      public:
        /** Optional element 'tds:GetRelayOutputs' of XML schema type 'tds:GetRelayOutputs' */
        _tds__GetRelayOutputs *tds__GetRelayOutputs;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetRelayOutputs */
        long soap_type() const { return SOAP_TYPE___tds__GetRelayOutputs; }
        /** Constructor with member initializations */
        __tds__GetRelayOutputs() : tds__GetRelayOutputs() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate___tds__GetRelayOutputs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36530 */
#ifndef SOAP_TYPE___tds__SetRelayOutputSettings
#define SOAP_TYPE___tds__SetRelayOutputSettings (1889)
/* Wrapper: */
struct SOAP_CMAC __tds__SetRelayOutputSettings {
      public:
        /** Optional element 'tds:SetRelayOutputSettings' of XML schema type 'tds:SetRelayOutputSettings' */
        _tds__SetRelayOutputSettings *tds__SetRelayOutputSettings;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetRelayOutputSettings */
        long soap_type() const { return SOAP_TYPE___tds__SetRelayOutputSettings; }
        /** Constructor with member initializations */
        __tds__SetRelayOutputSettings() : tds__SetRelayOutputSettings() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputSettings(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36600 */
#ifndef SOAP_TYPE___tds__SetRelayOutputState
#define SOAP_TYPE___tds__SetRelayOutputState (1893)
/* Wrapper: */
struct SOAP_CMAC __tds__SetRelayOutputState {
      public:
        /** Optional element 'tds:SetRelayOutputState' of XML schema type 'tds:SetRelayOutputState' */
        _tds__SetRelayOutputState *tds__SetRelayOutputState;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetRelayOutputState */
        long soap_type() const { return SOAP_TYPE___tds__SetRelayOutputState; }
        /** Constructor with member initializations */
        __tds__SetRelayOutputState() : tds__SetRelayOutputState() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputState(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36699 */
#ifndef SOAP_TYPE___tds__SendAuxiliaryCommand
#define SOAP_TYPE___tds__SendAuxiliaryCommand (1897)
/* Wrapper: */
struct SOAP_CMAC __tds__SendAuxiliaryCommand {
      public:
        /** Optional element 'tds:SendAuxiliaryCommand' of XML schema type 'tds:SendAuxiliaryCommand' */
        _tds__SendAuxiliaryCommand *tds__SendAuxiliaryCommand;
      public:
        /** Return unique type id SOAP_TYPE___tds__SendAuxiliaryCommand */
        long soap_type() const { return SOAP_TYPE___tds__SendAuxiliaryCommand; }
        /** Constructor with member initializations */
        __tds__SendAuxiliaryCommand() : tds__SendAuxiliaryCommand() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___tds__SendAuxiliaryCommand(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36766 */
#ifndef SOAP_TYPE___tds__GetCACertificates
#define SOAP_TYPE___tds__GetCACertificates (1901)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCACertificates {
      public:
        /** Optional element 'tds:GetCACertificates' of XML schema type 'tds:GetCACertificates' */
        _tds__GetCACertificates *tds__GetCACertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCACertificates */
        long soap_type() const { return SOAP_TYPE___tds__GetCACertificates; }
        /** Constructor with member initializations */
        __tds__GetCACertificates() : tds__GetCACertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCACertificates * SOAP_FMAC2 soap_instantiate___tds__GetCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36833 */
#ifndef SOAP_TYPE___tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE___tds__LoadCertificateWithPrivateKey (1905)
/* Wrapper: */
struct SOAP_CMAC __tds__LoadCertificateWithPrivateKey {
      public:
        /** Optional element 'tds:LoadCertificateWithPrivateKey' of XML schema type 'tds:LoadCertificateWithPrivateKey' */
        _tds__LoadCertificateWithPrivateKey *tds__LoadCertificateWithPrivateKey;
      public:
        /** Return unique type id SOAP_TYPE___tds__LoadCertificateWithPrivateKey */
        long soap_type() const { return SOAP_TYPE___tds__LoadCertificateWithPrivateKey; }
        /** Constructor with member initializations */
        __tds__LoadCertificateWithPrivateKey() : tds__LoadCertificateWithPrivateKey() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate___tds__LoadCertificateWithPrivateKey(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36900 */
#ifndef SOAP_TYPE___tds__GetCertificateInformation
#define SOAP_TYPE___tds__GetCertificateInformation (1909)
/* Wrapper: */
struct SOAP_CMAC __tds__GetCertificateInformation {
      public:
        /** Optional element 'tds:GetCertificateInformation' of XML schema type 'tds:GetCertificateInformation' */
        _tds__GetCertificateInformation *tds__GetCertificateInformation;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetCertificateInformation */
        long soap_type() const { return SOAP_TYPE___tds__GetCertificateInformation; }
        /** Constructor with member initializations */
        __tds__GetCertificateInformation() : tds__GetCertificateInformation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate___tds__GetCertificateInformation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:36967 */
#ifndef SOAP_TYPE___tds__LoadCACertificates
#define SOAP_TYPE___tds__LoadCACertificates (1913)
/* Wrapper: */
struct SOAP_CMAC __tds__LoadCACertificates {
      public:
        /** Optional element 'tds:LoadCACertificates' of XML schema type 'tds:LoadCACertificates' */
        _tds__LoadCACertificates *tds__LoadCACertificates;
      public:
        /** Return unique type id SOAP_TYPE___tds__LoadCACertificates */
        long soap_type() const { return SOAP_TYPE___tds__LoadCACertificates; }
        /** Constructor with member initializations */
        __tds__LoadCACertificates() : tds__LoadCACertificates() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCACertificates(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37034 */
#ifndef SOAP_TYPE___tds__CreateDot1XConfiguration
#define SOAP_TYPE___tds__CreateDot1XConfiguration (1917)
/* Wrapper: */
struct SOAP_CMAC __tds__CreateDot1XConfiguration {
      public:
        /** Optional element 'tds:CreateDot1XConfiguration' of XML schema type 'tds:CreateDot1XConfiguration' */
        _tds__CreateDot1XConfiguration *tds__CreateDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__CreateDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__CreateDot1XConfiguration; }
        /** Constructor with member initializations */
        __tds__CreateDot1XConfiguration() : tds__CreateDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37101 */
#ifndef SOAP_TYPE___tds__SetDot1XConfiguration
#define SOAP_TYPE___tds__SetDot1XConfiguration (1921)
/* Wrapper: */
struct SOAP_CMAC __tds__SetDot1XConfiguration {
      public:
        /** Optional element 'tds:SetDot1XConfiguration' of XML schema type 'tds:SetDot1XConfiguration' */
        _tds__SetDot1XConfiguration *tds__SetDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__SetDot1XConfiguration; }
        /** Constructor with member initializations */
        __tds__SetDot1XConfiguration() : tds__SetDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37168 */
#ifndef SOAP_TYPE___tds__GetDot1XConfiguration
#define SOAP_TYPE___tds__GetDot1XConfiguration (1925)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDot1XConfiguration {
      public:
        /** Optional element 'tds:GetDot1XConfiguration' of XML schema type 'tds:GetDot1XConfiguration' */
        _tds__GetDot1XConfiguration *tds__GetDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__GetDot1XConfiguration; }
        /** Constructor with member initializations */
        __tds__GetDot1XConfiguration() : tds__GetDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37235 */
#ifndef SOAP_TYPE___tds__GetDot1XConfigurations
#define SOAP_TYPE___tds__GetDot1XConfigurations (1929)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDot1XConfigurations {
      public:
        /** Optional element 'tds:GetDot1XConfigurations' of XML schema type 'tds:GetDot1XConfigurations' */
        _tds__GetDot1XConfigurations *tds__GetDot1XConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDot1XConfigurations */
        long soap_type() const { return SOAP_TYPE___tds__GetDot1XConfigurations; }
        /** Constructor with member initializations */
        __tds__GetDot1XConfigurations() : tds__GetDot1XConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37302 */
#ifndef SOAP_TYPE___tds__DeleteDot1XConfiguration
#define SOAP_TYPE___tds__DeleteDot1XConfiguration (1933)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteDot1XConfiguration {
      public:
        /** Optional element 'tds:DeleteDot1XConfiguration' of XML schema type 'tds:DeleteDot1XConfiguration' */
        _tds__DeleteDot1XConfiguration *tds__DeleteDot1XConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteDot1XConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__DeleteDot1XConfiguration; }
        /** Constructor with member initializations */
        __tds__DeleteDot1XConfiguration() : tds__DeleteDot1XConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteDot1XConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37371 */
#ifndef SOAP_TYPE___tds__GetDot11Capabilities
#define SOAP_TYPE___tds__GetDot11Capabilities (1937)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDot11Capabilities {
      public:
        /** Optional element 'tds:GetDot11Capabilities' of XML schema type 'tds:GetDot11Capabilities' */
        _tds__GetDot11Capabilities *tds__GetDot11Capabilities;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDot11Capabilities */
        long soap_type() const { return SOAP_TYPE___tds__GetDot11Capabilities; }
        /** Constructor with member initializations */
        __tds__GetDot11Capabilities() : tds__GetDot11Capabilities() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate___tds__GetDot11Capabilities(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37441 */
#ifndef SOAP_TYPE___tds__GetDot11Status
#define SOAP_TYPE___tds__GetDot11Status (1941)
/* Wrapper: */
struct SOAP_CMAC __tds__GetDot11Status {
      public:
        /** Optional element 'tds:GetDot11Status' of XML schema type 'tds:GetDot11Status' */
        _tds__GetDot11Status *tds__GetDot11Status;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetDot11Status */
        long soap_type() const { return SOAP_TYPE___tds__GetDot11Status; }
        /** Constructor with member initializations */
        __tds__GetDot11Status() : tds__GetDot11Status() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetDot11Status * SOAP_FMAC2 soap_instantiate___tds__GetDot11Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37511 */
#ifndef SOAP_TYPE___tds__ScanAvailableDot11Networks
#define SOAP_TYPE___tds__ScanAvailableDot11Networks (1945)
/* Wrapper: */
struct SOAP_CMAC __tds__ScanAvailableDot11Networks {
      public:
        /** Optional element 'tds:ScanAvailableDot11Networks' of XML schema type 'tds:ScanAvailableDot11Networks' */
        _tds__ScanAvailableDot11Networks *tds__ScanAvailableDot11Networks;
      public:
        /** Return unique type id SOAP_TYPE___tds__ScanAvailableDot11Networks */
        long soap_type() const { return SOAP_TYPE___tds__ScanAvailableDot11Networks; }
        /** Constructor with member initializations */
        __tds__ScanAvailableDot11Networks() : tds__ScanAvailableDot11Networks() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate___tds__ScanAvailableDot11Networks(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37598 */
#ifndef SOAP_TYPE___tds__GetSystemUris
#define SOAP_TYPE___tds__GetSystemUris (1949)
/* Wrapper: */
struct SOAP_CMAC __tds__GetSystemUris {
      public:
        /** Optional element 'tds:GetSystemUris' of XML schema type 'tds:GetSystemUris' */
        _tds__GetSystemUris *tds__GetSystemUris;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetSystemUris */
        long soap_type() const { return SOAP_TYPE___tds__GetSystemUris; }
        /** Constructor with member initializations */
        __tds__GetSystemUris() : tds__GetSystemUris() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetSystemUris * SOAP_FMAC2 soap_instantiate___tds__GetSystemUris(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37694 */
#ifndef SOAP_TYPE___tds__StartFirmwareUpgrade
#define SOAP_TYPE___tds__StartFirmwareUpgrade (1953)
/* Wrapper: */
struct SOAP_CMAC __tds__StartFirmwareUpgrade {
      public:
        /** Optional element 'tds:StartFirmwareUpgrade' of XML schema type 'tds:StartFirmwareUpgrade' */
        _tds__StartFirmwareUpgrade *tds__StartFirmwareUpgrade;
      public:
        /** Return unique type id SOAP_TYPE___tds__StartFirmwareUpgrade */
        long soap_type() const { return SOAP_TYPE___tds__StartFirmwareUpgrade; }
        /** Constructor with member initializations */
        __tds__StartFirmwareUpgrade() : tds__StartFirmwareUpgrade() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate___tds__StartFirmwareUpgrade(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37789 */
#ifndef SOAP_TYPE___tds__StartSystemRestore
#define SOAP_TYPE___tds__StartSystemRestore (1957)
/* Wrapper: */
struct SOAP_CMAC __tds__StartSystemRestore {
      public:
        /** Optional element 'tds:StartSystemRestore' of XML schema type 'tds:StartSystemRestore' */
        _tds__StartSystemRestore *tds__StartSystemRestore;
      public:
        /** Return unique type id SOAP_TYPE___tds__StartSystemRestore */
        long soap_type() const { return SOAP_TYPE___tds__StartSystemRestore; }
        /** Constructor with member initializations */
        __tds__StartSystemRestore() : tds__StartSystemRestore() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate___tds__StartSystemRestore(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37859 */
#ifndef SOAP_TYPE___tds__GetStorageConfigurations
#define SOAP_TYPE___tds__GetStorageConfigurations (1961)
/* Wrapper: */
struct SOAP_CMAC __tds__GetStorageConfigurations {
      public:
        /** Optional element 'tds:GetStorageConfigurations' of XML schema type 'tds:GetStorageConfigurations' */
        _tds__GetStorageConfigurations *tds__GetStorageConfigurations;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetStorageConfigurations */
        long soap_type() const { return SOAP_TYPE___tds__GetStorageConfigurations; }
        /** Constructor with member initializations */
        __tds__GetStorageConfigurations() : tds__GetStorageConfigurations() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetStorageConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfigurations(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:37930 */
#ifndef SOAP_TYPE___tds__CreateStorageConfiguration
#define SOAP_TYPE___tds__CreateStorageConfiguration (1965)
/* Wrapper: */
struct SOAP_CMAC __tds__CreateStorageConfiguration {
      public:
        /** Optional element 'tds:CreateStorageConfiguration' of XML schema type 'tds:CreateStorageConfiguration' */
        _tds__CreateStorageConfiguration *tds__CreateStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__CreateStorageConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__CreateStorageConfiguration; }
        /** Constructor with member initializations */
        __tds__CreateStorageConfiguration() : tds__CreateStorageConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__CreateStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38000 */
#ifndef SOAP_TYPE___tds__GetStorageConfiguration
#define SOAP_TYPE___tds__GetStorageConfiguration (1969)
/* Wrapper: */
struct SOAP_CMAC __tds__GetStorageConfiguration {
      public:
        /** Optional element 'tds:GetStorageConfiguration' of XML schema type 'tds:GetStorageConfiguration' */
        _tds__GetStorageConfiguration *tds__GetStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetStorageConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__GetStorageConfiguration; }
        /** Constructor with member initializations */
        __tds__GetStorageConfiguration() : tds__GetStorageConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38069 */
#ifndef SOAP_TYPE___tds__SetStorageConfiguration
#define SOAP_TYPE___tds__SetStorageConfiguration (1973)
/* Wrapper: */
struct SOAP_CMAC __tds__SetStorageConfiguration {
      public:
        /** Optional element 'tds:SetStorageConfiguration' of XML schema type 'tds:SetStorageConfiguration' */
        _tds__SetStorageConfiguration *tds__SetStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetStorageConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__SetStorageConfiguration; }
        /** Constructor with member initializations */
        __tds__SetStorageConfiguration() : tds__SetStorageConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38139 */
#ifndef SOAP_TYPE___tds__DeleteStorageConfiguration
#define SOAP_TYPE___tds__DeleteStorageConfiguration (1977)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteStorageConfiguration {
      public:
        /** Optional element 'tds:DeleteStorageConfiguration' of XML schema type 'tds:DeleteStorageConfiguration' */
        _tds__DeleteStorageConfiguration *tds__DeleteStorageConfiguration;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteStorageConfiguration */
        long soap_type() const { return SOAP_TYPE___tds__DeleteStorageConfiguration; }
        /** Constructor with member initializations */
        __tds__DeleteStorageConfiguration() : tds__DeleteStorageConfiguration() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteStorageConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteStorageConfiguration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38209 */
#ifndef SOAP_TYPE___tds__GetGeoLocation
#define SOAP_TYPE___tds__GetGeoLocation (1981)
/* Wrapper: */
struct SOAP_CMAC __tds__GetGeoLocation {
      public:
        /** Optional element 'tds:GetGeoLocation' of XML schema type 'tds:GetGeoLocation' */
        _tds__GetGeoLocation *tds__GetGeoLocation;
      public:
        /** Return unique type id SOAP_TYPE___tds__GetGeoLocation */
        long soap_type() const { return SOAP_TYPE___tds__GetGeoLocation; }
        /** Constructor with member initializations */
        __tds__GetGeoLocation() : tds__GetGeoLocation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__GetGeoLocation * SOAP_FMAC2 soap_instantiate___tds__GetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38279 */
#ifndef SOAP_TYPE___tds__SetGeoLocation
#define SOAP_TYPE___tds__SetGeoLocation (1985)
/* Wrapper: */
struct SOAP_CMAC __tds__SetGeoLocation {
      public:
        /** Optional element 'tds:SetGeoLocation' of XML schema type 'tds:SetGeoLocation' */
        _tds__SetGeoLocation *tds__SetGeoLocation;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetGeoLocation */
        long soap_type() const { return SOAP_TYPE___tds__SetGeoLocation; }
        /** Constructor with member initializations */
        __tds__SetGeoLocation() : tds__SetGeoLocation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetGeoLocation * SOAP_FMAC2 soap_instantiate___tds__SetGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38348 */
#ifndef SOAP_TYPE___tds__DeleteGeoLocation
#define SOAP_TYPE___tds__DeleteGeoLocation (1989)
/* Wrapper: */
struct SOAP_CMAC __tds__DeleteGeoLocation {
      public:
        /** Optional element 'tds:DeleteGeoLocation' of XML schema type 'tds:DeleteGeoLocation' */
        _tds__DeleteGeoLocation *tds__DeleteGeoLocation;
      public:
        /** Return unique type id SOAP_TYPE___tds__DeleteGeoLocation */
        long soap_type() const { return SOAP_TYPE___tds__DeleteGeoLocation; }
        /** Constructor with member initializations */
        __tds__DeleteGeoLocation() : tds__DeleteGeoLocation() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__DeleteGeoLocation * SOAP_FMAC2 soap_instantiate___tds__DeleteGeoLocation(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* onvif.h:38418 */
#ifndef SOAP_TYPE___tds__SetHashingAlgorithm
#define SOAP_TYPE___tds__SetHashingAlgorithm (1993)
/* Wrapper: */
struct SOAP_CMAC __tds__SetHashingAlgorithm {
      public:
        /** Optional element 'tds:SetHashingAlgorithm' of XML schema type 'tds:SetHashingAlgorithm' */
        _tds__SetHashingAlgorithm *tds__SetHashingAlgorithm;
      public:
        /** Return unique type id SOAP_TYPE___tds__SetHashingAlgorithm */
        long soap_type() const { return SOAP_TYPE___tds__SetHashingAlgorithm; }
        /** Constructor with member initializations */
        __tds__SetHashingAlgorithm() : tds__SetHashingAlgorithm() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __tds__SetHashingAlgorithm * SOAP_FMAC2 soap_instantiate___tds__SetHashingAlgorithm(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/* wsa5.h:89 */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (17)
typedef char *wsa5__RelationshipTypeOpenEnum;
#endif

/* wsa5.h:92 */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (18)
typedef char *wsa5__FaultCodesOpenEnumType;
#endif

/* wsa5.h:211 */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (25)
typedef struct wsa5__EndpointReferenceType _wsa5__EndpointReference;
#endif

/* wsa5.h:214 */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (26)
typedef struct wsa5__ReferenceParametersType _wsa5__ReferenceParameters;
#endif

/* wsa5.h:217 */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (27)
typedef struct wsa5__MetadataType _wsa5__Metadata;
#endif

/* wsa5.h:220 */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (28)
typedef char *_wsa5__MessageID;
#endif

/* wsa5.h:223 */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (29)
typedef struct wsa5__RelatesToType _wsa5__RelatesTo;
#endif

/* wsa5.h:226 */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (30)
typedef struct wsa5__EndpointReferenceType _wsa5__ReplyTo;
#endif

/* wsa5.h:229 */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (31)
typedef struct wsa5__EndpointReferenceType _wsa5__From;
#endif

/* wsa5.h:232 */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (32)
typedef struct wsa5__EndpointReferenceType _wsa5__FaultTo;
#endif

/* wsa5.h:235 */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (33)
typedef char *_wsa5__To;
#endif

/* wsa5.h:238 */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (34)
typedef char *_wsa5__Action;
#endif

/* wsa5.h:241 */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (36)
typedef ULONG64 _wsa5__RetryAfter;
#endif

/* wsa5.h:244 */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (37)
typedef _QName _wsa5__ProblemHeaderQName;
#endif

/* wsa5.h:247 */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (38)
typedef char *_wsa5__ProblemIRI;
#endif

/* wsa5.h:250 */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (39)
typedef struct wsa5__ProblemActionType _wsa5__ProblemAction;
#endif

/* onvif.h:232 */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (68)
typedef std::string xsd__NCName;
#endif

/* onvif.h:249 */
#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (71)
typedef std::string xsd__anySimpleType;
#endif

/* onvif.h:259 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (73)
typedef std::string xsd__anyURI;
#endif

/* onvif.h:297 */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (82)
typedef std::string xsd__duration;
#endif

/* onvif.h:328 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (88)
typedef std::string xsd__integer;
#endif

/* onvif.h:338 */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (90)
typedef std::string xsd__nonNegativeInteger;
#endif

/* onvif.h:355 */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (93)
typedef std::string xsd__token;
#endif

/* onvif.h:367 */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (95)
typedef std::string _xml__lang;
#endif

/* onvif.h:1849 */
#ifndef SOAP_TYPE_tt__IntList
#define SOAP_TYPE_tt__IntList (823)
typedef std::string tt__IntList;
#endif

/* onvif.h:1853 */
#ifndef SOAP_TYPE_tt__FloatList
#define SOAP_TYPE_tt__FloatList (824)
typedef std::string tt__FloatList;
#endif

/* onvif.h:1857 */
#ifndef SOAP_TYPE_tt__StringAttrList
#define SOAP_TYPE_tt__StringAttrList (825)
typedef std::string tt__StringAttrList;
#endif

/* onvif.h:1861 */
#ifndef SOAP_TYPE_tt__StringList
#define SOAP_TYPE_tt__StringList (826)
typedef std::string tt__StringList;
#endif

/* onvif.h:1865 */
#ifndef SOAP_TYPE_tt__ReferenceTokenList
#define SOAP_TYPE_tt__ReferenceTokenList (827)
typedef std::string tt__ReferenceTokenList;
#endif

/* onvif.h:1876 */
#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (828)
typedef std::string wsnt__AbsoluteOrRelativeTimeType;
#endif

/* onvif.h:1974 */
#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (833)
typedef std::string tt__Name;
#endif

/* onvif.h:2351 */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority (867)
typedef xsd__integer tt__NetworkInterfaceConfigPriority;
#endif

/* onvif.h:2384 */
#ifndef SOAP_TYPE_tt__IANA_IfTypes
#define SOAP_TYPE_tt__IANA_IfTypes (871)
typedef int tt__IANA_IfTypes;
#endif

/* onvif.h:2451 */
#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (879)
typedef xsd__token tt__IPv4Address;
#endif

/* onvif.h:2463 */
#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (881)
typedef xsd__token tt__IPv6Address;
#endif

/* onvif.h:2475 */
#ifndef SOAP_TYPE_tt__HwAddress
#define SOAP_TYPE_tt__HwAddress (883)
typedef xsd__token tt__HwAddress;
#endif

/* onvif.h:2504 */
#ifndef SOAP_TYPE_tt__DNSName
#define SOAP_TYPE_tt__DNSName (887)
typedef xsd__token tt__DNSName;
#endif

/* onvif.h:2516 */
#ifndef SOAP_TYPE_tt__Domain
#define SOAP_TYPE_tt__Domain (889)
typedef xsd__token tt__Domain;
#endif

/* onvif.h:2564 */
#ifndef SOAP_TYPE_tt__Dot11SSIDType
#define SOAP_TYPE_tt__Dot11SSIDType (895)
typedef xsd__hexBinary tt__Dot11SSIDType;
#endif

/* onvif.h:2634 */
#ifndef SOAP_TYPE_tt__Dot11PSK
#define SOAP_TYPE_tt__Dot11PSK (903)
typedef xsd__hexBinary tt__Dot11PSK;
#endif

/* onvif.h:2647 */
#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase
#define SOAP_TYPE_tt__Dot11PSKPassphrase (905)
typedef std::string tt__Dot11PSKPassphrase;
#endif

/* onvif.h:2930 */
#ifndef SOAP_TYPE_tt__AuxiliaryData
#define SOAP_TYPE_tt__AuxiliaryData (933)
typedef std::string tt__AuxiliaryData;
#endif

/* onvif.h:3392 */
#ifndef SOAP_TYPE_tt__Description
#define SOAP_TYPE_tt__Description (979)
typedef std::string tt__Description;
#endif

/* onvif.h:3404 */
#ifndef SOAP_TYPE_tt__XPathExpression
#define SOAP_TYPE_tt__XPathExpression (981)
typedef std::string tt__XPathExpression;
#endif

/* onvif.h:3499 */
#ifndef SOAP_TYPE_tt__RecordingJobMode
#define SOAP_TYPE_tt__RecordingJobMode (989)
typedef std::string tt__RecordingJobMode;
#endif

/* onvif.h:3511 */
#ifndef SOAP_TYPE_tt__RecordingJobState
#define SOAP_TYPE_tt__RecordingJobState (991)
typedef std::string tt__RecordingJobState;
#endif

/* onvif.h:3595 */
#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (999)
typedef std::string tt__ReferenceToken;
#endif

/* onvif.h:3672 */
#ifndef SOAP_TYPE_wstop__FullTopicExpression
#define SOAP_TYPE_wstop__FullTopicExpression (1005)
typedef std::string wstop__FullTopicExpression;
#endif

/* onvif.h:3690 */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (1007)
typedef std::string wstop__ConcreteTopicExpression;
#endif

/* onvif.h:3707 */
#ifndef SOAP_TYPE_wstop__SimpleTopicExpression
#define SOAP_TYPE_wstop__SimpleTopicExpression (1009)
typedef xsd__QName wstop__SimpleTopicExpression;
#endif

/* onvif.h:3719 */
#ifndef SOAP_TYPE_tt__ReceiverReference
#define SOAP_TYPE_tt__ReceiverReference (1011)
typedef tt__ReferenceToken tt__ReceiverReference;
#endif

/* onvif.h:3731 */
#ifndef SOAP_TYPE_tt__RecordingReference
#define SOAP_TYPE_tt__RecordingReference (1013)
typedef tt__ReferenceToken tt__RecordingReference;
#endif

/* onvif.h:3743 */
#ifndef SOAP_TYPE_tt__TrackReference
#define SOAP_TYPE_tt__TrackReference (1015)
typedef tt__ReferenceToken tt__TrackReference;
#endif

/* onvif.h:3755 */
#ifndef SOAP_TYPE_tt__JobToken
#define SOAP_TYPE_tt__JobToken (1017)
typedef tt__ReferenceToken tt__JobToken;
#endif

/* onvif.h:3767 */
#ifndef SOAP_TYPE_tt__RecordingJobReference
#define SOAP_TYPE_tt__RecordingJobReference (1019)
typedef tt__ReferenceToken tt__RecordingJobReference;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* tt__IANA_IfTypes has binding name 'tt__IANA_IfTypes' for type 'tt:IANA-IfTypes' */
#ifndef SOAP_TYPE_tt__IANA_IfTypes
#define SOAP_TYPE_tt__IANA_IfTypes (871)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* float has binding name 'float' for type 'xsd:float' */
#ifndef SOAP_TYPE_float
#define SOAP_TYPE_float (85)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (81)
#endif

/* unsigned char has binding name 'unsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_unsignedByte
#define SOAP_TYPE_unsignedByte (10)
#endif

/* unsigned int has binding name 'unsignedInt' for type 'xsd:unsignedInt' */
#ifndef SOAP_TYPE_unsignedInt
#define SOAP_TYPE_unsignedInt (9)
#endif

/* _wsa5__RetryAfter has binding name '_wsa5__RetryAfter' for type '' */
#ifndef SOAP_TYPE__wsa5__RetryAfter
#define SOAP_TYPE__wsa5__RetryAfter (36)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (35)
#endif

/* time_t has binding name 'dateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_dateTime
#define SOAP_TYPE_dateTime (79)
#endif

/* enum tt__Entity has binding name 'tt__Entity' for type 'tt:Entity' */
#ifndef SOAP_TYPE_tt__Entity
#define SOAP_TYPE_tt__Entity (1003)
#endif

/* enum tt__MoveStatus has binding name 'tt__MoveStatus' for type 'tt:MoveStatus' */
#ifndef SOAP_TYPE_tt__MoveStatus
#define SOAP_TYPE_tt__MoveStatus (1001)
#endif

/* enum tt__OSDType has binding name 'tt__OSDType' for type 'tt:OSDType' */
#ifndef SOAP_TYPE_tt__OSDType
#define SOAP_TYPE_tt__OSDType (997)
#endif

/* enum tt__AudioClassType has binding name 'tt__AudioClassType' for type 'tt:AudioClassType' */
#ifndef SOAP_TYPE_tt__AudioClassType
#define SOAP_TYPE_tt__AudioClassType (995)
#endif

/* enum tt__ModeOfOperation has binding name 'tt__ModeOfOperation' for type 'tt:ModeOfOperation' */
#ifndef SOAP_TYPE_tt__ModeOfOperation
#define SOAP_TYPE_tt__ModeOfOperation (993)
#endif

/* enum tt__TrackType has binding name 'tt__TrackType' for type 'tt:TrackType' */
#ifndef SOAP_TYPE_tt__TrackType
#define SOAP_TYPE_tt__TrackType (987)
#endif

/* enum tt__RecordingStatus has binding name 'tt__RecordingStatus' for type 'tt:RecordingStatus' */
#ifndef SOAP_TYPE_tt__RecordingStatus
#define SOAP_TYPE_tt__RecordingStatus (985)
#endif

/* enum tt__SearchState has binding name 'tt__SearchState' for type 'tt:SearchState' */
#ifndef SOAP_TYPE_tt__SearchState
#define SOAP_TYPE_tt__SearchState (983)
#endif

/* enum tt__ReceiverState has binding name 'tt__ReceiverState' for type 'tt:ReceiverState' */
#ifndef SOAP_TYPE_tt__ReceiverState
#define SOAP_TYPE_tt__ReceiverState (977)
#endif

/* enum tt__ReceiverMode has binding name 'tt__ReceiverMode' for type 'tt:ReceiverMode' */
#ifndef SOAP_TYPE_tt__ReceiverMode
#define SOAP_TYPE_tt__ReceiverMode (975)
#endif

/* enum tt__Direction has binding name 'tt__Direction' for type 'tt:Direction' */
#ifndef SOAP_TYPE_tt__Direction
#define SOAP_TYPE_tt__Direction (973)
#endif

/* enum tt__PropertyOperation has binding name 'tt__PropertyOperation' for type 'tt:PropertyOperation' */
#ifndef SOAP_TYPE_tt__PropertyOperation
#define SOAP_TYPE_tt__PropertyOperation (971)
#endif

/* enum tt__ImageSendingType has binding name 'tt__ImageSendingType' for type 'tt:ImageSendingType' */
#ifndef SOAP_TYPE_tt__ImageSendingType
#define SOAP_TYPE_tt__ImageSendingType (969)
#endif

/* enum tt__DefoggingMode has binding name 'tt__DefoggingMode' for type 'tt:DefoggingMode' */
#ifndef SOAP_TYPE_tt__DefoggingMode
#define SOAP_TYPE_tt__DefoggingMode (967)
#endif

/* enum tt__ToneCompensationMode has binding name 'tt__ToneCompensationMode' for type 'tt:ToneCompensationMode' */
#ifndef SOAP_TYPE_tt__ToneCompensationMode
#define SOAP_TYPE_tt__ToneCompensationMode (965)
#endif

/* enum tt__IrCutFilterAutoBoundaryType has binding name 'tt__IrCutFilterAutoBoundaryType' for type 'tt:IrCutFilterAutoBoundaryType' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoBoundaryType
#define SOAP_TYPE_tt__IrCutFilterAutoBoundaryType (963)
#endif

/* enum tt__ImageStabilizationMode has binding name 'tt__ImageStabilizationMode' for type 'tt:ImageStabilizationMode' */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode
#define SOAP_TYPE_tt__ImageStabilizationMode (961)
#endif

/* enum tt__IrCutFilterMode has binding name 'tt__IrCutFilterMode' for type 'tt:IrCutFilterMode' */
#ifndef SOAP_TYPE_tt__IrCutFilterMode
#define SOAP_TYPE_tt__IrCutFilterMode (959)
#endif

/* enum tt__WhiteBalanceMode has binding name 'tt__WhiteBalanceMode' for type 'tt:WhiteBalanceMode' */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode
#define SOAP_TYPE_tt__WhiteBalanceMode (957)
#endif

/* enum tt__Enabled has binding name 'tt__Enabled' for type 'tt:Enabled' */
#ifndef SOAP_TYPE_tt__Enabled
#define SOAP_TYPE_tt__Enabled (955)
#endif

/* enum tt__ExposureMode has binding name 'tt__ExposureMode' for type 'tt:ExposureMode' */
#ifndef SOAP_TYPE_tt__ExposureMode
#define SOAP_TYPE_tt__ExposureMode (953)
#endif

/* enum tt__ExposurePriority has binding name 'tt__ExposurePriority' for type 'tt:ExposurePriority' */
#ifndef SOAP_TYPE_tt__ExposurePriority
#define SOAP_TYPE_tt__ExposurePriority (951)
#endif

/* enum tt__BacklightCompensationMode has binding name 'tt__BacklightCompensationMode' for type 'tt:BacklightCompensationMode' */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode
#define SOAP_TYPE_tt__BacklightCompensationMode (949)
#endif

/* enum tt__WideDynamicMode has binding name 'tt__WideDynamicMode' for type 'tt:WideDynamicMode' */
#ifndef SOAP_TYPE_tt__WideDynamicMode
#define SOAP_TYPE_tt__WideDynamicMode (947)
#endif

/* enum tt__AFModes has binding name 'tt__AFModes' for type 'tt:AFModes' */
#ifndef SOAP_TYPE_tt__AFModes
#define SOAP_TYPE_tt__AFModes (945)
#endif

/* enum tt__AutoFocusMode has binding name 'tt__AutoFocusMode' for type 'tt:AutoFocusMode' */
#ifndef SOAP_TYPE_tt__AutoFocusMode
#define SOAP_TYPE_tt__AutoFocusMode (943)
#endif

/* enum tt__MoveAndTrackMethod has binding name 'tt__MoveAndTrackMethod' for type 'tt:MoveAndTrackMethod' */
#ifndef SOAP_TYPE_tt__MoveAndTrackMethod
#define SOAP_TYPE_tt__MoveAndTrackMethod (941)
#endif

/* enum tt__PTZPresetTourOperation has binding name 'tt__PTZPresetTourOperation' for type 'tt:PTZPresetTourOperation' */
#ifndef SOAP_TYPE_tt__PTZPresetTourOperation
#define SOAP_TYPE_tt__PTZPresetTourOperation (939)
#endif

/* enum tt__PTZPresetTourDirection has binding name 'tt__PTZPresetTourDirection' for type 'tt:PTZPresetTourDirection' */
#ifndef SOAP_TYPE_tt__PTZPresetTourDirection
#define SOAP_TYPE_tt__PTZPresetTourDirection (937)
#endif

/* enum tt__PTZPresetTourState has binding name 'tt__PTZPresetTourState' for type 'tt:PTZPresetTourState' */
#ifndef SOAP_TYPE_tt__PTZPresetTourState
#define SOAP_TYPE_tt__PTZPresetTourState (935)
#endif

/* enum tt__ReverseMode has binding name 'tt__ReverseMode' for type 'tt:ReverseMode' */
#ifndef SOAP_TYPE_tt__ReverseMode
#define SOAP_TYPE_tt__ReverseMode (931)
#endif

/* enum tt__EFlipMode has binding name 'tt__EFlipMode' for type 'tt:EFlipMode' */
#ifndef SOAP_TYPE_tt__EFlipMode
#define SOAP_TYPE_tt__EFlipMode (929)
#endif

/* enum tt__DigitalIdleState has binding name 'tt__DigitalIdleState' for type 'tt:DigitalIdleState' */
#ifndef SOAP_TYPE_tt__DigitalIdleState
#define SOAP_TYPE_tt__DigitalIdleState (927)
#endif

/* enum tt__RelayMode has binding name 'tt__RelayMode' for type 'tt:RelayMode' */
#ifndef SOAP_TYPE_tt__RelayMode
#define SOAP_TYPE_tt__RelayMode (925)
#endif

/* enum tt__RelayIdleState has binding name 'tt__RelayIdleState' for type 'tt:RelayIdleState' */
#ifndef SOAP_TYPE_tt__RelayIdleState
#define SOAP_TYPE_tt__RelayIdleState (923)
#endif

/* enum tt__RelayLogicalState has binding name 'tt__RelayLogicalState' for type 'tt:RelayLogicalState' */
#ifndef SOAP_TYPE_tt__RelayLogicalState
#define SOAP_TYPE_tt__RelayLogicalState (921)
#endif

/* enum tt__UserLevel has binding name 'tt__UserLevel' for type 'tt:UserLevel' */
#ifndef SOAP_TYPE_tt__UserLevel
#define SOAP_TYPE_tt__UserLevel (919)
#endif

/* enum tt__SetDateTimeType has binding name 'tt__SetDateTimeType' for type 'tt:SetDateTimeType' */
#ifndef SOAP_TYPE_tt__SetDateTimeType
#define SOAP_TYPE_tt__SetDateTimeType (917)
#endif

/* enum tt__FactoryDefaultType has binding name 'tt__FactoryDefaultType' for type 'tt:FactoryDefaultType' */
#ifndef SOAP_TYPE_tt__FactoryDefaultType
#define SOAP_TYPE_tt__FactoryDefaultType (915)
#endif

/* enum tt__SystemLogType has binding name 'tt__SystemLogType' for type 'tt:SystemLogType' */
#ifndef SOAP_TYPE_tt__SystemLogType
#define SOAP_TYPE_tt__SystemLogType (913)
#endif

/* enum tt__CapabilityCategory has binding name 'tt__CapabilityCategory' for type 'tt:CapabilityCategory' */
#ifndef SOAP_TYPE_tt__CapabilityCategory
#define SOAP_TYPE_tt__CapabilityCategory (911)
#endif

/* enum tt__Dot11AuthAndMangementSuite has binding name 'tt__Dot11AuthAndMangementSuite' for type 'tt:Dot11AuthAndMangementSuite' */
#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite (909)
#endif

/* enum tt__Dot11SignalStrength has binding name 'tt__Dot11SignalStrength' for type 'tt:Dot11SignalStrength' */
#ifndef SOAP_TYPE_tt__Dot11SignalStrength
#define SOAP_TYPE_tt__Dot11SignalStrength (907)
#endif

/* enum tt__Dot11Cipher has binding name 'tt__Dot11Cipher' for type 'tt:Dot11Cipher' */
#ifndef SOAP_TYPE_tt__Dot11Cipher
#define SOAP_TYPE_tt__Dot11Cipher (901)
#endif

/* enum tt__Dot11SecurityMode has binding name 'tt__Dot11SecurityMode' for type 'tt:Dot11SecurityMode' */
#ifndef SOAP_TYPE_tt__Dot11SecurityMode
#define SOAP_TYPE_tt__Dot11SecurityMode (899)
#endif

/* enum tt__Dot11StationMode has binding name 'tt__Dot11StationMode' for type 'tt:Dot11StationMode' */
#ifndef SOAP_TYPE_tt__Dot11StationMode
#define SOAP_TYPE_tt__Dot11StationMode (897)
#endif

/* enum tt__DynamicDNSType has binding name 'tt__DynamicDNSType' for type 'tt:DynamicDNSType' */
#ifndef SOAP_TYPE_tt__DynamicDNSType
#define SOAP_TYPE_tt__DynamicDNSType (893)
#endif

/* enum tt__IPAddressFilterType has binding name 'tt__IPAddressFilterType' for type 'tt:IPAddressFilterType' */
#ifndef SOAP_TYPE_tt__IPAddressFilterType
#define SOAP_TYPE_tt__IPAddressFilterType (891)
#endif

/* enum tt__IPType has binding name 'tt__IPType' for type 'tt:IPType' */
#ifndef SOAP_TYPE_tt__IPType
#define SOAP_TYPE_tt__IPType (885)
#endif

/* enum tt__NetworkHostType has binding name 'tt__NetworkHostType' for type 'tt:NetworkHostType' */
#ifndef SOAP_TYPE_tt__NetworkHostType
#define SOAP_TYPE_tt__NetworkHostType (877)
#endif

/* enum tt__NetworkProtocolType has binding name 'tt__NetworkProtocolType' for type 'tt:NetworkProtocolType' */
#ifndef SOAP_TYPE_tt__NetworkProtocolType
#define SOAP_TYPE_tt__NetworkProtocolType (875)
#endif

/* enum tt__IPv6DHCPConfiguration has binding name 'tt__IPv6DHCPConfiguration' for type 'tt:IPv6DHCPConfiguration' */
#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration
#define SOAP_TYPE_tt__IPv6DHCPConfiguration (873)
#endif

/* enum tt__Duplex has binding name 'tt__Duplex' for type 'tt:Duplex' */
#ifndef SOAP_TYPE_tt__Duplex
#define SOAP_TYPE_tt__Duplex (869)
#endif

/* enum tt__DiscoveryMode has binding name 'tt__DiscoveryMode' for type 'tt:DiscoveryMode' */
#ifndef SOAP_TYPE_tt__DiscoveryMode
#define SOAP_TYPE_tt__DiscoveryMode (865)
#endif

/* enum tt__ScopeDefinition has binding name 'tt__ScopeDefinition' for type 'tt:ScopeDefinition' */
#ifndef SOAP_TYPE_tt__ScopeDefinition
#define SOAP_TYPE_tt__ScopeDefinition (863)
#endif

/* enum tt__TransportProtocol has binding name 'tt__TransportProtocol' for type 'tt:TransportProtocol' */
#ifndef SOAP_TYPE_tt__TransportProtocol
#define SOAP_TYPE_tt__TransportProtocol (861)
#endif

/* enum tt__StreamType has binding name 'tt__StreamType' for type 'tt:StreamType' */
#ifndef SOAP_TYPE_tt__StreamType
#define SOAP_TYPE_tt__StreamType (859)
#endif

/* enum tt__MetadataCompressionType has binding name 'tt__MetadataCompressionType' for type 'tt:MetadataCompressionType' */
#ifndef SOAP_TYPE_tt__MetadataCompressionType
#define SOAP_TYPE_tt__MetadataCompressionType (857)
#endif

/* enum tt__AudioEncodingMimeNames has binding name 'tt__AudioEncodingMimeNames' for type 'tt:AudioEncodingMimeNames' */
#ifndef SOAP_TYPE_tt__AudioEncodingMimeNames
#define SOAP_TYPE_tt__AudioEncodingMimeNames (855)
#endif

/* enum tt__AudioEncoding has binding name 'tt__AudioEncoding' for type 'tt:AudioEncoding' */
#ifndef SOAP_TYPE_tt__AudioEncoding
#define SOAP_TYPE_tt__AudioEncoding (853)
#endif

/* enum tt__VideoEncodingProfiles has binding name 'tt__VideoEncodingProfiles' for type 'tt:VideoEncodingProfiles' */
#ifndef SOAP_TYPE_tt__VideoEncodingProfiles
#define SOAP_TYPE_tt__VideoEncodingProfiles (851)
#endif

/* enum tt__VideoEncodingMimeNames has binding name 'tt__VideoEncodingMimeNames' for type 'tt:VideoEncodingMimeNames' */
#ifndef SOAP_TYPE_tt__VideoEncodingMimeNames
#define SOAP_TYPE_tt__VideoEncodingMimeNames (849)
#endif

/* enum tt__H264Profile has binding name 'tt__H264Profile' for type 'tt:H264Profile' */
#ifndef SOAP_TYPE_tt__H264Profile
#define SOAP_TYPE_tt__H264Profile (847)
#endif

/* enum tt__Mpeg4Profile has binding name 'tt__Mpeg4Profile' for type 'tt:Mpeg4Profile' */
#ifndef SOAP_TYPE_tt__Mpeg4Profile
#define SOAP_TYPE_tt__Mpeg4Profile (845)
#endif

/* enum tt__VideoEncoding has binding name 'tt__VideoEncoding' for type 'tt:VideoEncoding' */
#ifndef SOAP_TYPE_tt__VideoEncoding
#define SOAP_TYPE_tt__VideoEncoding (843)
#endif

/* enum tt__ViewModes has binding name 'tt__ViewModes' for type 'tt:ViewModes' */
#ifndef SOAP_TYPE_tt__ViewModes
#define SOAP_TYPE_tt__ViewModes (841)
#endif

/* enum tt__SceneOrientationOption has binding name 'tt__SceneOrientationOption' for type 'tt:SceneOrientationOption' */
#ifndef SOAP_TYPE_tt__SceneOrientationOption
#define SOAP_TYPE_tt__SceneOrientationOption (839)
#endif

/* enum tt__SceneOrientationMode has binding name 'tt__SceneOrientationMode' for type 'tt:SceneOrientationMode' */
#ifndef SOAP_TYPE_tt__SceneOrientationMode
#define SOAP_TYPE_tt__SceneOrientationMode (837)
#endif

/* enum tt__RotateMode has binding name 'tt__RotateMode' for type 'tt:RotateMode' */
#ifndef SOAP_TYPE_tt__RotateMode
#define SOAP_TYPE_tt__RotateMode (835)
#endif

/* enum tds__StorageType has binding name 'tds__StorageType' for type 'tds:StorageType' */
#ifndef SOAP_TYPE_tds__StorageType
#define SOAP_TYPE_tds__StorageType (831)
#endif

/* enum tds__AutoGeoModes has binding name 'tds__AutoGeoModes' for type 'tds:AutoGeoModes' */
#ifndef SOAP_TYPE_tds__AutoGeoModes
#define SOAP_TYPE_tds__AutoGeoModes (829)
#endif

/* bool has binding name 'bool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_bool
#define SOAP_TYPE_bool (77)
#endif

/* enum _wsa5__IsReferenceParameter has binding name '_wsa5__IsReferenceParameter' for type 'wsa5:IsReferenceParameter' */
#ifndef SOAP_TYPE__wsa5__IsReferenceParameter
#define SOAP_TYPE__wsa5__IsReferenceParameter (40)
#endif

/* enum wsa5__FaultCodesType has binding name 'wsa5__FaultCodesType' for type 'wsa5:FaultCodesType' */
#ifndef SOAP_TYPE_wsa5__FaultCodesType
#define SOAP_TYPE_wsa5__FaultCodesType (20)
#endif

/* enum wsa5__RelationshipType has binding name 'wsa5__RelationshipType' for type 'wsa5:RelationshipType' */
#ifndef SOAP_TYPE_wsa5__RelationshipType
#define SOAP_TYPE_wsa5__RelationshipType (19)
#endif

/* _wstop__TopicNamespaceType_Topic has binding name '_wstop__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE__wstop__TopicNamespaceType_Topic
#define SOAP_TYPE__wstop__TopicNamespaceType_Topic (1590)
#endif

/* _wsrfbf__BaseFaultType_FaultCause has binding name '_wsrfbf__BaseFaultType_FaultCause' for type '' */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause (1552)
#endif

/* _wsrfbf__BaseFaultType_Description has binding name '_wsrfbf__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_Description
#define SOAP_TYPE__wsrfbf__BaseFaultType_Description (1549)
#endif

/* _wsrfbf__BaseFaultType_ErrorCode has binding name '_wsrfbf__BaseFaultType_ErrorCode' for type '' */
#ifndef SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode (1547)
#endif

/* _wsnt__Subscribe_SubscriptionPolicy has binding name '_wsnt__Subscribe_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy (1544)
#endif

/* _wsnt__NotificationMessageHolderType_Message has binding name '_wsnt__NotificationMessageHolderType_Message' for type '' */
#ifndef SOAP_TYPE__wsnt__NotificationMessageHolderType_Message
#define SOAP_TYPE__wsnt__NotificationMessageHolderType_Message (1538)
#endif

/* _tt__ColorDescriptor_ColorCluster has binding name '_tt__ColorDescriptor_ColorCluster' for type '' */
#ifndef SOAP_TYPE__tt__ColorDescriptor_ColorCluster
#define SOAP_TYPE__tt__ColorDescriptor_ColorCluster (1524)
#endif

/* _tt__RecordingEventFilter_Filter has binding name '_tt__RecordingEventFilter_Filter' for type '' */
#ifndef SOAP_TYPE__tt__RecordingEventFilter_Filter
#define SOAP_TYPE__tt__RecordingEventFilter_Filter (1468)
#endif

/* _tt__ConfigDescription_Messages has binding name '_tt__ConfigDescription_Messages' for type '' */
#ifndef SOAP_TYPE__tt__ConfigDescription_Messages
#define SOAP_TYPE__tt__ConfigDescription_Messages (1409)
#endif

/* _tt__ItemListDescription_ElementItemDescription has binding name '_tt__ItemListDescription_ElementItemDescription' for type '' */
#ifndef SOAP_TYPE__tt__ItemListDescription_ElementItemDescription
#define SOAP_TYPE__tt__ItemListDescription_ElementItemDescription (1399)
#endif

/* _tt__ItemListDescription_SimpleItemDescription has binding name '_tt__ItemListDescription_SimpleItemDescription' for type '' */
#ifndef SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription (1397)
#endif

/* _tt__ItemList_ElementItem has binding name '_tt__ItemList_ElementItem' for type '' */
#ifndef SOAP_TYPE__tt__ItemList_ElementItem
#define SOAP_TYPE__tt__ItemList_ElementItem (1392)
#endif

/* _tt__ItemList_SimpleItem has binding name '_tt__ItemList_SimpleItem' for type '' */
#ifndef SOAP_TYPE__tt__ItemList_SimpleItem
#define SOAP_TYPE__tt__ItemList_SimpleItem (1390)
#endif

/* _tt__EventSubscription_SubscriptionPolicy has binding name '_tt__EventSubscription_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy (1164)
#endif

/* _tds__GetSystemUrisResponse_Extension has binding name '_tds__GetSystemUrisResponse_Extension' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse_Extension
#define SOAP_TYPE__tds__GetSystemUrisResponse_Extension (1104)
#endif

/* _tds__StorageConfigurationData_Extension has binding name '_tds__StorageConfigurationData_Extension' for type '' */
#ifndef SOAP_TYPE__tds__StorageConfigurationData_Extension
#define SOAP_TYPE__tds__StorageConfigurationData_Extension (1038)
#endif

/* _tds__UserCredential_Extension has binding name '_tds__UserCredential_Extension' for type '' */
#ifndef SOAP_TYPE__tds__UserCredential_Extension
#define SOAP_TYPE__tds__UserCredential_Extension (1034)
#endif

/* _tds__Service_Capabilities has binding name '_tds__Service_Capabilities' for type '' */
#ifndef SOAP_TYPE__tds__Service_Capabilities
#define SOAP_TYPE__tds__Service_Capabilities (1021)
#endif

/* tt__RecordingJobReference__ has binding name 'tt__RecordingJobReference__' for type 'tt:RecordingJobReference' */
#ifndef SOAP_TYPE_tt__RecordingJobReference__
#define SOAP_TYPE_tt__RecordingJobReference__ (1020)
#endif

/* tt__RecordingJobReference has binding name 'tt__RecordingJobReference' for type 'tt:RecordingJobReference' */
#ifndef SOAP_TYPE_tt__RecordingJobReference
#define SOAP_TYPE_tt__RecordingJobReference (1019)
#endif

/* tt__JobToken__ has binding name 'tt__JobToken__' for type 'tt:JobToken' */
#ifndef SOAP_TYPE_tt__JobToken__
#define SOAP_TYPE_tt__JobToken__ (1018)
#endif

/* tt__JobToken has binding name 'tt__JobToken' for type 'tt:JobToken' */
#ifndef SOAP_TYPE_tt__JobToken
#define SOAP_TYPE_tt__JobToken (1017)
#endif

/* tt__TrackReference__ has binding name 'tt__TrackReference__' for type 'tt:TrackReference' */
#ifndef SOAP_TYPE_tt__TrackReference__
#define SOAP_TYPE_tt__TrackReference__ (1016)
#endif

/* tt__TrackReference has binding name 'tt__TrackReference' for type 'tt:TrackReference' */
#ifndef SOAP_TYPE_tt__TrackReference
#define SOAP_TYPE_tt__TrackReference (1015)
#endif

/* tt__RecordingReference__ has binding name 'tt__RecordingReference__' for type 'tt:RecordingReference' */
#ifndef SOAP_TYPE_tt__RecordingReference__
#define SOAP_TYPE_tt__RecordingReference__ (1014)
#endif

/* tt__RecordingReference has binding name 'tt__RecordingReference' for type 'tt:RecordingReference' */
#ifndef SOAP_TYPE_tt__RecordingReference
#define SOAP_TYPE_tt__RecordingReference (1013)
#endif

/* tt__ReceiverReference__ has binding name 'tt__ReceiverReference__' for type 'tt:ReceiverReference' */
#ifndef SOAP_TYPE_tt__ReceiverReference__
#define SOAP_TYPE_tt__ReceiverReference__ (1012)
#endif

/* tt__ReceiverReference has binding name 'tt__ReceiverReference' for type 'tt:ReceiverReference' */
#ifndef SOAP_TYPE_tt__ReceiverReference
#define SOAP_TYPE_tt__ReceiverReference (1011)
#endif

/* wstop__SimpleTopicExpression__ has binding name 'wstop__SimpleTopicExpression__' for type 'wstop:SimpleTopicExpression' */
#ifndef SOAP_TYPE_wstop__SimpleTopicExpression__
#define SOAP_TYPE_wstop__SimpleTopicExpression__ (1010)
#endif

/* wstop__SimpleTopicExpression has binding name 'wstop__SimpleTopicExpression' for type 'xsd:QName' */
#ifndef SOAP_TYPE_wstop__SimpleTopicExpression
#define SOAP_TYPE_wstop__SimpleTopicExpression (1009)
#endif

/* wstop__ConcreteTopicExpression__ has binding name 'wstop__ConcreteTopicExpression__' for type 'wstop:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression__
#define SOAP_TYPE_wstop__ConcreteTopicExpression__ (1008)
#endif

/* wstop__ConcreteTopicExpression has binding name 'wstop__ConcreteTopicExpression' for type 'wstop:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_wstop__ConcreteTopicExpression
#define SOAP_TYPE_wstop__ConcreteTopicExpression (1007)
#endif

/* wstop__FullTopicExpression__ has binding name 'wstop__FullTopicExpression__' for type 'wstop:FullTopicExpression' */
#ifndef SOAP_TYPE_wstop__FullTopicExpression__
#define SOAP_TYPE_wstop__FullTopicExpression__ (1006)
#endif

/* wstop__FullTopicExpression has binding name 'wstop__FullTopicExpression' for type 'wstop:FullTopicExpression' */
#ifndef SOAP_TYPE_wstop__FullTopicExpression
#define SOAP_TYPE_wstop__FullTopicExpression (1005)
#endif

/* tt__Entity_ has binding name 'tt__Entity_' for type 'tt:Entity' */
#ifndef SOAP_TYPE_tt__Entity_
#define SOAP_TYPE_tt__Entity_ (1004)
#endif

/* tt__MoveStatus_ has binding name 'tt__MoveStatus_' for type 'tt:MoveStatus' */
#ifndef SOAP_TYPE_tt__MoveStatus_
#define SOAP_TYPE_tt__MoveStatus_ (1002)
#endif

/* tt__ReferenceToken__ has binding name 'tt__ReferenceToken__' for type 'tt:ReferenceToken' */
#ifndef SOAP_TYPE_tt__ReferenceToken__
#define SOAP_TYPE_tt__ReferenceToken__ (1000)
#endif

/* tt__ReferenceToken has binding name 'tt__ReferenceToken' for type 'tt:ReferenceToken' */
#ifndef SOAP_TYPE_tt__ReferenceToken
#define SOAP_TYPE_tt__ReferenceToken (999)
#endif

/* tt__OSDType_ has binding name 'tt__OSDType_' for type 'tt:OSDType' */
#ifndef SOAP_TYPE_tt__OSDType_
#define SOAP_TYPE_tt__OSDType_ (998)
#endif

/* tt__AudioClassType_ has binding name 'tt__AudioClassType_' for type 'tt:AudioClassType' */
#ifndef SOAP_TYPE_tt__AudioClassType_
#define SOAP_TYPE_tt__AudioClassType_ (996)
#endif

/* tt__ModeOfOperation_ has binding name 'tt__ModeOfOperation_' for type 'tt:ModeOfOperation' */
#ifndef SOAP_TYPE_tt__ModeOfOperation_
#define SOAP_TYPE_tt__ModeOfOperation_ (994)
#endif

/* tt__RecordingJobState__ has binding name 'tt__RecordingJobState__' for type 'tt:RecordingJobState' */
#ifndef SOAP_TYPE_tt__RecordingJobState__
#define SOAP_TYPE_tt__RecordingJobState__ (992)
#endif

/* tt__RecordingJobState has binding name 'tt__RecordingJobState' for type 'tt:RecordingJobState' */
#ifndef SOAP_TYPE_tt__RecordingJobState
#define SOAP_TYPE_tt__RecordingJobState (991)
#endif

/* tt__RecordingJobMode__ has binding name 'tt__RecordingJobMode__' for type 'tt:RecordingJobMode' */
#ifndef SOAP_TYPE_tt__RecordingJobMode__
#define SOAP_TYPE_tt__RecordingJobMode__ (990)
#endif

/* tt__RecordingJobMode has binding name 'tt__RecordingJobMode' for type 'tt:RecordingJobMode' */
#ifndef SOAP_TYPE_tt__RecordingJobMode
#define SOAP_TYPE_tt__RecordingJobMode (989)
#endif

/* tt__TrackType_ has binding name 'tt__TrackType_' for type 'tt:TrackType' */
#ifndef SOAP_TYPE_tt__TrackType_
#define SOAP_TYPE_tt__TrackType_ (988)
#endif

/* tt__RecordingStatus_ has binding name 'tt__RecordingStatus_' for type 'tt:RecordingStatus' */
#ifndef SOAP_TYPE_tt__RecordingStatus_
#define SOAP_TYPE_tt__RecordingStatus_ (986)
#endif

/* tt__SearchState_ has binding name 'tt__SearchState_' for type 'tt:SearchState' */
#ifndef SOAP_TYPE_tt__SearchState_
#define SOAP_TYPE_tt__SearchState_ (984)
#endif

/* tt__XPathExpression__ has binding name 'tt__XPathExpression__' for type 'tt:XPathExpression' */
#ifndef SOAP_TYPE_tt__XPathExpression__
#define SOAP_TYPE_tt__XPathExpression__ (982)
#endif

/* tt__XPathExpression has binding name 'tt__XPathExpression' for type 'tt:XPathExpression' */
#ifndef SOAP_TYPE_tt__XPathExpression
#define SOAP_TYPE_tt__XPathExpression (981)
#endif

/* tt__Description__ has binding name 'tt__Description__' for type 'tt:Description' */
#ifndef SOAP_TYPE_tt__Description__
#define SOAP_TYPE_tt__Description__ (980)
#endif

/* tt__Description has binding name 'tt__Description' for type 'tt:Description' */
#ifndef SOAP_TYPE_tt__Description
#define SOAP_TYPE_tt__Description (979)
#endif

/* tt__ReceiverState_ has binding name 'tt__ReceiverState_' for type 'tt:ReceiverState' */
#ifndef SOAP_TYPE_tt__ReceiverState_
#define SOAP_TYPE_tt__ReceiverState_ (978)
#endif

/* tt__ReceiverMode_ has binding name 'tt__ReceiverMode_' for type 'tt:ReceiverMode' */
#ifndef SOAP_TYPE_tt__ReceiverMode_
#define SOAP_TYPE_tt__ReceiverMode_ (976)
#endif

/* tt__Direction_ has binding name 'tt__Direction_' for type 'tt:Direction' */
#ifndef SOAP_TYPE_tt__Direction_
#define SOAP_TYPE_tt__Direction_ (974)
#endif

/* tt__PropertyOperation_ has binding name 'tt__PropertyOperation_' for type 'tt:PropertyOperation' */
#ifndef SOAP_TYPE_tt__PropertyOperation_
#define SOAP_TYPE_tt__PropertyOperation_ (972)
#endif

/* tt__ImageSendingType_ has binding name 'tt__ImageSendingType_' for type 'tt:ImageSendingType' */
#ifndef SOAP_TYPE_tt__ImageSendingType_
#define SOAP_TYPE_tt__ImageSendingType_ (970)
#endif

/* tt__DefoggingMode_ has binding name 'tt__DefoggingMode_' for type 'tt:DefoggingMode' */
#ifndef SOAP_TYPE_tt__DefoggingMode_
#define SOAP_TYPE_tt__DefoggingMode_ (968)
#endif

/* tt__ToneCompensationMode_ has binding name 'tt__ToneCompensationMode_' for type 'tt:ToneCompensationMode' */
#ifndef SOAP_TYPE_tt__ToneCompensationMode_
#define SOAP_TYPE_tt__ToneCompensationMode_ (966)
#endif

/* tt__IrCutFilterAutoBoundaryType_ has binding name 'tt__IrCutFilterAutoBoundaryType_' for type 'tt:IrCutFilterAutoBoundaryType' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoBoundaryType_
#define SOAP_TYPE_tt__IrCutFilterAutoBoundaryType_ (964)
#endif

/* tt__ImageStabilizationMode_ has binding name 'tt__ImageStabilizationMode_' for type 'tt:ImageStabilizationMode' */
#ifndef SOAP_TYPE_tt__ImageStabilizationMode_
#define SOAP_TYPE_tt__ImageStabilizationMode_ (962)
#endif

/* tt__IrCutFilterMode_ has binding name 'tt__IrCutFilterMode_' for type 'tt:IrCutFilterMode' */
#ifndef SOAP_TYPE_tt__IrCutFilterMode_
#define SOAP_TYPE_tt__IrCutFilterMode_ (960)
#endif

/* tt__WhiteBalanceMode_ has binding name 'tt__WhiteBalanceMode_' for type 'tt:WhiteBalanceMode' */
#ifndef SOAP_TYPE_tt__WhiteBalanceMode_
#define SOAP_TYPE_tt__WhiteBalanceMode_ (958)
#endif

/* tt__Enabled_ has binding name 'tt__Enabled_' for type 'tt:Enabled' */
#ifndef SOAP_TYPE_tt__Enabled_
#define SOAP_TYPE_tt__Enabled_ (956)
#endif

/* tt__ExposureMode_ has binding name 'tt__ExposureMode_' for type 'tt:ExposureMode' */
#ifndef SOAP_TYPE_tt__ExposureMode_
#define SOAP_TYPE_tt__ExposureMode_ (954)
#endif

/* tt__ExposurePriority_ has binding name 'tt__ExposurePriority_' for type 'tt:ExposurePriority' */
#ifndef SOAP_TYPE_tt__ExposurePriority_
#define SOAP_TYPE_tt__ExposurePriority_ (952)
#endif

/* tt__BacklightCompensationMode_ has binding name 'tt__BacklightCompensationMode_' for type 'tt:BacklightCompensationMode' */
#ifndef SOAP_TYPE_tt__BacklightCompensationMode_
#define SOAP_TYPE_tt__BacklightCompensationMode_ (950)
#endif

/* tt__WideDynamicMode_ has binding name 'tt__WideDynamicMode_' for type 'tt:WideDynamicMode' */
#ifndef SOAP_TYPE_tt__WideDynamicMode_
#define SOAP_TYPE_tt__WideDynamicMode_ (948)
#endif

/* tt__AFModes_ has binding name 'tt__AFModes_' for type 'tt:AFModes' */
#ifndef SOAP_TYPE_tt__AFModes_
#define SOAP_TYPE_tt__AFModes_ (946)
#endif

/* tt__AutoFocusMode_ has binding name 'tt__AutoFocusMode_' for type 'tt:AutoFocusMode' */
#ifndef SOAP_TYPE_tt__AutoFocusMode_
#define SOAP_TYPE_tt__AutoFocusMode_ (944)
#endif

/* tt__MoveAndTrackMethod_ has binding name 'tt__MoveAndTrackMethod_' for type 'tt:MoveAndTrackMethod' */
#ifndef SOAP_TYPE_tt__MoveAndTrackMethod_
#define SOAP_TYPE_tt__MoveAndTrackMethod_ (942)
#endif

/* tt__PTZPresetTourOperation_ has binding name 'tt__PTZPresetTourOperation_' for type 'tt:PTZPresetTourOperation' */
#ifndef SOAP_TYPE_tt__PTZPresetTourOperation_
#define SOAP_TYPE_tt__PTZPresetTourOperation_ (940)
#endif

/* tt__PTZPresetTourDirection_ has binding name 'tt__PTZPresetTourDirection_' for type 'tt:PTZPresetTourDirection' */
#ifndef SOAP_TYPE_tt__PTZPresetTourDirection_
#define SOAP_TYPE_tt__PTZPresetTourDirection_ (938)
#endif

/* tt__PTZPresetTourState_ has binding name 'tt__PTZPresetTourState_' for type 'tt:PTZPresetTourState' */
#ifndef SOAP_TYPE_tt__PTZPresetTourState_
#define SOAP_TYPE_tt__PTZPresetTourState_ (936)
#endif

/* tt__AuxiliaryData__ has binding name 'tt__AuxiliaryData__' for type 'tt:AuxiliaryData' */
#ifndef SOAP_TYPE_tt__AuxiliaryData__
#define SOAP_TYPE_tt__AuxiliaryData__ (934)
#endif

/* tt__AuxiliaryData has binding name 'tt__AuxiliaryData' for type 'tt:AuxiliaryData' */
#ifndef SOAP_TYPE_tt__AuxiliaryData
#define SOAP_TYPE_tt__AuxiliaryData (933)
#endif

/* tt__ReverseMode_ has binding name 'tt__ReverseMode_' for type 'tt:ReverseMode' */
#ifndef SOAP_TYPE_tt__ReverseMode_
#define SOAP_TYPE_tt__ReverseMode_ (932)
#endif

/* tt__EFlipMode_ has binding name 'tt__EFlipMode_' for type 'tt:EFlipMode' */
#ifndef SOAP_TYPE_tt__EFlipMode_
#define SOAP_TYPE_tt__EFlipMode_ (930)
#endif

/* tt__DigitalIdleState_ has binding name 'tt__DigitalIdleState_' for type 'tt:DigitalIdleState' */
#ifndef SOAP_TYPE_tt__DigitalIdleState_
#define SOAP_TYPE_tt__DigitalIdleState_ (928)
#endif

/* tt__RelayMode_ has binding name 'tt__RelayMode_' for type 'tt:RelayMode' */
#ifndef SOAP_TYPE_tt__RelayMode_
#define SOAP_TYPE_tt__RelayMode_ (926)
#endif

/* tt__RelayIdleState_ has binding name 'tt__RelayIdleState_' for type 'tt:RelayIdleState' */
#ifndef SOAP_TYPE_tt__RelayIdleState_
#define SOAP_TYPE_tt__RelayIdleState_ (924)
#endif

/* tt__RelayLogicalState_ has binding name 'tt__RelayLogicalState_' for type 'tt:RelayLogicalState' */
#ifndef SOAP_TYPE_tt__RelayLogicalState_
#define SOAP_TYPE_tt__RelayLogicalState_ (922)
#endif

/* tt__UserLevel_ has binding name 'tt__UserLevel_' for type 'tt:UserLevel' */
#ifndef SOAP_TYPE_tt__UserLevel_
#define SOAP_TYPE_tt__UserLevel_ (920)
#endif

/* tt__SetDateTimeType_ has binding name 'tt__SetDateTimeType_' for type 'tt:SetDateTimeType' */
#ifndef SOAP_TYPE_tt__SetDateTimeType_
#define SOAP_TYPE_tt__SetDateTimeType_ (918)
#endif

/* tt__FactoryDefaultType_ has binding name 'tt__FactoryDefaultType_' for type 'tt:FactoryDefaultType' */
#ifndef SOAP_TYPE_tt__FactoryDefaultType_
#define SOAP_TYPE_tt__FactoryDefaultType_ (916)
#endif

/* tt__SystemLogType_ has binding name 'tt__SystemLogType_' for type 'tt:SystemLogType' */
#ifndef SOAP_TYPE_tt__SystemLogType_
#define SOAP_TYPE_tt__SystemLogType_ (914)
#endif

/* tt__CapabilityCategory_ has binding name 'tt__CapabilityCategory_' for type 'tt:CapabilityCategory' */
#ifndef SOAP_TYPE_tt__CapabilityCategory_
#define SOAP_TYPE_tt__CapabilityCategory_ (912)
#endif

/* tt__Dot11AuthAndMangementSuite_ has binding name 'tt__Dot11AuthAndMangementSuite_' for type 'tt:Dot11AuthAndMangementSuite' */
#ifndef SOAP_TYPE_tt__Dot11AuthAndMangementSuite_
#define SOAP_TYPE_tt__Dot11AuthAndMangementSuite_ (910)
#endif

/* tt__Dot11SignalStrength_ has binding name 'tt__Dot11SignalStrength_' for type 'tt:Dot11SignalStrength' */
#ifndef SOAP_TYPE_tt__Dot11SignalStrength_
#define SOAP_TYPE_tt__Dot11SignalStrength_ (908)
#endif

/* tt__Dot11PSKPassphrase__ has binding name 'tt__Dot11PSKPassphrase__' for type 'tt:Dot11PSKPassphrase' */
#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase__
#define SOAP_TYPE_tt__Dot11PSKPassphrase__ (906)
#endif

/* tt__Dot11PSKPassphrase has binding name 'tt__Dot11PSKPassphrase' for type 'tt:Dot11PSKPassphrase' */
#ifndef SOAP_TYPE_tt__Dot11PSKPassphrase
#define SOAP_TYPE_tt__Dot11PSKPassphrase (905)
#endif

/* tt__Dot11PSK__ has binding name 'tt__Dot11PSK__' for type 'tt:Dot11PSK' */
#ifndef SOAP_TYPE_tt__Dot11PSK__
#define SOAP_TYPE_tt__Dot11PSK__ (904)
#endif

/* tt__Dot11PSK has binding name 'tt__Dot11PSK' for type 'tt:Dot11PSK' */
#ifndef SOAP_TYPE_tt__Dot11PSK
#define SOAP_TYPE_tt__Dot11PSK (903)
#endif

/* tt__Dot11Cipher_ has binding name 'tt__Dot11Cipher_' for type 'tt:Dot11Cipher' */
#ifndef SOAP_TYPE_tt__Dot11Cipher_
#define SOAP_TYPE_tt__Dot11Cipher_ (902)
#endif

/* tt__Dot11SecurityMode_ has binding name 'tt__Dot11SecurityMode_' for type 'tt:Dot11SecurityMode' */
#ifndef SOAP_TYPE_tt__Dot11SecurityMode_
#define SOAP_TYPE_tt__Dot11SecurityMode_ (900)
#endif

/* tt__Dot11StationMode_ has binding name 'tt__Dot11StationMode_' for type 'tt:Dot11StationMode' */
#ifndef SOAP_TYPE_tt__Dot11StationMode_
#define SOAP_TYPE_tt__Dot11StationMode_ (898)
#endif

/* tt__Dot11SSIDType__ has binding name 'tt__Dot11SSIDType__' for type 'tt:Dot11SSIDType' */
#ifndef SOAP_TYPE_tt__Dot11SSIDType__
#define SOAP_TYPE_tt__Dot11SSIDType__ (896)
#endif

/* tt__Dot11SSIDType has binding name 'tt__Dot11SSIDType' for type 'tt:Dot11SSIDType' */
#ifndef SOAP_TYPE_tt__Dot11SSIDType
#define SOAP_TYPE_tt__Dot11SSIDType (895)
#endif

/* tt__DynamicDNSType_ has binding name 'tt__DynamicDNSType_' for type 'tt:DynamicDNSType' */
#ifndef SOAP_TYPE_tt__DynamicDNSType_
#define SOAP_TYPE_tt__DynamicDNSType_ (894)
#endif

/* tt__IPAddressFilterType_ has binding name 'tt__IPAddressFilterType_' for type 'tt:IPAddressFilterType' */
#ifndef SOAP_TYPE_tt__IPAddressFilterType_
#define SOAP_TYPE_tt__IPAddressFilterType_ (892)
#endif

/* tt__Domain__ has binding name 'tt__Domain__' for type 'tt:Domain' */
#ifndef SOAP_TYPE_tt__Domain__
#define SOAP_TYPE_tt__Domain__ (890)
#endif

/* tt__Domain has binding name 'tt__Domain' for type 'tt:Domain' */
#ifndef SOAP_TYPE_tt__Domain
#define SOAP_TYPE_tt__Domain (889)
#endif

/* tt__DNSName__ has binding name 'tt__DNSName__' for type 'tt:DNSName' */
#ifndef SOAP_TYPE_tt__DNSName__
#define SOAP_TYPE_tt__DNSName__ (888)
#endif

/* tt__DNSName has binding name 'tt__DNSName' for type 'tt:DNSName' */
#ifndef SOAP_TYPE_tt__DNSName
#define SOAP_TYPE_tt__DNSName (887)
#endif

/* tt__IPType_ has binding name 'tt__IPType_' for type 'tt:IPType' */
#ifndef SOAP_TYPE_tt__IPType_
#define SOAP_TYPE_tt__IPType_ (886)
#endif

/* tt__HwAddress__ has binding name 'tt__HwAddress__' for type 'tt:HwAddress' */
#ifndef SOAP_TYPE_tt__HwAddress__
#define SOAP_TYPE_tt__HwAddress__ (884)
#endif

/* tt__HwAddress has binding name 'tt__HwAddress' for type 'tt:HwAddress' */
#ifndef SOAP_TYPE_tt__HwAddress
#define SOAP_TYPE_tt__HwAddress (883)
#endif

/* tt__IPv6Address__ has binding name 'tt__IPv6Address__' for type 'tt:IPv6Address' */
#ifndef SOAP_TYPE_tt__IPv6Address__
#define SOAP_TYPE_tt__IPv6Address__ (882)
#endif

/* tt__IPv6Address has binding name 'tt__IPv6Address' for type 'tt:IPv6Address' */
#ifndef SOAP_TYPE_tt__IPv6Address
#define SOAP_TYPE_tt__IPv6Address (881)
#endif

/* tt__IPv4Address__ has binding name 'tt__IPv4Address__' for type 'tt:IPv4Address' */
#ifndef SOAP_TYPE_tt__IPv4Address__
#define SOAP_TYPE_tt__IPv4Address__ (880)
#endif

/* tt__IPv4Address has binding name 'tt__IPv4Address' for type 'tt:IPv4Address' */
#ifndef SOAP_TYPE_tt__IPv4Address
#define SOAP_TYPE_tt__IPv4Address (879)
#endif

/* tt__NetworkHostType_ has binding name 'tt__NetworkHostType_' for type 'tt:NetworkHostType' */
#ifndef SOAP_TYPE_tt__NetworkHostType_
#define SOAP_TYPE_tt__NetworkHostType_ (878)
#endif

/* tt__NetworkProtocolType_ has binding name 'tt__NetworkProtocolType_' for type 'tt:NetworkProtocolType' */
#ifndef SOAP_TYPE_tt__NetworkProtocolType_
#define SOAP_TYPE_tt__NetworkProtocolType_ (876)
#endif

/* tt__IPv6DHCPConfiguration_ has binding name 'tt__IPv6DHCPConfiguration_' for type 'tt:IPv6DHCPConfiguration' */
#ifndef SOAP_TYPE_tt__IPv6DHCPConfiguration_
#define SOAP_TYPE_tt__IPv6DHCPConfiguration_ (874)
#endif

/* tt__IANA_IfTypes__ has binding name 'tt__IANA_IfTypes__' for type 'tt:IANA-IfTypes' */
#ifndef SOAP_TYPE_tt__IANA_IfTypes__
#define SOAP_TYPE_tt__IANA_IfTypes__ (872)
#endif

/* tt__Duplex_ has binding name 'tt__Duplex_' for type 'tt:Duplex' */
#ifndef SOAP_TYPE_tt__Duplex_
#define SOAP_TYPE_tt__Duplex_ (870)
#endif

/* tt__NetworkInterfaceConfigPriority__ has binding name 'tt__NetworkInterfaceConfigPriority__' for type 'tt:NetworkInterfaceConfigPriority' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority__
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority__ (868)
#endif

/* tt__NetworkInterfaceConfigPriority has binding name 'tt__NetworkInterfaceConfigPriority' for type 'tt:NetworkInterfaceConfigPriority' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConfigPriority
#define SOAP_TYPE_tt__NetworkInterfaceConfigPriority (867)
#endif

/* tt__DiscoveryMode_ has binding name 'tt__DiscoveryMode_' for type 'tt:DiscoveryMode' */
#ifndef SOAP_TYPE_tt__DiscoveryMode_
#define SOAP_TYPE_tt__DiscoveryMode_ (866)
#endif

/* tt__ScopeDefinition_ has binding name 'tt__ScopeDefinition_' for type 'tt:ScopeDefinition' */
#ifndef SOAP_TYPE_tt__ScopeDefinition_
#define SOAP_TYPE_tt__ScopeDefinition_ (864)
#endif

/* tt__TransportProtocol_ has binding name 'tt__TransportProtocol_' for type 'tt:TransportProtocol' */
#ifndef SOAP_TYPE_tt__TransportProtocol_
#define SOAP_TYPE_tt__TransportProtocol_ (862)
#endif

/* tt__StreamType_ has binding name 'tt__StreamType_' for type 'tt:StreamType' */
#ifndef SOAP_TYPE_tt__StreamType_
#define SOAP_TYPE_tt__StreamType_ (860)
#endif

/* tt__MetadataCompressionType_ has binding name 'tt__MetadataCompressionType_' for type 'tt:MetadataCompressionType' */
#ifndef SOAP_TYPE_tt__MetadataCompressionType_
#define SOAP_TYPE_tt__MetadataCompressionType_ (858)
#endif

/* tt__AudioEncodingMimeNames_ has binding name 'tt__AudioEncodingMimeNames_' for type 'tt:AudioEncodingMimeNames' */
#ifndef SOAP_TYPE_tt__AudioEncodingMimeNames_
#define SOAP_TYPE_tt__AudioEncodingMimeNames_ (856)
#endif

/* tt__AudioEncoding_ has binding name 'tt__AudioEncoding_' for type 'tt:AudioEncoding' */
#ifndef SOAP_TYPE_tt__AudioEncoding_
#define SOAP_TYPE_tt__AudioEncoding_ (854)
#endif

/* tt__VideoEncodingProfiles_ has binding name 'tt__VideoEncodingProfiles_' for type 'tt:VideoEncodingProfiles' */
#ifndef SOAP_TYPE_tt__VideoEncodingProfiles_
#define SOAP_TYPE_tt__VideoEncodingProfiles_ (852)
#endif

/* tt__VideoEncodingMimeNames_ has binding name 'tt__VideoEncodingMimeNames_' for type 'tt:VideoEncodingMimeNames' */
#ifndef SOAP_TYPE_tt__VideoEncodingMimeNames_
#define SOAP_TYPE_tt__VideoEncodingMimeNames_ (850)
#endif

/* tt__H264Profile_ has binding name 'tt__H264Profile_' for type 'tt:H264Profile' */
#ifndef SOAP_TYPE_tt__H264Profile_
#define SOAP_TYPE_tt__H264Profile_ (848)
#endif

/* tt__Mpeg4Profile_ has binding name 'tt__Mpeg4Profile_' for type 'tt:Mpeg4Profile' */
#ifndef SOAP_TYPE_tt__Mpeg4Profile_
#define SOAP_TYPE_tt__Mpeg4Profile_ (846)
#endif

/* tt__VideoEncoding_ has binding name 'tt__VideoEncoding_' for type 'tt:VideoEncoding' */
#ifndef SOAP_TYPE_tt__VideoEncoding_
#define SOAP_TYPE_tt__VideoEncoding_ (844)
#endif

/* tt__ViewModes_ has binding name 'tt__ViewModes_' for type 'tt:ViewModes' */
#ifndef SOAP_TYPE_tt__ViewModes_
#define SOAP_TYPE_tt__ViewModes_ (842)
#endif

/* tt__SceneOrientationOption_ has binding name 'tt__SceneOrientationOption_' for type 'tt:SceneOrientationOption' */
#ifndef SOAP_TYPE_tt__SceneOrientationOption_
#define SOAP_TYPE_tt__SceneOrientationOption_ (840)
#endif

/* tt__SceneOrientationMode_ has binding name 'tt__SceneOrientationMode_' for type 'tt:SceneOrientationMode' */
#ifndef SOAP_TYPE_tt__SceneOrientationMode_
#define SOAP_TYPE_tt__SceneOrientationMode_ (838)
#endif

/* tt__RotateMode_ has binding name 'tt__RotateMode_' for type 'tt:RotateMode' */
#ifndef SOAP_TYPE_tt__RotateMode_
#define SOAP_TYPE_tt__RotateMode_ (836)
#endif

/* tt__Name__ has binding name 'tt__Name__' for type 'tt:Name' */
#ifndef SOAP_TYPE_tt__Name__
#define SOAP_TYPE_tt__Name__ (834)
#endif

/* tt__Name has binding name 'tt__Name' for type 'tt:Name' */
#ifndef SOAP_TYPE_tt__Name
#define SOAP_TYPE_tt__Name (833)
#endif

/* tds__StorageType_ has binding name 'tds__StorageType_' for type 'tds:StorageType' */
#ifndef SOAP_TYPE_tds__StorageType_
#define SOAP_TYPE_tds__StorageType_ (832)
#endif

/* tds__AutoGeoModes_ has binding name 'tds__AutoGeoModes_' for type 'tds:AutoGeoModes' */
#ifndef SOAP_TYPE_tds__AutoGeoModes_
#define SOAP_TYPE_tds__AutoGeoModes_ (830)
#endif

/* wsnt__AbsoluteOrRelativeTimeType has binding name 'wsnt__AbsoluteOrRelativeTimeType' for type 'wsnt:AbsoluteOrRelativeTimeType' */
#ifndef SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType (828)
#endif

/* tt__ReferenceTokenList has binding name 'tt__ReferenceTokenList' for type 'tt:ReferenceTokenList' */
#ifndef SOAP_TYPE_tt__ReferenceTokenList
#define SOAP_TYPE_tt__ReferenceTokenList (827)
#endif

/* tt__StringList has binding name 'tt__StringList' for type 'tt:StringList' */
#ifndef SOAP_TYPE_tt__StringList
#define SOAP_TYPE_tt__StringList (826)
#endif

/* tt__StringAttrList has binding name 'tt__StringAttrList' for type 'tt:StringAttrList' */
#ifndef SOAP_TYPE_tt__StringAttrList
#define SOAP_TYPE_tt__StringAttrList (825)
#endif

/* tt__FloatList has binding name 'tt__FloatList' for type 'tt:FloatList' */
#ifndef SOAP_TYPE_tt__FloatList
#define SOAP_TYPE_tt__FloatList (824)
#endif

/* tt__IntList has binding name 'tt__IntList' for type 'tt:IntList' */
#ifndef SOAP_TYPE_tt__IntList
#define SOAP_TYPE_tt__IntList (823)
#endif

/* wstop__TopicSetType has binding name 'wstop__TopicSetType' for type 'wstop:TopicSetType' */
#ifndef SOAP_TYPE_wstop__TopicSetType
#define SOAP_TYPE_wstop__TopicSetType (822)
#endif

/* wstop__TopicType has binding name 'wstop__TopicType' for type 'wstop:TopicType' */
#ifndef SOAP_TYPE_wstop__TopicType
#define SOAP_TYPE_wstop__TopicType (821)
#endif

/* wstop__TopicNamespaceType has binding name 'wstop__TopicNamespaceType' for type 'wstop:TopicNamespaceType' */
#ifndef SOAP_TYPE_wstop__TopicNamespaceType
#define SOAP_TYPE_wstop__TopicNamespaceType (820)
#endif

/* wstop__QueryExpressionType has binding name 'wstop__QueryExpressionType' for type 'wstop:QueryExpressionType' */
#ifndef SOAP_TYPE_wstop__QueryExpressionType
#define SOAP_TYPE_wstop__QueryExpressionType (819)
#endif

/* wstop__ExtensibleDocumented has binding name 'wstop__ExtensibleDocumented' for type 'wstop:ExtensibleDocumented' */
#ifndef SOAP_TYPE_wstop__ExtensibleDocumented
#define SOAP_TYPE_wstop__ExtensibleDocumented (818)
#endif

/* wstop__Documentation has binding name 'wstop__Documentation' for type 'wstop:Documentation' */
#ifndef SOAP_TYPE_wstop__Documentation
#define SOAP_TYPE_wstop__Documentation (817)
#endif

/* wsrfbf__BaseFaultType has binding name 'wsrfbf__BaseFaultType' for type 'wsrfbf:BaseFaultType' */
#ifndef SOAP_TYPE_wsrfbf__BaseFaultType
#define SOAP_TYPE_wsrfbf__BaseFaultType (816)
#endif

/* _wsnt__ResumeSubscriptionResponse has binding name '_wsnt__ResumeSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__ResumeSubscriptionResponse
#define SOAP_TYPE__wsnt__ResumeSubscriptionResponse (815)
#endif

/* _wsnt__ResumeSubscription has binding name '_wsnt__ResumeSubscription' for type '' */
#ifndef SOAP_TYPE__wsnt__ResumeSubscription
#define SOAP_TYPE__wsnt__ResumeSubscription (814)
#endif

/* _wsnt__PauseSubscriptionResponse has binding name '_wsnt__PauseSubscriptionResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__PauseSubscriptionResponse
#define SOAP_TYPE__wsnt__PauseSubscriptionResponse (813)
#endif

/* _wsnt__PauseSubscription has binding name '_wsnt__PauseSubscription' for type '' */
#ifndef SOAP_TYPE__wsnt__PauseSubscription
#define SOAP_TYPE__wsnt__PauseSubscription (812)
#endif

/* _wsnt__UnsubscribeResponse has binding name '_wsnt__UnsubscribeResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__UnsubscribeResponse
#define SOAP_TYPE__wsnt__UnsubscribeResponse (811)
#endif

/* _wsnt__Unsubscribe has binding name '_wsnt__Unsubscribe' for type '' */
#ifndef SOAP_TYPE__wsnt__Unsubscribe
#define SOAP_TYPE__wsnt__Unsubscribe (810)
#endif

/* _wsnt__RenewResponse has binding name '_wsnt__RenewResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__RenewResponse
#define SOAP_TYPE__wsnt__RenewResponse (809)
#endif

/* _wsnt__Renew has binding name '_wsnt__Renew' for type '' */
#ifndef SOAP_TYPE__wsnt__Renew
#define SOAP_TYPE__wsnt__Renew (808)
#endif

/* _wsnt__CreatePullPointResponse has binding name '_wsnt__CreatePullPointResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__CreatePullPointResponse
#define SOAP_TYPE__wsnt__CreatePullPointResponse (807)
#endif

/* _wsnt__CreatePullPoint has binding name '_wsnt__CreatePullPoint' for type '' */
#ifndef SOAP_TYPE__wsnt__CreatePullPoint
#define SOAP_TYPE__wsnt__CreatePullPoint (806)
#endif

/* _wsnt__DestroyPullPointResponse has binding name '_wsnt__DestroyPullPointResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__DestroyPullPointResponse
#define SOAP_TYPE__wsnt__DestroyPullPointResponse (805)
#endif

/* _wsnt__DestroyPullPoint has binding name '_wsnt__DestroyPullPoint' for type '' */
#ifndef SOAP_TYPE__wsnt__DestroyPullPoint
#define SOAP_TYPE__wsnt__DestroyPullPoint (804)
#endif

/* _wsnt__GetMessagesResponse has binding name '_wsnt__GetMessagesResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__GetMessagesResponse
#define SOAP_TYPE__wsnt__GetMessagesResponse (803)
#endif

/* _wsnt__GetMessages has binding name '_wsnt__GetMessages' for type '' */
#ifndef SOAP_TYPE__wsnt__GetMessages
#define SOAP_TYPE__wsnt__GetMessages (802)
#endif

/* _wsnt__GetCurrentMessageResponse has binding name '_wsnt__GetCurrentMessageResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessageResponse
#define SOAP_TYPE__wsnt__GetCurrentMessageResponse (801)
#endif

/* _wsnt__GetCurrentMessage has binding name '_wsnt__GetCurrentMessage' for type '' */
#ifndef SOAP_TYPE__wsnt__GetCurrentMessage
#define SOAP_TYPE__wsnt__GetCurrentMessage (800)
#endif

/* _wsnt__SubscribeResponse has binding name '_wsnt__SubscribeResponse' for type '' */
#ifndef SOAP_TYPE__wsnt__SubscribeResponse
#define SOAP_TYPE__wsnt__SubscribeResponse (799)
#endif

/* _wsnt__Subscribe has binding name '_wsnt__Subscribe' for type '' */
#ifndef SOAP_TYPE__wsnt__Subscribe
#define SOAP_TYPE__wsnt__Subscribe (798)
#endif

/* _wsnt__UseRaw has binding name '_wsnt__UseRaw' for type '' */
#ifndef SOAP_TYPE__wsnt__UseRaw
#define SOAP_TYPE__wsnt__UseRaw (797)
#endif

/* _wsnt__Notify has binding name '_wsnt__Notify' for type '' */
#ifndef SOAP_TYPE__wsnt__Notify
#define SOAP_TYPE__wsnt__Notify (796)
#endif

/* _wsnt__SubscriptionManagerRP has binding name '_wsnt__SubscriptionManagerRP' for type '' */
#ifndef SOAP_TYPE__wsnt__SubscriptionManagerRP
#define SOAP_TYPE__wsnt__SubscriptionManagerRP (795)
#endif

/* _wsnt__NotificationProducerRP has binding name '_wsnt__NotificationProducerRP' for type '' */
#ifndef SOAP_TYPE__wsnt__NotificationProducerRP
#define SOAP_TYPE__wsnt__NotificationProducerRP (794)
#endif

/* wsnt__ResumeFailedFaultType has binding name 'wsnt__ResumeFailedFaultType' for type 'wsnt:ResumeFailedFaultType' */
#ifndef SOAP_TYPE_wsnt__ResumeFailedFaultType
#define SOAP_TYPE_wsnt__ResumeFailedFaultType (793)
#endif

/* wsnt__PauseFailedFaultType has binding name 'wsnt__PauseFailedFaultType' for type 'wsnt:PauseFailedFaultType' */
#ifndef SOAP_TYPE_wsnt__PauseFailedFaultType
#define SOAP_TYPE_wsnt__PauseFailedFaultType (792)
#endif

/* wsnt__UnableToDestroySubscriptionFaultType has binding name 'wsnt__UnableToDestroySubscriptionFaultType' for type 'wsnt:UnableToDestroySubscriptionFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType (791)
#endif

/* wsnt__UnacceptableTerminationTimeFaultType has binding name 'wsnt__UnacceptableTerminationTimeFaultType' for type 'wsnt:UnacceptableTerminationTimeFaultType' */
#ifndef SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType (790)
#endif

/* wsnt__UnableToCreatePullPointFaultType has binding name 'wsnt__UnableToCreatePullPointFaultType' for type 'wsnt:UnableToCreatePullPointFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType
#define SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType (789)
#endif

/* wsnt__UnableToDestroyPullPointFaultType has binding name 'wsnt__UnableToDestroyPullPointFaultType' for type 'wsnt:UnableToDestroyPullPointFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType (788)
#endif

/* wsnt__UnableToGetMessagesFaultType has binding name 'wsnt__UnableToGetMessagesFaultType' for type 'wsnt:UnableToGetMessagesFaultType' */
#ifndef SOAP_TYPE_wsnt__UnableToGetMessagesFaultType
#define SOAP_TYPE_wsnt__UnableToGetMessagesFaultType (787)
#endif

/* wsnt__NoCurrentMessageOnTopicFaultType has binding name 'wsnt__NoCurrentMessageOnTopicFaultType' for type 'wsnt:NoCurrentMessageOnTopicFaultType' */
#ifndef SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType (786)
#endif

/* wsnt__UnacceptableInitialTerminationTimeFaultType has binding name 'wsnt__UnacceptableInitialTerminationTimeFaultType' for type 'wsnt:UnacceptableInitialTerminationTimeFaultType' */
#ifndef SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType (785)
#endif

/* wsnt__NotifyMessageNotSupportedFaultType has binding name 'wsnt__NotifyMessageNotSupportedFaultType' for type 'wsnt:NotifyMessageNotSupportedFaultType' */
#ifndef SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType (784)
#endif

/* wsnt__UnsupportedPolicyRequestFaultType has binding name 'wsnt__UnsupportedPolicyRequestFaultType' for type 'wsnt:UnsupportedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType (783)
#endif

/* wsnt__UnrecognizedPolicyRequestFaultType has binding name 'wsnt__UnrecognizedPolicyRequestFaultType' for type 'wsnt:UnrecognizedPolicyRequestFaultType' */
#ifndef SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType (782)
#endif

/* wsnt__InvalidMessageContentExpressionFaultType has binding name 'wsnt__InvalidMessageContentExpressionFaultType' for type 'wsnt:InvalidMessageContentExpressionFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType (781)
#endif

/* wsnt__InvalidProducerPropertiesExpressionFaultType has binding name 'wsnt__InvalidProducerPropertiesExpressionFaultType' for type 'wsnt:InvalidProducerPropertiesExpressionFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType (780)
#endif

/* wsnt__MultipleTopicsSpecifiedFaultType has binding name 'wsnt__MultipleTopicsSpecifiedFaultType' for type 'wsnt:MultipleTopicsSpecifiedFaultType' */
#ifndef SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType (779)
#endif

/* wsnt__TopicNotSupportedFaultType has binding name 'wsnt__TopicNotSupportedFaultType' for type 'wsnt:TopicNotSupportedFaultType' */
#ifndef SOAP_TYPE_wsnt__TopicNotSupportedFaultType
#define SOAP_TYPE_wsnt__TopicNotSupportedFaultType (778)
#endif

/* wsnt__InvalidTopicExpressionFaultType has binding name 'wsnt__InvalidTopicExpressionFaultType' for type 'wsnt:InvalidTopicExpressionFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType
#define SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType (777)
#endif

/* wsnt__TopicExpressionDialectUnknownFaultType has binding name 'wsnt__TopicExpressionDialectUnknownFaultType' for type 'wsnt:TopicExpressionDialectUnknownFaultType' */
#ifndef SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType (776)
#endif

/* wsnt__InvalidFilterFaultType has binding name 'wsnt__InvalidFilterFaultType' for type 'wsnt:InvalidFilterFaultType' */
#ifndef SOAP_TYPE_wsnt__InvalidFilterFaultType
#define SOAP_TYPE_wsnt__InvalidFilterFaultType (775)
#endif

/* wsnt__SubscribeCreationFailedFaultType has binding name 'wsnt__SubscribeCreationFailedFaultType' for type 'wsnt:SubscribeCreationFailedFaultType' */
#ifndef SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType
#define SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType (774)
#endif

/* wsnt__NotificationMessageHolderType has binding name 'wsnt__NotificationMessageHolderType' for type 'wsnt:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_wsnt__NotificationMessageHolderType
#define SOAP_TYPE_wsnt__NotificationMessageHolderType (773)
#endif

/* wsnt__SubscriptionPolicyType has binding name 'wsnt__SubscriptionPolicyType' for type 'wsnt:SubscriptionPolicyType' */
#ifndef SOAP_TYPE_wsnt__SubscriptionPolicyType
#define SOAP_TYPE_wsnt__SubscriptionPolicyType (772)
#endif

/* wsnt__FilterType has binding name 'wsnt__FilterType' for type 'wsnt:FilterType' */
#ifndef SOAP_TYPE_wsnt__FilterType
#define SOAP_TYPE_wsnt__FilterType (771)
#endif

/* wsnt__TopicExpressionType has binding name 'wsnt__TopicExpressionType' for type 'wsnt:TopicExpressionType' */
#ifndef SOAP_TYPE_wsnt__TopicExpressionType
#define SOAP_TYPE_wsnt__TopicExpressionType (770)
#endif

/* wsnt__QueryExpressionType has binding name 'wsnt__QueryExpressionType' for type 'wsnt:QueryExpressionType' */
#ifndef SOAP_TYPE_wsnt__QueryExpressionType
#define SOAP_TYPE_wsnt__QueryExpressionType (769)
#endif

/* _tt__Message has binding name '_tt__Message' for type '' */
#ifndef SOAP_TYPE__tt__Message
#define SOAP_TYPE__tt__Message (768)
#endif

/* _tt__StringItems has binding name '_tt__StringItems' for type '' */
#ifndef SOAP_TYPE__tt__StringItems
#define SOAP_TYPE__tt__StringItems (767)
#endif

/* tt__LocationEntity has binding name 'tt__LocationEntity' for type 'tt:LocationEntity' */
#ifndef SOAP_TYPE_tt__LocationEntity
#define SOAP_TYPE_tt__LocationEntity (766)
#endif

/* tt__LocalOrientation has binding name 'tt__LocalOrientation' for type 'tt:LocalOrientation' */
#ifndef SOAP_TYPE_tt__LocalOrientation
#define SOAP_TYPE_tt__LocalOrientation (765)
#endif

/* tt__LocalLocation has binding name 'tt__LocalLocation' for type 'tt:LocalLocation' */
#ifndef SOAP_TYPE_tt__LocalLocation
#define SOAP_TYPE_tt__LocalLocation (764)
#endif

/* tt__GeoOrientation has binding name 'tt__GeoOrientation' for type 'tt:GeoOrientation' */
#ifndef SOAP_TYPE_tt__GeoOrientation
#define SOAP_TYPE_tt__GeoOrientation (763)
#endif

/* tt__GeoLocation has binding name 'tt__GeoLocation' for type 'tt:GeoLocation' */
#ifndef SOAP_TYPE_tt__GeoLocation
#define SOAP_TYPE_tt__GeoLocation (762)
#endif

/* tt__TransformationExtension has binding name 'tt__TransformationExtension' for type 'tt:TransformationExtension' */
#ifndef SOAP_TYPE_tt__TransformationExtension
#define SOAP_TYPE_tt__TransformationExtension (761)
#endif

/* tt__Transformation has binding name 'tt__Transformation' for type 'tt:Transformation' */
#ifndef SOAP_TYPE_tt__Transformation
#define SOAP_TYPE_tt__Transformation (760)
#endif

/* tt__ColorDescriptor has binding name 'tt__ColorDescriptor' for type 'tt:ColorDescriptor' */
#ifndef SOAP_TYPE_tt__ColorDescriptor
#define SOAP_TYPE_tt__ColorDescriptor (759)
#endif

/* tt__ColorCovariance has binding name 'tt__ColorCovariance' for type 'tt:ColorCovariance' */
#ifndef SOAP_TYPE_tt__ColorCovariance
#define SOAP_TYPE_tt__ColorCovariance (758)
#endif

/* tt__Color has binding name 'tt__Color' for type 'tt:Color' */
#ifndef SOAP_TYPE_tt__Color
#define SOAP_TYPE_tt__Color (757)
#endif

/* tt__Polygon has binding name 'tt__Polygon' for type 'tt:Polygon' */
#ifndef SOAP_TYPE_tt__Polygon
#define SOAP_TYPE_tt__Polygon (756)
#endif

/* tt__Rectangle has binding name 'tt__Rectangle' for type 'tt:Rectangle' */
#ifndef SOAP_TYPE_tt__Rectangle
#define SOAP_TYPE_tt__Rectangle (755)
#endif

/* tt__Vector has binding name 'tt__Vector' for type 'tt:Vector' */
#ifndef SOAP_TYPE_tt__Vector
#define SOAP_TYPE_tt__Vector (754)
#endif

/* tt__PTZMoveStatus has binding name 'tt__PTZMoveStatus' for type 'tt:PTZMoveStatus' */
#ifndef SOAP_TYPE_tt__PTZMoveStatus
#define SOAP_TYPE_tt__PTZMoveStatus (753)
#endif

/* tt__PTZStatus has binding name 'tt__PTZStatus' for type 'tt:PTZStatus' */
#ifndef SOAP_TYPE_tt__PTZStatus
#define SOAP_TYPE_tt__PTZStatus (752)
#endif

/* tt__PTZVector has binding name 'tt__PTZVector' for type 'tt:PTZVector' */
#ifndef SOAP_TYPE_tt__PTZVector
#define SOAP_TYPE_tt__PTZVector (751)
#endif

/* tt__Vector1D has binding name 'tt__Vector1D' for type 'tt:Vector1D' */
#ifndef SOAP_TYPE_tt__Vector1D
#define SOAP_TYPE_tt__Vector1D (750)
#endif

/* tt__Vector2D has binding name 'tt__Vector2D' for type 'tt:Vector2D' */
#ifndef SOAP_TYPE_tt__Vector2D
#define SOAP_TYPE_tt__Vector2D (749)
#endif

/* tt__IntRange has binding name 'tt__IntRange' for type 'tt:IntRange' */
#ifndef SOAP_TYPE_tt__IntRange
#define SOAP_TYPE_tt__IntRange (748)
#endif

/* tt__PolygonOptions has binding name 'tt__PolygonOptions' for type 'tt:PolygonOptions' */
#ifndef SOAP_TYPE_tt__PolygonOptions
#define SOAP_TYPE_tt__PolygonOptions (747)
#endif

/* tt__StorageReferencePathExtension has binding name 'tt__StorageReferencePathExtension' for type 'tt:StorageReferencePathExtension' */
#ifndef SOAP_TYPE_tt__StorageReferencePathExtension
#define SOAP_TYPE_tt__StorageReferencePathExtension (746)
#endif

/* tt__StorageReferencePath has binding name 'tt__StorageReferencePath' for type 'tt:StorageReferencePath' */
#ifndef SOAP_TYPE_tt__StorageReferencePath
#define SOAP_TYPE_tt__StorageReferencePath (745)
#endif

/* tt__ArrayOfFileProgressExtension has binding name 'tt__ArrayOfFileProgressExtension' for type 'tt:ArrayOfFileProgressExtension' */
#ifndef SOAP_TYPE_tt__ArrayOfFileProgressExtension
#define SOAP_TYPE_tt__ArrayOfFileProgressExtension (744)
#endif

/* tt__ArrayOfFileProgress has binding name 'tt__ArrayOfFileProgress' for type 'tt:ArrayOfFileProgress' */
#ifndef SOAP_TYPE_tt__ArrayOfFileProgress
#define SOAP_TYPE_tt__ArrayOfFileProgress (743)
#endif

/* tt__FileProgress has binding name 'tt__FileProgress' for type 'tt:FileProgress' */
#ifndef SOAP_TYPE_tt__FileProgress
#define SOAP_TYPE_tt__FileProgress (742)
#endif

/* tt__OSDConfigurationOptionsExtension has binding name 'tt__OSDConfigurationOptionsExtension' for type 'tt:OSDConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptionsExtension
#define SOAP_TYPE_tt__OSDConfigurationOptionsExtension (741)
#endif

/* tt__OSDConfigurationOptions has binding name 'tt__OSDConfigurationOptions' for type 'tt:OSDConfigurationOptions' */
#ifndef SOAP_TYPE_tt__OSDConfigurationOptions
#define SOAP_TYPE_tt__OSDConfigurationOptions (740)
#endif

/* tt__MaximumNumberOfOSDs has binding name 'tt__MaximumNumberOfOSDs' for type 'tt:MaximumNumberOfOSDs' */
#ifndef SOAP_TYPE_tt__MaximumNumberOfOSDs
#define SOAP_TYPE_tt__MaximumNumberOfOSDs (739)
#endif

/* tt__OSDConfigurationExtension has binding name 'tt__OSDConfigurationExtension' for type 'tt:OSDConfigurationExtension' */
#ifndef SOAP_TYPE_tt__OSDConfigurationExtension
#define SOAP_TYPE_tt__OSDConfigurationExtension (738)
#endif

/* tt__OSDConfiguration has binding name 'tt__OSDConfiguration' for type 'tt:OSDConfiguration' */
#ifndef SOAP_TYPE_tt__OSDConfiguration
#define SOAP_TYPE_tt__OSDConfiguration (737)
#endif

/* tt__OSDImgOptionsExtension has binding name 'tt__OSDImgOptionsExtension' for type 'tt:OSDImgOptionsExtension' */
#ifndef SOAP_TYPE_tt__OSDImgOptionsExtension
#define SOAP_TYPE_tt__OSDImgOptionsExtension (736)
#endif

/* tt__OSDImgOptions has binding name 'tt__OSDImgOptions' for type 'tt:OSDImgOptions' */
#ifndef SOAP_TYPE_tt__OSDImgOptions
#define SOAP_TYPE_tt__OSDImgOptions (735)
#endif

/* tt__OSDTextOptionsExtension has binding name 'tt__OSDTextOptionsExtension' for type 'tt:OSDTextOptionsExtension' */
#ifndef SOAP_TYPE_tt__OSDTextOptionsExtension
#define SOAP_TYPE_tt__OSDTextOptionsExtension (734)
#endif

/* tt__OSDTextOptions has binding name 'tt__OSDTextOptions' for type 'tt:OSDTextOptions' */
#ifndef SOAP_TYPE_tt__OSDTextOptions
#define SOAP_TYPE_tt__OSDTextOptions (733)
#endif

/* tt__OSDColorOptionsExtension has binding name 'tt__OSDColorOptionsExtension' for type 'tt:OSDColorOptionsExtension' */
#ifndef SOAP_TYPE_tt__OSDColorOptionsExtension
#define SOAP_TYPE_tt__OSDColorOptionsExtension (732)
#endif

/* tt__OSDColorOptions has binding name 'tt__OSDColorOptions' for type 'tt:OSDColorOptions' */
#ifndef SOAP_TYPE_tt__OSDColorOptions
#define SOAP_TYPE_tt__OSDColorOptions (731)
#endif

/* tt__ColorOptions has binding name 'tt__ColorOptions' for type 'tt:ColorOptions' */
#ifndef SOAP_TYPE_tt__ColorOptions
#define SOAP_TYPE_tt__ColorOptions (730)
#endif

/* tt__ColorspaceRange has binding name 'tt__ColorspaceRange' for type 'tt:ColorspaceRange' */
#ifndef SOAP_TYPE_tt__ColorspaceRange
#define SOAP_TYPE_tt__ColorspaceRange (729)
#endif

/* tt__OSDImgConfigurationExtension has binding name 'tt__OSDImgConfigurationExtension' for type 'tt:OSDImgConfigurationExtension' */
#ifndef SOAP_TYPE_tt__OSDImgConfigurationExtension
#define SOAP_TYPE_tt__OSDImgConfigurationExtension (728)
#endif

/* tt__OSDImgConfiguration has binding name 'tt__OSDImgConfiguration' for type 'tt:OSDImgConfiguration' */
#ifndef SOAP_TYPE_tt__OSDImgConfiguration
#define SOAP_TYPE_tt__OSDImgConfiguration (727)
#endif

/* tt__OSDTextConfigurationExtension has binding name 'tt__OSDTextConfigurationExtension' for type 'tt:OSDTextConfigurationExtension' */
#ifndef SOAP_TYPE_tt__OSDTextConfigurationExtension
#define SOAP_TYPE_tt__OSDTextConfigurationExtension (726)
#endif

/* tt__OSDTextConfiguration has binding name 'tt__OSDTextConfiguration' for type 'tt:OSDTextConfiguration' */
#ifndef SOAP_TYPE_tt__OSDTextConfiguration
#define SOAP_TYPE_tt__OSDTextConfiguration (725)
#endif

/* tt__OSDColor has binding name 'tt__OSDColor' for type 'tt:OSDColor' */
#ifndef SOAP_TYPE_tt__OSDColor
#define SOAP_TYPE_tt__OSDColor (724)
#endif

/* tt__OSDPosConfigurationExtension has binding name 'tt__OSDPosConfigurationExtension' for type 'tt:OSDPosConfigurationExtension' */
#ifndef SOAP_TYPE_tt__OSDPosConfigurationExtension
#define SOAP_TYPE_tt__OSDPosConfigurationExtension (723)
#endif

/* tt__OSDPosConfiguration has binding name 'tt__OSDPosConfiguration' for type 'tt:OSDPosConfiguration' */
#ifndef SOAP_TYPE_tt__OSDPosConfiguration
#define SOAP_TYPE_tt__OSDPosConfiguration (722)
#endif

/* tt__OSDReference has binding name 'tt__OSDReference' for type 'tt:OSDReference' */
#ifndef SOAP_TYPE_tt__OSDReference
#define SOAP_TYPE_tt__OSDReference (721)
#endif

/* tt__ProfileStatusExtension has binding name 'tt__ProfileStatusExtension' for type 'tt:ProfileStatusExtension' */
#ifndef SOAP_TYPE_tt__ProfileStatusExtension
#define SOAP_TYPE_tt__ProfileStatusExtension (720)
#endif

/* tt__ProfileStatus has binding name 'tt__ProfileStatus' for type 'tt:ProfileStatus' */
#ifndef SOAP_TYPE_tt__ProfileStatus
#define SOAP_TYPE_tt__ProfileStatus (719)
#endif

/* tt__ActiveConnection has binding name 'tt__ActiveConnection' for type 'tt:ActiveConnection' */
#ifndef SOAP_TYPE_tt__ActiveConnection
#define SOAP_TYPE_tt__ActiveConnection (718)
#endif

/* tt__AudioClassDescriptorExtension has binding name 'tt__AudioClassDescriptorExtension' for type 'tt:AudioClassDescriptorExtension' */
#ifndef SOAP_TYPE_tt__AudioClassDescriptorExtension
#define SOAP_TYPE_tt__AudioClassDescriptorExtension (717)
#endif

/* tt__AudioClassDescriptor has binding name 'tt__AudioClassDescriptor' for type 'tt:AudioClassDescriptor' */
#ifndef SOAP_TYPE_tt__AudioClassDescriptor
#define SOAP_TYPE_tt__AudioClassDescriptor (716)
#endif

/* tt__AudioClassCandidate has binding name 'tt__AudioClassCandidate' for type 'tt:AudioClassCandidate' */
#ifndef SOAP_TYPE_tt__AudioClassCandidate
#define SOAP_TYPE_tt__AudioClassCandidate (715)
#endif

/* tt__ActionEngineEventPayloadExtension has binding name 'tt__ActionEngineEventPayloadExtension' for type 'tt:ActionEngineEventPayloadExtension' */
#ifndef SOAP_TYPE_tt__ActionEngineEventPayloadExtension
#define SOAP_TYPE_tt__ActionEngineEventPayloadExtension (714)
#endif

/* tt__ActionEngineEventPayload has binding name 'tt__ActionEngineEventPayload' for type 'tt:ActionEngineEventPayload' */
#ifndef SOAP_TYPE_tt__ActionEngineEventPayload
#define SOAP_TYPE_tt__ActionEngineEventPayload (713)
#endif

/* tt__AnalyticsState has binding name 'tt__AnalyticsState' for type 'tt:AnalyticsState' */
#ifndef SOAP_TYPE_tt__AnalyticsState
#define SOAP_TYPE_tt__AnalyticsState (712)
#endif

/* tt__AnalyticsStateInformation has binding name 'tt__AnalyticsStateInformation' for type 'tt:AnalyticsStateInformation' */
#ifndef SOAP_TYPE_tt__AnalyticsStateInformation
#define SOAP_TYPE_tt__AnalyticsStateInformation (711)
#endif

/* tt__AnalyticsEngineControl has binding name 'tt__AnalyticsEngineControl' for type 'tt:AnalyticsEngineControl' */
#ifndef SOAP_TYPE_tt__AnalyticsEngineControl
#define SOAP_TYPE_tt__AnalyticsEngineControl (710)
#endif

/* tt__MetadataInputExtension has binding name 'tt__MetadataInputExtension' for type 'tt:MetadataInputExtension' */
#ifndef SOAP_TYPE_tt__MetadataInputExtension
#define SOAP_TYPE_tt__MetadataInputExtension (709)
#endif

/* tt__MetadataInput has binding name 'tt__MetadataInput' for type 'tt:MetadataInput' */
#ifndef SOAP_TYPE_tt__MetadataInput
#define SOAP_TYPE_tt__MetadataInput (708)
#endif

/* tt__SourceIdentificationExtension has binding name 'tt__SourceIdentificationExtension' for type 'tt:SourceIdentificationExtension' */
#ifndef SOAP_TYPE_tt__SourceIdentificationExtension
#define SOAP_TYPE_tt__SourceIdentificationExtension (707)
#endif

/* tt__SourceIdentification has binding name 'tt__SourceIdentification' for type 'tt:SourceIdentification' */
#ifndef SOAP_TYPE_tt__SourceIdentification
#define SOAP_TYPE_tt__SourceIdentification (706)
#endif

/* tt__AnalyticsEngineInput has binding name 'tt__AnalyticsEngineInput' for type 'tt:AnalyticsEngineInput' */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInput
#define SOAP_TYPE_tt__AnalyticsEngineInput (705)
#endif

/* tt__AnalyticsEngineInputInfoExtension has binding name 'tt__AnalyticsEngineInputInfoExtension' for type 'tt:AnalyticsEngineInputInfoExtension' */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension (704)
#endif

/* tt__AnalyticsEngineInputInfo has binding name 'tt__AnalyticsEngineInputInfo' for type 'tt:AnalyticsEngineInputInfo' */
#ifndef SOAP_TYPE_tt__AnalyticsEngineInputInfo
#define SOAP_TYPE_tt__AnalyticsEngineInputInfo (703)
#endif

/* tt__EngineConfiguration has binding name 'tt__EngineConfiguration' for type 'tt:EngineConfiguration' */
#ifndef SOAP_TYPE_tt__EngineConfiguration
#define SOAP_TYPE_tt__EngineConfiguration (702)
#endif

/* tt__AnalyticsDeviceEngineConfigurationExtension has binding name 'tt__AnalyticsDeviceEngineConfigurationExtension' for type 'tt:AnalyticsDeviceEngineConfigurationExtension' */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension (701)
#endif

/* tt__AnalyticsDeviceEngineConfiguration has binding name 'tt__AnalyticsDeviceEngineConfiguration' for type 'tt:AnalyticsDeviceEngineConfiguration' */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration (700)
#endif

/* tt__AnalyticsEngine has binding name 'tt__AnalyticsEngine' for type 'tt:AnalyticsEngine' */
#ifndef SOAP_TYPE_tt__AnalyticsEngine
#define SOAP_TYPE_tt__AnalyticsEngine (699)
#endif

/* tt__ReplayConfiguration has binding name 'tt__ReplayConfiguration' for type 'tt:ReplayConfiguration' */
#ifndef SOAP_TYPE_tt__ReplayConfiguration
#define SOAP_TYPE_tt__ReplayConfiguration (698)
#endif

/* tt__GetRecordingJobsResponseItem has binding name 'tt__GetRecordingJobsResponseItem' for type 'tt:GetRecordingJobsResponseItem' */
#ifndef SOAP_TYPE_tt__GetRecordingJobsResponseItem
#define SOAP_TYPE_tt__GetRecordingJobsResponseItem (697)
#endif

/* tt__RecordingJobStateTrack has binding name 'tt__RecordingJobStateTrack' for type 'tt:RecordingJobStateTrack' */
#ifndef SOAP_TYPE_tt__RecordingJobStateTrack
#define SOAP_TYPE_tt__RecordingJobStateTrack (696)
#endif

/* tt__RecordingJobStateTracks has binding name 'tt__RecordingJobStateTracks' for type 'tt:RecordingJobStateTracks' */
#ifndef SOAP_TYPE_tt__RecordingJobStateTracks
#define SOAP_TYPE_tt__RecordingJobStateTracks (695)
#endif

/* tt__RecordingJobStateSource has binding name 'tt__RecordingJobStateSource' for type 'tt:RecordingJobStateSource' */
#ifndef SOAP_TYPE_tt__RecordingJobStateSource
#define SOAP_TYPE_tt__RecordingJobStateSource (694)
#endif

/* tt__RecordingJobStateInformationExtension has binding name 'tt__RecordingJobStateInformationExtension' for type 'tt:RecordingJobStateInformationExtension' */
#ifndef SOAP_TYPE_tt__RecordingJobStateInformationExtension
#define SOAP_TYPE_tt__RecordingJobStateInformationExtension (693)
#endif

/* tt__RecordingJobStateInformation has binding name 'tt__RecordingJobStateInformation' for type 'tt:RecordingJobStateInformation' */
#ifndef SOAP_TYPE_tt__RecordingJobStateInformation
#define SOAP_TYPE_tt__RecordingJobStateInformation (692)
#endif

/* tt__RecordingJobTrack has binding name 'tt__RecordingJobTrack' for type 'tt:RecordingJobTrack' */
#ifndef SOAP_TYPE_tt__RecordingJobTrack
#define SOAP_TYPE_tt__RecordingJobTrack (691)
#endif

/* tt__RecordingJobSourceExtension has binding name 'tt__RecordingJobSourceExtension' for type 'tt:RecordingJobSourceExtension' */
#ifndef SOAP_TYPE_tt__RecordingJobSourceExtension
#define SOAP_TYPE_tt__RecordingJobSourceExtension (690)
#endif

/* tt__RecordingJobSource has binding name 'tt__RecordingJobSource' for type 'tt:RecordingJobSource' */
#ifndef SOAP_TYPE_tt__RecordingJobSource
#define SOAP_TYPE_tt__RecordingJobSource (689)
#endif

/* tt__RecordingJobConfigurationExtension has binding name 'tt__RecordingJobConfigurationExtension' for type 'tt:RecordingJobConfigurationExtension' */
#ifndef SOAP_TYPE_tt__RecordingJobConfigurationExtension
#define SOAP_TYPE_tt__RecordingJobConfigurationExtension (688)
#endif

/* tt__RecordingEventFilter has binding name 'tt__RecordingEventFilter' for type 'tt:RecordingEventFilter' */
#ifndef SOAP_TYPE_tt__RecordingEventFilter
#define SOAP_TYPE_tt__RecordingEventFilter (687)
#endif

/* tt__RecordingJobConfiguration has binding name 'tt__RecordingJobConfiguration' for type 'tt:RecordingJobConfiguration' */
#ifndef SOAP_TYPE_tt__RecordingJobConfiguration
#define SOAP_TYPE_tt__RecordingJobConfiguration (686)
#endif

/* tt__GetTracksResponseItem has binding name 'tt__GetTracksResponseItem' for type 'tt:GetTracksResponseItem' */
#ifndef SOAP_TYPE_tt__GetTracksResponseItem
#define SOAP_TYPE_tt__GetTracksResponseItem (685)
#endif

/* tt__GetTracksResponseList has binding name 'tt__GetTracksResponseList' for type 'tt:GetTracksResponseList' */
#ifndef SOAP_TYPE_tt__GetTracksResponseList
#define SOAP_TYPE_tt__GetTracksResponseList (684)
#endif

/* tt__GetRecordingsResponseItem has binding name 'tt__GetRecordingsResponseItem' for type 'tt:GetRecordingsResponseItem' */
#ifndef SOAP_TYPE_tt__GetRecordingsResponseItem
#define SOAP_TYPE_tt__GetRecordingsResponseItem (683)
#endif

/* tt__TrackConfiguration has binding name 'tt__TrackConfiguration' for type 'tt:TrackConfiguration' */
#ifndef SOAP_TYPE_tt__TrackConfiguration
#define SOAP_TYPE_tt__TrackConfiguration (682)
#endif

/* tt__RecordingConfiguration has binding name 'tt__RecordingConfiguration' for type 'tt:RecordingConfiguration' */
#ifndef SOAP_TYPE_tt__RecordingConfiguration
#define SOAP_TYPE_tt__RecordingConfiguration (681)
#endif

/* tt__MetadataAttributes has binding name 'tt__MetadataAttributes' for type 'tt:MetadataAttributes' */
#ifndef SOAP_TYPE_tt__MetadataAttributes
#define SOAP_TYPE_tt__MetadataAttributes (680)
#endif

/* tt__AudioAttributes has binding name 'tt__AudioAttributes' for type 'tt:AudioAttributes' */
#ifndef SOAP_TYPE_tt__AudioAttributes
#define SOAP_TYPE_tt__AudioAttributes (679)
#endif

/* tt__VideoAttributes has binding name 'tt__VideoAttributes' for type 'tt:VideoAttributes' */
#ifndef SOAP_TYPE_tt__VideoAttributes
#define SOAP_TYPE_tt__VideoAttributes (678)
#endif

/* tt__TrackAttributesExtension has binding name 'tt__TrackAttributesExtension' for type 'tt:TrackAttributesExtension' */
#ifndef SOAP_TYPE_tt__TrackAttributesExtension
#define SOAP_TYPE_tt__TrackAttributesExtension (677)
#endif

/* tt__TrackAttributes has binding name 'tt__TrackAttributes' for type 'tt:TrackAttributes' */
#ifndef SOAP_TYPE_tt__TrackAttributes
#define SOAP_TYPE_tt__TrackAttributes (676)
#endif

/* tt__MediaAttributes has binding name 'tt__MediaAttributes' for type 'tt:MediaAttributes' */
#ifndef SOAP_TYPE_tt__MediaAttributes
#define SOAP_TYPE_tt__MediaAttributes (675)
#endif

/* tt__TrackInformation has binding name 'tt__TrackInformation' for type 'tt:TrackInformation' */
#ifndef SOAP_TYPE_tt__TrackInformation
#define SOAP_TYPE_tt__TrackInformation (674)
#endif

/* tt__RecordingSourceInformation has binding name 'tt__RecordingSourceInformation' for type 'tt:RecordingSourceInformation' */
#ifndef SOAP_TYPE_tt__RecordingSourceInformation
#define SOAP_TYPE_tt__RecordingSourceInformation (673)
#endif

/* tt__RecordingInformation has binding name 'tt__RecordingInformation' for type 'tt:RecordingInformation' */
#ifndef SOAP_TYPE_tt__RecordingInformation
#define SOAP_TYPE_tt__RecordingInformation (672)
#endif

/* tt__FindMetadataResult has binding name 'tt__FindMetadataResult' for type 'tt:FindMetadataResult' */
#ifndef SOAP_TYPE_tt__FindMetadataResult
#define SOAP_TYPE_tt__FindMetadataResult (671)
#endif

/* tt__FindMetadataResultList has binding name 'tt__FindMetadataResultList' for type 'tt:FindMetadataResultList' */
#ifndef SOAP_TYPE_tt__FindMetadataResultList
#define SOAP_TYPE_tt__FindMetadataResultList (670)
#endif

/* tt__FindPTZPositionResult has binding name 'tt__FindPTZPositionResult' for type 'tt:FindPTZPositionResult' */
#ifndef SOAP_TYPE_tt__FindPTZPositionResult
#define SOAP_TYPE_tt__FindPTZPositionResult (669)
#endif

/* tt__FindPTZPositionResultList has binding name 'tt__FindPTZPositionResultList' for type 'tt:FindPTZPositionResultList' */
#ifndef SOAP_TYPE_tt__FindPTZPositionResultList
#define SOAP_TYPE_tt__FindPTZPositionResultList (668)
#endif

/* tt__FindEventResult has binding name 'tt__FindEventResult' for type 'tt:FindEventResult' */
#ifndef SOAP_TYPE_tt__FindEventResult
#define SOAP_TYPE_tt__FindEventResult (667)
#endif

/* tt__FindEventResultList has binding name 'tt__FindEventResultList' for type 'tt:FindEventResultList' */
#ifndef SOAP_TYPE_tt__FindEventResultList
#define SOAP_TYPE_tt__FindEventResultList (666)
#endif

/* tt__FindRecordingResultList has binding name 'tt__FindRecordingResultList' for type 'tt:FindRecordingResultList' */
#ifndef SOAP_TYPE_tt__FindRecordingResultList
#define SOAP_TYPE_tt__FindRecordingResultList (665)
#endif

/* tt__MetadataFilter has binding name 'tt__MetadataFilter' for type 'tt:MetadataFilter' */
#ifndef SOAP_TYPE_tt__MetadataFilter
#define SOAP_TYPE_tt__MetadataFilter (664)
#endif

/* tt__PTZPositionFilter has binding name 'tt__PTZPositionFilter' for type 'tt:PTZPositionFilter' */
#ifndef SOAP_TYPE_tt__PTZPositionFilter
#define SOAP_TYPE_tt__PTZPositionFilter (663)
#endif

/* tt__EventFilter has binding name 'tt__EventFilter' for type 'tt:EventFilter' */
#ifndef SOAP_TYPE_tt__EventFilter
#define SOAP_TYPE_tt__EventFilter (662)
#endif

/* tt__SearchScopeExtension has binding name 'tt__SearchScopeExtension' for type 'tt:SearchScopeExtension' */
#ifndef SOAP_TYPE_tt__SearchScopeExtension
#define SOAP_TYPE_tt__SearchScopeExtension (661)
#endif

/* tt__SearchScope has binding name 'tt__SearchScope' for type 'tt:SearchScope' */
#ifndef SOAP_TYPE_tt__SearchScope
#define SOAP_TYPE_tt__SearchScope (660)
#endif

/* tt__RecordingSummary has binding name 'tt__RecordingSummary' for type 'tt:RecordingSummary' */
#ifndef SOAP_TYPE_tt__RecordingSummary
#define SOAP_TYPE_tt__RecordingSummary (659)
#endif

/* tt__DateTimeRange has binding name 'tt__DateTimeRange' for type 'tt:DateTimeRange' */
#ifndef SOAP_TYPE_tt__DateTimeRange
#define SOAP_TYPE_tt__DateTimeRange (658)
#endif

/* tt__SourceReference has binding name 'tt__SourceReference' for type 'tt:SourceReference' */
#ifndef SOAP_TYPE_tt__SourceReference
#define SOAP_TYPE_tt__SourceReference (657)
#endif

/* tt__ReceiverStateInformation has binding name 'tt__ReceiverStateInformation' for type 'tt:ReceiverStateInformation' */
#ifndef SOAP_TYPE_tt__ReceiverStateInformation
#define SOAP_TYPE_tt__ReceiverStateInformation (656)
#endif

/* tt__ReceiverConfiguration has binding name 'tt__ReceiverConfiguration' for type 'tt:ReceiverConfiguration' */
#ifndef SOAP_TYPE_tt__ReceiverConfiguration
#define SOAP_TYPE_tt__ReceiverConfiguration (655)
#endif

/* tt__Receiver has binding name 'tt__Receiver' for type 'tt:Receiver' */
#ifndef SOAP_TYPE_tt__Receiver
#define SOAP_TYPE_tt__Receiver (654)
#endif

/* tt__PaneOptionExtension has binding name 'tt__PaneOptionExtension' for type 'tt:PaneOptionExtension' */
#ifndef SOAP_TYPE_tt__PaneOptionExtension
#define SOAP_TYPE_tt__PaneOptionExtension (653)
#endif

/* tt__PaneLayoutOptions has binding name 'tt__PaneLayoutOptions' for type 'tt:PaneLayoutOptions' */
#ifndef SOAP_TYPE_tt__PaneLayoutOptions
#define SOAP_TYPE_tt__PaneLayoutOptions (652)
#endif

/* tt__LayoutOptionsExtension has binding name 'tt__LayoutOptionsExtension' for type 'tt:LayoutOptionsExtension' */
#ifndef SOAP_TYPE_tt__LayoutOptionsExtension
#define SOAP_TYPE_tt__LayoutOptionsExtension (651)
#endif

/* tt__LayoutOptions has binding name 'tt__LayoutOptions' for type 'tt:LayoutOptions' */
#ifndef SOAP_TYPE_tt__LayoutOptions
#define SOAP_TYPE_tt__LayoutOptions (650)
#endif

/* tt__CodingCapabilities has binding name 'tt__CodingCapabilities' for type 'tt:CodingCapabilities' */
#ifndef SOAP_TYPE_tt__CodingCapabilities
#define SOAP_TYPE_tt__CodingCapabilities (649)
#endif

/* tt__LayoutExtension has binding name 'tt__LayoutExtension' for type 'tt:LayoutExtension' */
#ifndef SOAP_TYPE_tt__LayoutExtension
#define SOAP_TYPE_tt__LayoutExtension (648)
#endif

/* tt__Layout has binding name 'tt__Layout' for type 'tt:Layout' */
#ifndef SOAP_TYPE_tt__Layout
#define SOAP_TYPE_tt__Layout (647)
#endif

/* tt__PaneLayout has binding name 'tt__PaneLayout' for type 'tt:PaneLayout' */
#ifndef SOAP_TYPE_tt__PaneLayout
#define SOAP_TYPE_tt__PaneLayout (646)
#endif

/* tt__PaneConfiguration has binding name 'tt__PaneConfiguration' for type 'tt:PaneConfiguration' */
#ifndef SOAP_TYPE_tt__PaneConfiguration
#define SOAP_TYPE_tt__PaneConfiguration (645)
#endif

/* tt__CellLayout has binding name 'tt__CellLayout' for type 'tt:CellLayout' */
#ifndef SOAP_TYPE_tt__CellLayout
#define SOAP_TYPE_tt__CellLayout (644)
#endif

/* tt__MotionExpressionConfiguration has binding name 'tt__MotionExpressionConfiguration' for type 'tt:MotionExpressionConfiguration' */
#ifndef SOAP_TYPE_tt__MotionExpressionConfiguration
#define SOAP_TYPE_tt__MotionExpressionConfiguration (643)
#endif

/* tt__MotionExpression has binding name 'tt__MotionExpression' for type 'tt:MotionExpression' */
#ifndef SOAP_TYPE_tt__MotionExpression
#define SOAP_TYPE_tt__MotionExpression (642)
#endif

/* tt__PolylineArrayConfiguration has binding name 'tt__PolylineArrayConfiguration' for type 'tt:PolylineArrayConfiguration' */
#ifndef SOAP_TYPE_tt__PolylineArrayConfiguration
#define SOAP_TYPE_tt__PolylineArrayConfiguration (641)
#endif

/* tt__PolylineArrayExtension has binding name 'tt__PolylineArrayExtension' for type 'tt:PolylineArrayExtension' */
#ifndef SOAP_TYPE_tt__PolylineArrayExtension
#define SOAP_TYPE_tt__PolylineArrayExtension (640)
#endif

/* tt__PolylineArray has binding name 'tt__PolylineArray' for type 'tt:PolylineArray' */
#ifndef SOAP_TYPE_tt__PolylineArray
#define SOAP_TYPE_tt__PolylineArray (639)
#endif

/* tt__SupportedAnalyticsModulesExtension has binding name 'tt__SupportedAnalyticsModulesExtension' for type 'tt:SupportedAnalyticsModulesExtension' */
#ifndef SOAP_TYPE_tt__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_tt__SupportedAnalyticsModulesExtension (638)
#endif

/* tt__SupportedAnalyticsModules has binding name 'tt__SupportedAnalyticsModules' for type 'tt:SupportedAnalyticsModules' */
#ifndef SOAP_TYPE_tt__SupportedAnalyticsModules
#define SOAP_TYPE_tt__SupportedAnalyticsModules (637)
#endif

/* tt__SupportedRulesExtension has binding name 'tt__SupportedRulesExtension' for type 'tt:SupportedRulesExtension' */
#ifndef SOAP_TYPE_tt__SupportedRulesExtension
#define SOAP_TYPE_tt__SupportedRulesExtension (636)
#endif

/* tt__SupportedRules has binding name 'tt__SupportedRules' for type 'tt:SupportedRules' */
#ifndef SOAP_TYPE_tt__SupportedRules
#define SOAP_TYPE_tt__SupportedRules (635)
#endif

/* tt__ConfigDescriptionExtension has binding name 'tt__ConfigDescriptionExtension' for type 'tt:ConfigDescriptionExtension' */
#ifndef SOAP_TYPE_tt__ConfigDescriptionExtension
#define SOAP_TYPE_tt__ConfigDescriptionExtension (634)
#endif

/* tt__ConfigDescription has binding name 'tt__ConfigDescription' for type 'tt:ConfigDescription' */
#ifndef SOAP_TYPE_tt__ConfigDescription
#define SOAP_TYPE_tt__ConfigDescription (633)
#endif

/* tt__Config has binding name 'tt__Config' for type 'tt:Config' */
#ifndef SOAP_TYPE_tt__Config
#define SOAP_TYPE_tt__Config (632)
#endif

/* tt__RuleEngineConfigurationExtension has binding name 'tt__RuleEngineConfigurationExtension' for type 'tt:RuleEngineConfigurationExtension' */
#ifndef SOAP_TYPE_tt__RuleEngineConfigurationExtension
#define SOAP_TYPE_tt__RuleEngineConfigurationExtension (631)
#endif

/* tt__RuleEngineConfiguration has binding name 'tt__RuleEngineConfiguration' for type 'tt:RuleEngineConfiguration' */
#ifndef SOAP_TYPE_tt__RuleEngineConfiguration
#define SOAP_TYPE_tt__RuleEngineConfiguration (630)
#endif

/* tt__AnalyticsEngineConfigurationExtension has binding name 'tt__AnalyticsEngineConfigurationExtension' for type 'tt:AnalyticsEngineConfigurationExtension' */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension (629)
#endif

/* tt__AnalyticsEngineConfiguration has binding name 'tt__AnalyticsEngineConfiguration' for type 'tt:AnalyticsEngineConfiguration' */
#ifndef SOAP_TYPE_tt__AnalyticsEngineConfiguration
#define SOAP_TYPE_tt__AnalyticsEngineConfiguration (628)
#endif

/* tt__Polyline has binding name 'tt__Polyline' for type 'tt:Polyline' */
#ifndef SOAP_TYPE_tt__Polyline
#define SOAP_TYPE_tt__Polyline (627)
#endif

/* tt__ItemListDescriptionExtension has binding name 'tt__ItemListDescriptionExtension' for type 'tt:ItemListDescriptionExtension' */
#ifndef SOAP_TYPE_tt__ItemListDescriptionExtension
#define SOAP_TYPE_tt__ItemListDescriptionExtension (626)
#endif

/* tt__ItemListDescription has binding name 'tt__ItemListDescription' for type 'tt:ItemListDescription' */
#ifndef SOAP_TYPE_tt__ItemListDescription
#define SOAP_TYPE_tt__ItemListDescription (625)
#endif

/* tt__MessageDescriptionExtension has binding name 'tt__MessageDescriptionExtension' for type 'tt:MessageDescriptionExtension' */
#ifndef SOAP_TYPE_tt__MessageDescriptionExtension
#define SOAP_TYPE_tt__MessageDescriptionExtension (624)
#endif

/* tt__MessageDescription has binding name 'tt__MessageDescription' for type 'tt:MessageDescription' */
#ifndef SOAP_TYPE_tt__MessageDescription
#define SOAP_TYPE_tt__MessageDescription (623)
#endif

/* tt__ItemListExtension has binding name 'tt__ItemListExtension' for type 'tt:ItemListExtension' */
#ifndef SOAP_TYPE_tt__ItemListExtension
#define SOAP_TYPE_tt__ItemListExtension (622)
#endif

/* tt__ItemList has binding name 'tt__ItemList' for type 'tt:ItemList' */
#ifndef SOAP_TYPE_tt__ItemList
#define SOAP_TYPE_tt__ItemList (621)
#endif

/* tt__MessageExtension has binding name 'tt__MessageExtension' for type 'tt:MessageExtension' */
#ifndef SOAP_TYPE_tt__MessageExtension
#define SOAP_TYPE_tt__MessageExtension (620)
#endif

/* tt__NoiseReductionOptions has binding name 'tt__NoiseReductionOptions' for type 'tt:NoiseReductionOptions' */
#ifndef SOAP_TYPE_tt__NoiseReductionOptions
#define SOAP_TYPE_tt__NoiseReductionOptions (619)
#endif

/* tt__DefoggingOptions has binding name 'tt__DefoggingOptions' for type 'tt:DefoggingOptions' */
#ifndef SOAP_TYPE_tt__DefoggingOptions
#define SOAP_TYPE_tt__DefoggingOptions (618)
#endif

/* tt__ToneCompensationOptions has binding name 'tt__ToneCompensationOptions' for type 'tt:ToneCompensationOptions' */
#ifndef SOAP_TYPE_tt__ToneCompensationOptions
#define SOAP_TYPE_tt__ToneCompensationOptions (617)
#endif

/* tt__FocusOptions20Extension has binding name 'tt__FocusOptions20Extension' for type 'tt:FocusOptions20Extension' */
#ifndef SOAP_TYPE_tt__FocusOptions20Extension
#define SOAP_TYPE_tt__FocusOptions20Extension (616)
#endif

/* tt__FocusOptions20 has binding name 'tt__FocusOptions20' for type 'tt:FocusOptions20' */
#ifndef SOAP_TYPE_tt__FocusOptions20
#define SOAP_TYPE_tt__FocusOptions20 (615)
#endif

/* tt__WhiteBalanceOptions20Extension has binding name 'tt__WhiteBalanceOptions20Extension' for type 'tt:WhiteBalanceOptions20Extension' */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20Extension
#define SOAP_TYPE_tt__WhiteBalanceOptions20Extension (614)
#endif

/* tt__WhiteBalanceOptions20 has binding name 'tt__WhiteBalanceOptions20' for type 'tt:WhiteBalanceOptions20' */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions20
#define SOAP_TYPE_tt__WhiteBalanceOptions20 (613)
#endif

/* tt__FocusConfiguration20Extension has binding name 'tt__FocusConfiguration20Extension' for type 'tt:FocusConfiguration20Extension' */
#ifndef SOAP_TYPE_tt__FocusConfiguration20Extension
#define SOAP_TYPE_tt__FocusConfiguration20Extension (612)
#endif

/* tt__FocusConfiguration20 has binding name 'tt__FocusConfiguration20' for type 'tt:FocusConfiguration20' */
#ifndef SOAP_TYPE_tt__FocusConfiguration20
#define SOAP_TYPE_tt__FocusConfiguration20 (611)
#endif

/* tt__WhiteBalance20Extension has binding name 'tt__WhiteBalance20Extension' for type 'tt:WhiteBalance20Extension' */
#ifndef SOAP_TYPE_tt__WhiteBalance20Extension
#define SOAP_TYPE_tt__WhiteBalance20Extension (610)
#endif

/* tt__WhiteBalance20 has binding name 'tt__WhiteBalance20' for type 'tt:WhiteBalance20' */
#ifndef SOAP_TYPE_tt__WhiteBalance20
#define SOAP_TYPE_tt__WhiteBalance20 (609)
#endif

/* tt__RelativeFocusOptions20 has binding name 'tt__RelativeFocusOptions20' for type 'tt:RelativeFocusOptions20' */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions20
#define SOAP_TYPE_tt__RelativeFocusOptions20 (608)
#endif

/* tt__MoveOptions20 has binding name 'tt__MoveOptions20' for type 'tt:MoveOptions20' */
#ifndef SOAP_TYPE_tt__MoveOptions20
#define SOAP_TYPE_tt__MoveOptions20 (607)
#endif

/* tt__ExposureOptions20 has binding name 'tt__ExposureOptions20' for type 'tt:ExposureOptions20' */
#ifndef SOAP_TYPE_tt__ExposureOptions20
#define SOAP_TYPE_tt__ExposureOptions20 (606)
#endif

/* tt__BacklightCompensationOptions20 has binding name 'tt__BacklightCompensationOptions20' for type 'tt:BacklightCompensationOptions20' */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions20
#define SOAP_TYPE_tt__BacklightCompensationOptions20 (605)
#endif

/* tt__WideDynamicRangeOptions20 has binding name 'tt__WideDynamicRangeOptions20' for type 'tt:WideDynamicRangeOptions20' */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions20
#define SOAP_TYPE_tt__WideDynamicRangeOptions20 (604)
#endif

/* tt__IrCutFilterAutoAdjustmentOptionsExtension has binding name 'tt__IrCutFilterAutoAdjustmentOptionsExtension' for type 'tt:IrCutFilterAutoAdjustmentOptionsExtension' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptionsExtension (603)
#endif

/* tt__IrCutFilterAutoAdjustmentOptions has binding name 'tt__IrCutFilterAutoAdjustmentOptions' for type 'tt:IrCutFilterAutoAdjustmentOptions' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentOptions (602)
#endif

/* tt__ImageStabilizationOptionsExtension has binding name 'tt__ImageStabilizationOptionsExtension' for type 'tt:ImageStabilizationOptionsExtension' */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptionsExtension
#define SOAP_TYPE_tt__ImageStabilizationOptionsExtension (601)
#endif

/* tt__ImageStabilizationOptions has binding name 'tt__ImageStabilizationOptions' for type 'tt:ImageStabilizationOptions' */
#ifndef SOAP_TYPE_tt__ImageStabilizationOptions
#define SOAP_TYPE_tt__ImageStabilizationOptions (600)
#endif

/* tt__ImagingOptions20Extension4 has binding name 'tt__ImagingOptions20Extension4' for type 'tt:ImagingOptions20Extension4' */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension4
#define SOAP_TYPE_tt__ImagingOptions20Extension4 (599)
#endif

/* tt__ImagingOptions20Extension3 has binding name 'tt__ImagingOptions20Extension3' for type 'tt:ImagingOptions20Extension3' */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension3
#define SOAP_TYPE_tt__ImagingOptions20Extension3 (598)
#endif

/* tt__ImagingOptions20Extension2 has binding name 'tt__ImagingOptions20Extension2' for type 'tt:ImagingOptions20Extension2' */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension2
#define SOAP_TYPE_tt__ImagingOptions20Extension2 (597)
#endif

/* tt__ImagingOptions20Extension has binding name 'tt__ImagingOptions20Extension' for type 'tt:ImagingOptions20Extension' */
#ifndef SOAP_TYPE_tt__ImagingOptions20Extension
#define SOAP_TYPE_tt__ImagingOptions20Extension (596)
#endif

/* tt__ImagingOptions20 has binding name 'tt__ImagingOptions20' for type 'tt:ImagingOptions20' */
#ifndef SOAP_TYPE_tt__ImagingOptions20
#define SOAP_TYPE_tt__ImagingOptions20 (595)
#endif

/* tt__NoiseReduction has binding name 'tt__NoiseReduction' for type 'tt:NoiseReduction' */
#ifndef SOAP_TYPE_tt__NoiseReduction
#define SOAP_TYPE_tt__NoiseReduction (594)
#endif

/* tt__DefoggingExtension has binding name 'tt__DefoggingExtension' for type 'tt:DefoggingExtension' */
#ifndef SOAP_TYPE_tt__DefoggingExtension
#define SOAP_TYPE_tt__DefoggingExtension (593)
#endif

/* tt__Defogging has binding name 'tt__Defogging' for type 'tt:Defogging' */
#ifndef SOAP_TYPE_tt__Defogging
#define SOAP_TYPE_tt__Defogging (592)
#endif

/* tt__ToneCompensationExtension has binding name 'tt__ToneCompensationExtension' for type 'tt:ToneCompensationExtension' */
#ifndef SOAP_TYPE_tt__ToneCompensationExtension
#define SOAP_TYPE_tt__ToneCompensationExtension (591)
#endif

/* tt__ToneCompensation has binding name 'tt__ToneCompensation' for type 'tt:ToneCompensation' */
#ifndef SOAP_TYPE_tt__ToneCompensation
#define SOAP_TYPE_tt__ToneCompensation (590)
#endif

/* tt__Exposure20 has binding name 'tt__Exposure20' for type 'tt:Exposure20' */
#ifndef SOAP_TYPE_tt__Exposure20
#define SOAP_TYPE_tt__Exposure20 (589)
#endif

/* tt__BacklightCompensation20 has binding name 'tt__BacklightCompensation20' for type 'tt:BacklightCompensation20' */
#ifndef SOAP_TYPE_tt__BacklightCompensation20
#define SOAP_TYPE_tt__BacklightCompensation20 (588)
#endif

/* tt__WideDynamicRange20 has binding name 'tt__WideDynamicRange20' for type 'tt:WideDynamicRange20' */
#ifndef SOAP_TYPE_tt__WideDynamicRange20
#define SOAP_TYPE_tt__WideDynamicRange20 (587)
#endif

/* tt__IrCutFilterAutoAdjustmentExtension has binding name 'tt__IrCutFilterAutoAdjustmentExtension' for type 'tt:IrCutFilterAutoAdjustmentExtension' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustmentExtension (586)
#endif

/* tt__IrCutFilterAutoAdjustment has binding name 'tt__IrCutFilterAutoAdjustment' for type 'tt:IrCutFilterAutoAdjustment' */
#ifndef SOAP_TYPE_tt__IrCutFilterAutoAdjustment
#define SOAP_TYPE_tt__IrCutFilterAutoAdjustment (585)
#endif

/* tt__ImageStabilizationExtension has binding name 'tt__ImageStabilizationExtension' for type 'tt:ImageStabilizationExtension' */
#ifndef SOAP_TYPE_tt__ImageStabilizationExtension
#define SOAP_TYPE_tt__ImageStabilizationExtension (584)
#endif

/* tt__ImageStabilization has binding name 'tt__ImageStabilization' for type 'tt:ImageStabilization' */
#ifndef SOAP_TYPE_tt__ImageStabilization
#define SOAP_TYPE_tt__ImageStabilization (583)
#endif

/* tt__ImagingSettingsExtension204 has binding name 'tt__ImagingSettingsExtension204' for type 'tt:ImagingSettingsExtension204' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension204
#define SOAP_TYPE_tt__ImagingSettingsExtension204 (582)
#endif

/* tt__ImagingSettingsExtension203 has binding name 'tt__ImagingSettingsExtension203' for type 'tt:ImagingSettingsExtension203' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension203
#define SOAP_TYPE_tt__ImagingSettingsExtension203 (581)
#endif

/* tt__ImagingSettingsExtension202 has binding name 'tt__ImagingSettingsExtension202' for type 'tt:ImagingSettingsExtension202' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension202
#define SOAP_TYPE_tt__ImagingSettingsExtension202 (580)
#endif

/* tt__ImagingSettingsExtension20 has binding name 'tt__ImagingSettingsExtension20' for type 'tt:ImagingSettingsExtension20' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension20
#define SOAP_TYPE_tt__ImagingSettingsExtension20 (579)
#endif

/* tt__ImagingSettings20 has binding name 'tt__ImagingSettings20' for type 'tt:ImagingSettings20' */
#ifndef SOAP_TYPE_tt__ImagingSettings20
#define SOAP_TYPE_tt__ImagingSettings20 (578)
#endif

/* tt__FocusStatus20Extension has binding name 'tt__FocusStatus20Extension' for type 'tt:FocusStatus20Extension' */
#ifndef SOAP_TYPE_tt__FocusStatus20Extension
#define SOAP_TYPE_tt__FocusStatus20Extension (577)
#endif

/* tt__FocusStatus20 has binding name 'tt__FocusStatus20' for type 'tt:FocusStatus20' */
#ifndef SOAP_TYPE_tt__FocusStatus20
#define SOAP_TYPE_tt__FocusStatus20 (576)
#endif

/* tt__ImagingStatus20Extension has binding name 'tt__ImagingStatus20Extension' for type 'tt:ImagingStatus20Extension' */
#ifndef SOAP_TYPE_tt__ImagingStatus20Extension
#define SOAP_TYPE_tt__ImagingStatus20Extension (575)
#endif

/* tt__ImagingStatus20 has binding name 'tt__ImagingStatus20' for type 'tt:ImagingStatus20' */
#ifndef SOAP_TYPE_tt__ImagingStatus20
#define SOAP_TYPE_tt__ImagingStatus20 (574)
#endif

/* tt__WhiteBalance has binding name 'tt__WhiteBalance' for type 'tt:WhiteBalance' */
#ifndef SOAP_TYPE_tt__WhiteBalance
#define SOAP_TYPE_tt__WhiteBalance (573)
#endif

/* tt__ContinuousFocusOptions has binding name 'tt__ContinuousFocusOptions' for type 'tt:ContinuousFocusOptions' */
#ifndef SOAP_TYPE_tt__ContinuousFocusOptions
#define SOAP_TYPE_tt__ContinuousFocusOptions (572)
#endif

/* tt__RelativeFocusOptions has binding name 'tt__RelativeFocusOptions' for type 'tt:RelativeFocusOptions' */
#ifndef SOAP_TYPE_tt__RelativeFocusOptions
#define SOAP_TYPE_tt__RelativeFocusOptions (571)
#endif

/* tt__AbsoluteFocusOptions has binding name 'tt__AbsoluteFocusOptions' for type 'tt:AbsoluteFocusOptions' */
#ifndef SOAP_TYPE_tt__AbsoluteFocusOptions
#define SOAP_TYPE_tt__AbsoluteFocusOptions (570)
#endif

/* tt__MoveOptions has binding name 'tt__MoveOptions' for type 'tt:MoveOptions' */
#ifndef SOAP_TYPE_tt__MoveOptions
#define SOAP_TYPE_tt__MoveOptions (569)
#endif

/* tt__ContinuousFocus has binding name 'tt__ContinuousFocus' for type 'tt:ContinuousFocus' */
#ifndef SOAP_TYPE_tt__ContinuousFocus
#define SOAP_TYPE_tt__ContinuousFocus (568)
#endif

/* tt__RelativeFocus has binding name 'tt__RelativeFocus' for type 'tt:RelativeFocus' */
#ifndef SOAP_TYPE_tt__RelativeFocus
#define SOAP_TYPE_tt__RelativeFocus (567)
#endif

/* tt__AbsoluteFocus has binding name 'tt__AbsoluteFocus' for type 'tt:AbsoluteFocus' */
#ifndef SOAP_TYPE_tt__AbsoluteFocus
#define SOAP_TYPE_tt__AbsoluteFocus (566)
#endif

/* tt__FocusMove has binding name 'tt__FocusMove' for type 'tt:FocusMove' */
#ifndef SOAP_TYPE_tt__FocusMove
#define SOAP_TYPE_tt__FocusMove (565)
#endif

/* tt__WhiteBalanceOptions has binding name 'tt__WhiteBalanceOptions' for type 'tt:WhiteBalanceOptions' */
#ifndef SOAP_TYPE_tt__WhiteBalanceOptions
#define SOAP_TYPE_tt__WhiteBalanceOptions (564)
#endif

/* tt__ExposureOptions has binding name 'tt__ExposureOptions' for type 'tt:ExposureOptions' */
#ifndef SOAP_TYPE_tt__ExposureOptions
#define SOAP_TYPE_tt__ExposureOptions (563)
#endif

/* tt__FocusOptions has binding name 'tt__FocusOptions' for type 'tt:FocusOptions' */
#ifndef SOAP_TYPE_tt__FocusOptions
#define SOAP_TYPE_tt__FocusOptions (562)
#endif

/* tt__BacklightCompensationOptions has binding name 'tt__BacklightCompensationOptions' for type 'tt:BacklightCompensationOptions' */
#ifndef SOAP_TYPE_tt__BacklightCompensationOptions
#define SOAP_TYPE_tt__BacklightCompensationOptions (561)
#endif

/* tt__WideDynamicRangeOptions has binding name 'tt__WideDynamicRangeOptions' for type 'tt:WideDynamicRangeOptions' */
#ifndef SOAP_TYPE_tt__WideDynamicRangeOptions
#define SOAP_TYPE_tt__WideDynamicRangeOptions (560)
#endif

/* tt__ImagingOptions has binding name 'tt__ImagingOptions' for type 'tt:ImagingOptions' */
#ifndef SOAP_TYPE_tt__ImagingOptions
#define SOAP_TYPE_tt__ImagingOptions (559)
#endif

/* tt__BacklightCompensation has binding name 'tt__BacklightCompensation' for type 'tt:BacklightCompensation' */
#ifndef SOAP_TYPE_tt__BacklightCompensation
#define SOAP_TYPE_tt__BacklightCompensation (558)
#endif

/* tt__WideDynamicRange has binding name 'tt__WideDynamicRange' for type 'tt:WideDynamicRange' */
#ifndef SOAP_TYPE_tt__WideDynamicRange
#define SOAP_TYPE_tt__WideDynamicRange (557)
#endif

/* tt__Exposure has binding name 'tt__Exposure' for type 'tt:Exposure' */
#ifndef SOAP_TYPE_tt__Exposure
#define SOAP_TYPE_tt__Exposure (556)
#endif

/* tt__ImagingSettingsExtension has binding name 'tt__ImagingSettingsExtension' for type 'tt:ImagingSettingsExtension' */
#ifndef SOAP_TYPE_tt__ImagingSettingsExtension
#define SOAP_TYPE_tt__ImagingSettingsExtension (555)
#endif

/* tt__ImagingSettings has binding name 'tt__ImagingSettings' for type 'tt:ImagingSettings' */
#ifndef SOAP_TYPE_tt__ImagingSettings
#define SOAP_TYPE_tt__ImagingSettings (554)
#endif

/* tt__FocusConfiguration has binding name 'tt__FocusConfiguration' for type 'tt:FocusConfiguration' */
#ifndef SOAP_TYPE_tt__FocusConfiguration
#define SOAP_TYPE_tt__FocusConfiguration (553)
#endif

/* tt__FocusStatus has binding name 'tt__FocusStatus' for type 'tt:FocusStatus' */
#ifndef SOAP_TYPE_tt__FocusStatus
#define SOAP_TYPE_tt__FocusStatus (552)
#endif

/* tt__ImagingStatus has binding name 'tt__ImagingStatus' for type 'tt:ImagingStatus' */
#ifndef SOAP_TYPE_tt__ImagingStatus
#define SOAP_TYPE_tt__ImagingStatus (551)
#endif

/* tt__PTZPresetTourStartingConditionOptionsExtension has binding name 'tt__PTZPresetTourStartingConditionOptionsExtension' for type 'tt:PTZPresetTourStartingConditionOptionsExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension (550)
#endif

/* tt__PTZPresetTourStartingConditionOptions has binding name 'tt__PTZPresetTourStartingConditionOptions' for type 'tt:PTZPresetTourStartingConditionOptions' */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions (549)
#endif

/* tt__PTZPresetTourPresetDetailOptionsExtension has binding name 'tt__PTZPresetTourPresetDetailOptionsExtension' for type 'tt:PTZPresetTourPresetDetailOptionsExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension (548)
#endif

/* tt__PTZPresetTourPresetDetailOptions has binding name 'tt__PTZPresetTourPresetDetailOptions' for type 'tt:PTZPresetTourPresetDetailOptions' */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions (547)
#endif

/* tt__PTZPresetTourSpotOptions has binding name 'tt__PTZPresetTourSpotOptions' for type 'tt:PTZPresetTourSpotOptions' */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotOptions
#define SOAP_TYPE_tt__PTZPresetTourSpotOptions (546)
#endif

/* tt__PTZPresetTourOptions has binding name 'tt__PTZPresetTourOptions' for type 'tt:PTZPresetTourOptions' */
#ifndef SOAP_TYPE_tt__PTZPresetTourOptions
#define SOAP_TYPE_tt__PTZPresetTourOptions (545)
#endif

/* tt__PTZPresetTourStartingConditionExtension has binding name 'tt__PTZPresetTourStartingConditionExtension' for type 'tt:PTZPresetTourStartingConditionExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension (544)
#endif

/* tt__PTZPresetTourStartingCondition has binding name 'tt__PTZPresetTourStartingCondition' for type 'tt:PTZPresetTourStartingCondition' */
#ifndef SOAP_TYPE_tt__PTZPresetTourStartingCondition
#define SOAP_TYPE_tt__PTZPresetTourStartingCondition (543)
#endif

/* tt__PTZPresetTourStatusExtension has binding name 'tt__PTZPresetTourStatusExtension' for type 'tt:PTZPresetTourStatusExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatusExtension
#define SOAP_TYPE_tt__PTZPresetTourStatusExtension (542)
#endif

/* tt__PTZPresetTourStatus has binding name 'tt__PTZPresetTourStatus' for type 'tt:PTZPresetTourStatus' */
#ifndef SOAP_TYPE_tt__PTZPresetTourStatus
#define SOAP_TYPE_tt__PTZPresetTourStatus (541)
#endif

/* tt__PTZPresetTourTypeExtension has binding name 'tt__PTZPresetTourTypeExtension' for type 'tt:PTZPresetTourTypeExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourTypeExtension
#define SOAP_TYPE_tt__PTZPresetTourTypeExtension (540)
#endif

/* tt__PTZPresetTourPresetDetail has binding name 'tt__PTZPresetTourPresetDetail' for type 'tt:PTZPresetTourPresetDetail' */
#ifndef SOAP_TYPE_tt__PTZPresetTourPresetDetail
#define SOAP_TYPE_tt__PTZPresetTourPresetDetail (539)
#endif

/* tt__PTZPresetTourSpotExtension has binding name 'tt__PTZPresetTourSpotExtension' for type 'tt:PTZPresetTourSpotExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpotExtension
#define SOAP_TYPE_tt__PTZPresetTourSpotExtension (538)
#endif

/* tt__PTZPresetTourSpot has binding name 'tt__PTZPresetTourSpot' for type 'tt:PTZPresetTourSpot' */
#ifndef SOAP_TYPE_tt__PTZPresetTourSpot
#define SOAP_TYPE_tt__PTZPresetTourSpot (537)
#endif

/* tt__PTZPresetTourExtension has binding name 'tt__PTZPresetTourExtension' for type 'tt:PTZPresetTourExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourExtension
#define SOAP_TYPE_tt__PTZPresetTourExtension (536)
#endif

/* tt__PresetTour has binding name 'tt__PresetTour' for type 'tt:PresetTour' */
#ifndef SOAP_TYPE_tt__PresetTour
#define SOAP_TYPE_tt__PresetTour (535)
#endif

/* tt__PTZPreset has binding name 'tt__PTZPreset' for type 'tt:PTZPreset' */
#ifndef SOAP_TYPE_tt__PTZPreset
#define SOAP_TYPE_tt__PTZPreset (534)
#endif

/* tt__PTZSpeed has binding name 'tt__PTZSpeed' for type 'tt:PTZSpeed' */
#ifndef SOAP_TYPE_tt__PTZSpeed
#define SOAP_TYPE_tt__PTZSpeed (533)
#endif

/* tt__Space1DDescription has binding name 'tt__Space1DDescription' for type 'tt:Space1DDescription' */
#ifndef SOAP_TYPE_tt__Space1DDescription
#define SOAP_TYPE_tt__Space1DDescription (532)
#endif

/* tt__Space2DDescription has binding name 'tt__Space2DDescription' for type 'tt:Space2DDescription' */
#ifndef SOAP_TYPE_tt__Space2DDescription
#define SOAP_TYPE_tt__Space2DDescription (531)
#endif

/* tt__PTZSpacesExtension has binding name 'tt__PTZSpacesExtension' for type 'tt:PTZSpacesExtension' */
#ifndef SOAP_TYPE_tt__PTZSpacesExtension
#define SOAP_TYPE_tt__PTZSpacesExtension (530)
#endif

/* tt__PTZSpaces has binding name 'tt__PTZSpaces' for type 'tt:PTZSpaces' */
#ifndef SOAP_TYPE_tt__PTZSpaces
#define SOAP_TYPE_tt__PTZSpaces (529)
#endif

/* tt__ZoomLimits has binding name 'tt__ZoomLimits' for type 'tt:ZoomLimits' */
#ifndef SOAP_TYPE_tt__ZoomLimits
#define SOAP_TYPE_tt__ZoomLimits (528)
#endif

/* tt__PanTiltLimits has binding name 'tt__PanTiltLimits' for type 'tt:PanTiltLimits' */
#ifndef SOAP_TYPE_tt__PanTiltLimits
#define SOAP_TYPE_tt__PanTiltLimits (527)
#endif

/* tt__ReverseOptionsExtension has binding name 'tt__ReverseOptionsExtension' for type 'tt:ReverseOptionsExtension' */
#ifndef SOAP_TYPE_tt__ReverseOptionsExtension
#define SOAP_TYPE_tt__ReverseOptionsExtension (526)
#endif

/* tt__ReverseOptions has binding name 'tt__ReverseOptions' for type 'tt:ReverseOptions' */
#ifndef SOAP_TYPE_tt__ReverseOptions
#define SOAP_TYPE_tt__ReverseOptions (525)
#endif

/* tt__EFlipOptionsExtension has binding name 'tt__EFlipOptionsExtension' for type 'tt:EFlipOptionsExtension' */
#ifndef SOAP_TYPE_tt__EFlipOptionsExtension
#define SOAP_TYPE_tt__EFlipOptionsExtension (524)
#endif

/* tt__EFlipOptions has binding name 'tt__EFlipOptions' for type 'tt:EFlipOptions' */
#ifndef SOAP_TYPE_tt__EFlipOptions
#define SOAP_TYPE_tt__EFlipOptions (523)
#endif

/* tt__PTControlDirectionOptionsExtension has binding name 'tt__PTControlDirectionOptionsExtension' for type 'tt:PTControlDirectionOptionsExtension' */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptionsExtension
#define SOAP_TYPE_tt__PTControlDirectionOptionsExtension (522)
#endif

/* tt__PTControlDirectionOptions has binding name 'tt__PTControlDirectionOptions' for type 'tt:PTControlDirectionOptions' */
#ifndef SOAP_TYPE_tt__PTControlDirectionOptions
#define SOAP_TYPE_tt__PTControlDirectionOptions (521)
#endif

/* tt__PTZConfigurationOptions2 has binding name 'tt__PTZConfigurationOptions2' for type 'tt:PTZConfigurationOptions2' */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions2
#define SOAP_TYPE_tt__PTZConfigurationOptions2 (520)
#endif

/* tt__PTZConfigurationOptions has binding name 'tt__PTZConfigurationOptions' for type 'tt:PTZConfigurationOptions' */
#ifndef SOAP_TYPE_tt__PTZConfigurationOptions
#define SOAP_TYPE_tt__PTZConfigurationOptions (519)
#endif

/* tt__Reverse has binding name 'tt__Reverse' for type 'tt:Reverse' */
#ifndef SOAP_TYPE_tt__Reverse
#define SOAP_TYPE_tt__Reverse (518)
#endif

/* tt__EFlip has binding name 'tt__EFlip' for type 'tt:EFlip' */
#ifndef SOAP_TYPE_tt__EFlip
#define SOAP_TYPE_tt__EFlip (517)
#endif

/* tt__PTControlDirectionExtension has binding name 'tt__PTControlDirectionExtension' for type 'tt:PTControlDirectionExtension' */
#ifndef SOAP_TYPE_tt__PTControlDirectionExtension
#define SOAP_TYPE_tt__PTControlDirectionExtension (516)
#endif

/* tt__PTControlDirection has binding name 'tt__PTControlDirection' for type 'tt:PTControlDirection' */
#ifndef SOAP_TYPE_tt__PTControlDirection
#define SOAP_TYPE_tt__PTControlDirection (515)
#endif

/* tt__PTZConfigurationExtension2 has binding name 'tt__PTZConfigurationExtension2' for type 'tt:PTZConfigurationExtension2' */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension2
#define SOAP_TYPE_tt__PTZConfigurationExtension2 (514)
#endif

/* tt__PTZConfigurationExtension has binding name 'tt__PTZConfigurationExtension' for type 'tt:PTZConfigurationExtension' */
#ifndef SOAP_TYPE_tt__PTZConfigurationExtension
#define SOAP_TYPE_tt__PTZConfigurationExtension (513)
#endif

/* tt__PTZConfiguration has binding name 'tt__PTZConfiguration' for type 'tt:PTZConfiguration' */
#ifndef SOAP_TYPE_tt__PTZConfiguration
#define SOAP_TYPE_tt__PTZConfiguration (512)
#endif

/* tt__PTZPresetTourSupportedExtension has binding name 'tt__PTZPresetTourSupportedExtension' for type 'tt:PTZPresetTourSupportedExtension' */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupportedExtension
#define SOAP_TYPE_tt__PTZPresetTourSupportedExtension (511)
#endif

/* tt__PTZPresetTourSupported has binding name 'tt__PTZPresetTourSupported' for type 'tt:PTZPresetTourSupported' */
#ifndef SOAP_TYPE_tt__PTZPresetTourSupported
#define SOAP_TYPE_tt__PTZPresetTourSupported (510)
#endif

/* tt__PTZNodeExtension2 has binding name 'tt__PTZNodeExtension2' for type 'tt:PTZNodeExtension2' */
#ifndef SOAP_TYPE_tt__PTZNodeExtension2
#define SOAP_TYPE_tt__PTZNodeExtension2 (509)
#endif

/* tt__PTZNodeExtension has binding name 'tt__PTZNodeExtension' for type 'tt:PTZNodeExtension' */
#ifndef SOAP_TYPE_tt__PTZNodeExtension
#define SOAP_TYPE_tt__PTZNodeExtension (508)
#endif

/* tt__PTZNode has binding name 'tt__PTZNode' for type 'tt:PTZNode' */
#ifndef SOAP_TYPE_tt__PTZNode
#define SOAP_TYPE_tt__PTZNode (507)
#endif

/* tt__DigitalInput has binding name 'tt__DigitalInput' for type 'tt:DigitalInput' */
#ifndef SOAP_TYPE_tt__DigitalInput
#define SOAP_TYPE_tt__DigitalInput (506)
#endif

/* tt__RelayOutput has binding name 'tt__RelayOutput' for type 'tt:RelayOutput' */
#ifndef SOAP_TYPE_tt__RelayOutput
#define SOAP_TYPE_tt__RelayOutput (505)
#endif

/* tt__RelayOutputSettings has binding name 'tt__RelayOutputSettings' for type 'tt:RelayOutputSettings' */
#ifndef SOAP_TYPE_tt__RelayOutputSettings
#define SOAP_TYPE_tt__RelayOutputSettings (504)
#endif

/* tt__GenericEapPwdConfigurationExtension has binding name 'tt__GenericEapPwdConfigurationExtension' for type 'tt:GenericEapPwdConfigurationExtension' */
#ifndef SOAP_TYPE_tt__GenericEapPwdConfigurationExtension
#define SOAP_TYPE_tt__GenericEapPwdConfigurationExtension (503)
#endif

/* tt__TLSConfiguration has binding name 'tt__TLSConfiguration' for type 'tt:TLSConfiguration' */
#ifndef SOAP_TYPE_tt__TLSConfiguration
#define SOAP_TYPE_tt__TLSConfiguration (502)
#endif

/* tt__EapMethodExtension has binding name 'tt__EapMethodExtension' for type 'tt:EapMethodExtension' */
#ifndef SOAP_TYPE_tt__EapMethodExtension
#define SOAP_TYPE_tt__EapMethodExtension (501)
#endif

/* tt__EAPMethodConfiguration has binding name 'tt__EAPMethodConfiguration' for type 'tt:EAPMethodConfiguration' */
#ifndef SOAP_TYPE_tt__EAPMethodConfiguration
#define SOAP_TYPE_tt__EAPMethodConfiguration (500)
#endif

/* tt__Dot1XConfigurationExtension has binding name 'tt__Dot1XConfigurationExtension' for type 'tt:Dot1XConfigurationExtension' */
#ifndef SOAP_TYPE_tt__Dot1XConfigurationExtension
#define SOAP_TYPE_tt__Dot1XConfigurationExtension (499)
#endif

/* tt__Dot1XConfiguration has binding name 'tt__Dot1XConfiguration' for type 'tt:Dot1XConfiguration' */
#ifndef SOAP_TYPE_tt__Dot1XConfiguration
#define SOAP_TYPE_tt__Dot1XConfiguration (498)
#endif

/* tt__CertificateInformationExtension has binding name 'tt__CertificateInformationExtension' for type 'tt:CertificateInformationExtension' */
#ifndef SOAP_TYPE_tt__CertificateInformationExtension
#define SOAP_TYPE_tt__CertificateInformationExtension (497)
#endif

/* tt__CertificateUsage has binding name 'tt__CertificateUsage' for type 'tt:CertificateUsage' */
#ifndef SOAP_TYPE_tt__CertificateUsage
#define SOAP_TYPE_tt__CertificateUsage (496)
#endif

/* tt__CertificateInformation has binding name 'tt__CertificateInformation' for type 'tt:CertificateInformation' */
#ifndef SOAP_TYPE_tt__CertificateInformation
#define SOAP_TYPE_tt__CertificateInformation (495)
#endif

/* tt__CertificateWithPrivateKey has binding name 'tt__CertificateWithPrivateKey' for type 'tt:CertificateWithPrivateKey' */
#ifndef SOAP_TYPE_tt__CertificateWithPrivateKey
#define SOAP_TYPE_tt__CertificateWithPrivateKey (494)
#endif

/* tt__CertificateStatus has binding name 'tt__CertificateStatus' for type 'tt:CertificateStatus' */
#ifndef SOAP_TYPE_tt__CertificateStatus
#define SOAP_TYPE_tt__CertificateStatus (493)
#endif

/* tt__Certificate has binding name 'tt__Certificate' for type 'tt:Certificate' */
#ifndef SOAP_TYPE_tt__Certificate
#define SOAP_TYPE_tt__Certificate (492)
#endif

/* tt__CertificateGenerationParametersExtension has binding name 'tt__CertificateGenerationParametersExtension' for type 'tt:CertificateGenerationParametersExtension' */
#ifndef SOAP_TYPE_tt__CertificateGenerationParametersExtension
#define SOAP_TYPE_tt__CertificateGenerationParametersExtension (491)
#endif

/* tt__CertificateGenerationParameters has binding name 'tt__CertificateGenerationParameters' for type 'tt:CertificateGenerationParameters' */
#ifndef SOAP_TYPE_tt__CertificateGenerationParameters
#define SOAP_TYPE_tt__CertificateGenerationParameters (490)
#endif

/* tt__UserExtension has binding name 'tt__UserExtension' for type 'tt:UserExtension' */
#ifndef SOAP_TYPE_tt__UserExtension
#define SOAP_TYPE_tt__UserExtension (489)
#endif

/* tt__User has binding name 'tt__User' for type 'tt:User' */
#ifndef SOAP_TYPE_tt__User
#define SOAP_TYPE_tt__User (488)
#endif

/* tt__RemoteUser has binding name 'tt__RemoteUser' for type 'tt:RemoteUser' */
#ifndef SOAP_TYPE_tt__RemoteUser
#define SOAP_TYPE_tt__RemoteUser (487)
#endif

/* tt__TimeZone has binding name 'tt__TimeZone' for type 'tt:TimeZone' */
#ifndef SOAP_TYPE_tt__TimeZone
#define SOAP_TYPE_tt__TimeZone (486)
#endif

/* tt__Time has binding name 'tt__Time' for type 'tt:Time' */
#ifndef SOAP_TYPE_tt__Time
#define SOAP_TYPE_tt__Time (485)
#endif

/* tt__Date has binding name 'tt__Date' for type 'tt:Date' */
#ifndef SOAP_TYPE_tt__Date
#define SOAP_TYPE_tt__Date (484)
#endif

/* tt__DateTime has binding name 'tt__DateTime' for type 'tt:DateTime' */
#ifndef SOAP_TYPE_tt__DateTime
#define SOAP_TYPE_tt__DateTime (483)
#endif

/* tt__SystemDateTimeExtension has binding name 'tt__SystemDateTimeExtension' for type 'tt:SystemDateTimeExtension' */
#ifndef SOAP_TYPE_tt__SystemDateTimeExtension
#define SOAP_TYPE_tt__SystemDateTimeExtension (482)
#endif

/* tt__SystemDateTime has binding name 'tt__SystemDateTime' for type 'tt:SystemDateTime' */
#ifndef SOAP_TYPE_tt__SystemDateTime
#define SOAP_TYPE_tt__SystemDateTime (481)
#endif

/* tt__SystemLogUri has binding name 'tt__SystemLogUri' for type 'tt:SystemLogUri' */
#ifndef SOAP_TYPE_tt__SystemLogUri
#define SOAP_TYPE_tt__SystemLogUri (480)
#endif

/* tt__SystemLogUriList has binding name 'tt__SystemLogUriList' for type 'tt:SystemLogUriList' */
#ifndef SOAP_TYPE_tt__SystemLogUriList
#define SOAP_TYPE_tt__SystemLogUriList (479)
#endif

/* tt__BackupFile has binding name 'tt__BackupFile' for type 'tt:BackupFile' */
#ifndef SOAP_TYPE_tt__BackupFile
#define SOAP_TYPE_tt__BackupFile (478)
#endif

/* tt__AttachmentData has binding name 'tt__AttachmentData' for type 'tt:AttachmentData' */
#ifndef SOAP_TYPE_tt__AttachmentData
#define SOAP_TYPE_tt__AttachmentData (477)
#endif

/* tt__BinaryData has binding name 'tt__BinaryData' for type 'tt:BinaryData' */
#ifndef SOAP_TYPE_tt__BinaryData
#define SOAP_TYPE_tt__BinaryData (476)
#endif

/* tt__SupportInformation has binding name 'tt__SupportInformation' for type 'tt:SupportInformation' */
#ifndef SOAP_TYPE_tt__SupportInformation
#define SOAP_TYPE_tt__SupportInformation (475)
#endif

/* tt__SystemLog has binding name 'tt__SystemLog' for type 'tt:SystemLog' */
#ifndef SOAP_TYPE_tt__SystemLog
#define SOAP_TYPE_tt__SystemLog (474)
#endif

/* tt__AnalyticsDeviceExtension has binding name 'tt__AnalyticsDeviceExtension' for type 'tt:AnalyticsDeviceExtension' */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceExtension
#define SOAP_TYPE_tt__AnalyticsDeviceExtension (473)
#endif

/* tt__AnalyticsDeviceCapabilities has binding name 'tt__AnalyticsDeviceCapabilities' for type 'tt:AnalyticsDeviceCapabilities' */
#ifndef SOAP_TYPE_tt__AnalyticsDeviceCapabilities
#define SOAP_TYPE_tt__AnalyticsDeviceCapabilities (472)
#endif

/* tt__ReceiverCapabilities has binding name 'tt__ReceiverCapabilities' for type 'tt:ReceiverCapabilities' */
#ifndef SOAP_TYPE_tt__ReceiverCapabilities
#define SOAP_TYPE_tt__ReceiverCapabilities (471)
#endif

/* tt__ReplayCapabilities has binding name 'tt__ReplayCapabilities' for type 'tt:ReplayCapabilities' */
#ifndef SOAP_TYPE_tt__ReplayCapabilities
#define SOAP_TYPE_tt__ReplayCapabilities (470)
#endif

/* tt__SearchCapabilities has binding name 'tt__SearchCapabilities' for type 'tt:SearchCapabilities' */
#ifndef SOAP_TYPE_tt__SearchCapabilities
#define SOAP_TYPE_tt__SearchCapabilities (469)
#endif

/* tt__RecordingCapabilities has binding name 'tt__RecordingCapabilities' for type 'tt:RecordingCapabilities' */
#ifndef SOAP_TYPE_tt__RecordingCapabilities
#define SOAP_TYPE_tt__RecordingCapabilities (468)
#endif

/* tt__DisplayCapabilities has binding name 'tt__DisplayCapabilities' for type 'tt:DisplayCapabilities' */
#ifndef SOAP_TYPE_tt__DisplayCapabilities
#define SOAP_TYPE_tt__DisplayCapabilities (467)
#endif

/* tt__DeviceIOCapabilities has binding name 'tt__DeviceIOCapabilities' for type 'tt:DeviceIOCapabilities' */
#ifndef SOAP_TYPE_tt__DeviceIOCapabilities
#define SOAP_TYPE_tt__DeviceIOCapabilities (466)
#endif

/* tt__PTZCapabilities has binding name 'tt__PTZCapabilities' for type 'tt:PTZCapabilities' */
#ifndef SOAP_TYPE_tt__PTZCapabilities
#define SOAP_TYPE_tt__PTZCapabilities (465)
#endif

/* tt__ImagingCapabilities has binding name 'tt__ImagingCapabilities' for type 'tt:ImagingCapabilities' */
#ifndef SOAP_TYPE_tt__ImagingCapabilities
#define SOAP_TYPE_tt__ImagingCapabilities (464)
#endif

/* tt__OnvifVersion has binding name 'tt__OnvifVersion' for type 'tt:OnvifVersion' */
#ifndef SOAP_TYPE_tt__OnvifVersion
#define SOAP_TYPE_tt__OnvifVersion (463)
#endif

/* tt__SystemCapabilitiesExtension2 has binding name 'tt__SystemCapabilitiesExtension2' for type 'tt:SystemCapabilitiesExtension2' */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension2
#define SOAP_TYPE_tt__SystemCapabilitiesExtension2 (462)
#endif

/* tt__SystemCapabilitiesExtension has binding name 'tt__SystemCapabilitiesExtension' for type 'tt:SystemCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__SystemCapabilitiesExtension
#define SOAP_TYPE_tt__SystemCapabilitiesExtension (461)
#endif

/* tt__SystemCapabilities has binding name 'tt__SystemCapabilities' for type 'tt:SystemCapabilities' */
#ifndef SOAP_TYPE_tt__SystemCapabilities
#define SOAP_TYPE_tt__SystemCapabilities (460)
#endif

/* tt__SecurityCapabilitiesExtension2 has binding name 'tt__SecurityCapabilitiesExtension2' for type 'tt:SecurityCapabilitiesExtension2' */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension2
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension2 (459)
#endif

/* tt__SecurityCapabilitiesExtension has binding name 'tt__SecurityCapabilitiesExtension' for type 'tt:SecurityCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__SecurityCapabilitiesExtension
#define SOAP_TYPE_tt__SecurityCapabilitiesExtension (458)
#endif

/* tt__SecurityCapabilities has binding name 'tt__SecurityCapabilities' for type 'tt:SecurityCapabilities' */
#ifndef SOAP_TYPE_tt__SecurityCapabilities
#define SOAP_TYPE_tt__SecurityCapabilities (457)
#endif

/* tt__NetworkCapabilitiesExtension2 has binding name 'tt__NetworkCapabilitiesExtension2' for type 'tt:NetworkCapabilitiesExtension2' */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension2
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension2 (456)
#endif

/* tt__NetworkCapabilitiesExtension has binding name 'tt__NetworkCapabilitiesExtension' for type 'tt:NetworkCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__NetworkCapabilitiesExtension
#define SOAP_TYPE_tt__NetworkCapabilitiesExtension (455)
#endif

/* tt__NetworkCapabilities has binding name 'tt__NetworkCapabilities' for type 'tt:NetworkCapabilities' */
#ifndef SOAP_TYPE_tt__NetworkCapabilities
#define SOAP_TYPE_tt__NetworkCapabilities (454)
#endif

/* tt__ProfileCapabilities has binding name 'tt__ProfileCapabilities' for type 'tt:ProfileCapabilities' */
#ifndef SOAP_TYPE_tt__ProfileCapabilities
#define SOAP_TYPE_tt__ProfileCapabilities (453)
#endif

/* tt__RealTimeStreamingCapabilitiesExtension has binding name 'tt__RealTimeStreamingCapabilitiesExtension' for type 'tt:RealTimeStreamingCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension (452)
#endif

/* tt__RealTimeStreamingCapabilities has binding name 'tt__RealTimeStreamingCapabilities' for type 'tt:RealTimeStreamingCapabilities' */
#ifndef SOAP_TYPE_tt__RealTimeStreamingCapabilities
#define SOAP_TYPE_tt__RealTimeStreamingCapabilities (451)
#endif

/* tt__MediaCapabilitiesExtension has binding name 'tt__MediaCapabilitiesExtension' for type 'tt:MediaCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__MediaCapabilitiesExtension
#define SOAP_TYPE_tt__MediaCapabilitiesExtension (450)
#endif

/* tt__MediaCapabilities has binding name 'tt__MediaCapabilities' for type 'tt:MediaCapabilities' */
#ifndef SOAP_TYPE_tt__MediaCapabilities
#define SOAP_TYPE_tt__MediaCapabilities (449)
#endif

/* tt__IOCapabilitiesExtension2 has binding name 'tt__IOCapabilitiesExtension2' for type 'tt:IOCapabilitiesExtension2' */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension2
#define SOAP_TYPE_tt__IOCapabilitiesExtension2 (448)
#endif

/* tt__IOCapabilitiesExtension has binding name 'tt__IOCapabilitiesExtension' for type 'tt:IOCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__IOCapabilitiesExtension
#define SOAP_TYPE_tt__IOCapabilitiesExtension (447)
#endif

/* tt__IOCapabilities has binding name 'tt__IOCapabilities' for type 'tt:IOCapabilities' */
#ifndef SOAP_TYPE_tt__IOCapabilities
#define SOAP_TYPE_tt__IOCapabilities (446)
#endif

/* tt__EventCapabilities has binding name 'tt__EventCapabilities' for type 'tt:EventCapabilities' */
#ifndef SOAP_TYPE_tt__EventCapabilities
#define SOAP_TYPE_tt__EventCapabilities (445)
#endif

/* tt__DeviceCapabilitiesExtension has binding name 'tt__DeviceCapabilitiesExtension' for type 'tt:DeviceCapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__DeviceCapabilitiesExtension
#define SOAP_TYPE_tt__DeviceCapabilitiesExtension (444)
#endif

/* tt__DeviceCapabilities has binding name 'tt__DeviceCapabilities' for type 'tt:DeviceCapabilities' */
#ifndef SOAP_TYPE_tt__DeviceCapabilities
#define SOAP_TYPE_tt__DeviceCapabilities (443)
#endif

/* tt__AnalyticsCapabilities has binding name 'tt__AnalyticsCapabilities' for type 'tt:AnalyticsCapabilities' */
#ifndef SOAP_TYPE_tt__AnalyticsCapabilities
#define SOAP_TYPE_tt__AnalyticsCapabilities (442)
#endif

/* tt__CapabilitiesExtension2 has binding name 'tt__CapabilitiesExtension2' for type 'tt:CapabilitiesExtension2' */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension2
#define SOAP_TYPE_tt__CapabilitiesExtension2 (441)
#endif

/* tt__CapabilitiesExtension has binding name 'tt__CapabilitiesExtension' for type 'tt:CapabilitiesExtension' */
#ifndef SOAP_TYPE_tt__CapabilitiesExtension
#define SOAP_TYPE_tt__CapabilitiesExtension (440)
#endif

/* tt__Capabilities has binding name 'tt__Capabilities' for type 'tt:Capabilities' */
#ifndef SOAP_TYPE_tt__Capabilities
#define SOAP_TYPE_tt__Capabilities (439)
#endif

/* tt__Dot11AvailableNetworksExtension has binding name 'tt__Dot11AvailableNetworksExtension' for type 'tt:Dot11AvailableNetworksExtension' */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworksExtension
#define SOAP_TYPE_tt__Dot11AvailableNetworksExtension (438)
#endif

/* tt__Dot11AvailableNetworks has binding name 'tt__Dot11AvailableNetworks' for type 'tt:Dot11AvailableNetworks' */
#ifndef SOAP_TYPE_tt__Dot11AvailableNetworks
#define SOAP_TYPE_tt__Dot11AvailableNetworks (437)
#endif

/* tt__Dot11Status has binding name 'tt__Dot11Status' for type 'tt:Dot11Status' */
#ifndef SOAP_TYPE_tt__Dot11Status
#define SOAP_TYPE_tt__Dot11Status (436)
#endif

/* tt__Dot11Capabilities has binding name 'tt__Dot11Capabilities' for type 'tt:Dot11Capabilities' */
#ifndef SOAP_TYPE_tt__Dot11Capabilities
#define SOAP_TYPE_tt__Dot11Capabilities (435)
#endif

/* tt__NetworkInterfaceSetConfigurationExtension2 has binding name 'tt__NetworkInterfaceSetConfigurationExtension2' for type 'tt:NetworkInterfaceSetConfigurationExtension2' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2 (434)
#endif

/* tt__Dot11PSKSetExtension has binding name 'tt__Dot11PSKSetExtension' for type 'tt:Dot11PSKSetExtension' */
#ifndef SOAP_TYPE_tt__Dot11PSKSetExtension
#define SOAP_TYPE_tt__Dot11PSKSetExtension (433)
#endif

/* tt__Dot11PSKSet has binding name 'tt__Dot11PSKSet' for type 'tt:Dot11PSKSet' */
#ifndef SOAP_TYPE_tt__Dot11PSKSet
#define SOAP_TYPE_tt__Dot11PSKSet (432)
#endif

/* tt__Dot11SecurityConfigurationExtension has binding name 'tt__Dot11SecurityConfigurationExtension' for type 'tt:Dot11SecurityConfigurationExtension' */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_tt__Dot11SecurityConfigurationExtension (431)
#endif

/* tt__Dot11SecurityConfiguration has binding name 'tt__Dot11SecurityConfiguration' for type 'tt:Dot11SecurityConfiguration' */
#ifndef SOAP_TYPE_tt__Dot11SecurityConfiguration
#define SOAP_TYPE_tt__Dot11SecurityConfiguration (430)
#endif

/* tt__Dot11Configuration has binding name 'tt__Dot11Configuration' for type 'tt:Dot11Configuration' */
#ifndef SOAP_TYPE_tt__Dot11Configuration
#define SOAP_TYPE_tt__Dot11Configuration (429)
#endif

/* tt__IPAddressFilterExtension has binding name 'tt__IPAddressFilterExtension' for type 'tt:IPAddressFilterExtension' */
#ifndef SOAP_TYPE_tt__IPAddressFilterExtension
#define SOAP_TYPE_tt__IPAddressFilterExtension (428)
#endif

/* tt__IPAddressFilter has binding name 'tt__IPAddressFilter' for type 'tt:IPAddressFilter' */
#ifndef SOAP_TYPE_tt__IPAddressFilter
#define SOAP_TYPE_tt__IPAddressFilter (427)
#endif

/* tt__NetworkZeroConfigurationExtension2 has binding name 'tt__NetworkZeroConfigurationExtension2' for type 'tt:NetworkZeroConfigurationExtension2' */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension2 (426)
#endif

/* tt__NetworkZeroConfigurationExtension has binding name 'tt__NetworkZeroConfigurationExtension' for type 'tt:NetworkZeroConfigurationExtension' */
#ifndef SOAP_TYPE_tt__NetworkZeroConfigurationExtension
#define SOAP_TYPE_tt__NetworkZeroConfigurationExtension (425)
#endif

/* tt__NetworkZeroConfiguration has binding name 'tt__NetworkZeroConfiguration' for type 'tt:NetworkZeroConfiguration' */
#ifndef SOAP_TYPE_tt__NetworkZeroConfiguration
#define SOAP_TYPE_tt__NetworkZeroConfiguration (424)
#endif

/* tt__NetworkGateway has binding name 'tt__NetworkGateway' for type 'tt:NetworkGateway' */
#ifndef SOAP_TYPE_tt__NetworkGateway
#define SOAP_TYPE_tt__NetworkGateway (423)
#endif

/* tt__IPv4NetworkInterfaceSetConfiguration has binding name 'tt__IPv4NetworkInterfaceSetConfiguration' for type 'tt:IPv4NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration (422)
#endif

/* tt__IPv6NetworkInterfaceSetConfiguration has binding name 'tt__IPv6NetworkInterfaceSetConfiguration' for type 'tt:IPv6NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration (421)
#endif

/* tt__NetworkInterfaceSetConfigurationExtension has binding name 'tt__NetworkInterfaceSetConfigurationExtension' for type 'tt:NetworkInterfaceSetConfigurationExtension' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension (420)
#endif

/* tt__NetworkInterfaceSetConfiguration has binding name 'tt__NetworkInterfaceSetConfiguration' for type 'tt:NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_tt__NetworkInterfaceSetConfiguration (419)
#endif

/* tt__DynamicDNSInformationExtension has binding name 'tt__DynamicDNSInformationExtension' for type 'tt:DynamicDNSInformationExtension' */
#ifndef SOAP_TYPE_tt__DynamicDNSInformationExtension
#define SOAP_TYPE_tt__DynamicDNSInformationExtension (418)
#endif

/* tt__DynamicDNSInformation has binding name 'tt__DynamicDNSInformation' for type 'tt:DynamicDNSInformation' */
#ifndef SOAP_TYPE_tt__DynamicDNSInformation
#define SOAP_TYPE_tt__DynamicDNSInformation (417)
#endif

/* tt__NTPInformationExtension has binding name 'tt__NTPInformationExtension' for type 'tt:NTPInformationExtension' */
#ifndef SOAP_TYPE_tt__NTPInformationExtension
#define SOAP_TYPE_tt__NTPInformationExtension (416)
#endif

/* tt__NTPInformation has binding name 'tt__NTPInformation' for type 'tt:NTPInformation' */
#ifndef SOAP_TYPE_tt__NTPInformation
#define SOAP_TYPE_tt__NTPInformation (415)
#endif

/* tt__DNSInformationExtension has binding name 'tt__DNSInformationExtension' for type 'tt:DNSInformationExtension' */
#ifndef SOAP_TYPE_tt__DNSInformationExtension
#define SOAP_TYPE_tt__DNSInformationExtension (414)
#endif

/* tt__DNSInformation has binding name 'tt__DNSInformation' for type 'tt:DNSInformation' */
#ifndef SOAP_TYPE_tt__DNSInformation
#define SOAP_TYPE_tt__DNSInformation (413)
#endif

/* tt__HostnameInformationExtension has binding name 'tt__HostnameInformationExtension' for type 'tt:HostnameInformationExtension' */
#ifndef SOAP_TYPE_tt__HostnameInformationExtension
#define SOAP_TYPE_tt__HostnameInformationExtension (412)
#endif

/* tt__HostnameInformation has binding name 'tt__HostnameInformation' for type 'tt:HostnameInformation' */
#ifndef SOAP_TYPE_tt__HostnameInformation
#define SOAP_TYPE_tt__HostnameInformation (411)
#endif

/* tt__PrefixedIPv6Address has binding name 'tt__PrefixedIPv6Address' for type 'tt:PrefixedIPv6Address' */
#ifndef SOAP_TYPE_tt__PrefixedIPv6Address
#define SOAP_TYPE_tt__PrefixedIPv6Address (410)
#endif

/* tt__PrefixedIPv4Address has binding name 'tt__PrefixedIPv4Address' for type 'tt:PrefixedIPv4Address' */
#ifndef SOAP_TYPE_tt__PrefixedIPv4Address
#define SOAP_TYPE_tt__PrefixedIPv4Address (409)
#endif

/* tt__IPAddress has binding name 'tt__IPAddress' for type 'tt:IPAddress' */
#ifndef SOAP_TYPE_tt__IPAddress
#define SOAP_TYPE_tt__IPAddress (408)
#endif

/* tt__NetworkHostExtension has binding name 'tt__NetworkHostExtension' for type 'tt:NetworkHostExtension' */
#ifndef SOAP_TYPE_tt__NetworkHostExtension
#define SOAP_TYPE_tt__NetworkHostExtension (407)
#endif

/* tt__NetworkHost has binding name 'tt__NetworkHost' for type 'tt:NetworkHost' */
#ifndef SOAP_TYPE_tt__NetworkHost
#define SOAP_TYPE_tt__NetworkHost (406)
#endif

/* tt__NetworkProtocolExtension has binding name 'tt__NetworkProtocolExtension' for type 'tt:NetworkProtocolExtension' */
#ifndef SOAP_TYPE_tt__NetworkProtocolExtension
#define SOAP_TYPE_tt__NetworkProtocolExtension (405)
#endif

/* tt__NetworkProtocol has binding name 'tt__NetworkProtocol' for type 'tt:NetworkProtocol' */
#ifndef SOAP_TYPE_tt__NetworkProtocol
#define SOAP_TYPE_tt__NetworkProtocol (404)
#endif

/* tt__IPv6ConfigurationExtension has binding name 'tt__IPv6ConfigurationExtension' for type 'tt:IPv6ConfigurationExtension' */
#ifndef SOAP_TYPE_tt__IPv6ConfigurationExtension
#define SOAP_TYPE_tt__IPv6ConfigurationExtension (403)
#endif

/* tt__IPv6Configuration has binding name 'tt__IPv6Configuration' for type 'tt:IPv6Configuration' */
#ifndef SOAP_TYPE_tt__IPv6Configuration
#define SOAP_TYPE_tt__IPv6Configuration (402)
#endif

/* tt__IPv4Configuration has binding name 'tt__IPv4Configuration' for type 'tt:IPv4Configuration' */
#ifndef SOAP_TYPE_tt__IPv4Configuration
#define SOAP_TYPE_tt__IPv4Configuration (401)
#endif

/* tt__IPv4NetworkInterface has binding name 'tt__IPv4NetworkInterface' for type 'tt:IPv4NetworkInterface' */
#ifndef SOAP_TYPE_tt__IPv4NetworkInterface
#define SOAP_TYPE_tt__IPv4NetworkInterface (400)
#endif

/* tt__IPv6NetworkInterface has binding name 'tt__IPv6NetworkInterface' for type 'tt:IPv6NetworkInterface' */
#ifndef SOAP_TYPE_tt__IPv6NetworkInterface
#define SOAP_TYPE_tt__IPv6NetworkInterface (399)
#endif

/* tt__NetworkInterfaceInfo has binding name 'tt__NetworkInterfaceInfo' for type 'tt:NetworkInterfaceInfo' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceInfo
#define SOAP_TYPE_tt__NetworkInterfaceInfo (398)
#endif

/* tt__NetworkInterfaceConnectionSetting has binding name 'tt__NetworkInterfaceConnectionSetting' for type 'tt:NetworkInterfaceConnectionSetting' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_tt__NetworkInterfaceConnectionSetting (397)
#endif

/* tt__NetworkInterfaceLink has binding name 'tt__NetworkInterfaceLink' for type 'tt:NetworkInterfaceLink' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceLink
#define SOAP_TYPE_tt__NetworkInterfaceLink (396)
#endif

/* tt__NetworkInterfaceExtension2 has binding name 'tt__NetworkInterfaceExtension2' for type 'tt:NetworkInterfaceExtension2' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension2
#define SOAP_TYPE_tt__NetworkInterfaceExtension2 (395)
#endif

/* tt__Dot3Configuration has binding name 'tt__Dot3Configuration' for type 'tt:Dot3Configuration' */
#ifndef SOAP_TYPE_tt__Dot3Configuration
#define SOAP_TYPE_tt__Dot3Configuration (394)
#endif

/* tt__NetworkInterfaceExtension has binding name 'tt__NetworkInterfaceExtension' for type 'tt:NetworkInterfaceExtension' */
#ifndef SOAP_TYPE_tt__NetworkInterfaceExtension
#define SOAP_TYPE_tt__NetworkInterfaceExtension (393)
#endif

/* tt__NetworkInterface has binding name 'tt__NetworkInterface' for type 'tt:NetworkInterface' */
#ifndef SOAP_TYPE_tt__NetworkInterface
#define SOAP_TYPE_tt__NetworkInterface (392)
#endif

/* tt__Scope has binding name 'tt__Scope' for type 'tt:Scope' */
#ifndef SOAP_TYPE_tt__Scope
#define SOAP_TYPE_tt__Scope (391)
#endif

/* tt__MediaUri has binding name 'tt__MediaUri' for type 'tt:MediaUri' */
#ifndef SOAP_TYPE_tt__MediaUri
#define SOAP_TYPE_tt__MediaUri (390)
#endif

/* tt__Transport has binding name 'tt__Transport' for type 'tt:Transport' */
#ifndef SOAP_TYPE_tt__Transport
#define SOAP_TYPE_tt__Transport (389)
#endif

/* tt__StreamSetup has binding name 'tt__StreamSetup' for type 'tt:StreamSetup' */
#ifndef SOAP_TYPE_tt__StreamSetup
#define SOAP_TYPE_tt__StreamSetup (388)
#endif

/* tt__MulticastConfiguration has binding name 'tt__MulticastConfiguration' for type 'tt:MulticastConfiguration' */
#ifndef SOAP_TYPE_tt__MulticastConfiguration
#define SOAP_TYPE_tt__MulticastConfiguration (387)
#endif

/* tt__AudioDecoderConfigurationOptionsExtension has binding name 'tt__AudioDecoderConfigurationOptionsExtension' for type 'tt:AudioDecoderConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension (386)
#endif

/* tt__G726DecOptions has binding name 'tt__G726DecOptions' for type 'tt:G726DecOptions' */
#ifndef SOAP_TYPE_tt__G726DecOptions
#define SOAP_TYPE_tt__G726DecOptions (385)
#endif

/* tt__AACDecOptions has binding name 'tt__AACDecOptions' for type 'tt:AACDecOptions' */
#ifndef SOAP_TYPE_tt__AACDecOptions
#define SOAP_TYPE_tt__AACDecOptions (384)
#endif

/* tt__G711DecOptions has binding name 'tt__G711DecOptions' for type 'tt:G711DecOptions' */
#ifndef SOAP_TYPE_tt__G711DecOptions
#define SOAP_TYPE_tt__G711DecOptions (383)
#endif

/* tt__AudioDecoderConfigurationOptions has binding name 'tt__AudioDecoderConfigurationOptions' for type 'tt:AudioDecoderConfigurationOptions' */
#ifndef SOAP_TYPE_tt__AudioDecoderConfigurationOptions
#define SOAP_TYPE_tt__AudioDecoderConfigurationOptions (382)
#endif

/* tt__AudioDecoderConfiguration has binding name 'tt__AudioDecoderConfiguration' for type 'tt:AudioDecoderConfiguration' */
#ifndef SOAP_TYPE_tt__AudioDecoderConfiguration
#define SOAP_TYPE_tt__AudioDecoderConfiguration (381)
#endif

/* tt__AudioOutputConfigurationOptions has binding name 'tt__AudioOutputConfigurationOptions' for type 'tt:AudioOutputConfigurationOptions' */
#ifndef SOAP_TYPE_tt__AudioOutputConfigurationOptions
#define SOAP_TYPE_tt__AudioOutputConfigurationOptions (380)
#endif

/* tt__AudioOutputConfiguration has binding name 'tt__AudioOutputConfiguration' for type 'tt:AudioOutputConfiguration' */
#ifndef SOAP_TYPE_tt__AudioOutputConfiguration
#define SOAP_TYPE_tt__AudioOutputConfiguration (379)
#endif

/* tt__AudioOutput has binding name 'tt__AudioOutput' for type 'tt:AudioOutput' */
#ifndef SOAP_TYPE_tt__AudioOutput
#define SOAP_TYPE_tt__AudioOutput (378)
#endif

/* tt__VideoDecoderConfigurationOptionsExtension has binding name 'tt__VideoDecoderConfigurationOptionsExtension' for type 'tt:VideoDecoderConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension (377)
#endif

/* tt__Mpeg4DecOptions has binding name 'tt__Mpeg4DecOptions' for type 'tt:Mpeg4DecOptions' */
#ifndef SOAP_TYPE_tt__Mpeg4DecOptions
#define SOAP_TYPE_tt__Mpeg4DecOptions (376)
#endif

/* tt__JpegDecOptions has binding name 'tt__JpegDecOptions' for type 'tt:JpegDecOptions' */
#ifndef SOAP_TYPE_tt__JpegDecOptions
#define SOAP_TYPE_tt__JpegDecOptions (375)
#endif

/* tt__H264DecOptions has binding name 'tt__H264DecOptions' for type 'tt:H264DecOptions' */
#ifndef SOAP_TYPE_tt__H264DecOptions
#define SOAP_TYPE_tt__H264DecOptions (374)
#endif

/* tt__VideoDecoderConfigurationOptions has binding name 'tt__VideoDecoderConfigurationOptions' for type 'tt:VideoDecoderConfigurationOptions' */
#ifndef SOAP_TYPE_tt__VideoDecoderConfigurationOptions
#define SOAP_TYPE_tt__VideoDecoderConfigurationOptions (373)
#endif

/* tt__VideoOutputConfigurationOptions has binding name 'tt__VideoOutputConfigurationOptions' for type 'tt:VideoOutputConfigurationOptions' */
#ifndef SOAP_TYPE_tt__VideoOutputConfigurationOptions
#define SOAP_TYPE_tt__VideoOutputConfigurationOptions (372)
#endif

/* tt__VideoOutputConfiguration has binding name 'tt__VideoOutputConfiguration' for type 'tt:VideoOutputConfiguration' */
#ifndef SOAP_TYPE_tt__VideoOutputConfiguration
#define SOAP_TYPE_tt__VideoOutputConfiguration (371)
#endif

/* tt__VideoOutputExtension has binding name 'tt__VideoOutputExtension' for type 'tt:VideoOutputExtension' */
#ifndef SOAP_TYPE_tt__VideoOutputExtension
#define SOAP_TYPE_tt__VideoOutputExtension (370)
#endif

/* tt__VideoOutput has binding name 'tt__VideoOutput' for type 'tt:VideoOutput' */
#ifndef SOAP_TYPE_tt__VideoOutput
#define SOAP_TYPE_tt__VideoOutput (369)
#endif

/* tt__PTZStatusFilterOptionsExtension has binding name 'tt__PTZStatusFilterOptionsExtension' for type 'tt:PTZStatusFilterOptionsExtension' */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_tt__PTZStatusFilterOptionsExtension (368)
#endif

/* tt__PTZStatusFilterOptions has binding name 'tt__PTZStatusFilterOptions' for type 'tt:PTZStatusFilterOptions' */
#ifndef SOAP_TYPE_tt__PTZStatusFilterOptions
#define SOAP_TYPE_tt__PTZStatusFilterOptions (367)
#endif

/* tt__MetadataConfigurationOptionsExtension2 has binding name 'tt__MetadataConfigurationOptionsExtension2' for type 'tt:MetadataConfigurationOptionsExtension2' */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension2 (366)
#endif

/* tt__MetadataConfigurationOptionsExtension has binding name 'tt__MetadataConfigurationOptionsExtension' for type 'tt:MetadataConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_tt__MetadataConfigurationOptionsExtension (365)
#endif

/* tt__MetadataConfigurationOptions has binding name 'tt__MetadataConfigurationOptions' for type 'tt:MetadataConfigurationOptions' */
#ifndef SOAP_TYPE_tt__MetadataConfigurationOptions
#define SOAP_TYPE_tt__MetadataConfigurationOptions (364)
#endif

/* tt__EventSubscription has binding name 'tt__EventSubscription' for type 'tt:EventSubscription' */
#ifndef SOAP_TYPE_tt__EventSubscription
#define SOAP_TYPE_tt__EventSubscription (363)
#endif

/* tt__PTZFilter has binding name 'tt__PTZFilter' for type 'tt:PTZFilter' */
#ifndef SOAP_TYPE_tt__PTZFilter
#define SOAP_TYPE_tt__PTZFilter (362)
#endif

/* tt__MetadataConfigurationExtension has binding name 'tt__MetadataConfigurationExtension' for type 'tt:MetadataConfigurationExtension' */
#ifndef SOAP_TYPE_tt__MetadataConfigurationExtension
#define SOAP_TYPE_tt__MetadataConfigurationExtension (361)
#endif

/* tt__MetadataConfiguration has binding name 'tt__MetadataConfiguration' for type 'tt:MetadataConfiguration' */
#ifndef SOAP_TYPE_tt__MetadataConfiguration
#define SOAP_TYPE_tt__MetadataConfiguration (360)
#endif

/* tt__VideoAnalyticsConfiguration has binding name 'tt__VideoAnalyticsConfiguration' for type 'tt:VideoAnalyticsConfiguration' */
#ifndef SOAP_TYPE_tt__VideoAnalyticsConfiguration
#define SOAP_TYPE_tt__VideoAnalyticsConfiguration (359)
#endif

/* tt__AudioEncoder2ConfigurationOptions has binding name 'tt__AudioEncoder2ConfigurationOptions' for type 'tt:AudioEncoder2ConfigurationOptions' */
#ifndef SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoder2ConfigurationOptions (358)
#endif

/* tt__AudioEncoder2Configuration has binding name 'tt__AudioEncoder2Configuration' for type 'tt:AudioEncoder2Configuration' */
#ifndef SOAP_TYPE_tt__AudioEncoder2Configuration
#define SOAP_TYPE_tt__AudioEncoder2Configuration (357)
#endif

/* tt__AudioEncoderConfigurationOption has binding name 'tt__AudioEncoderConfigurationOption' for type 'tt:AudioEncoderConfigurationOption' */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOption
#define SOAP_TYPE_tt__AudioEncoderConfigurationOption (356)
#endif

/* tt__AudioEncoderConfigurationOptions has binding name 'tt__AudioEncoderConfigurationOptions' for type 'tt:AudioEncoderConfigurationOptions' */
#ifndef SOAP_TYPE_tt__AudioEncoderConfigurationOptions
#define SOAP_TYPE_tt__AudioEncoderConfigurationOptions (355)
#endif

/* tt__AudioEncoderConfiguration has binding name 'tt__AudioEncoderConfiguration' for type 'tt:AudioEncoderConfiguration' */
#ifndef SOAP_TYPE_tt__AudioEncoderConfiguration
#define SOAP_TYPE_tt__AudioEncoderConfiguration (354)
#endif

/* tt__AudioSourceOptionsExtension has binding name 'tt__AudioSourceOptionsExtension' for type 'tt:AudioSourceOptionsExtension' */
#ifndef SOAP_TYPE_tt__AudioSourceOptionsExtension
#define SOAP_TYPE_tt__AudioSourceOptionsExtension (353)
#endif

/* tt__AudioSourceConfigurationOptions has binding name 'tt__AudioSourceConfigurationOptions' for type 'tt:AudioSourceConfigurationOptions' */
#ifndef SOAP_TYPE_tt__AudioSourceConfigurationOptions
#define SOAP_TYPE_tt__AudioSourceConfigurationOptions (352)
#endif

/* tt__AudioSourceConfiguration has binding name 'tt__AudioSourceConfiguration' for type 'tt:AudioSourceConfiguration' */
#ifndef SOAP_TYPE_tt__AudioSourceConfiguration
#define SOAP_TYPE_tt__AudioSourceConfiguration (351)
#endif

/* tt__VideoEncoder2ConfigurationOptions has binding name 'tt__VideoEncoder2ConfigurationOptions' for type 'tt:VideoEncoder2ConfigurationOptions' */
#ifndef SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoder2ConfigurationOptions (350)
#endif

/* tt__VideoRateControl2 has binding name 'tt__VideoRateControl2' for type 'tt:VideoRateControl2' */
#ifndef SOAP_TYPE_tt__VideoRateControl2
#define SOAP_TYPE_tt__VideoRateControl2 (349)
#endif

/* tt__VideoResolution2 has binding name 'tt__VideoResolution2' for type 'tt:VideoResolution2' */
#ifndef SOAP_TYPE_tt__VideoResolution2
#define SOAP_TYPE_tt__VideoResolution2 (348)
#endif

/* tt__VideoEncoder2Configuration has binding name 'tt__VideoEncoder2Configuration' for type 'tt:VideoEncoder2Configuration' */
#ifndef SOAP_TYPE_tt__VideoEncoder2Configuration
#define SOAP_TYPE_tt__VideoEncoder2Configuration (347)
#endif

/* tt__H264Options2 has binding name 'tt__H264Options2' for type 'tt:H264Options2' */
#ifndef SOAP_TYPE_tt__H264Options2
#define SOAP_TYPE_tt__H264Options2 (346)
#endif

/* tt__H264Options has binding name 'tt__H264Options' for type 'tt:H264Options' */
#ifndef SOAP_TYPE_tt__H264Options
#define SOAP_TYPE_tt__H264Options (345)
#endif

/* tt__Mpeg4Options2 has binding name 'tt__Mpeg4Options2' for type 'tt:Mpeg4Options2' */
#ifndef SOAP_TYPE_tt__Mpeg4Options2
#define SOAP_TYPE_tt__Mpeg4Options2 (344)
#endif

/* tt__Mpeg4Options has binding name 'tt__Mpeg4Options' for type 'tt:Mpeg4Options' */
#ifndef SOAP_TYPE_tt__Mpeg4Options
#define SOAP_TYPE_tt__Mpeg4Options (343)
#endif

/* tt__JpegOptions2 has binding name 'tt__JpegOptions2' for type 'tt:JpegOptions2' */
#ifndef SOAP_TYPE_tt__JpegOptions2
#define SOAP_TYPE_tt__JpegOptions2 (342)
#endif

/* tt__JpegOptions has binding name 'tt__JpegOptions' for type 'tt:JpegOptions' */
#ifndef SOAP_TYPE_tt__JpegOptions
#define SOAP_TYPE_tt__JpegOptions (341)
#endif

/* tt__VideoEncoderOptionsExtension2 has binding name 'tt__VideoEncoderOptionsExtension2' for type 'tt:VideoEncoderOptionsExtension2' */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension2
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension2 (340)
#endif

/* tt__VideoEncoderOptionsExtension has binding name 'tt__VideoEncoderOptionsExtension' for type 'tt:VideoEncoderOptionsExtension' */
#ifndef SOAP_TYPE_tt__VideoEncoderOptionsExtension
#define SOAP_TYPE_tt__VideoEncoderOptionsExtension (339)
#endif

/* tt__VideoEncoderConfigurationOptions has binding name 'tt__VideoEncoderConfigurationOptions' for type 'tt:VideoEncoderConfigurationOptions' */
#ifndef SOAP_TYPE_tt__VideoEncoderConfigurationOptions
#define SOAP_TYPE_tt__VideoEncoderConfigurationOptions (338)
#endif

/* tt__H264Configuration has binding name 'tt__H264Configuration' for type 'tt:H264Configuration' */
#ifndef SOAP_TYPE_tt__H264Configuration
#define SOAP_TYPE_tt__H264Configuration (337)
#endif

/* tt__Mpeg4Configuration has binding name 'tt__Mpeg4Configuration' for type 'tt:Mpeg4Configuration' */
#ifndef SOAP_TYPE_tt__Mpeg4Configuration
#define SOAP_TYPE_tt__Mpeg4Configuration (336)
#endif

/* tt__VideoRateControl has binding name 'tt__VideoRateControl' for type 'tt:VideoRateControl' */
#ifndef SOAP_TYPE_tt__VideoRateControl
#define SOAP_TYPE_tt__VideoRateControl (335)
#endif

/* tt__VideoResolution has binding name 'tt__VideoResolution' for type 'tt:VideoResolution' */
#ifndef SOAP_TYPE_tt__VideoResolution
#define SOAP_TYPE_tt__VideoResolution (334)
#endif

/* tt__VideoEncoderConfiguration has binding name 'tt__VideoEncoderConfiguration' for type 'tt:VideoEncoderConfiguration' */
#ifndef SOAP_TYPE_tt__VideoEncoderConfiguration
#define SOAP_TYPE_tt__VideoEncoderConfiguration (333)
#endif

/* tt__SceneOrientation has binding name 'tt__SceneOrientation' for type 'tt:SceneOrientation' */
#ifndef SOAP_TYPE_tt__SceneOrientation
#define SOAP_TYPE_tt__SceneOrientation (332)
#endif

/* tt__RotateOptionsExtension has binding name 'tt__RotateOptionsExtension' for type 'tt:RotateOptionsExtension' */
#ifndef SOAP_TYPE_tt__RotateOptionsExtension
#define SOAP_TYPE_tt__RotateOptionsExtension (331)
#endif

/* tt__RotateOptions has binding name 'tt__RotateOptions' for type 'tt:RotateOptions' */
#ifndef SOAP_TYPE_tt__RotateOptions
#define SOAP_TYPE_tt__RotateOptions (330)
#endif

/* tt__VideoSourceConfigurationOptionsExtension2 has binding name 'tt__VideoSourceConfigurationOptionsExtension2' for type 'tt:VideoSourceConfigurationOptionsExtension2' */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2 (329)
#endif

/* tt__VideoSourceConfigurationOptionsExtension has binding name 'tt__VideoSourceConfigurationOptionsExtension' for type 'tt:VideoSourceConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension (328)
#endif

/* tt__VideoSourceConfigurationOptions has binding name 'tt__VideoSourceConfigurationOptions' for type 'tt:VideoSourceConfigurationOptions' */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationOptions
#define SOAP_TYPE_tt__VideoSourceConfigurationOptions (327)
#endif

/* tt__LensDescription has binding name 'tt__LensDescription' for type 'tt:LensDescription' */
#ifndef SOAP_TYPE_tt__LensDescription
#define SOAP_TYPE_tt__LensDescription (326)
#endif

/* tt__LensOffset has binding name 'tt__LensOffset' for type 'tt:LensOffset' */
#ifndef SOAP_TYPE_tt__LensOffset
#define SOAP_TYPE_tt__LensOffset (325)
#endif

/* tt__LensProjection has binding name 'tt__LensProjection' for type 'tt:LensProjection' */
#ifndef SOAP_TYPE_tt__LensProjection
#define SOAP_TYPE_tt__LensProjection (324)
#endif

/* tt__RotateExtension has binding name 'tt__RotateExtension' for type 'tt:RotateExtension' */
#ifndef SOAP_TYPE_tt__RotateExtension
#define SOAP_TYPE_tt__RotateExtension (323)
#endif

/* tt__Rotate has binding name 'tt__Rotate' for type 'tt:Rotate' */
#ifndef SOAP_TYPE_tt__Rotate
#define SOAP_TYPE_tt__Rotate (322)
#endif

/* tt__VideoSourceConfigurationExtension2 has binding name 'tt__VideoSourceConfigurationExtension2' for type 'tt:VideoSourceConfigurationExtension2' */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension2
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension2 (321)
#endif

/* tt__VideoSourceConfigurationExtension has binding name 'tt__VideoSourceConfigurationExtension' for type 'tt:VideoSourceConfigurationExtension' */
#ifndef SOAP_TYPE_tt__VideoSourceConfigurationExtension
#define SOAP_TYPE_tt__VideoSourceConfigurationExtension (320)
#endif

/* tt__VideoSourceConfiguration has binding name 'tt__VideoSourceConfiguration' for type 'tt:VideoSourceConfiguration' */
#ifndef SOAP_TYPE_tt__VideoSourceConfiguration
#define SOAP_TYPE_tt__VideoSourceConfiguration (319)
#endif

/* tt__ConfigurationEntity has binding name 'tt__ConfigurationEntity' for type 'tt:ConfigurationEntity' */
#ifndef SOAP_TYPE_tt__ConfigurationEntity
#define SOAP_TYPE_tt__ConfigurationEntity (318)
#endif

/* tt__ProfileExtension2 has binding name 'tt__ProfileExtension2' for type 'tt:ProfileExtension2' */
#ifndef SOAP_TYPE_tt__ProfileExtension2
#define SOAP_TYPE_tt__ProfileExtension2 (317)
#endif

/* tt__ProfileExtension has binding name 'tt__ProfileExtension' for type 'tt:ProfileExtension' */
#ifndef SOAP_TYPE_tt__ProfileExtension
#define SOAP_TYPE_tt__ProfileExtension (316)
#endif

/* tt__Profile has binding name 'tt__Profile' for type 'tt:Profile' */
#ifndef SOAP_TYPE_tt__Profile
#define SOAP_TYPE_tt__Profile (315)
#endif

/* tt__AudioSource has binding name 'tt__AudioSource' for type 'tt:AudioSource' */
#ifndef SOAP_TYPE_tt__AudioSource
#define SOAP_TYPE_tt__AudioSource (314)
#endif

/* tt__VideoSourceExtension2 has binding name 'tt__VideoSourceExtension2' for type 'tt:VideoSourceExtension2' */
#ifndef SOAP_TYPE_tt__VideoSourceExtension2
#define SOAP_TYPE_tt__VideoSourceExtension2 (313)
#endif

/* tt__VideoSourceExtension has binding name 'tt__VideoSourceExtension' for type 'tt:VideoSourceExtension' */
#ifndef SOAP_TYPE_tt__VideoSourceExtension
#define SOAP_TYPE_tt__VideoSourceExtension (312)
#endif

/* tt__VideoSource has binding name 'tt__VideoSource' for type 'tt:VideoSource' */
#ifndef SOAP_TYPE_tt__VideoSource
#define SOAP_TYPE_tt__VideoSource (311)
#endif

/* tt__AnyHolder has binding name 'tt__AnyHolder' for type 'tt:AnyHolder' */
#ifndef SOAP_TYPE_tt__AnyHolder
#define SOAP_TYPE_tt__AnyHolder (310)
#endif

/* tt__FloatItems has binding name 'tt__FloatItems' for type 'tt:FloatItems' */
#ifndef SOAP_TYPE_tt__FloatItems
#define SOAP_TYPE_tt__FloatItems (309)
#endif

/* tt__IntItems has binding name 'tt__IntItems' for type 'tt:IntItems' */
#ifndef SOAP_TYPE_tt__IntItems
#define SOAP_TYPE_tt__IntItems (308)
#endif

/* tt__DurationRange has binding name 'tt__DurationRange' for type 'tt:DurationRange' */
#ifndef SOAP_TYPE_tt__DurationRange
#define SOAP_TYPE_tt__DurationRange (307)
#endif

/* tt__FloatRange has binding name 'tt__FloatRange' for type 'tt:FloatRange' */
#ifndef SOAP_TYPE_tt__FloatRange
#define SOAP_TYPE_tt__FloatRange (306)
#endif

/* tt__IntRectangleRange has binding name 'tt__IntRectangleRange' for type 'tt:IntRectangleRange' */
#ifndef SOAP_TYPE_tt__IntRectangleRange
#define SOAP_TYPE_tt__IntRectangleRange (305)
#endif

/* tt__IntRectangle has binding name 'tt__IntRectangle' for type 'tt:IntRectangle' */
#ifndef SOAP_TYPE_tt__IntRectangle
#define SOAP_TYPE_tt__IntRectangle (304)
#endif

/* tt__DeviceEntity has binding name 'tt__DeviceEntity' for type 'tt:DeviceEntity' */
#ifndef SOAP_TYPE_tt__DeviceEntity
#define SOAP_TYPE_tt__DeviceEntity (303)
#endif

/* _tds__DeleteGeoLocationResponse has binding name '_tds__DeleteGeoLocationResponse' for type '' */
#ifndef SOAP_TYPE__tds__DeleteGeoLocationResponse
#define SOAP_TYPE__tds__DeleteGeoLocationResponse (302)
#endif

/* _tds__DeleteGeoLocation has binding name '_tds__DeleteGeoLocation' for type '' */
#ifndef SOAP_TYPE__tds__DeleteGeoLocation
#define SOAP_TYPE__tds__DeleteGeoLocation (301)
#endif

/* _tds__SetGeoLocationResponse has binding name '_tds__SetGeoLocationResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetGeoLocationResponse
#define SOAP_TYPE__tds__SetGeoLocationResponse (300)
#endif

/* _tds__SetGeoLocation has binding name '_tds__SetGeoLocation' for type '' */
#ifndef SOAP_TYPE__tds__SetGeoLocation
#define SOAP_TYPE__tds__SetGeoLocation (299)
#endif

/* _tds__GetGeoLocationResponse has binding name '_tds__GetGeoLocationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetGeoLocationResponse
#define SOAP_TYPE__tds__GetGeoLocationResponse (298)
#endif

/* _tds__GetGeoLocation has binding name '_tds__GetGeoLocation' for type '' */
#ifndef SOAP_TYPE__tds__GetGeoLocation
#define SOAP_TYPE__tds__GetGeoLocation (297)
#endif

/* _tds__DeleteStorageConfigurationResponse has binding name '_tds__DeleteStorageConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__DeleteStorageConfigurationResponse
#define SOAP_TYPE__tds__DeleteStorageConfigurationResponse (296)
#endif

/* _tds__DeleteStorageConfiguration has binding name '_tds__DeleteStorageConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__DeleteStorageConfiguration
#define SOAP_TYPE__tds__DeleteStorageConfiguration (295)
#endif

/* _tds__SetStorageConfigurationResponse has binding name '_tds__SetStorageConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetStorageConfigurationResponse
#define SOAP_TYPE__tds__SetStorageConfigurationResponse (294)
#endif

/* _tds__SetStorageConfiguration has binding name '_tds__SetStorageConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__SetStorageConfiguration
#define SOAP_TYPE__tds__SetStorageConfiguration (293)
#endif

/* _tds__GetStorageConfigurationResponse has binding name '_tds__GetStorageConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationResponse
#define SOAP_TYPE__tds__GetStorageConfigurationResponse (292)
#endif

/* _tds__GetStorageConfiguration has binding name '_tds__GetStorageConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__GetStorageConfiguration
#define SOAP_TYPE__tds__GetStorageConfiguration (291)
#endif

/* _tds__CreateStorageConfigurationResponse has binding name '_tds__CreateStorageConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__CreateStorageConfigurationResponse
#define SOAP_TYPE__tds__CreateStorageConfigurationResponse (290)
#endif

/* _tds__CreateStorageConfiguration has binding name '_tds__CreateStorageConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__CreateStorageConfiguration
#define SOAP_TYPE__tds__CreateStorageConfiguration (289)
#endif

/* _tds__GetStorageConfigurationsResponse has binding name '_tds__GetStorageConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetStorageConfigurationsResponse
#define SOAP_TYPE__tds__GetStorageConfigurationsResponse (288)
#endif

/* _tds__GetStorageConfigurations has binding name '_tds__GetStorageConfigurations' for type '' */
#ifndef SOAP_TYPE__tds__GetStorageConfigurations
#define SOAP_TYPE__tds__GetStorageConfigurations (287)
#endif

/* _tds__SetHashingAlgorithmResponse has binding name '_tds__SetHashingAlgorithmResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetHashingAlgorithmResponse
#define SOAP_TYPE__tds__SetHashingAlgorithmResponse (286)
#endif

/* _tds__SetHashingAlgorithm has binding name '_tds__SetHashingAlgorithm' for type '' */
#ifndef SOAP_TYPE__tds__SetHashingAlgorithm
#define SOAP_TYPE__tds__SetHashingAlgorithm (285)
#endif

/* _tds__StartSystemRestoreResponse has binding name '_tds__StartSystemRestoreResponse' for type '' */
#ifndef SOAP_TYPE__tds__StartSystemRestoreResponse
#define SOAP_TYPE__tds__StartSystemRestoreResponse (284)
#endif

/* _tds__StartSystemRestore has binding name '_tds__StartSystemRestore' for type '' */
#ifndef SOAP_TYPE__tds__StartSystemRestore
#define SOAP_TYPE__tds__StartSystemRestore (283)
#endif

/* _tds__StartFirmwareUpgradeResponse has binding name '_tds__StartFirmwareUpgradeResponse' for type '' */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgradeResponse
#define SOAP_TYPE__tds__StartFirmwareUpgradeResponse (282)
#endif

/* _tds__StartFirmwareUpgrade has binding name '_tds__StartFirmwareUpgrade' for type '' */
#ifndef SOAP_TYPE__tds__StartFirmwareUpgrade
#define SOAP_TYPE__tds__StartFirmwareUpgrade (281)
#endif

/* _tds__GetSystemUrisResponse has binding name '_tds__GetSystemUrisResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemUrisResponse
#define SOAP_TYPE__tds__GetSystemUrisResponse (280)
#endif

/* _tds__GetSystemUris has binding name '_tds__GetSystemUris' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemUris
#define SOAP_TYPE__tds__GetSystemUris (279)
#endif

/* _tds__ScanAvailableDot11NetworksResponse has binding name '_tds__ScanAvailableDot11NetworksResponse' for type '' */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse
#define SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse (278)
#endif

/* _tds__ScanAvailableDot11Networks has binding name '_tds__ScanAvailableDot11Networks' for type '' */
#ifndef SOAP_TYPE__tds__ScanAvailableDot11Networks
#define SOAP_TYPE__tds__ScanAvailableDot11Networks (277)
#endif

/* _tds__GetDot11StatusResponse has binding name '_tds__GetDot11StatusResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDot11StatusResponse
#define SOAP_TYPE__tds__GetDot11StatusResponse (276)
#endif

/* _tds__GetDot11Status has binding name '_tds__GetDot11Status' for type '' */
#ifndef SOAP_TYPE__tds__GetDot11Status
#define SOAP_TYPE__tds__GetDot11Status (275)
#endif

/* _tds__GetDot11CapabilitiesResponse has binding name '_tds__GetDot11CapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDot11CapabilitiesResponse
#define SOAP_TYPE__tds__GetDot11CapabilitiesResponse (274)
#endif

/* _tds__GetDot11Capabilities has binding name '_tds__GetDot11Capabilities' for type '' */
#ifndef SOAP_TYPE__tds__GetDot11Capabilities
#define SOAP_TYPE__tds__GetDot11Capabilities (273)
#endif

/* _tds__SendAuxiliaryCommandResponse has binding name '_tds__SendAuxiliaryCommandResponse' for type '' */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommandResponse
#define SOAP_TYPE__tds__SendAuxiliaryCommandResponse (272)
#endif

/* _tds__SendAuxiliaryCommand has binding name '_tds__SendAuxiliaryCommand' for type '' */
#ifndef SOAP_TYPE__tds__SendAuxiliaryCommand
#define SOAP_TYPE__tds__SendAuxiliaryCommand (271)
#endif

/* _tds__SetRelayOutputStateResponse has binding name '_tds__SetRelayOutputStateResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetRelayOutputStateResponse
#define SOAP_TYPE__tds__SetRelayOutputStateResponse (270)
#endif

/* _tds__SetRelayOutputState has binding name '_tds__SetRelayOutputState' for type '' */
#ifndef SOAP_TYPE__tds__SetRelayOutputState
#define SOAP_TYPE__tds__SetRelayOutputState (269)
#endif

/* _tds__SetRelayOutputSettingsResponse has binding name '_tds__SetRelayOutputSettingsResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettingsResponse
#define SOAP_TYPE__tds__SetRelayOutputSettingsResponse (268)
#endif

/* _tds__SetRelayOutputSettings has binding name '_tds__SetRelayOutputSettings' for type '' */
#ifndef SOAP_TYPE__tds__SetRelayOutputSettings
#define SOAP_TYPE__tds__SetRelayOutputSettings (267)
#endif

/* _tds__GetRelayOutputsResponse has binding name '_tds__GetRelayOutputsResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetRelayOutputsResponse
#define SOAP_TYPE__tds__GetRelayOutputsResponse (266)
#endif

/* _tds__GetRelayOutputs has binding name '_tds__GetRelayOutputs' for type '' */
#ifndef SOAP_TYPE__tds__GetRelayOutputs
#define SOAP_TYPE__tds__GetRelayOutputs (265)
#endif

/* _tds__DeleteDot1XConfigurationResponse has binding name '_tds__DeleteDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfigurationResponse
#define SOAP_TYPE__tds__DeleteDot1XConfigurationResponse (264)
#endif

/* _tds__DeleteDot1XConfiguration has binding name '_tds__DeleteDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__DeleteDot1XConfiguration
#define SOAP_TYPE__tds__DeleteDot1XConfiguration (263)
#endif

/* _tds__GetDot1XConfigurationsResponse has binding name '_tds__GetDot1XConfigurationsResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationsResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationsResponse (262)
#endif

/* _tds__GetDot1XConfigurations has binding name '_tds__GetDot1XConfigurations' for type '' */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurations
#define SOAP_TYPE__tds__GetDot1XConfigurations (261)
#endif

/* _tds__GetDot1XConfigurationResponse has binding name '_tds__GetDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDot1XConfigurationResponse
#define SOAP_TYPE__tds__GetDot1XConfigurationResponse (260)
#endif

/* _tds__GetDot1XConfiguration has binding name '_tds__GetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__GetDot1XConfiguration
#define SOAP_TYPE__tds__GetDot1XConfiguration (259)
#endif

/* _tds__SetDot1XConfigurationResponse has binding name '_tds__SetDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetDot1XConfigurationResponse
#define SOAP_TYPE__tds__SetDot1XConfigurationResponse (258)
#endif

/* _tds__SetDot1XConfiguration has binding name '_tds__SetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__SetDot1XConfiguration
#define SOAP_TYPE__tds__SetDot1XConfiguration (257)
#endif

/* _tds__CreateDot1XConfigurationResponse has binding name '_tds__CreateDot1XConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__CreateDot1XConfigurationResponse
#define SOAP_TYPE__tds__CreateDot1XConfigurationResponse (256)
#endif

/* _tds__CreateDot1XConfiguration has binding name '_tds__CreateDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__CreateDot1XConfiguration
#define SOAP_TYPE__tds__CreateDot1XConfiguration (255)
#endif

/* _tds__LoadCACertificatesResponse has binding name '_tds__LoadCACertificatesResponse' for type '' */
#ifndef SOAP_TYPE__tds__LoadCACertificatesResponse
#define SOAP_TYPE__tds__LoadCACertificatesResponse (254)
#endif

/* _tds__LoadCACertificates has binding name '_tds__LoadCACertificates' for type '' */
#ifndef SOAP_TYPE__tds__LoadCACertificates
#define SOAP_TYPE__tds__LoadCACertificates (253)
#endif

/* _tds__GetCertificateInformationResponse has binding name '_tds__GetCertificateInformationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetCertificateInformationResponse
#define SOAP_TYPE__tds__GetCertificateInformationResponse (252)
#endif

/* _tds__GetCertificateInformation has binding name '_tds__GetCertificateInformation' for type '' */
#ifndef SOAP_TYPE__tds__GetCertificateInformation
#define SOAP_TYPE__tds__GetCertificateInformation (251)
#endif

/* _tds__LoadCertificateWithPrivateKeyResponse has binding name '_tds__LoadCertificateWithPrivateKeyResponse' for type '' */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse (250)
#endif

/* _tds__LoadCertificateWithPrivateKey has binding name '_tds__LoadCertificateWithPrivateKey' for type '' */
#ifndef SOAP_TYPE__tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE__tds__LoadCertificateWithPrivateKey (249)
#endif

/* _tds__GetCACertificatesResponse has binding name '_tds__GetCACertificatesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetCACertificatesResponse
#define SOAP_TYPE__tds__GetCACertificatesResponse (248)
#endif

/* _tds__GetCACertificates has binding name '_tds__GetCACertificates' for type '' */
#ifndef SOAP_TYPE__tds__GetCACertificates
#define SOAP_TYPE__tds__GetCACertificates (247)
#endif

/* _tds__SetClientCertificateModeResponse has binding name '_tds__SetClientCertificateModeResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetClientCertificateModeResponse
#define SOAP_TYPE__tds__SetClientCertificateModeResponse (246)
#endif

/* _tds__SetClientCertificateMode has binding name '_tds__SetClientCertificateMode' for type '' */
#ifndef SOAP_TYPE__tds__SetClientCertificateMode
#define SOAP_TYPE__tds__SetClientCertificateMode (245)
#endif

/* _tds__GetClientCertificateModeResponse has binding name '_tds__GetClientCertificateModeResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetClientCertificateModeResponse
#define SOAP_TYPE__tds__GetClientCertificateModeResponse (244)
#endif

/* _tds__GetClientCertificateMode has binding name '_tds__GetClientCertificateMode' for type '' */
#ifndef SOAP_TYPE__tds__GetClientCertificateMode
#define SOAP_TYPE__tds__GetClientCertificateMode (243)
#endif

/* _tds__LoadCertificatesResponse has binding name '_tds__LoadCertificatesResponse' for type '' */
#ifndef SOAP_TYPE__tds__LoadCertificatesResponse
#define SOAP_TYPE__tds__LoadCertificatesResponse (242)
#endif

/* _tds__LoadCertificates has binding name '_tds__LoadCertificates' for type '' */
#ifndef SOAP_TYPE__tds__LoadCertificates
#define SOAP_TYPE__tds__LoadCertificates (241)
#endif

/* _tds__GetPkcs10RequestResponse has binding name '_tds__GetPkcs10RequestResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetPkcs10RequestResponse
#define SOAP_TYPE__tds__GetPkcs10RequestResponse (240)
#endif

/* _tds__GetPkcs10Request has binding name '_tds__GetPkcs10Request' for type '' */
#ifndef SOAP_TYPE__tds__GetPkcs10Request
#define SOAP_TYPE__tds__GetPkcs10Request (239)
#endif

/* _tds__DeleteCertificatesResponse has binding name '_tds__DeleteCertificatesResponse' for type '' */
#ifndef SOAP_TYPE__tds__DeleteCertificatesResponse
#define SOAP_TYPE__tds__DeleteCertificatesResponse (238)
#endif

/* _tds__DeleteCertificates has binding name '_tds__DeleteCertificates' for type '' */
#ifndef SOAP_TYPE__tds__DeleteCertificates
#define SOAP_TYPE__tds__DeleteCertificates (237)
#endif

/* _tds__SetCertificatesStatusResponse has binding name '_tds__SetCertificatesStatusResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetCertificatesStatusResponse
#define SOAP_TYPE__tds__SetCertificatesStatusResponse (236)
#endif

/* _tds__SetCertificatesStatus has binding name '_tds__SetCertificatesStatus' for type '' */
#ifndef SOAP_TYPE__tds__SetCertificatesStatus
#define SOAP_TYPE__tds__SetCertificatesStatus (235)
#endif

/* _tds__GetCertificatesStatusResponse has binding name '_tds__GetCertificatesStatusResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetCertificatesStatusResponse
#define SOAP_TYPE__tds__GetCertificatesStatusResponse (234)
#endif

/* _tds__GetCertificatesStatus has binding name '_tds__GetCertificatesStatus' for type '' */
#ifndef SOAP_TYPE__tds__GetCertificatesStatus
#define SOAP_TYPE__tds__GetCertificatesStatus (233)
#endif

/* _tds__GetCertificatesResponse has binding name '_tds__GetCertificatesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetCertificatesResponse
#define SOAP_TYPE__tds__GetCertificatesResponse (232)
#endif

/* _tds__GetCertificates has binding name '_tds__GetCertificates' for type '' */
#ifndef SOAP_TYPE__tds__GetCertificates
#define SOAP_TYPE__tds__GetCertificates (231)
#endif

/* _tds__CreateCertificateResponse has binding name '_tds__CreateCertificateResponse' for type '' */
#ifndef SOAP_TYPE__tds__CreateCertificateResponse
#define SOAP_TYPE__tds__CreateCertificateResponse (230)
#endif

/* _tds__CreateCertificate has binding name '_tds__CreateCertificate' for type '' */
#ifndef SOAP_TYPE__tds__CreateCertificate
#define SOAP_TYPE__tds__CreateCertificate (229)
#endif

/* _tds__SetAccessPolicyResponse has binding name '_tds__SetAccessPolicyResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetAccessPolicyResponse
#define SOAP_TYPE__tds__SetAccessPolicyResponse (228)
#endif

/* _tds__SetAccessPolicy has binding name '_tds__SetAccessPolicy' for type '' */
#ifndef SOAP_TYPE__tds__SetAccessPolicy
#define SOAP_TYPE__tds__SetAccessPolicy (227)
#endif

/* _tds__GetAccessPolicyResponse has binding name '_tds__GetAccessPolicyResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetAccessPolicyResponse
#define SOAP_TYPE__tds__GetAccessPolicyResponse (226)
#endif

/* _tds__GetAccessPolicy has binding name '_tds__GetAccessPolicy' for type '' */
#ifndef SOAP_TYPE__tds__GetAccessPolicy
#define SOAP_TYPE__tds__GetAccessPolicy (225)
#endif

/* _tds__RemoveIPAddressFilterResponse has binding name '_tds__RemoveIPAddressFilterResponse' for type '' */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilterResponse
#define SOAP_TYPE__tds__RemoveIPAddressFilterResponse (224)
#endif

/* _tds__RemoveIPAddressFilter has binding name '_tds__RemoveIPAddressFilter' for type '' */
#ifndef SOAP_TYPE__tds__RemoveIPAddressFilter
#define SOAP_TYPE__tds__RemoveIPAddressFilter (223)
#endif

/* _tds__AddIPAddressFilterResponse has binding name '_tds__AddIPAddressFilterResponse' for type '' */
#ifndef SOAP_TYPE__tds__AddIPAddressFilterResponse
#define SOAP_TYPE__tds__AddIPAddressFilterResponse (222)
#endif

/* _tds__AddIPAddressFilter has binding name '_tds__AddIPAddressFilter' for type '' */
#ifndef SOAP_TYPE__tds__AddIPAddressFilter
#define SOAP_TYPE__tds__AddIPAddressFilter (221)
#endif

/* _tds__SetIPAddressFilterResponse has binding name '_tds__SetIPAddressFilterResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetIPAddressFilterResponse
#define SOAP_TYPE__tds__SetIPAddressFilterResponse (220)
#endif

/* _tds__SetIPAddressFilter has binding name '_tds__SetIPAddressFilter' for type '' */
#ifndef SOAP_TYPE__tds__SetIPAddressFilter
#define SOAP_TYPE__tds__SetIPAddressFilter (219)
#endif

/* _tds__GetIPAddressFilterResponse has binding name '_tds__GetIPAddressFilterResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetIPAddressFilterResponse
#define SOAP_TYPE__tds__GetIPAddressFilterResponse (218)
#endif

/* _tds__GetIPAddressFilter has binding name '_tds__GetIPAddressFilter' for type '' */
#ifndef SOAP_TYPE__tds__GetIPAddressFilter
#define SOAP_TYPE__tds__GetIPAddressFilter (217)
#endif

/* _tds__SetZeroConfigurationResponse has binding name '_tds__SetZeroConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetZeroConfigurationResponse
#define SOAP_TYPE__tds__SetZeroConfigurationResponse (216)
#endif

/* _tds__SetZeroConfiguration has binding name '_tds__SetZeroConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__SetZeroConfiguration
#define SOAP_TYPE__tds__SetZeroConfiguration (215)
#endif

/* _tds__GetZeroConfigurationResponse has binding name '_tds__GetZeroConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetZeroConfigurationResponse
#define SOAP_TYPE__tds__GetZeroConfigurationResponse (214)
#endif

/* _tds__GetZeroConfiguration has binding name '_tds__GetZeroConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__GetZeroConfiguration
#define SOAP_TYPE__tds__GetZeroConfiguration (213)
#endif

/* _tds__SetNetworkDefaultGatewayResponse has binding name '_tds__SetNetworkDefaultGatewayResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse (212)
#endif

/* _tds__SetNetworkDefaultGateway has binding name '_tds__SetNetworkDefaultGateway' for type '' */
#ifndef SOAP_TYPE__tds__SetNetworkDefaultGateway
#define SOAP_TYPE__tds__SetNetworkDefaultGateway (211)
#endif

/* _tds__GetNetworkDefaultGatewayResponse has binding name '_tds__GetNetworkDefaultGatewayResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse
#define SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse (210)
#endif

/* _tds__GetNetworkDefaultGateway has binding name '_tds__GetNetworkDefaultGateway' for type '' */
#ifndef SOAP_TYPE__tds__GetNetworkDefaultGateway
#define SOAP_TYPE__tds__GetNetworkDefaultGateway (209)
#endif

/* _tds__SetNetworkProtocolsResponse has binding name '_tds__SetNetworkProtocolsResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetNetworkProtocolsResponse
#define SOAP_TYPE__tds__SetNetworkProtocolsResponse (208)
#endif

/* _tds__SetNetworkProtocols has binding name '_tds__SetNetworkProtocols' for type '' */
#ifndef SOAP_TYPE__tds__SetNetworkProtocols
#define SOAP_TYPE__tds__SetNetworkProtocols (207)
#endif

/* _tds__GetNetworkProtocolsResponse has binding name '_tds__GetNetworkProtocolsResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetNetworkProtocolsResponse
#define SOAP_TYPE__tds__GetNetworkProtocolsResponse (206)
#endif

/* _tds__GetNetworkProtocols has binding name '_tds__GetNetworkProtocols' for type '' */
#ifndef SOAP_TYPE__tds__GetNetworkProtocols
#define SOAP_TYPE__tds__GetNetworkProtocols (205)
#endif

/* _tds__SetNetworkInterfacesResponse has binding name '_tds__SetNetworkInterfacesResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetNetworkInterfacesResponse
#define SOAP_TYPE__tds__SetNetworkInterfacesResponse (204)
#endif

/* _tds__SetNetworkInterfaces has binding name '_tds__SetNetworkInterfaces' for type '' */
#ifndef SOAP_TYPE__tds__SetNetworkInterfaces
#define SOAP_TYPE__tds__SetNetworkInterfaces (203)
#endif

/* _tds__GetNetworkInterfacesResponse has binding name '_tds__GetNetworkInterfacesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetNetworkInterfacesResponse
#define SOAP_TYPE__tds__GetNetworkInterfacesResponse (202)
#endif

/* _tds__GetNetworkInterfaces has binding name '_tds__GetNetworkInterfaces' for type '' */
#ifndef SOAP_TYPE__tds__GetNetworkInterfaces
#define SOAP_TYPE__tds__GetNetworkInterfaces (201)
#endif

/* _tds__SetDynamicDNSResponse has binding name '_tds__SetDynamicDNSResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetDynamicDNSResponse
#define SOAP_TYPE__tds__SetDynamicDNSResponse (200)
#endif

/* _tds__SetDynamicDNS has binding name '_tds__SetDynamicDNS' for type '' */
#ifndef SOAP_TYPE__tds__SetDynamicDNS
#define SOAP_TYPE__tds__SetDynamicDNS (199)
#endif

/* _tds__GetDynamicDNSResponse has binding name '_tds__GetDynamicDNSResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDynamicDNSResponse
#define SOAP_TYPE__tds__GetDynamicDNSResponse (198)
#endif

/* _tds__GetDynamicDNS has binding name '_tds__GetDynamicDNS' for type '' */
#ifndef SOAP_TYPE__tds__GetDynamicDNS
#define SOAP_TYPE__tds__GetDynamicDNS (197)
#endif

/* _tds__SetNTPResponse has binding name '_tds__SetNTPResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetNTPResponse
#define SOAP_TYPE__tds__SetNTPResponse (196)
#endif

/* _tds__SetNTP has binding name '_tds__SetNTP' for type '' */
#ifndef SOAP_TYPE__tds__SetNTP
#define SOAP_TYPE__tds__SetNTP (195)
#endif

/* _tds__GetNTPResponse has binding name '_tds__GetNTPResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetNTPResponse
#define SOAP_TYPE__tds__GetNTPResponse (194)
#endif

/* _tds__GetNTP has binding name '_tds__GetNTP' for type '' */
#ifndef SOAP_TYPE__tds__GetNTP
#define SOAP_TYPE__tds__GetNTP (193)
#endif

/* _tds__SetDNSResponse has binding name '_tds__SetDNSResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetDNSResponse
#define SOAP_TYPE__tds__SetDNSResponse (192)
#endif

/* _tds__SetDNS has binding name '_tds__SetDNS' for type '' */
#ifndef SOAP_TYPE__tds__SetDNS
#define SOAP_TYPE__tds__SetDNS (191)
#endif

/* _tds__GetDNSResponse has binding name '_tds__GetDNSResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDNSResponse
#define SOAP_TYPE__tds__GetDNSResponse (190)
#endif

/* _tds__GetDNS has binding name '_tds__GetDNS' for type '' */
#ifndef SOAP_TYPE__tds__GetDNS
#define SOAP_TYPE__tds__GetDNS (189)
#endif

/* _tds__SetHostnameFromDHCPResponse has binding name '_tds__SetHostnameFromDHCPResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCPResponse
#define SOAP_TYPE__tds__SetHostnameFromDHCPResponse (188)
#endif

/* _tds__SetHostnameFromDHCP has binding name '_tds__SetHostnameFromDHCP' for type '' */
#ifndef SOAP_TYPE__tds__SetHostnameFromDHCP
#define SOAP_TYPE__tds__SetHostnameFromDHCP (187)
#endif

/* _tds__SetHostnameResponse has binding name '_tds__SetHostnameResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetHostnameResponse
#define SOAP_TYPE__tds__SetHostnameResponse (186)
#endif

/* _tds__SetHostname has binding name '_tds__SetHostname' for type '' */
#ifndef SOAP_TYPE__tds__SetHostname
#define SOAP_TYPE__tds__SetHostname (185)
#endif

/* _tds__GetHostnameResponse has binding name '_tds__GetHostnameResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetHostnameResponse
#define SOAP_TYPE__tds__GetHostnameResponse (184)
#endif

/* _tds__GetHostname has binding name '_tds__GetHostname' for type '' */
#ifndef SOAP_TYPE__tds__GetHostname
#define SOAP_TYPE__tds__GetHostname (183)
#endif

/* _tds__GetCapabilitiesResponse has binding name '_tds__GetCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetCapabilitiesResponse
#define SOAP_TYPE__tds__GetCapabilitiesResponse (182)
#endif

/* _tds__GetCapabilities has binding name '_tds__GetCapabilities' for type '' */
#ifndef SOAP_TYPE__tds__GetCapabilities
#define SOAP_TYPE__tds__GetCapabilities (181)
#endif

/* _tds__SetAuthFailureWarningConfigurationResponse has binding name '_tds__SetAuthFailureWarningConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse
#define SOAP_TYPE__tds__SetAuthFailureWarningConfigurationResponse (180)
#endif

/* _tds__SetAuthFailureWarningConfiguration has binding name '_tds__SetAuthFailureWarningConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__SetAuthFailureWarningConfiguration
#define SOAP_TYPE__tds__SetAuthFailureWarningConfiguration (179)
#endif

/* _tds__GetAuthFailureWarningConfigurationResponse has binding name '_tds__GetAuthFailureWarningConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse
#define SOAP_TYPE__tds__GetAuthFailureWarningConfigurationResponse (178)
#endif

/* _tds__GetAuthFailureWarningConfiguration has binding name '_tds__GetAuthFailureWarningConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__GetAuthFailureWarningConfiguration
#define SOAP_TYPE__tds__GetAuthFailureWarningConfiguration (177)
#endif

/* _tds__GetAuthFailureWarningOptionsResponse has binding name '_tds__GetAuthFailureWarningOptionsResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse
#define SOAP_TYPE__tds__GetAuthFailureWarningOptionsResponse (176)
#endif

/* _tds__GetAuthFailureWarningOptions has binding name '_tds__GetAuthFailureWarningOptions' for type '' */
#ifndef SOAP_TYPE__tds__GetAuthFailureWarningOptions
#define SOAP_TYPE__tds__GetAuthFailureWarningOptions (175)
#endif

/* _tds__SetPasswordHistoryConfigurationResponse has binding name '_tds__SetPasswordHistoryConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse
#define SOAP_TYPE__tds__SetPasswordHistoryConfigurationResponse (174)
#endif

/* _tds__SetPasswordHistoryConfiguration has binding name '_tds__SetPasswordHistoryConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__SetPasswordHistoryConfiguration
#define SOAP_TYPE__tds__SetPasswordHistoryConfiguration (173)
#endif

/* _tds__GetPasswordHistoryConfigurationResponse has binding name '_tds__GetPasswordHistoryConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse
#define SOAP_TYPE__tds__GetPasswordHistoryConfigurationResponse (172)
#endif

/* _tds__GetPasswordHistoryConfiguration has binding name '_tds__GetPasswordHistoryConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__GetPasswordHistoryConfiguration
#define SOAP_TYPE__tds__GetPasswordHistoryConfiguration (171)
#endif

/* _tds__SetPasswordComplexityConfigurationResponse has binding name '_tds__SetPasswordComplexityConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse
#define SOAP_TYPE__tds__SetPasswordComplexityConfigurationResponse (170)
#endif

/* _tds__SetPasswordComplexityConfiguration has binding name '_tds__SetPasswordComplexityConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__SetPasswordComplexityConfiguration
#define SOAP_TYPE__tds__SetPasswordComplexityConfiguration (169)
#endif

/* _tds__GetPasswordComplexityConfigurationResponse has binding name '_tds__GetPasswordComplexityConfigurationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse
#define SOAP_TYPE__tds__GetPasswordComplexityConfigurationResponse (168)
#endif

/* _tds__GetPasswordComplexityConfiguration has binding name '_tds__GetPasswordComplexityConfiguration' for type '' */
#ifndef SOAP_TYPE__tds__GetPasswordComplexityConfiguration
#define SOAP_TYPE__tds__GetPasswordComplexityConfiguration (167)
#endif

/* _tds__GetPasswordComplexityOptionsResponse has binding name '_tds__GetPasswordComplexityOptionsResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse
#define SOAP_TYPE__tds__GetPasswordComplexityOptionsResponse (166)
#endif

/* _tds__GetPasswordComplexityOptions has binding name '_tds__GetPasswordComplexityOptions' for type '' */
#ifndef SOAP_TYPE__tds__GetPasswordComplexityOptions
#define SOAP_TYPE__tds__GetPasswordComplexityOptions (165)
#endif

/* _tds__GetWsdlUrlResponse has binding name '_tds__GetWsdlUrlResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetWsdlUrlResponse
#define SOAP_TYPE__tds__GetWsdlUrlResponse (164)
#endif

/* _tds__GetWsdlUrl has binding name '_tds__GetWsdlUrl' for type '' */
#ifndef SOAP_TYPE__tds__GetWsdlUrl
#define SOAP_TYPE__tds__GetWsdlUrl (163)
#endif

/* _tds__SetUserResponse has binding name '_tds__SetUserResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetUserResponse
#define SOAP_TYPE__tds__SetUserResponse (162)
#endif

/* _tds__SetUser has binding name '_tds__SetUser' for type '' */
#ifndef SOAP_TYPE__tds__SetUser
#define SOAP_TYPE__tds__SetUser (161)
#endif

/* _tds__DeleteUsersResponse has binding name '_tds__DeleteUsersResponse' for type '' */
#ifndef SOAP_TYPE__tds__DeleteUsersResponse
#define SOAP_TYPE__tds__DeleteUsersResponse (160)
#endif

/* _tds__DeleteUsers has binding name '_tds__DeleteUsers' for type '' */
#ifndef SOAP_TYPE__tds__DeleteUsers
#define SOAP_TYPE__tds__DeleteUsers (159)
#endif

/* _tds__CreateUsersResponse has binding name '_tds__CreateUsersResponse' for type '' */
#ifndef SOAP_TYPE__tds__CreateUsersResponse
#define SOAP_TYPE__tds__CreateUsersResponse (158)
#endif

/* _tds__CreateUsers has binding name '_tds__CreateUsers' for type '' */
#ifndef SOAP_TYPE__tds__CreateUsers
#define SOAP_TYPE__tds__CreateUsers (157)
#endif

/* _tds__GetUsersResponse has binding name '_tds__GetUsersResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetUsersResponse
#define SOAP_TYPE__tds__GetUsersResponse (156)
#endif

/* _tds__GetUsers has binding name '_tds__GetUsers' for type '' */
#ifndef SOAP_TYPE__tds__GetUsers
#define SOAP_TYPE__tds__GetUsers (155)
#endif

/* _tds__SetRemoteUserResponse has binding name '_tds__SetRemoteUserResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetRemoteUserResponse
#define SOAP_TYPE__tds__SetRemoteUserResponse (154)
#endif

/* _tds__SetRemoteUser has binding name '_tds__SetRemoteUser' for type '' */
#ifndef SOAP_TYPE__tds__SetRemoteUser
#define SOAP_TYPE__tds__SetRemoteUser (153)
#endif

/* _tds__GetRemoteUserResponse has binding name '_tds__GetRemoteUserResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetRemoteUserResponse
#define SOAP_TYPE__tds__GetRemoteUserResponse (152)
#endif

/* _tds__GetRemoteUser has binding name '_tds__GetRemoteUser' for type '' */
#ifndef SOAP_TYPE__tds__GetRemoteUser
#define SOAP_TYPE__tds__GetRemoteUser (151)
#endif

/* _tds__GetEndpointReferenceResponse has binding name '_tds__GetEndpointReferenceResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetEndpointReferenceResponse
#define SOAP_TYPE__tds__GetEndpointReferenceResponse (150)
#endif

/* _tds__GetEndpointReference has binding name '_tds__GetEndpointReference' for type '' */
#ifndef SOAP_TYPE__tds__GetEndpointReference
#define SOAP_TYPE__tds__GetEndpointReference (149)
#endif

/* _tds__SetDPAddressesResponse has binding name '_tds__SetDPAddressesResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetDPAddressesResponse
#define SOAP_TYPE__tds__SetDPAddressesResponse (148)
#endif

/* _tds__SetDPAddresses has binding name '_tds__SetDPAddresses' for type '' */
#ifndef SOAP_TYPE__tds__SetDPAddresses
#define SOAP_TYPE__tds__SetDPAddresses (147)
#endif

/* _tds__GetDPAddressesResponse has binding name '_tds__GetDPAddressesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDPAddressesResponse
#define SOAP_TYPE__tds__GetDPAddressesResponse (146)
#endif

/* _tds__GetDPAddresses has binding name '_tds__GetDPAddresses' for type '' */
#ifndef SOAP_TYPE__tds__GetDPAddresses
#define SOAP_TYPE__tds__GetDPAddresses (145)
#endif

/* _tds__SetRemoteDiscoveryModeResponse has binding name '_tds__SetRemoteDiscoveryModeResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse (144)
#endif

/* _tds__SetRemoteDiscoveryMode has binding name '_tds__SetRemoteDiscoveryMode' for type '' */
#ifndef SOAP_TYPE__tds__SetRemoteDiscoveryMode
#define SOAP_TYPE__tds__SetRemoteDiscoveryMode (143)
#endif

/* _tds__GetRemoteDiscoveryModeResponse has binding name '_tds__GetRemoteDiscoveryModeResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse
#define SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse (142)
#endif

/* _tds__GetRemoteDiscoveryMode has binding name '_tds__GetRemoteDiscoveryMode' for type '' */
#ifndef SOAP_TYPE__tds__GetRemoteDiscoveryMode
#define SOAP_TYPE__tds__GetRemoteDiscoveryMode (141)
#endif

/* _tds__SetDiscoveryModeResponse has binding name '_tds__SetDiscoveryModeResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetDiscoveryModeResponse
#define SOAP_TYPE__tds__SetDiscoveryModeResponse (140)
#endif

/* _tds__SetDiscoveryMode has binding name '_tds__SetDiscoveryMode' for type '' */
#ifndef SOAP_TYPE__tds__SetDiscoveryMode
#define SOAP_TYPE__tds__SetDiscoveryMode (139)
#endif

/* _tds__GetDiscoveryModeResponse has binding name '_tds__GetDiscoveryModeResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDiscoveryModeResponse
#define SOAP_TYPE__tds__GetDiscoveryModeResponse (138)
#endif

/* _tds__GetDiscoveryMode has binding name '_tds__GetDiscoveryMode' for type '' */
#ifndef SOAP_TYPE__tds__GetDiscoveryMode
#define SOAP_TYPE__tds__GetDiscoveryMode (137)
#endif

/* _tds__RemoveScopesResponse has binding name '_tds__RemoveScopesResponse' for type '' */
#ifndef SOAP_TYPE__tds__RemoveScopesResponse
#define SOAP_TYPE__tds__RemoveScopesResponse (136)
#endif

/* _tds__RemoveScopes has binding name '_tds__RemoveScopes' for type '' */
#ifndef SOAP_TYPE__tds__RemoveScopes
#define SOAP_TYPE__tds__RemoveScopes (135)
#endif

/* _tds__AddScopesResponse has binding name '_tds__AddScopesResponse' for type '' */
#ifndef SOAP_TYPE__tds__AddScopesResponse
#define SOAP_TYPE__tds__AddScopesResponse (134)
#endif

/* _tds__AddScopes has binding name '_tds__AddScopes' for type '' */
#ifndef SOAP_TYPE__tds__AddScopes
#define SOAP_TYPE__tds__AddScopes (133)
#endif

/* _tds__SetScopesResponse has binding name '_tds__SetScopesResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetScopesResponse
#define SOAP_TYPE__tds__SetScopesResponse (132)
#endif

/* _tds__SetScopes has binding name '_tds__SetScopes' for type '' */
#ifndef SOAP_TYPE__tds__SetScopes
#define SOAP_TYPE__tds__SetScopes (131)
#endif

/* _tds__GetScopesResponse has binding name '_tds__GetScopesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetScopesResponse
#define SOAP_TYPE__tds__GetScopesResponse (130)
#endif

/* _tds__GetScopes has binding name '_tds__GetScopes' for type '' */
#ifndef SOAP_TYPE__tds__GetScopes
#define SOAP_TYPE__tds__GetScopes (129)
#endif

/* _tds__GetSystemLogResponse has binding name '_tds__GetSystemLogResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemLogResponse
#define SOAP_TYPE__tds__GetSystemLogResponse (128)
#endif

/* _tds__GetSystemLog has binding name '_tds__GetSystemLog' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemLog
#define SOAP_TYPE__tds__GetSystemLog (127)
#endif

/* _tds__GetSystemSupportInformationResponse has binding name '_tds__GetSystemSupportInformationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformationResponse
#define SOAP_TYPE__tds__GetSystemSupportInformationResponse (126)
#endif

/* _tds__GetSystemSupportInformation has binding name '_tds__GetSystemSupportInformation' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemSupportInformation
#define SOAP_TYPE__tds__GetSystemSupportInformation (125)
#endif

/* _tds__GetSystemBackupResponse has binding name '_tds__GetSystemBackupResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemBackupResponse
#define SOAP_TYPE__tds__GetSystemBackupResponse (124)
#endif

/* _tds__GetSystemBackup has binding name '_tds__GetSystemBackup' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemBackup
#define SOAP_TYPE__tds__GetSystemBackup (123)
#endif

/* _tds__RestoreSystemResponse has binding name '_tds__RestoreSystemResponse' for type '' */
#ifndef SOAP_TYPE__tds__RestoreSystemResponse
#define SOAP_TYPE__tds__RestoreSystemResponse (122)
#endif

/* _tds__RestoreSystem has binding name '_tds__RestoreSystem' for type '' */
#ifndef SOAP_TYPE__tds__RestoreSystem
#define SOAP_TYPE__tds__RestoreSystem (121)
#endif

/* _tds__SystemRebootResponse has binding name '_tds__SystemRebootResponse' for type '' */
#ifndef SOAP_TYPE__tds__SystemRebootResponse
#define SOAP_TYPE__tds__SystemRebootResponse (120)
#endif

/* _tds__SystemReboot has binding name '_tds__SystemReboot' for type '' */
#ifndef SOAP_TYPE__tds__SystemReboot
#define SOAP_TYPE__tds__SystemReboot (119)
#endif

/* _tds__UpgradeSystemFirmwareResponse has binding name '_tds__UpgradeSystemFirmwareResponse' for type '' */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmwareResponse
#define SOAP_TYPE__tds__UpgradeSystemFirmwareResponse (118)
#endif

/* _tds__UpgradeSystemFirmware has binding name '_tds__UpgradeSystemFirmware' for type '' */
#ifndef SOAP_TYPE__tds__UpgradeSystemFirmware
#define SOAP_TYPE__tds__UpgradeSystemFirmware (117)
#endif

/* _tds__SetSystemFactoryDefaultResponse has binding name '_tds__SetSystemFactoryDefaultResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefaultResponse
#define SOAP_TYPE__tds__SetSystemFactoryDefaultResponse (116)
#endif

/* _tds__SetSystemFactoryDefault has binding name '_tds__SetSystemFactoryDefault' for type '' */
#ifndef SOAP_TYPE__tds__SetSystemFactoryDefault
#define SOAP_TYPE__tds__SetSystemFactoryDefault (115)
#endif

/* _tds__GetSystemDateAndTimeResponse has binding name '_tds__GetSystemDateAndTimeResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__GetSystemDateAndTimeResponse (114)
#endif

/* _tds__GetSystemDateAndTime has binding name '_tds__GetSystemDateAndTime' for type '' */
#ifndef SOAP_TYPE__tds__GetSystemDateAndTime
#define SOAP_TYPE__tds__GetSystemDateAndTime (113)
#endif

/* _tds__SetSystemDateAndTimeResponse has binding name '_tds__SetSystemDateAndTimeResponse' for type '' */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTimeResponse
#define SOAP_TYPE__tds__SetSystemDateAndTimeResponse (112)
#endif

/* _tds__SetSystemDateAndTime has binding name '_tds__SetSystemDateAndTime' for type '' */
#ifndef SOAP_TYPE__tds__SetSystemDateAndTime
#define SOAP_TYPE__tds__SetSystemDateAndTime (111)
#endif

/* _tds__GetDeviceInformationResponse has binding name '_tds__GetDeviceInformationResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetDeviceInformationResponse
#define SOAP_TYPE__tds__GetDeviceInformationResponse (110)
#endif

/* _tds__GetDeviceInformation has binding name '_tds__GetDeviceInformation' for type '' */
#ifndef SOAP_TYPE__tds__GetDeviceInformation
#define SOAP_TYPE__tds__GetDeviceInformation (109)
#endif

/* _tds__GetServiceCapabilitiesResponse has binding name '_tds__GetServiceCapabilitiesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetServiceCapabilitiesResponse
#define SOAP_TYPE__tds__GetServiceCapabilitiesResponse (108)
#endif

/* _tds__GetServiceCapabilities has binding name '_tds__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE__tds__GetServiceCapabilities
#define SOAP_TYPE__tds__GetServiceCapabilities (107)
#endif

/* _tds__GetServicesResponse has binding name '_tds__GetServicesResponse' for type '' */
#ifndef SOAP_TYPE__tds__GetServicesResponse
#define SOAP_TYPE__tds__GetServicesResponse (106)
#endif

/* _tds__GetServices has binding name '_tds__GetServices' for type '' */
#ifndef SOAP_TYPE__tds__GetServices
#define SOAP_TYPE__tds__GetServices (105)
#endif

/* tds__StorageConfiguration has binding name 'tds__StorageConfiguration' for type 'tds:StorageConfiguration' */
#ifndef SOAP_TYPE_tds__StorageConfiguration
#define SOAP_TYPE_tds__StorageConfiguration (104)
#endif

/* tds__StorageConfigurationData has binding name 'tds__StorageConfigurationData' for type 'tds:StorageConfigurationData' */
#ifndef SOAP_TYPE_tds__StorageConfigurationData
#define SOAP_TYPE_tds__StorageConfigurationData (103)
#endif

/* tds__UserCredential has binding name 'tds__UserCredential' for type 'tds:UserCredential' */
#ifndef SOAP_TYPE_tds__UserCredential
#define SOAP_TYPE_tds__UserCredential (102)
#endif

/* tds__MiscCapabilities has binding name 'tds__MiscCapabilities' for type 'tds:MiscCapabilities' */
#ifndef SOAP_TYPE_tds__MiscCapabilities
#define SOAP_TYPE_tds__MiscCapabilities (101)
#endif

/* tds__SystemCapabilities has binding name 'tds__SystemCapabilities' for type 'tds:SystemCapabilities' */
#ifndef SOAP_TYPE_tds__SystemCapabilities
#define SOAP_TYPE_tds__SystemCapabilities (100)
#endif

/* tds__SecurityCapabilities has binding name 'tds__SecurityCapabilities' for type 'tds:SecurityCapabilities' */
#ifndef SOAP_TYPE_tds__SecurityCapabilities
#define SOAP_TYPE_tds__SecurityCapabilities (99)
#endif

/* tds__NetworkCapabilities has binding name 'tds__NetworkCapabilities' for type 'tds:NetworkCapabilities' */
#ifndef SOAP_TYPE_tds__NetworkCapabilities
#define SOAP_TYPE_tds__NetworkCapabilities (98)
#endif

/* tds__DeviceServiceCapabilities has binding name 'tds__DeviceServiceCapabilities' for type 'tds:DeviceServiceCapabilities' */
#ifndef SOAP_TYPE_tds__DeviceServiceCapabilities
#define SOAP_TYPE_tds__DeviceServiceCapabilities (97)
#endif

/* tds__Service has binding name 'tds__Service' for type 'tds:Service' */
#ifndef SOAP_TYPE_tds__Service
#define SOAP_TYPE_tds__Service (96)
#endif

/* _xml__lang has binding name '_xml__lang' for type '' */
#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (95)
#endif

/* xsd__token__ has binding name 'xsd__token__' for type 'xsd:token' */
#ifndef SOAP_TYPE_xsd__token__
#define SOAP_TYPE_xsd__token__ (94)
#endif

/* xsd__token has binding name 'xsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (93)
#endif

/* xsd__string_ has binding name 'xsd__string_' for type 'xsd:string' */
#ifndef SOAP_TYPE_xsd__string_
#define SOAP_TYPE_xsd__string_ (92)
#endif

/* xsd__nonNegativeInteger__ has binding name 'xsd__nonNegativeInteger__' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger__
#define SOAP_TYPE_xsd__nonNegativeInteger__ (91)
#endif

/* xsd__nonNegativeInteger has binding name 'xsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (90)
#endif

/* xsd__integer__ has binding name 'xsd__integer__' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer__
#define SOAP_TYPE_xsd__integer__ (89)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (88)
#endif

/* xsd__int_ has binding name 'xsd__int_' for type 'xsd:int' */
#ifndef SOAP_TYPE_xsd__int_
#define SOAP_TYPE_xsd__int_ (87)
#endif

/* xsd__hexBinary__ has binding name 'xsd__hexBinary__' for type 'xsd:hexBinary' */
#ifndef SOAP_TYPE_xsd__hexBinary__
#define SOAP_TYPE_xsd__hexBinary__ (86)
#endif

/* xsd__float_ has binding name 'xsd__float_' for type 'xsd:float' */
#ifndef SOAP_TYPE_xsd__float_
#define SOAP_TYPE_xsd__float_ (84)
#endif

/* xsd__duration__ has binding name 'xsd__duration__' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration__
#define SOAP_TYPE_xsd__duration__ (83)
#endif

/* xsd__duration has binding name 'xsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (82)
#endif

/* xsd__double_ has binding name 'xsd__double_' for type 'xsd:double' */
#ifndef SOAP_TYPE_xsd__double_
#define SOAP_TYPE_xsd__double_ (80)
#endif

/* xsd__dateTime_ has binding name 'xsd__dateTime_' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_xsd__dateTime_
#define SOAP_TYPE_xsd__dateTime_ (78)
#endif

/* xsd__boolean_ has binding name 'xsd__boolean_' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_xsd__boolean_
#define SOAP_TYPE_xsd__boolean_ (76)
#endif

/* xsd__base64Binary__ has binding name 'xsd__base64Binary__' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary__
#define SOAP_TYPE_xsd__base64Binary__ (75)
#endif

/* xsd__anyURI__ has binding name 'xsd__anyURI__' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI__
#define SOAP_TYPE_xsd__anyURI__ (74)
#endif

/* xsd__anyURI has binding name 'xsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (73)
#endif

/* xsd__anySimpleType__ has binding name 'xsd__anySimpleType__' for type 'xsd:anySimpleType' */
#ifndef SOAP_TYPE_xsd__anySimpleType__
#define SOAP_TYPE_xsd__anySimpleType__ (72)
#endif

/* xsd__anySimpleType has binding name 'xsd__anySimpleType' for type 'xsd:anySimpleType' */
#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (71)
#endif

/* xsd__QName__ has binding name 'xsd__QName__' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName__
#define SOAP_TYPE_xsd__QName__ (70)
#endif

/* xsd__NCName__ has binding name 'xsd__NCName__' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_xsd__NCName__
#define SOAP_TYPE_xsd__NCName__ (69)
#endif

/* xsd__NCName has binding name 'xsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (68)
#endif

/* SOAP_ENV__Fault_ has binding name 'SOAP_ENV__Fault_' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault_
#define SOAP_TYPE_SOAP_ENV__Fault_ (67)
#endif

/* SOAP_ENV__Envelope_ has binding name 'SOAP_ENV__Envelope_' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope_
#define SOAP_TYPE_SOAP_ENV__Envelope_ (66)
#endif

/* wsa5__EndpointReferenceType__ has binding name 'wsa5__EndpointReferenceType__' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType__
#define SOAP_TYPE_wsa5__EndpointReferenceType__ (65)
#endif

/* xsd__hexBinary has binding name 'xsd__hexBinary' for type 'xsd:hexBinary' */
#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (64)
#endif

/* xsd__base64Binary has binding name 'xsd__base64Binary' for type 'xsd:base64Binary' */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (63)
#endif

/* xsd__QName has binding name 'xsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (62)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (61)
#endif

/* xsd__anyType has binding name 'xsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (57)
#endif

/* struct SOAP_ENV__Envelope has binding name 'SOAP_ENV__Envelope' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (59)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (56)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (52)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (50)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (48)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (42)
#endif

/* struct chan__ChannelInstanceType has binding name 'chan__ChannelInstanceType' for type 'chan:ChannelInstanceType' */
#ifndef SOAP_TYPE_chan__ChannelInstanceType
#define SOAP_TYPE_chan__ChannelInstanceType (41)
#endif

/* _wsa5__ProblemAction has binding name '_wsa5__ProblemAction' for type '' */
#ifndef SOAP_TYPE__wsa5__ProblemAction
#define SOAP_TYPE__wsa5__ProblemAction (39)
#endif

/* _wsa5__FaultTo has binding name '_wsa5__FaultTo' for type '' */
#ifndef SOAP_TYPE__wsa5__FaultTo
#define SOAP_TYPE__wsa5__FaultTo (32)
#endif

/* _wsa5__From has binding name '_wsa5__From' for type '' */
#ifndef SOAP_TYPE__wsa5__From
#define SOAP_TYPE__wsa5__From (31)
#endif

/* _wsa5__ReplyTo has binding name '_wsa5__ReplyTo' for type '' */
#ifndef SOAP_TYPE__wsa5__ReplyTo
#define SOAP_TYPE__wsa5__ReplyTo (30)
#endif

/* _wsa5__RelatesTo has binding name '_wsa5__RelatesTo' for type '' */
#ifndef SOAP_TYPE__wsa5__RelatesTo
#define SOAP_TYPE__wsa5__RelatesTo (29)
#endif

/* _wsa5__Metadata has binding name '_wsa5__Metadata' for type '' */
#ifndef SOAP_TYPE__wsa5__Metadata
#define SOAP_TYPE__wsa5__Metadata (27)
#endif

/* _wsa5__ReferenceParameters has binding name '_wsa5__ReferenceParameters' for type '' */
#ifndef SOAP_TYPE__wsa5__ReferenceParameters
#define SOAP_TYPE__wsa5__ReferenceParameters (26)
#endif

/* _wsa5__EndpointReference has binding name '_wsa5__EndpointReference' for type '' */
#ifndef SOAP_TYPE__wsa5__EndpointReference
#define SOAP_TYPE__wsa5__EndpointReference (25)
#endif

/* struct wsa5__ProblemActionType has binding name 'wsa5__ProblemActionType' for type 'wsa5:ProblemActionType' */
#ifndef SOAP_TYPE_wsa5__ProblemActionType
#define SOAP_TYPE_wsa5__ProblemActionType (16)
#endif

/* struct wsa5__RelatesToType has binding name 'wsa5__RelatesToType' for type 'wsa5:RelatesToType' */
#ifndef SOAP_TYPE_wsa5__RelatesToType
#define SOAP_TYPE_wsa5__RelatesToType (15)
#endif

/* struct wsa5__MetadataType has binding name 'wsa5__MetadataType' for type 'wsa5:MetadataType' */
#ifndef SOAP_TYPE_wsa5__MetadataType
#define SOAP_TYPE_wsa5__MetadataType (14)
#endif

/* struct wsa5__ReferenceParametersType has binding name 'wsa5__ReferenceParametersType' for type 'wsa5:ReferenceParametersType' */
#ifndef SOAP_TYPE_wsa5__ReferenceParametersType
#define SOAP_TYPE_wsa5__ReferenceParametersType (13)
#endif

/* struct wsa5__EndpointReferenceType has binding name 'wsa5__EndpointReferenceType' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_wsa5__EndpointReferenceType
#define SOAP_TYPE_wsa5__EndpointReferenceType (12)
#endif

/* struct _xop__Include has binding name '_xop__Include' for type '' */
#ifndef SOAP_TYPE__xop__Include
#define SOAP_TYPE__xop__Include (8)
#endif

/* _tds__SetHashingAlgorithm * has binding name 'PointerTo_tds__SetHashingAlgorithm' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetHashingAlgorithm
#define SOAP_TYPE_PointerTo_tds__SetHashingAlgorithm (1990)
#endif

/* _tds__DeleteGeoLocation * has binding name 'PointerTo_tds__DeleteGeoLocation' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__DeleteGeoLocation
#define SOAP_TYPE_PointerTo_tds__DeleteGeoLocation (1986)
#endif

/* _tds__SetGeoLocation * has binding name 'PointerTo_tds__SetGeoLocation' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetGeoLocation
#define SOAP_TYPE_PointerTo_tds__SetGeoLocation (1982)
#endif

/* _tds__GetGeoLocation * has binding name 'PointerTo_tds__GetGeoLocation' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetGeoLocation
#define SOAP_TYPE_PointerTo_tds__GetGeoLocation (1978)
#endif

/* _tds__DeleteStorageConfiguration * has binding name 'PointerTo_tds__DeleteStorageConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__DeleteStorageConfiguration
#define SOAP_TYPE_PointerTo_tds__DeleteStorageConfiguration (1974)
#endif

/* _tds__SetStorageConfiguration * has binding name 'PointerTo_tds__SetStorageConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetStorageConfiguration
#define SOAP_TYPE_PointerTo_tds__SetStorageConfiguration (1970)
#endif

/* _tds__GetStorageConfiguration * has binding name 'PointerTo_tds__GetStorageConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetStorageConfiguration
#define SOAP_TYPE_PointerTo_tds__GetStorageConfiguration (1966)
#endif

/* _tds__CreateStorageConfiguration * has binding name 'PointerTo_tds__CreateStorageConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__CreateStorageConfiguration
#define SOAP_TYPE_PointerTo_tds__CreateStorageConfiguration (1962)
#endif

/* _tds__GetStorageConfigurations * has binding name 'PointerTo_tds__GetStorageConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetStorageConfigurations
#define SOAP_TYPE_PointerTo_tds__GetStorageConfigurations (1958)
#endif

/* _tds__StartSystemRestore * has binding name 'PointerTo_tds__StartSystemRestore' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__StartSystemRestore
#define SOAP_TYPE_PointerTo_tds__StartSystemRestore (1954)
#endif

/* _tds__StartFirmwareUpgrade * has binding name 'PointerTo_tds__StartFirmwareUpgrade' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__StartFirmwareUpgrade
#define SOAP_TYPE_PointerTo_tds__StartFirmwareUpgrade (1950)
#endif

/* _tds__GetSystemUris * has binding name 'PointerTo_tds__GetSystemUris' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetSystemUris
#define SOAP_TYPE_PointerTo_tds__GetSystemUris (1946)
#endif

/* _tds__ScanAvailableDot11Networks * has binding name 'PointerTo_tds__ScanAvailableDot11Networks' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__ScanAvailableDot11Networks
#define SOAP_TYPE_PointerTo_tds__ScanAvailableDot11Networks (1942)
#endif

/* _tds__GetDot11Status * has binding name 'PointerTo_tds__GetDot11Status' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDot11Status
#define SOAP_TYPE_PointerTo_tds__GetDot11Status (1938)
#endif

/* _tds__GetDot11Capabilities * has binding name 'PointerTo_tds__GetDot11Capabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDot11Capabilities
#define SOAP_TYPE_PointerTo_tds__GetDot11Capabilities (1934)
#endif

/* _tds__DeleteDot1XConfiguration * has binding name 'PointerTo_tds__DeleteDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__DeleteDot1XConfiguration
#define SOAP_TYPE_PointerTo_tds__DeleteDot1XConfiguration (1930)
#endif

/* _tds__GetDot1XConfigurations * has binding name 'PointerTo_tds__GetDot1XConfigurations' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDot1XConfigurations
#define SOAP_TYPE_PointerTo_tds__GetDot1XConfigurations (1926)
#endif

/* _tds__GetDot1XConfiguration * has binding name 'PointerTo_tds__GetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDot1XConfiguration
#define SOAP_TYPE_PointerTo_tds__GetDot1XConfiguration (1922)
#endif

/* _tds__SetDot1XConfiguration * has binding name 'PointerTo_tds__SetDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetDot1XConfiguration
#define SOAP_TYPE_PointerTo_tds__SetDot1XConfiguration (1918)
#endif

/* _tds__CreateDot1XConfiguration * has binding name 'PointerTo_tds__CreateDot1XConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__CreateDot1XConfiguration
#define SOAP_TYPE_PointerTo_tds__CreateDot1XConfiguration (1914)
#endif

/* _tds__LoadCACertificates * has binding name 'PointerTo_tds__LoadCACertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__LoadCACertificates
#define SOAP_TYPE_PointerTo_tds__LoadCACertificates (1910)
#endif

/* _tds__GetCertificateInformation * has binding name 'PointerTo_tds__GetCertificateInformation' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetCertificateInformation
#define SOAP_TYPE_PointerTo_tds__GetCertificateInformation (1906)
#endif

/* _tds__LoadCertificateWithPrivateKey * has binding name 'PointerTo_tds__LoadCertificateWithPrivateKey' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKey
#define SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKey (1902)
#endif

/* _tds__GetCACertificates * has binding name 'PointerTo_tds__GetCACertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetCACertificates
#define SOAP_TYPE_PointerTo_tds__GetCACertificates (1898)
#endif

/* _tds__SendAuxiliaryCommand * has binding name 'PointerTo_tds__SendAuxiliaryCommand' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommand
#define SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommand (1894)
#endif

/* _tds__SetRelayOutputState * has binding name 'PointerTo_tds__SetRelayOutputState' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetRelayOutputState
#define SOAP_TYPE_PointerTo_tds__SetRelayOutputState (1890)
#endif

/* _tds__SetRelayOutputSettings * has binding name 'PointerTo_tds__SetRelayOutputSettings' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetRelayOutputSettings
#define SOAP_TYPE_PointerTo_tds__SetRelayOutputSettings (1886)
#endif

/* _tds__GetRelayOutputs * has binding name 'PointerTo_tds__GetRelayOutputs' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetRelayOutputs
#define SOAP_TYPE_PointerTo_tds__GetRelayOutputs (1882)
#endif

/* _tds__SetClientCertificateMode * has binding name 'PointerTo_tds__SetClientCertificateMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetClientCertificateMode
#define SOAP_TYPE_PointerTo_tds__SetClientCertificateMode (1878)
#endif

/* _tds__GetClientCertificateMode * has binding name 'PointerTo_tds__GetClientCertificateMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetClientCertificateMode
#define SOAP_TYPE_PointerTo_tds__GetClientCertificateMode (1874)
#endif

/* _tds__LoadCertificates * has binding name 'PointerTo_tds__LoadCertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__LoadCertificates
#define SOAP_TYPE_PointerTo_tds__LoadCertificates (1870)
#endif

/* _tds__GetPkcs10Request * has binding name 'PointerTo_tds__GetPkcs10Request' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetPkcs10Request
#define SOAP_TYPE_PointerTo_tds__GetPkcs10Request (1866)
#endif

/* _tds__DeleteCertificates * has binding name 'PointerTo_tds__DeleteCertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__DeleteCertificates
#define SOAP_TYPE_PointerTo_tds__DeleteCertificates (1862)
#endif

/* _tds__SetCertificatesStatus * has binding name 'PointerTo_tds__SetCertificatesStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetCertificatesStatus
#define SOAP_TYPE_PointerTo_tds__SetCertificatesStatus (1858)
#endif

/* _tds__GetCertificatesStatus * has binding name 'PointerTo_tds__GetCertificatesStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetCertificatesStatus
#define SOAP_TYPE_PointerTo_tds__GetCertificatesStatus (1854)
#endif

/* _tds__GetCertificates * has binding name 'PointerTo_tds__GetCertificates' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetCertificates
#define SOAP_TYPE_PointerTo_tds__GetCertificates (1850)
#endif

/* _tds__CreateCertificate * has binding name 'PointerTo_tds__CreateCertificate' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__CreateCertificate
#define SOAP_TYPE_PointerTo_tds__CreateCertificate (1846)
#endif

/* _tds__SetAccessPolicy * has binding name 'PointerTo_tds__SetAccessPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetAccessPolicy
#define SOAP_TYPE_PointerTo_tds__SetAccessPolicy (1842)
#endif

/* _tds__GetAccessPolicy * has binding name 'PointerTo_tds__GetAccessPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetAccessPolicy
#define SOAP_TYPE_PointerTo_tds__GetAccessPolicy (1838)
#endif

/* _tds__RemoveIPAddressFilter * has binding name 'PointerTo_tds__RemoveIPAddressFilter' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilter
#define SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilter (1834)
#endif

/* _tds__AddIPAddressFilter * has binding name 'PointerTo_tds__AddIPAddressFilter' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__AddIPAddressFilter
#define SOAP_TYPE_PointerTo_tds__AddIPAddressFilter (1830)
#endif

/* _tds__SetIPAddressFilter * has binding name 'PointerTo_tds__SetIPAddressFilter' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetIPAddressFilter
#define SOAP_TYPE_PointerTo_tds__SetIPAddressFilter (1826)
#endif

/* _tds__GetIPAddressFilter * has binding name 'PointerTo_tds__GetIPAddressFilter' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetIPAddressFilter
#define SOAP_TYPE_PointerTo_tds__GetIPAddressFilter (1822)
#endif

/* _tds__SetZeroConfiguration * has binding name 'PointerTo_tds__SetZeroConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetZeroConfiguration
#define SOAP_TYPE_PointerTo_tds__SetZeroConfiguration (1818)
#endif

/* _tds__GetZeroConfiguration * has binding name 'PointerTo_tds__GetZeroConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetZeroConfiguration
#define SOAP_TYPE_PointerTo_tds__GetZeroConfiguration (1814)
#endif

/* _tds__SetNetworkDefaultGateway * has binding name 'PointerTo_tds__SetNetworkDefaultGateway' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGateway
#define SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGateway (1810)
#endif

/* _tds__GetNetworkDefaultGateway * has binding name 'PointerTo_tds__GetNetworkDefaultGateway' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGateway
#define SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGateway (1806)
#endif

/* _tds__SetNetworkProtocols * has binding name 'PointerTo_tds__SetNetworkProtocols' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetNetworkProtocols
#define SOAP_TYPE_PointerTo_tds__SetNetworkProtocols (1802)
#endif

/* _tds__GetNetworkProtocols * has binding name 'PointerTo_tds__GetNetworkProtocols' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetNetworkProtocols
#define SOAP_TYPE_PointerTo_tds__GetNetworkProtocols (1798)
#endif

/* _tds__SetNetworkInterfaces * has binding name 'PointerTo_tds__SetNetworkInterfaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetNetworkInterfaces
#define SOAP_TYPE_PointerTo_tds__SetNetworkInterfaces (1794)
#endif

/* _tds__GetNetworkInterfaces * has binding name 'PointerTo_tds__GetNetworkInterfaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetNetworkInterfaces
#define SOAP_TYPE_PointerTo_tds__GetNetworkInterfaces (1790)
#endif

/* _tds__SetDynamicDNS * has binding name 'PointerTo_tds__SetDynamicDNS' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetDynamicDNS
#define SOAP_TYPE_PointerTo_tds__SetDynamicDNS (1786)
#endif

/* _tds__GetDynamicDNS * has binding name 'PointerTo_tds__GetDynamicDNS' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDynamicDNS
#define SOAP_TYPE_PointerTo_tds__GetDynamicDNS (1782)
#endif

/* _tds__SetNTP * has binding name 'PointerTo_tds__SetNTP' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetNTP
#define SOAP_TYPE_PointerTo_tds__SetNTP (1778)
#endif

/* _tds__GetNTP * has binding name 'PointerTo_tds__GetNTP' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetNTP
#define SOAP_TYPE_PointerTo_tds__GetNTP (1774)
#endif

/* _tds__SetDNS * has binding name 'PointerTo_tds__SetDNS' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetDNS
#define SOAP_TYPE_PointerTo_tds__SetDNS (1770)
#endif

/* _tds__GetDNS * has binding name 'PointerTo_tds__GetDNS' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDNS
#define SOAP_TYPE_PointerTo_tds__GetDNS (1766)
#endif

/* _tds__SetHostnameFromDHCP * has binding name 'PointerTo_tds__SetHostnameFromDHCP' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCP
#define SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCP (1762)
#endif

/* _tds__SetHostname * has binding name 'PointerTo_tds__SetHostname' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetHostname
#define SOAP_TYPE_PointerTo_tds__SetHostname (1758)
#endif

/* _tds__GetHostname * has binding name 'PointerTo_tds__GetHostname' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetHostname
#define SOAP_TYPE_PointerTo_tds__GetHostname (1754)
#endif

/* _tds__SetDPAddresses * has binding name 'PointerTo_tds__SetDPAddresses' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetDPAddresses
#define SOAP_TYPE_PointerTo_tds__SetDPAddresses (1750)
#endif

/* _tds__GetCapabilities * has binding name 'PointerTo_tds__GetCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetCapabilities
#define SOAP_TYPE_PointerTo_tds__GetCapabilities (1746)
#endif

/* _tds__SetAuthFailureWarningConfiguration * has binding name 'PointerTo_tds__SetAuthFailureWarningConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetAuthFailureWarningConfiguration
#define SOAP_TYPE_PointerTo_tds__SetAuthFailureWarningConfiguration (1742)
#endif

/* _tds__GetAuthFailureWarningConfiguration * has binding name 'PointerTo_tds__GetAuthFailureWarningConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetAuthFailureWarningConfiguration
#define SOAP_TYPE_PointerTo_tds__GetAuthFailureWarningConfiguration (1738)
#endif

/* _tds__GetAuthFailureWarningOptions * has binding name 'PointerTo_tds__GetAuthFailureWarningOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetAuthFailureWarningOptions
#define SOAP_TYPE_PointerTo_tds__GetAuthFailureWarningOptions (1734)
#endif

/* _tds__SetPasswordHistoryConfiguration * has binding name 'PointerTo_tds__SetPasswordHistoryConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetPasswordHistoryConfiguration
#define SOAP_TYPE_PointerTo_tds__SetPasswordHistoryConfiguration (1730)
#endif

/* _tds__GetPasswordHistoryConfiguration * has binding name 'PointerTo_tds__GetPasswordHistoryConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetPasswordHistoryConfiguration
#define SOAP_TYPE_PointerTo_tds__GetPasswordHistoryConfiguration (1726)
#endif

/* _tds__SetPasswordComplexityConfiguration * has binding name 'PointerTo_tds__SetPasswordComplexityConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetPasswordComplexityConfiguration
#define SOAP_TYPE_PointerTo_tds__SetPasswordComplexityConfiguration (1722)
#endif

/* _tds__GetPasswordComplexityConfiguration * has binding name 'PointerTo_tds__GetPasswordComplexityConfiguration' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetPasswordComplexityConfiguration
#define SOAP_TYPE_PointerTo_tds__GetPasswordComplexityConfiguration (1718)
#endif

/* _tds__GetPasswordComplexityOptions * has binding name 'PointerTo_tds__GetPasswordComplexityOptions' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetPasswordComplexityOptions
#define SOAP_TYPE_PointerTo_tds__GetPasswordComplexityOptions (1714)
#endif

/* _tds__GetWsdlUrl * has binding name 'PointerTo_tds__GetWsdlUrl' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetWsdlUrl
#define SOAP_TYPE_PointerTo_tds__GetWsdlUrl (1710)
#endif

/* _tds__SetUser * has binding name 'PointerTo_tds__SetUser' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetUser
#define SOAP_TYPE_PointerTo_tds__SetUser (1706)
#endif

/* _tds__DeleteUsers * has binding name 'PointerTo_tds__DeleteUsers' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__DeleteUsers
#define SOAP_TYPE_PointerTo_tds__DeleteUsers (1702)
#endif

/* _tds__CreateUsers * has binding name 'PointerTo_tds__CreateUsers' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__CreateUsers
#define SOAP_TYPE_PointerTo_tds__CreateUsers (1698)
#endif

/* _tds__GetUsers * has binding name 'PointerTo_tds__GetUsers' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetUsers
#define SOAP_TYPE_PointerTo_tds__GetUsers (1694)
#endif

/* _tds__SetRemoteUser * has binding name 'PointerTo_tds__SetRemoteUser' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetRemoteUser
#define SOAP_TYPE_PointerTo_tds__SetRemoteUser (1690)
#endif

/* _tds__GetRemoteUser * has binding name 'PointerTo_tds__GetRemoteUser' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetRemoteUser
#define SOAP_TYPE_PointerTo_tds__GetRemoteUser (1686)
#endif

/* _tds__GetEndpointReference * has binding name 'PointerTo_tds__GetEndpointReference' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetEndpointReference
#define SOAP_TYPE_PointerTo_tds__GetEndpointReference (1682)
#endif

/* _tds__GetDPAddresses * has binding name 'PointerTo_tds__GetDPAddresses' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDPAddresses
#define SOAP_TYPE_PointerTo_tds__GetDPAddresses (1678)
#endif

/* _tds__SetRemoteDiscoveryMode * has binding name 'PointerTo_tds__SetRemoteDiscoveryMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryMode
#define SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryMode (1674)
#endif

/* _tds__GetRemoteDiscoveryMode * has binding name 'PointerTo_tds__GetRemoteDiscoveryMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryMode
#define SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryMode (1670)
#endif

/* _tds__SetDiscoveryMode * has binding name 'PointerTo_tds__SetDiscoveryMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetDiscoveryMode
#define SOAP_TYPE_PointerTo_tds__SetDiscoveryMode (1666)
#endif

/* _tds__GetDiscoveryMode * has binding name 'PointerTo_tds__GetDiscoveryMode' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDiscoveryMode
#define SOAP_TYPE_PointerTo_tds__GetDiscoveryMode (1662)
#endif

/* _tds__RemoveScopes * has binding name 'PointerTo_tds__RemoveScopes' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__RemoveScopes
#define SOAP_TYPE_PointerTo_tds__RemoveScopes (1658)
#endif

/* _tds__AddScopes * has binding name 'PointerTo_tds__AddScopes' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__AddScopes
#define SOAP_TYPE_PointerTo_tds__AddScopes (1654)
#endif

/* _tds__SetScopes * has binding name 'PointerTo_tds__SetScopes' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetScopes
#define SOAP_TYPE_PointerTo_tds__SetScopes (1650)
#endif

/* _tds__GetScopes * has binding name 'PointerTo_tds__GetScopes' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetScopes
#define SOAP_TYPE_PointerTo_tds__GetScopes (1646)
#endif

/* _tds__GetSystemSupportInformation * has binding name 'PointerTo_tds__GetSystemSupportInformation' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetSystemSupportInformation
#define SOAP_TYPE_PointerTo_tds__GetSystemSupportInformation (1642)
#endif

/* _tds__GetSystemLog * has binding name 'PointerTo_tds__GetSystemLog' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetSystemLog
#define SOAP_TYPE_PointerTo_tds__GetSystemLog (1638)
#endif

/* _tds__GetSystemBackup * has binding name 'PointerTo_tds__GetSystemBackup' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetSystemBackup
#define SOAP_TYPE_PointerTo_tds__GetSystemBackup (1634)
#endif

/* _tds__RestoreSystem * has binding name 'PointerTo_tds__RestoreSystem' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__RestoreSystem
#define SOAP_TYPE_PointerTo_tds__RestoreSystem (1630)
#endif

/* _tds__SystemReboot * has binding name 'PointerTo_tds__SystemReboot' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SystemReboot
#define SOAP_TYPE_PointerTo_tds__SystemReboot (1626)
#endif

/* _tds__UpgradeSystemFirmware * has binding name 'PointerTo_tds__UpgradeSystemFirmware' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmware
#define SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmware (1622)
#endif

/* _tds__SetSystemFactoryDefault * has binding name 'PointerTo_tds__SetSystemFactoryDefault' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefault
#define SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefault (1618)
#endif

/* _tds__GetSystemDateAndTime * has binding name 'PointerTo_tds__GetSystemDateAndTime' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetSystemDateAndTime
#define SOAP_TYPE_PointerTo_tds__GetSystemDateAndTime (1614)
#endif

/* _tds__SetSystemDateAndTime * has binding name 'PointerTo_tds__SetSystemDateAndTime' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__SetSystemDateAndTime
#define SOAP_TYPE_PointerTo_tds__SetSystemDateAndTime (1610)
#endif

/* _tds__GetDeviceInformation * has binding name 'PointerTo_tds__GetDeviceInformation' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetDeviceInformation
#define SOAP_TYPE_PointerTo_tds__GetDeviceInformation (1606)
#endif

/* _tds__GetServiceCapabilities * has binding name 'PointerTo_tds__GetServiceCapabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetServiceCapabilities
#define SOAP_TYPE_PointerTo_tds__GetServiceCapabilities (1602)
#endif

/* _tds__GetServices * has binding name 'PointerTo_tds__GetServices' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetServices
#define SOAP_TYPE_PointerTo_tds__GetServices (1598)
#endif

/* std::string * has binding name 'PointerToxsd__NCName' for type 'xsd:NCName' */
#ifndef SOAP_TYPE_PointerToxsd__NCName
#define SOAP_TYPE_PointerToxsd__NCName (1597)
#endif

/* std::string * has binding name 'PointerTowstop__ConcreteTopicExpression' for type 'wstop:ConcreteTopicExpression' */
#ifndef SOAP_TYPE_PointerTowstop__ConcreteTopicExpression
#define SOAP_TYPE_PointerTowstop__ConcreteTopicExpression (1595)
#endif

/* std::string * has binding name 'PointerToxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_PointerToxsd__QName
#define SOAP_TYPE_PointerToxsd__QName (1594)
#endif

/* wstop__TopicType * has binding name 'PointerTowstop__TopicType' for type 'wstop:TopicType' */
#ifndef SOAP_TYPE_PointerTowstop__TopicType
#define SOAP_TYPE_PointerTowstop__TopicType (1592)
#endif

/* wstop__QueryExpressionType * has binding name 'PointerTowstop__QueryExpressionType' for type 'wstop:QueryExpressionType' */
#ifndef SOAP_TYPE_PointerTowstop__QueryExpressionType
#define SOAP_TYPE_PointerTowstop__QueryExpressionType (1591)
#endif

/* tt__OSDConfigurationExtension * has binding name 'PointerTott__OSDConfigurationExtension' for type 'tt:OSDConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDConfigurationExtension
#define SOAP_TYPE_PointerTott__OSDConfigurationExtension (1588)
#endif

/* tt__OSDImgConfiguration * has binding name 'PointerTott__OSDImgConfiguration' for type 'tt:OSDImgConfiguration' */
#ifndef SOAP_TYPE_PointerTott__OSDImgConfiguration
#define SOAP_TYPE_PointerTott__OSDImgConfiguration (1587)
#endif

/* tt__OSDTextConfiguration * has binding name 'PointerTott__OSDTextConfiguration' for type 'tt:OSDTextConfiguration' */
#ifndef SOAP_TYPE_PointerTott__OSDTextConfiguration
#define SOAP_TYPE_PointerTott__OSDTextConfiguration (1586)
#endif

/* tt__OSDPosConfiguration * has binding name 'PointerTott__OSDPosConfiguration' for type 'tt:OSDPosConfiguration' */
#ifndef SOAP_TYPE_PointerTott__OSDPosConfiguration
#define SOAP_TYPE_PointerTott__OSDPosConfiguration (1585)
#endif

/* tt__OSDReference * has binding name 'PointerTott__OSDReference' for type 'tt:OSDReference' */
#ifndef SOAP_TYPE_PointerTott__OSDReference
#define SOAP_TYPE_PointerTott__OSDReference (1584)
#endif

/* tt__MetadataInput * has binding name 'PointerTott__MetadataInput' for type 'tt:MetadataInput' */
#ifndef SOAP_TYPE_PointerTott__MetadataInput
#define SOAP_TYPE_PointerTott__MetadataInput (1583)
#endif

/* tt__SourceIdentification * has binding name 'PointerTott__SourceIdentification' for type 'tt:SourceIdentification' */
#ifndef SOAP_TYPE_PointerTott__SourceIdentification
#define SOAP_TYPE_PointerTott__SourceIdentification (1582)
#endif

/* tt__AnalyticsDeviceEngineConfiguration * has binding name 'PointerTott__AnalyticsDeviceEngineConfiguration' for type 'tt:AnalyticsDeviceEngineConfiguration' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_PointerTott__AnalyticsDeviceEngineConfiguration (1581)
#endif

/* tt__PTZConfigurationExtension * has binding name 'PointerTott__PTZConfigurationExtension' for type 'tt:PTZConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZConfigurationExtension
#define SOAP_TYPE_PointerTott__PTZConfigurationExtension (1580)
#endif

/* tt__ZoomLimits * has binding name 'PointerTott__ZoomLimits' for type 'tt:ZoomLimits' */
#ifndef SOAP_TYPE_PointerTott__ZoomLimits
#define SOAP_TYPE_PointerTott__ZoomLimits (1579)
#endif

/* tt__PanTiltLimits * has binding name 'PointerTott__PanTiltLimits' for type 'tt:PanTiltLimits' */
#ifndef SOAP_TYPE_PointerTott__PanTiltLimits
#define SOAP_TYPE_PointerTott__PanTiltLimits (1578)
#endif

/* tt__PTZNodeExtension * has binding name 'PointerTott__PTZNodeExtension' for type 'tt:PTZNodeExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZNodeExtension
#define SOAP_TYPE_PointerTott__PTZNodeExtension (1577)
#endif

/* enum tt__DigitalIdleState * has binding name 'PointerTott__DigitalIdleState' for type 'tt:DigitalIdleState' */
#ifndef SOAP_TYPE_PointerTott__DigitalIdleState
#define SOAP_TYPE_PointerTott__DigitalIdleState (1576)
#endif

/* tt__NetworkInterfaceExtension * has binding name 'PointerTott__NetworkInterfaceExtension' for type 'tt:NetworkInterfaceExtension' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceExtension
#define SOAP_TYPE_PointerTott__NetworkInterfaceExtension (1575)
#endif

/* tt__IPv6NetworkInterface * has binding name 'PointerTott__IPv6NetworkInterface' for type 'tt:IPv6NetworkInterface' */
#ifndef SOAP_TYPE_PointerTott__IPv6NetworkInterface
#define SOAP_TYPE_PointerTott__IPv6NetworkInterface (1574)
#endif

/* tt__IPv4NetworkInterface * has binding name 'PointerTott__IPv4NetworkInterface' for type 'tt:IPv4NetworkInterface' */
#ifndef SOAP_TYPE_PointerTott__IPv4NetworkInterface
#define SOAP_TYPE_PointerTott__IPv4NetworkInterface (1573)
#endif

/* tt__NetworkInterfaceLink * has binding name 'PointerTott__NetworkInterfaceLink' for type 'tt:NetworkInterfaceLink' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceLink
#define SOAP_TYPE_PointerTott__NetworkInterfaceLink (1572)
#endif

/* tt__NetworkInterfaceInfo * has binding name 'PointerTott__NetworkInterfaceInfo' for type 'tt:NetworkInterfaceInfo' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceInfo
#define SOAP_TYPE_PointerTott__NetworkInterfaceInfo (1571)
#endif

/* tt__VideoOutputExtension * has binding name 'PointerTott__VideoOutputExtension' for type 'tt:VideoOutputExtension' */
#ifndef SOAP_TYPE_PointerTott__VideoOutputExtension
#define SOAP_TYPE_PointerTott__VideoOutputExtension (1570)
#endif

/* tt__Layout * has binding name 'PointerTott__Layout' for type 'tt:Layout' */
#ifndef SOAP_TYPE_PointerTott__Layout
#define SOAP_TYPE_PointerTott__Layout (1569)
#endif

/* tt__MetadataConfigurationExtension * has binding name 'PointerTott__MetadataConfigurationExtension' for type 'tt:MetadataConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__MetadataConfigurationExtension
#define SOAP_TYPE_PointerTott__MetadataConfigurationExtension (1568)
#endif

/* tt__EventSubscription * has binding name 'PointerTott__EventSubscription' for type 'tt:EventSubscription' */
#ifndef SOAP_TYPE_PointerTott__EventSubscription
#define SOAP_TYPE_PointerTott__EventSubscription (1567)
#endif

/* tt__PTZFilter * has binding name 'PointerTott__PTZFilter' for type 'tt:PTZFilter' */
#ifndef SOAP_TYPE_PointerTott__PTZFilter
#define SOAP_TYPE_PointerTott__PTZFilter (1566)
#endif

/* tt__RuleEngineConfiguration * has binding name 'PointerTott__RuleEngineConfiguration' for type 'tt:RuleEngineConfiguration' */
#ifndef SOAP_TYPE_PointerTott__RuleEngineConfiguration
#define SOAP_TYPE_PointerTott__RuleEngineConfiguration (1565)
#endif

/* tt__AnalyticsEngineConfiguration * has binding name 'PointerTott__AnalyticsEngineConfiguration' for type 'tt:AnalyticsEngineConfiguration' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration
#define SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration (1564)
#endif

/* tt__VideoRateControl2 * has binding name 'PointerTott__VideoRateControl2' for type 'tt:VideoRateControl2' */
#ifndef SOAP_TYPE_PointerTott__VideoRateControl2
#define SOAP_TYPE_PointerTott__VideoRateControl2 (1563)
#endif

/* tt__MulticastConfiguration * has binding name 'PointerTott__MulticastConfiguration' for type 'tt:MulticastConfiguration' */
#ifndef SOAP_TYPE_PointerTott__MulticastConfiguration
#define SOAP_TYPE_PointerTott__MulticastConfiguration (1562)
#endif

/* tt__H264Configuration * has binding name 'PointerTott__H264Configuration' for type 'tt:H264Configuration' */
#ifndef SOAP_TYPE_PointerTott__H264Configuration
#define SOAP_TYPE_PointerTott__H264Configuration (1561)
#endif

/* tt__Mpeg4Configuration * has binding name 'PointerTott__Mpeg4Configuration' for type 'tt:Mpeg4Configuration' */
#ifndef SOAP_TYPE_PointerTott__Mpeg4Configuration
#define SOAP_TYPE_PointerTott__Mpeg4Configuration (1560)
#endif

/* tt__VideoRateControl * has binding name 'PointerTott__VideoRateControl' for type 'tt:VideoRateControl' */
#ifndef SOAP_TYPE_PointerTott__VideoRateControl
#define SOAP_TYPE_PointerTott__VideoRateControl (1559)
#endif

/* tt__VideoSourceConfigurationExtension * has binding name 'PointerTott__VideoSourceConfigurationExtension' for type 'tt:VideoSourceConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension (1558)
#endif

/* tt__IntRectangle * has binding name 'PointerTott__IntRectangle' for type 'tt:IntRectangle' */
#ifndef SOAP_TYPE_PointerTott__IntRectangle
#define SOAP_TYPE_PointerTott__IntRectangle (1557)
#endif

/* tt__VideoSourceExtension * has binding name 'PointerTott__VideoSourceExtension' for type 'tt:VideoSourceExtension' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceExtension
#define SOAP_TYPE_PointerTott__VideoSourceExtension (1556)
#endif

/* tt__ImagingSettings * has binding name 'PointerTott__ImagingSettings' for type 'tt:ImagingSettings' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettings
#define SOAP_TYPE_PointerTott__ImagingSettings (1555)
#endif

/* wstop__Documentation * has binding name 'PointerTowstop__Documentation' for type 'wstop:Documentation' */
#ifndef SOAP_TYPE_PointerTowstop__Documentation
#define SOAP_TYPE_PointerTowstop__Documentation (1554)
#endif

/* _wsrfbf__BaseFaultType_FaultCause * has binding name 'PointerTo_wsrfbf__BaseFaultType_FaultCause' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause
#define SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause (1553)
#endif

/* std::string * has binding name 'PointerTo_xml__lang' for type '' */
#ifndef SOAP_TYPE_PointerTo_xml__lang
#define SOAP_TYPE_PointerTo_xml__lang (1550)
#endif

/* _wsrfbf__BaseFaultType_ErrorCode * has binding name 'PointerTo_wsrfbf__BaseFaultType_ErrorCode' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode
#define SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode (1548)
#endif

/* std::string * has binding name 'PointerToxsd__nonNegativeInteger' for type 'xsd:nonNegativeInteger' */
#ifndef SOAP_TYPE_PointerToxsd__nonNegativeInteger
#define SOAP_TYPE_PointerToxsd__nonNegativeInteger (1546)
#endif

/* _wsnt__Subscribe_SubscriptionPolicy * has binding name 'PointerTo_wsnt__Subscribe_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy
#define SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy (1545)
#endif

/* std::string * has binding name 'PointerTowsnt__AbsoluteOrRelativeTimeType' for type 'wsnt:AbsoluteOrRelativeTimeType' */
#ifndef SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_PointerTowsnt__AbsoluteOrRelativeTimeType (1543)
#endif

/* wsnt__SubscriptionPolicyType * has binding name 'PointerTowsnt__SubscriptionPolicyType' for type 'wsnt:SubscriptionPolicyType' */
#ifndef SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType
#define SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType (1541)
#endif

/* wstop__TopicSetType * has binding name 'PointerTowstop__TopicSetType' for type 'wstop:TopicSetType' */
#ifndef SOAP_TYPE_PointerTowstop__TopicSetType
#define SOAP_TYPE_PointerTowstop__TopicSetType (1540)
#endif

/* wsnt__TopicExpressionType * has binding name 'PointerTowsnt__TopicExpressionType' for type 'wsnt:TopicExpressionType' */
#ifndef SOAP_TYPE_PointerTowsnt__TopicExpressionType
#define SOAP_TYPE_PointerTowsnt__TopicExpressionType (1537)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTowsa5__EndpointReferenceType' for type 'wsa5:EndpointReferenceType' */
#ifndef SOAP_TYPE_PointerTowsa5__EndpointReferenceType
#define SOAP_TYPE_PointerTowsa5__EndpointReferenceType (1536)
#endif

/* enum tt__PropertyOperation * has binding name 'PointerTott__PropertyOperation' for type 'tt:PropertyOperation' */
#ifndef SOAP_TYPE_PointerTott__PropertyOperation
#define SOAP_TYPE_PointerTott__PropertyOperation (1535)
#endif

/* tt__MessageExtension * has binding name 'PointerTott__MessageExtension' for type 'tt:MessageExtension' */
#ifndef SOAP_TYPE_PointerTott__MessageExtension
#define SOAP_TYPE_PointerTott__MessageExtension (1534)
#endif

/* tt__LocalOrientation * has binding name 'PointerTott__LocalOrientation' for type 'tt:LocalOrientation' */
#ifndef SOAP_TYPE_PointerTott__LocalOrientation
#define SOAP_TYPE_PointerTott__LocalOrientation (1533)
#endif

/* tt__LocalLocation * has binding name 'PointerTott__LocalLocation' for type 'tt:LocalLocation' */
#ifndef SOAP_TYPE_PointerTott__LocalLocation
#define SOAP_TYPE_PointerTott__LocalLocation (1532)
#endif

/* tt__GeoOrientation * has binding name 'PointerTott__GeoOrientation' for type 'tt:GeoOrientation' */
#ifndef SOAP_TYPE_PointerTott__GeoOrientation
#define SOAP_TYPE_PointerTott__GeoOrientation (1531)
#endif

/* tt__GeoLocation * has binding name 'PointerTott__GeoLocation' for type 'tt:GeoLocation' */
#ifndef SOAP_TYPE_PointerTott__GeoLocation
#define SOAP_TYPE_PointerTott__GeoLocation (1530)
#endif

/* double * has binding name 'PointerTodouble' for type 'xsd:double' */
#ifndef SOAP_TYPE_PointerTodouble
#define SOAP_TYPE_PointerTodouble (1529)
#endif

/* tt__TransformationExtension * has binding name 'PointerTott__TransformationExtension' for type 'tt:TransformationExtension' */
#ifndef SOAP_TYPE_PointerTott__TransformationExtension
#define SOAP_TYPE_PointerTott__TransformationExtension (1528)
#endif

/* xsd__anyType * has binding name 'PointerToxsd__anyType' for type 'xsd:anyType' */
#ifndef SOAP_TYPE_PointerToxsd__anyType
#define SOAP_TYPE_PointerToxsd__anyType (1527)
#endif

/* tt__ColorCovariance * has binding name 'PointerTott__ColorCovariance' for type 'tt:ColorCovariance' */
#ifndef SOAP_TYPE_PointerTott__ColorCovariance
#define SOAP_TYPE_PointerTott__ColorCovariance (1525)
#endif

/* enum tt__MoveStatus * has binding name 'PointerTott__MoveStatus' for type 'tt:MoveStatus' */
#ifndef SOAP_TYPE_PointerTott__MoveStatus
#define SOAP_TYPE_PointerTott__MoveStatus (1523)
#endif

/* tt__PTZMoveStatus * has binding name 'PointerTott__PTZMoveStatus' for type 'tt:PTZMoveStatus' */
#ifndef SOAP_TYPE_PointerTott__PTZMoveStatus
#define SOAP_TYPE_PointerTott__PTZMoveStatus (1522)
#endif

/* tt__StorageReferencePathExtension * has binding name 'PointerTott__StorageReferencePathExtension' for type 'tt:StorageReferencePathExtension' */
#ifndef SOAP_TYPE_PointerTott__StorageReferencePathExtension
#define SOAP_TYPE_PointerTott__StorageReferencePathExtension (1521)
#endif

/* tt__ArrayOfFileProgressExtension * has binding name 'PointerTott__ArrayOfFileProgressExtension' for type 'tt:ArrayOfFileProgressExtension' */
#ifndef SOAP_TYPE_PointerTott__ArrayOfFileProgressExtension
#define SOAP_TYPE_PointerTott__ArrayOfFileProgressExtension (1520)
#endif

/* tt__FileProgress * has binding name 'PointerTott__FileProgress' for type 'tt:FileProgress' */
#ifndef SOAP_TYPE_PointerTott__FileProgress
#define SOAP_TYPE_PointerTott__FileProgress (1518)
#endif

/* tt__OSDConfigurationOptionsExtension * has binding name 'PointerTott__OSDConfigurationOptionsExtension' for type 'tt:OSDConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDConfigurationOptionsExtension
#define SOAP_TYPE_PointerTott__OSDConfigurationOptionsExtension (1517)
#endif

/* tt__OSDImgOptions * has binding name 'PointerTott__OSDImgOptions' for type 'tt:OSDImgOptions' */
#ifndef SOAP_TYPE_PointerTott__OSDImgOptions
#define SOAP_TYPE_PointerTott__OSDImgOptions (1516)
#endif

/* tt__OSDTextOptions * has binding name 'PointerTott__OSDTextOptions' for type 'tt:OSDTextOptions' */
#ifndef SOAP_TYPE_PointerTott__OSDTextOptions
#define SOAP_TYPE_PointerTott__OSDTextOptions (1515)
#endif

/* tt__MaximumNumberOfOSDs * has binding name 'PointerTott__MaximumNumberOfOSDs' for type 'tt:MaximumNumberOfOSDs' */
#ifndef SOAP_TYPE_PointerTott__MaximumNumberOfOSDs
#define SOAP_TYPE_PointerTott__MaximumNumberOfOSDs (1513)
#endif

/* tt__OSDImgOptionsExtension * has binding name 'PointerTott__OSDImgOptionsExtension' for type 'tt:OSDImgOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDImgOptionsExtension
#define SOAP_TYPE_PointerTott__OSDImgOptionsExtension (1512)
#endif

/* tt__OSDTextOptionsExtension * has binding name 'PointerTott__OSDTextOptionsExtension' for type 'tt:OSDTextOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDTextOptionsExtension
#define SOAP_TYPE_PointerTott__OSDTextOptionsExtension (1511)
#endif

/* tt__OSDColorOptions * has binding name 'PointerTott__OSDColorOptions' for type 'tt:OSDColorOptions' */
#ifndef SOAP_TYPE_PointerTott__OSDColorOptions
#define SOAP_TYPE_PointerTott__OSDColorOptions (1510)
#endif

/* tt__OSDColorOptionsExtension * has binding name 'PointerTott__OSDColorOptionsExtension' for type 'tt:OSDColorOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDColorOptionsExtension
#define SOAP_TYPE_PointerTott__OSDColorOptionsExtension (1509)
#endif

/* tt__ColorOptions * has binding name 'PointerTott__ColorOptions' for type 'tt:ColorOptions' */
#ifndef SOAP_TYPE_PointerTott__ColorOptions
#define SOAP_TYPE_PointerTott__ColorOptions (1508)
#endif

/* std::vector<tt__ColorspaceRange *> * has binding name 'PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange' for type 'tt:ColorspaceRange' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTott__ColorspaceRange (1507)
#endif

/* tt__ColorspaceRange * has binding name 'PointerTott__ColorspaceRange' for type 'tt:ColorspaceRange' */
#ifndef SOAP_TYPE_PointerTott__ColorspaceRange
#define SOAP_TYPE_PointerTott__ColorspaceRange (1505)
#endif

/* std::vector<tt__Color *> * has binding name 'PointerTostd__vectorTemplateOfPointerTott__Color' for type 'tt:Color' */
#ifndef SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTott__Color
#define SOAP_TYPE_PointerTostd__vectorTemplateOfPointerTott__Color (1504)
#endif

/* tt__OSDImgConfigurationExtension * has binding name 'PointerTott__OSDImgConfigurationExtension' for type 'tt:OSDImgConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDImgConfigurationExtension
#define SOAP_TYPE_PointerTott__OSDImgConfigurationExtension (1501)
#endif

/* tt__OSDTextConfigurationExtension * has binding name 'PointerTott__OSDTextConfigurationExtension' for type 'tt:OSDTextConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDTextConfigurationExtension
#define SOAP_TYPE_PointerTott__OSDTextConfigurationExtension (1500)
#endif

/* tt__OSDColor * has binding name 'PointerTott__OSDColor' for type 'tt:OSDColor' */
#ifndef SOAP_TYPE_PointerTott__OSDColor
#define SOAP_TYPE_PointerTott__OSDColor (1499)
#endif

/* tt__Color * has binding name 'PointerTott__Color' for type 'tt:Color' */
#ifndef SOAP_TYPE_PointerTott__Color
#define SOAP_TYPE_PointerTott__Color (1498)
#endif

/* tt__OSDPosConfigurationExtension * has binding name 'PointerTott__OSDPosConfigurationExtension' for type 'tt:OSDPosConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__OSDPosConfigurationExtension
#define SOAP_TYPE_PointerTott__OSDPosConfigurationExtension (1497)
#endif

/* tt__ProfileStatusExtension * has binding name 'PointerTott__ProfileStatusExtension' for type 'tt:ProfileStatusExtension' */
#ifndef SOAP_TYPE_PointerTott__ProfileStatusExtension
#define SOAP_TYPE_PointerTott__ProfileStatusExtension (1496)
#endif

/* tt__ActiveConnection * has binding name 'PointerTott__ActiveConnection' for type 'tt:ActiveConnection' */
#ifndef SOAP_TYPE_PointerTott__ActiveConnection
#define SOAP_TYPE_PointerTott__ActiveConnection (1494)
#endif

/* tt__AudioClassDescriptorExtension * has binding name 'PointerTott__AudioClassDescriptorExtension' for type 'tt:AudioClassDescriptorExtension' */
#ifndef SOAP_TYPE_PointerTott__AudioClassDescriptorExtension
#define SOAP_TYPE_PointerTott__AudioClassDescriptorExtension (1493)
#endif

/* tt__AudioClassCandidate * has binding name 'PointerTott__AudioClassCandidate' for type 'tt:AudioClassCandidate' */
#ifndef SOAP_TYPE_PointerTott__AudioClassCandidate
#define SOAP_TYPE_PointerTott__AudioClassCandidate (1491)
#endif

/* tt__ActionEngineEventPayloadExtension * has binding name 'PointerTott__ActionEngineEventPayloadExtension' for type 'tt:ActionEngineEventPayloadExtension' */
#ifndef SOAP_TYPE_PointerTott__ActionEngineEventPayloadExtension
#define SOAP_TYPE_PointerTott__ActionEngineEventPayloadExtension (1490)
#endif

/* struct SOAP_ENV__Fault * has binding name 'PointerToSOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Fault
#define SOAP_TYPE_PointerToSOAP_ENV__Fault (1489)
#endif

/* struct SOAP_ENV__Envelope * has binding name 'PointerToSOAP_ENV__Envelope' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Envelope
#define SOAP_TYPE_PointerToSOAP_ENV__Envelope (1488)
#endif

/* tt__AnalyticsState * has binding name 'PointerTott__AnalyticsState' for type 'tt:AnalyticsState' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsState
#define SOAP_TYPE_PointerTott__AnalyticsState (1487)
#endif

/* tt__MetadataInputExtension * has binding name 'PointerTott__MetadataInputExtension' for type 'tt:MetadataInputExtension' */
#ifndef SOAP_TYPE_PointerTott__MetadataInputExtension
#define SOAP_TYPE_PointerTott__MetadataInputExtension (1486)
#endif

/* tt__SourceIdentificationExtension * has binding name 'PointerTott__SourceIdentificationExtension' for type 'tt:SourceIdentificationExtension' */
#ifndef SOAP_TYPE_PointerTott__SourceIdentificationExtension
#define SOAP_TYPE_PointerTott__SourceIdentificationExtension (1485)
#endif

/* tt__AnalyticsEngineInputInfoExtension * has binding name 'PointerTott__AnalyticsEngineInputInfoExtension' for type 'tt:AnalyticsEngineInputInfoExtension' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_PointerTott__AnalyticsEngineInputInfoExtension (1484)
#endif

/* tt__AnalyticsEngineInputInfo * has binding name 'PointerTott__AnalyticsEngineInputInfo' for type 'tt:AnalyticsEngineInputInfo' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsEngineInputInfo
#define SOAP_TYPE_PointerTott__AnalyticsEngineInputInfo (1483)
#endif

/* tt__AnalyticsDeviceEngineConfigurationExtension * has binding name 'PointerTott__AnalyticsDeviceEngineConfigurationExtension' for type 'tt:AnalyticsDeviceEngineConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_PointerTott__AnalyticsDeviceEngineConfigurationExtension (1482)
#endif

/* tt__EngineConfiguration * has binding name 'PointerTott__EngineConfiguration' for type 'tt:EngineConfiguration' */
#ifndef SOAP_TYPE_PointerTott__EngineConfiguration
#define SOAP_TYPE_PointerTott__EngineConfiguration (1480)
#endif

/* tt__RecordingJobConfiguration * has binding name 'PointerTott__RecordingJobConfiguration' for type 'tt:RecordingJobConfiguration' */
#ifndef SOAP_TYPE_PointerTott__RecordingJobConfiguration
#define SOAP_TYPE_PointerTott__RecordingJobConfiguration (1479)
#endif

/* tt__RecordingJobStateTrack * has binding name 'PointerTott__RecordingJobStateTrack' for type 'tt:RecordingJobStateTrack' */
#ifndef SOAP_TYPE_PointerTott__RecordingJobStateTrack
#define SOAP_TYPE_PointerTott__RecordingJobStateTrack (1477)
#endif

/* tt__RecordingJobStateTracks * has binding name 'PointerTott__RecordingJobStateTracks' for type 'tt:RecordingJobStateTracks' */
#ifndef SOAP_TYPE_PointerTott__RecordingJobStateTracks
#define SOAP_TYPE_PointerTott__RecordingJobStateTracks (1476)
#endif

/* tt__RecordingJobStateInformationExtension * has binding name 'PointerTott__RecordingJobStateInformationExtension' for type 'tt:RecordingJobStateInformationExtension' */
#ifndef SOAP_TYPE_PointerTott__RecordingJobStateInformationExtension
#define SOAP_TYPE_PointerTott__RecordingJobStateInformationExtension (1475)
#endif

/* tt__RecordingJobStateSource * has binding name 'PointerTott__RecordingJobStateSource' for type 'tt:RecordingJobStateSource' */
#ifndef SOAP_TYPE_PointerTott__RecordingJobStateSource
#define SOAP_TYPE_PointerTott__RecordingJobStateSource (1473)
#endif

/* tt__RecordingJobSourceExtension * has binding name 'PointerTott__RecordingJobSourceExtension' for type 'tt:RecordingJobSourceExtension' */
#ifndef SOAP_TYPE_PointerTott__RecordingJobSourceExtension
#define SOAP_TYPE_PointerTott__RecordingJobSourceExtension (1472)
#endif

/* tt__RecordingJobTrack * has binding name 'PointerTott__RecordingJobTrack' for type 'tt:RecordingJobTrack' */
#ifndef SOAP_TYPE_PointerTott__RecordingJobTrack
#define SOAP_TYPE_PointerTott__RecordingJobTrack (1470)
#endif

/* tt__RecordingEventFilter * has binding name 'PointerTott__RecordingEventFilter' for type 'tt:RecordingEventFilter' */
#ifndef SOAP_TYPE_PointerTott__RecordingEventFilter
#define SOAP_TYPE_PointerTott__RecordingEventFilter (1467)
#endif

/* tt__RecordingJobConfigurationExtension * has binding name 'PointerTott__RecordingJobConfigurationExtension' for type 'tt:RecordingJobConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__RecordingJobConfigurationExtension
#define SOAP_TYPE_PointerTott__RecordingJobConfigurationExtension (1466)
#endif

/* tt__RecordingJobSource * has binding name 'PointerTott__RecordingJobSource' for type 'tt:RecordingJobSource' */
#ifndef SOAP_TYPE_PointerTott__RecordingJobSource
#define SOAP_TYPE_PointerTott__RecordingJobSource (1464)
#endif

/* tt__TrackConfiguration * has binding name 'PointerTott__TrackConfiguration' for type 'tt:TrackConfiguration' */
#ifndef SOAP_TYPE_PointerTott__TrackConfiguration
#define SOAP_TYPE_PointerTott__TrackConfiguration (1463)
#endif

/* tt__GetTracksResponseItem * has binding name 'PointerTott__GetTracksResponseItem' for type 'tt:GetTracksResponseItem' */
#ifndef SOAP_TYPE_PointerTott__GetTracksResponseItem
#define SOAP_TYPE_PointerTott__GetTracksResponseItem (1461)
#endif

/* tt__GetTracksResponseList * has binding name 'PointerTott__GetTracksResponseList' for type 'tt:GetTracksResponseList' */
#ifndef SOAP_TYPE_PointerTott__GetTracksResponseList
#define SOAP_TYPE_PointerTott__GetTracksResponseList (1460)
#endif

/* tt__RecordingConfiguration * has binding name 'PointerTott__RecordingConfiguration' for type 'tt:RecordingConfiguration' */
#ifndef SOAP_TYPE_PointerTott__RecordingConfiguration
#define SOAP_TYPE_PointerTott__RecordingConfiguration (1459)
#endif

/* tt__TrackAttributesExtension * has binding name 'PointerTott__TrackAttributesExtension' for type 'tt:TrackAttributesExtension' */
#ifndef SOAP_TYPE_PointerTott__TrackAttributesExtension
#define SOAP_TYPE_PointerTott__TrackAttributesExtension (1458)
#endif

/* tt__MetadataAttributes * has binding name 'PointerTott__MetadataAttributes' for type 'tt:MetadataAttributes' */
#ifndef SOAP_TYPE_PointerTott__MetadataAttributes
#define SOAP_TYPE_PointerTott__MetadataAttributes (1457)
#endif

/* tt__AudioAttributes * has binding name 'PointerTott__AudioAttributes' for type 'tt:AudioAttributes' */
#ifndef SOAP_TYPE_PointerTott__AudioAttributes
#define SOAP_TYPE_PointerTott__AudioAttributes (1456)
#endif

/* tt__VideoAttributes * has binding name 'PointerTott__VideoAttributes' for type 'tt:VideoAttributes' */
#ifndef SOAP_TYPE_PointerTott__VideoAttributes
#define SOAP_TYPE_PointerTott__VideoAttributes (1455)
#endif

/* tt__TrackAttributes * has binding name 'PointerTott__TrackAttributes' for type 'tt:TrackAttributes' */
#ifndef SOAP_TYPE_PointerTott__TrackAttributes
#define SOAP_TYPE_PointerTott__TrackAttributes (1453)
#endif

/* tt__TrackInformation * has binding name 'PointerTott__TrackInformation' for type 'tt:TrackInformation' */
#ifndef SOAP_TYPE_PointerTott__TrackInformation
#define SOAP_TYPE_PointerTott__TrackInformation (1451)
#endif

/* tt__RecordingSourceInformation * has binding name 'PointerTott__RecordingSourceInformation' for type 'tt:RecordingSourceInformation' */
#ifndef SOAP_TYPE_PointerTott__RecordingSourceInformation
#define SOAP_TYPE_PointerTott__RecordingSourceInformation (1450)
#endif

/* tt__FindMetadataResult * has binding name 'PointerTott__FindMetadataResult' for type 'tt:FindMetadataResult' */
#ifndef SOAP_TYPE_PointerTott__FindMetadataResult
#define SOAP_TYPE_PointerTott__FindMetadataResult (1448)
#endif

/* tt__FindPTZPositionResult * has binding name 'PointerTott__FindPTZPositionResult' for type 'tt:FindPTZPositionResult' */
#ifndef SOAP_TYPE_PointerTott__FindPTZPositionResult
#define SOAP_TYPE_PointerTott__FindPTZPositionResult (1446)
#endif

/* wsnt__NotificationMessageHolderType * has binding name 'PointerTowsnt__NotificationMessageHolderType' for type 'wsnt:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType
#define SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType (1445)
#endif

/* tt__FindEventResult * has binding name 'PointerTott__FindEventResult' for type 'tt:FindEventResult' */
#ifndef SOAP_TYPE_PointerTott__FindEventResult
#define SOAP_TYPE_PointerTott__FindEventResult (1443)
#endif

/* tt__RecordingInformation * has binding name 'PointerTott__RecordingInformation' for type 'tt:RecordingInformation' */
#ifndef SOAP_TYPE_PointerTott__RecordingInformation
#define SOAP_TYPE_PointerTott__RecordingInformation (1441)
#endif

/* tt__SearchScopeExtension * has binding name 'PointerTott__SearchScopeExtension' for type 'tt:SearchScopeExtension' */
#ifndef SOAP_TYPE_PointerTott__SearchScopeExtension
#define SOAP_TYPE_PointerTott__SearchScopeExtension (1440)
#endif

/* std::string * has binding name 'PointerTott__XPathExpression' for type 'tt:XPathExpression' */
#ifndef SOAP_TYPE_PointerTott__XPathExpression
#define SOAP_TYPE_PointerTott__XPathExpression (1439)
#endif

/* tt__SourceReference * has binding name 'PointerTott__SourceReference' for type 'tt:SourceReference' */
#ifndef SOAP_TYPE_PointerTott__SourceReference
#define SOAP_TYPE_PointerTott__SourceReference (1436)
#endif

/* tt__StreamSetup * has binding name 'PointerTott__StreamSetup' for type 'tt:StreamSetup' */
#ifndef SOAP_TYPE_PointerTott__StreamSetup
#define SOAP_TYPE_PointerTott__StreamSetup (1435)
#endif

/* tt__ReceiverConfiguration * has binding name 'PointerTott__ReceiverConfiguration' for type 'tt:ReceiverConfiguration' */
#ifndef SOAP_TYPE_PointerTott__ReceiverConfiguration
#define SOAP_TYPE_PointerTott__ReceiverConfiguration (1434)
#endif

/* tt__PaneOptionExtension * has binding name 'PointerTott__PaneOptionExtension' for type 'tt:PaneOptionExtension' */
#ifndef SOAP_TYPE_PointerTott__PaneOptionExtension
#define SOAP_TYPE_PointerTott__PaneOptionExtension (1433)
#endif

/* tt__LayoutOptionsExtension * has binding name 'PointerTott__LayoutOptionsExtension' for type 'tt:LayoutOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__LayoutOptionsExtension
#define SOAP_TYPE_PointerTott__LayoutOptionsExtension (1431)
#endif

/* tt__PaneLayoutOptions * has binding name 'PointerTott__PaneLayoutOptions' for type 'tt:PaneLayoutOptions' */
#ifndef SOAP_TYPE_PointerTott__PaneLayoutOptions
#define SOAP_TYPE_PointerTott__PaneLayoutOptions (1429)
#endif

/* tt__VideoDecoderConfigurationOptions * has binding name 'PointerTott__VideoDecoderConfigurationOptions' for type 'tt:VideoDecoderConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__VideoDecoderConfigurationOptions
#define SOAP_TYPE_PointerTott__VideoDecoderConfigurationOptions (1428)
#endif

/* tt__AudioDecoderConfigurationOptions * has binding name 'PointerTott__AudioDecoderConfigurationOptions' for type 'tt:AudioDecoderConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__AudioDecoderConfigurationOptions
#define SOAP_TYPE_PointerTott__AudioDecoderConfigurationOptions (1427)
#endif

/* tt__AudioEncoderConfigurationOptions * has binding name 'PointerTott__AudioEncoderConfigurationOptions' for type 'tt:AudioEncoderConfigurationOptions' */
#ifndef SOAP_TYPE_PointerTott__AudioEncoderConfigurationOptions
#define SOAP_TYPE_PointerTott__AudioEncoderConfigurationOptions (1426)
#endif

/* tt__LayoutExtension * has binding name 'PointerTott__LayoutExtension' for type 'tt:LayoutExtension' */
#ifndef SOAP_TYPE_PointerTott__LayoutExtension
#define SOAP_TYPE_PointerTott__LayoutExtension (1425)
#endif

/* tt__PaneLayout * has binding name 'PointerTott__PaneLayout' for type 'tt:PaneLayout' */
#ifndef SOAP_TYPE_PointerTott__PaneLayout
#define SOAP_TYPE_PointerTott__PaneLayout (1423)
#endif

/* tt__Transformation * has binding name 'PointerTott__Transformation' for type 'tt:Transformation' */
#ifndef SOAP_TYPE_PointerTott__Transformation
#define SOAP_TYPE_PointerTott__Transformation (1422)
#endif

/* tt__MotionExpression * has binding name 'PointerTott__MotionExpression' for type 'tt:MotionExpression' */
#ifndef SOAP_TYPE_PointerTott__MotionExpression
#define SOAP_TYPE_PointerTott__MotionExpression (1421)
#endif

/* tt__PolylineArray * has binding name 'PointerTott__PolylineArray' for type 'tt:PolylineArray' */
#ifndef SOAP_TYPE_PointerTott__PolylineArray
#define SOAP_TYPE_PointerTott__PolylineArray (1420)
#endif

/* tt__PolylineArrayExtension * has binding name 'PointerTott__PolylineArrayExtension' for type 'tt:PolylineArrayExtension' */
#ifndef SOAP_TYPE_PointerTott__PolylineArrayExtension
#define SOAP_TYPE_PointerTott__PolylineArrayExtension (1419)
#endif

/* tt__Polyline * has binding name 'PointerTott__Polyline' for type 'tt:Polyline' */
#ifndef SOAP_TYPE_PointerTott__Polyline
#define SOAP_TYPE_PointerTott__Polyline (1417)
#endif

/* tt__SupportedAnalyticsModulesExtension * has binding name 'PointerTott__SupportedAnalyticsModulesExtension' for type 'tt:SupportedAnalyticsModulesExtension' */
#ifndef SOAP_TYPE_PointerTott__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_PointerTott__SupportedAnalyticsModulesExtension (1416)
#endif

/* tt__SupportedRulesExtension * has binding name 'PointerTott__SupportedRulesExtension' for type 'tt:SupportedRulesExtension' */
#ifndef SOAP_TYPE_PointerTott__SupportedRulesExtension
#define SOAP_TYPE_PointerTott__SupportedRulesExtension (1415)
#endif

/* tt__ConfigDescription * has binding name 'PointerTott__ConfigDescription' for type 'tt:ConfigDescription' */
#ifndef SOAP_TYPE_PointerTott__ConfigDescription
#define SOAP_TYPE_PointerTott__ConfigDescription (1413)
#endif

/* std::string * has binding name 'PointerToxsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_PointerToxsd__integer
#define SOAP_TYPE_PointerToxsd__integer (1412)
#endif

/* tt__ConfigDescriptionExtension * has binding name 'PointerTott__ConfigDescriptionExtension' for type 'tt:ConfigDescriptionExtension' */
#ifndef SOAP_TYPE_PointerTott__ConfigDescriptionExtension
#define SOAP_TYPE_PointerTott__ConfigDescriptionExtension (1411)
#endif

/* tt__ItemList * has binding name 'PointerTott__ItemList' for type 'tt:ItemList' */
#ifndef SOAP_TYPE_PointerTott__ItemList
#define SOAP_TYPE_PointerTott__ItemList (1408)
#endif

/* tt__RuleEngineConfigurationExtension * has binding name 'PointerTott__RuleEngineConfigurationExtension' for type 'tt:RuleEngineConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension
#define SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension (1407)
#endif

/* tt__AnalyticsEngineConfigurationExtension * has binding name 'PointerTott__AnalyticsEngineConfigurationExtension' for type 'tt:AnalyticsEngineConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension (1406)
#endif

/* tt__Config * has binding name 'PointerTott__Config' for type 'tt:Config' */
#ifndef SOAP_TYPE_PointerTott__Config
#define SOAP_TYPE_PointerTott__Config (1404)
#endif

/* tt__Vector * has binding name 'PointerTott__Vector' for type 'tt:Vector' */
#ifndef SOAP_TYPE_PointerTott__Vector
#define SOAP_TYPE_PointerTott__Vector (1402)
#endif

/* tt__ItemListDescriptionExtension * has binding name 'PointerTott__ItemListDescriptionExtension' for type 'tt:ItemListDescriptionExtension' */
#ifndef SOAP_TYPE_PointerTott__ItemListDescriptionExtension
#define SOAP_TYPE_PointerTott__ItemListDescriptionExtension (1401)
#endif

/* tt__MessageDescriptionExtension * has binding name 'PointerTott__MessageDescriptionExtension' for type 'tt:MessageDescriptionExtension' */
#ifndef SOAP_TYPE_PointerTott__MessageDescriptionExtension
#define SOAP_TYPE_PointerTott__MessageDescriptionExtension (1396)
#endif

/* tt__ItemListDescription * has binding name 'PointerTott__ItemListDescription' for type 'tt:ItemListDescription' */
#ifndef SOAP_TYPE_PointerTott__ItemListDescription
#define SOAP_TYPE_PointerTott__ItemListDescription (1395)
#endif

/* tt__ItemListExtension * has binding name 'PointerTott__ItemListExtension' for type 'tt:ItemListExtension' */
#ifndef SOAP_TYPE_PointerTott__ItemListExtension
#define SOAP_TYPE_PointerTott__ItemListExtension (1394)
#endif

/* tt__FocusOptions20Extension * has binding name 'PointerTott__FocusOptions20Extension' for type 'tt:FocusOptions20Extension' */
#ifndef SOAP_TYPE_PointerTott__FocusOptions20Extension
#define SOAP_TYPE_PointerTott__FocusOptions20Extension (1389)
#endif

/* tt__WhiteBalanceOptions20Extension * has binding name 'PointerTott__WhiteBalanceOptions20Extension' for type 'tt:WhiteBalanceOptions20Extension' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension
#define SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension (1388)
#endif

/* tt__FocusConfiguration20Extension * has binding name 'PointerTott__FocusConfiguration20Extension' for type 'tt:FocusConfiguration20Extension' */
#ifndef SOAP_TYPE_PointerTott__FocusConfiguration20Extension
#define SOAP_TYPE_PointerTott__FocusConfiguration20Extension (1387)
#endif

/* tt__WhiteBalance20Extension * has binding name 'PointerTott__WhiteBalance20Extension' for type 'tt:WhiteBalance20Extension' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalance20Extension
#define SOAP_TYPE_PointerTott__WhiteBalance20Extension (1386)
#endif

/* tt__RelativeFocusOptions20 * has binding name 'PointerTott__RelativeFocusOptions20' for type 'tt:RelativeFocusOptions20' */
#ifndef SOAP_TYPE_PointerTott__RelativeFocusOptions20
#define SOAP_TYPE_PointerTott__RelativeFocusOptions20 (1385)
#endif

/* tt__IrCutFilterAutoAdjustmentOptionsExtension * has binding name 'PointerTott__IrCutFilterAutoAdjustmentOptionsExtension' for type 'tt:IrCutFilterAutoAdjustmentOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptionsExtension (1383)
#endif

/* tt__ImageStabilizationOptionsExtension * has binding name 'PointerTott__ImageStabilizationOptionsExtension' for type 'tt:ImageStabilizationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__ImageStabilizationOptionsExtension
#define SOAP_TYPE_PointerTott__ImageStabilizationOptionsExtension (1382)
#endif

/* tt__ImagingOptions20Extension4 * has binding name 'PointerTott__ImagingOptions20Extension4' for type 'tt:ImagingOptions20Extension4' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension4
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension4 (1380)
#endif

/* tt__NoiseReductionOptions * has binding name 'PointerTott__NoiseReductionOptions' for type 'tt:NoiseReductionOptions' */
#ifndef SOAP_TYPE_PointerTott__NoiseReductionOptions
#define SOAP_TYPE_PointerTott__NoiseReductionOptions (1379)
#endif

/* tt__DefoggingOptions * has binding name 'PointerTott__DefoggingOptions' for type 'tt:DefoggingOptions' */
#ifndef SOAP_TYPE_PointerTott__DefoggingOptions
#define SOAP_TYPE_PointerTott__DefoggingOptions (1378)
#endif

/* tt__ToneCompensationOptions * has binding name 'PointerTott__ToneCompensationOptions' for type 'tt:ToneCompensationOptions' */
#ifndef SOAP_TYPE_PointerTott__ToneCompensationOptions
#define SOAP_TYPE_PointerTott__ToneCompensationOptions (1377)
#endif

/* tt__ImagingOptions20Extension3 * has binding name 'PointerTott__ImagingOptions20Extension3' for type 'tt:ImagingOptions20Extension3' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension3
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension3 (1376)
#endif

/* tt__IrCutFilterAutoAdjustmentOptions * has binding name 'PointerTott__IrCutFilterAutoAdjustmentOptions' for type 'tt:IrCutFilterAutoAdjustmentOptions' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentOptions (1375)
#endif

/* tt__ImagingOptions20Extension2 * has binding name 'PointerTott__ImagingOptions20Extension2' for type 'tt:ImagingOptions20Extension2' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension2
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension2 (1374)
#endif

/* tt__ImageStabilizationOptions * has binding name 'PointerTott__ImageStabilizationOptions' for type 'tt:ImageStabilizationOptions' */
#ifndef SOAP_TYPE_PointerTott__ImageStabilizationOptions
#define SOAP_TYPE_PointerTott__ImageStabilizationOptions (1373)
#endif

/* tt__ImagingOptions20Extension * has binding name 'PointerTott__ImagingOptions20Extension' for type 'tt:ImagingOptions20Extension' */
#ifndef SOAP_TYPE_PointerTott__ImagingOptions20Extension
#define SOAP_TYPE_PointerTott__ImagingOptions20Extension (1372)
#endif

/* tt__WhiteBalanceOptions20 * has binding name 'PointerTott__WhiteBalanceOptions20' for type 'tt:WhiteBalanceOptions20' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalanceOptions20
#define SOAP_TYPE_PointerTott__WhiteBalanceOptions20 (1371)
#endif

/* tt__WideDynamicRangeOptions20 * has binding name 'PointerTott__WideDynamicRangeOptions20' for type 'tt:WideDynamicRangeOptions20' */
#ifndef SOAP_TYPE_PointerTott__WideDynamicRangeOptions20
#define SOAP_TYPE_PointerTott__WideDynamicRangeOptions20 (1370)
#endif

/* tt__FocusOptions20 * has binding name 'PointerTott__FocusOptions20' for type 'tt:FocusOptions20' */
#ifndef SOAP_TYPE_PointerTott__FocusOptions20
#define SOAP_TYPE_PointerTott__FocusOptions20 (1369)
#endif

/* tt__ExposureOptions20 * has binding name 'PointerTott__ExposureOptions20' for type 'tt:ExposureOptions20' */
#ifndef SOAP_TYPE_PointerTott__ExposureOptions20
#define SOAP_TYPE_PointerTott__ExposureOptions20 (1368)
#endif

/* tt__BacklightCompensationOptions20 * has binding name 'PointerTott__BacklightCompensationOptions20' for type 'tt:BacklightCompensationOptions20' */
#ifndef SOAP_TYPE_PointerTott__BacklightCompensationOptions20
#define SOAP_TYPE_PointerTott__BacklightCompensationOptions20 (1367)
#endif

/* tt__DefoggingExtension * has binding name 'PointerTott__DefoggingExtension' for type 'tt:DefoggingExtension' */
#ifndef SOAP_TYPE_PointerTott__DefoggingExtension
#define SOAP_TYPE_PointerTott__DefoggingExtension (1366)
#endif

/* tt__ToneCompensationExtension * has binding name 'PointerTott__ToneCompensationExtension' for type 'tt:ToneCompensationExtension' */
#ifndef SOAP_TYPE_PointerTott__ToneCompensationExtension
#define SOAP_TYPE_PointerTott__ToneCompensationExtension (1365)
#endif

/* enum tt__ExposurePriority * has binding name 'PointerTott__ExposurePriority' for type 'tt:ExposurePriority' */
#ifndef SOAP_TYPE_PointerTott__ExposurePriority
#define SOAP_TYPE_PointerTott__ExposurePriority (1364)
#endif

/* tt__IrCutFilterAutoAdjustmentExtension * has binding name 'PointerTott__IrCutFilterAutoAdjustmentExtension' for type 'tt:IrCutFilterAutoAdjustmentExtension' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustmentExtension (1363)
#endif

/* tt__ImageStabilizationExtension * has binding name 'PointerTott__ImageStabilizationExtension' for type 'tt:ImageStabilizationExtension' */
#ifndef SOAP_TYPE_PointerTott__ImageStabilizationExtension
#define SOAP_TYPE_PointerTott__ImageStabilizationExtension (1362)
#endif

/* tt__ImagingSettingsExtension204 * has binding name 'PointerTott__ImagingSettingsExtension204' for type 'tt:ImagingSettingsExtension204' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension204
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension204 (1361)
#endif

/* tt__NoiseReduction * has binding name 'PointerTott__NoiseReduction' for type 'tt:NoiseReduction' */
#ifndef SOAP_TYPE_PointerTott__NoiseReduction
#define SOAP_TYPE_PointerTott__NoiseReduction (1360)
#endif

/* tt__Defogging * has binding name 'PointerTott__Defogging' for type 'tt:Defogging' */
#ifndef SOAP_TYPE_PointerTott__Defogging
#define SOAP_TYPE_PointerTott__Defogging (1359)
#endif

/* tt__ToneCompensation * has binding name 'PointerTott__ToneCompensation' for type 'tt:ToneCompensation' */
#ifndef SOAP_TYPE_PointerTott__ToneCompensation
#define SOAP_TYPE_PointerTott__ToneCompensation (1358)
#endif

/* tt__ImagingSettingsExtension203 * has binding name 'PointerTott__ImagingSettingsExtension203' for type 'tt:ImagingSettingsExtension203' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension203
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension203 (1357)
#endif

/* tt__IrCutFilterAutoAdjustment * has binding name 'PointerTott__IrCutFilterAutoAdjustment' for type 'tt:IrCutFilterAutoAdjustment' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustment
#define SOAP_TYPE_PointerTott__IrCutFilterAutoAdjustment (1355)
#endif

/* tt__ImagingSettingsExtension202 * has binding name 'PointerTott__ImagingSettingsExtension202' for type 'tt:ImagingSettingsExtension202' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension202
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension202 (1354)
#endif

/* tt__ImageStabilization * has binding name 'PointerTott__ImageStabilization' for type 'tt:ImageStabilization' */
#ifndef SOAP_TYPE_PointerTott__ImageStabilization
#define SOAP_TYPE_PointerTott__ImageStabilization (1353)
#endif

/* tt__ImagingSettingsExtension20 * has binding name 'PointerTott__ImagingSettingsExtension20' for type 'tt:ImagingSettingsExtension20' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension20
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension20 (1352)
#endif

/* tt__WhiteBalance20 * has binding name 'PointerTott__WhiteBalance20' for type 'tt:WhiteBalance20' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalance20
#define SOAP_TYPE_PointerTott__WhiteBalance20 (1351)
#endif

/* tt__WideDynamicRange20 * has binding name 'PointerTott__WideDynamicRange20' for type 'tt:WideDynamicRange20' */
#ifndef SOAP_TYPE_PointerTott__WideDynamicRange20
#define SOAP_TYPE_PointerTott__WideDynamicRange20 (1350)
#endif

/* tt__FocusConfiguration20 * has binding name 'PointerTott__FocusConfiguration20' for type 'tt:FocusConfiguration20' */
#ifndef SOAP_TYPE_PointerTott__FocusConfiguration20
#define SOAP_TYPE_PointerTott__FocusConfiguration20 (1349)
#endif

/* tt__Exposure20 * has binding name 'PointerTott__Exposure20' for type 'tt:Exposure20' */
#ifndef SOAP_TYPE_PointerTott__Exposure20
#define SOAP_TYPE_PointerTott__Exposure20 (1348)
#endif

/* tt__BacklightCompensation20 * has binding name 'PointerTott__BacklightCompensation20' for type 'tt:BacklightCompensation20' */
#ifndef SOAP_TYPE_PointerTott__BacklightCompensation20
#define SOAP_TYPE_PointerTott__BacklightCompensation20 (1347)
#endif

/* tt__FocusStatus20Extension * has binding name 'PointerTott__FocusStatus20Extension' for type 'tt:FocusStatus20Extension' */
#ifndef SOAP_TYPE_PointerTott__FocusStatus20Extension
#define SOAP_TYPE_PointerTott__FocusStatus20Extension (1346)
#endif

/* tt__ImagingStatus20Extension * has binding name 'PointerTott__ImagingStatus20Extension' for type 'tt:ImagingStatus20Extension' */
#ifndef SOAP_TYPE_PointerTott__ImagingStatus20Extension
#define SOAP_TYPE_PointerTott__ImagingStatus20Extension (1345)
#endif

/* tt__FocusStatus20 * has binding name 'PointerTott__FocusStatus20' for type 'tt:FocusStatus20' */
#ifndef SOAP_TYPE_PointerTott__FocusStatus20
#define SOAP_TYPE_PointerTott__FocusStatus20 (1344)
#endif

/* tt__ContinuousFocusOptions * has binding name 'PointerTott__ContinuousFocusOptions' for type 'tt:ContinuousFocusOptions' */
#ifndef SOAP_TYPE_PointerTott__ContinuousFocusOptions
#define SOAP_TYPE_PointerTott__ContinuousFocusOptions (1343)
#endif

/* tt__RelativeFocusOptions * has binding name 'PointerTott__RelativeFocusOptions' for type 'tt:RelativeFocusOptions' */
#ifndef SOAP_TYPE_PointerTott__RelativeFocusOptions
#define SOAP_TYPE_PointerTott__RelativeFocusOptions (1342)
#endif

/* tt__AbsoluteFocusOptions * has binding name 'PointerTott__AbsoluteFocusOptions' for type 'tt:AbsoluteFocusOptions' */
#ifndef SOAP_TYPE_PointerTott__AbsoluteFocusOptions
#define SOAP_TYPE_PointerTott__AbsoluteFocusOptions (1341)
#endif

/* tt__ContinuousFocus * has binding name 'PointerTott__ContinuousFocus' for type 'tt:ContinuousFocus' */
#ifndef SOAP_TYPE_PointerTott__ContinuousFocus
#define SOAP_TYPE_PointerTott__ContinuousFocus (1340)
#endif

/* tt__RelativeFocus * has binding name 'PointerTott__RelativeFocus' for type 'tt:RelativeFocus' */
#ifndef SOAP_TYPE_PointerTott__RelativeFocus
#define SOAP_TYPE_PointerTott__RelativeFocus (1339)
#endif

/* tt__AbsoluteFocus * has binding name 'PointerTott__AbsoluteFocus' for type 'tt:AbsoluteFocus' */
#ifndef SOAP_TYPE_PointerTott__AbsoluteFocus
#define SOAP_TYPE_PointerTott__AbsoluteFocus (1338)
#endif

/* tt__WhiteBalanceOptions * has binding name 'PointerTott__WhiteBalanceOptions' for type 'tt:WhiteBalanceOptions' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalanceOptions
#define SOAP_TYPE_PointerTott__WhiteBalanceOptions (1332)
#endif

/* tt__WideDynamicRangeOptions * has binding name 'PointerTott__WideDynamicRangeOptions' for type 'tt:WideDynamicRangeOptions' */
#ifndef SOAP_TYPE_PointerTott__WideDynamicRangeOptions
#define SOAP_TYPE_PointerTott__WideDynamicRangeOptions (1331)
#endif

/* tt__FocusOptions * has binding name 'PointerTott__FocusOptions' for type 'tt:FocusOptions' */
#ifndef SOAP_TYPE_PointerTott__FocusOptions
#define SOAP_TYPE_PointerTott__FocusOptions (1329)
#endif

/* tt__ExposureOptions * has binding name 'PointerTott__ExposureOptions' for type 'tt:ExposureOptions' */
#ifndef SOAP_TYPE_PointerTott__ExposureOptions
#define SOAP_TYPE_PointerTott__ExposureOptions (1328)
#endif

/* tt__BacklightCompensationOptions * has binding name 'PointerTott__BacklightCompensationOptions' for type 'tt:BacklightCompensationOptions' */
#ifndef SOAP_TYPE_PointerTott__BacklightCompensationOptions
#define SOAP_TYPE_PointerTott__BacklightCompensationOptions (1327)
#endif

/* tt__Rectangle * has binding name 'PointerTott__Rectangle' for type 'tt:Rectangle' */
#ifndef SOAP_TYPE_PointerTott__Rectangle
#define SOAP_TYPE_PointerTott__Rectangle (1326)
#endif

/* tt__ImagingSettingsExtension * has binding name 'PointerTott__ImagingSettingsExtension' for type 'tt:ImagingSettingsExtension' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettingsExtension
#define SOAP_TYPE_PointerTott__ImagingSettingsExtension (1325)
#endif

/* tt__WhiteBalance * has binding name 'PointerTott__WhiteBalance' for type 'tt:WhiteBalance' */
#ifndef SOAP_TYPE_PointerTott__WhiteBalance
#define SOAP_TYPE_PointerTott__WhiteBalance (1324)
#endif

/* tt__WideDynamicRange * has binding name 'PointerTott__WideDynamicRange' for type 'tt:WideDynamicRange' */
#ifndef SOAP_TYPE_PointerTott__WideDynamicRange
#define SOAP_TYPE_PointerTott__WideDynamicRange (1323)
#endif

/* enum tt__IrCutFilterMode * has binding name 'PointerTott__IrCutFilterMode' for type 'tt:IrCutFilterMode' */
#ifndef SOAP_TYPE_PointerTott__IrCutFilterMode
#define SOAP_TYPE_PointerTott__IrCutFilterMode (1322)
#endif

/* tt__FocusConfiguration * has binding name 'PointerTott__FocusConfiguration' for type 'tt:FocusConfiguration' */
#ifndef SOAP_TYPE_PointerTott__FocusConfiguration
#define SOAP_TYPE_PointerTott__FocusConfiguration (1321)
#endif

/* tt__Exposure * has binding name 'PointerTott__Exposure' for type 'tt:Exposure' */
#ifndef SOAP_TYPE_PointerTott__Exposure
#define SOAP_TYPE_PointerTott__Exposure (1320)
#endif

/* tt__BacklightCompensation * has binding name 'PointerTott__BacklightCompensation' for type 'tt:BacklightCompensation' */
#ifndef SOAP_TYPE_PointerTott__BacklightCompensation
#define SOAP_TYPE_PointerTott__BacklightCompensation (1319)
#endif

/* tt__FocusStatus * has binding name 'PointerTott__FocusStatus' for type 'tt:FocusStatus' */
#ifndef SOAP_TYPE_PointerTott__FocusStatus
#define SOAP_TYPE_PointerTott__FocusStatus (1318)
#endif

/* tt__PTZPresetTourStartingConditionOptionsExtension * has binding name 'PointerTott__PTZPresetTourStartingConditionOptionsExtension' for type 'tt:PTZPresetTourStartingConditionOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptionsExtension (1317)
#endif

/* tt__PTZPresetTourPresetDetailOptionsExtension * has binding name 'PointerTott__PTZPresetTourPresetDetailOptionsExtension' for type 'tt:PTZPresetTourPresetDetailOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptionsExtension (1315)
#endif

/* tt__PTZPresetTourPresetDetailOptions * has binding name 'PointerTott__PTZPresetTourPresetDetailOptions' for type 'tt:PTZPresetTourPresetDetailOptions' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptions (1314)
#endif

/* tt__PTZPresetTourSpotOptions * has binding name 'PointerTott__PTZPresetTourSpotOptions' for type 'tt:PTZPresetTourSpotOptions' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourSpotOptions
#define SOAP_TYPE_PointerTott__PTZPresetTourSpotOptions (1313)
#endif

/* tt__PTZPresetTourStartingConditionOptions * has binding name 'PointerTott__PTZPresetTourStartingConditionOptions' for type 'tt:PTZPresetTourStartingConditionOptions' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptions (1312)
#endif

/* tt__PTZPresetTourStartingConditionExtension * has binding name 'PointerTott__PTZPresetTourStartingConditionExtension' for type 'tt:PTZPresetTourStartingConditionExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionExtension (1311)
#endif

/* enum tt__PTZPresetTourDirection * has binding name 'PointerTott__PTZPresetTourDirection' for type 'tt:PTZPresetTourDirection' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourDirection
#define SOAP_TYPE_PointerTott__PTZPresetTourDirection (1310)
#endif

/* tt__PTZPresetTourStatusExtension * has binding name 'PointerTott__PTZPresetTourStatusExtension' for type 'tt:PTZPresetTourStatusExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourStatusExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourStatusExtension (1309)
#endif

/* tt__PTZPresetTourTypeExtension * has binding name 'PointerTott__PTZPresetTourTypeExtension' for type 'tt:PTZPresetTourTypeExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourTypeExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourTypeExtension (1308)
#endif

/* tt__PTZPresetTourSpotExtension * has binding name 'PointerTott__PTZPresetTourSpotExtension' for type 'tt:PTZPresetTourSpotExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourSpotExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourSpotExtension (1306)
#endif

/* tt__PTZSpeed * has binding name 'PointerTott__PTZSpeed' for type 'tt:PTZSpeed' */
#ifndef SOAP_TYPE_PointerTott__PTZSpeed
#define SOAP_TYPE_PointerTott__PTZSpeed (1305)
#endif

/* tt__PTZPresetTourPresetDetail * has binding name 'PointerTott__PTZPresetTourPresetDetail' for type 'tt:PTZPresetTourPresetDetail' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourPresetDetail
#define SOAP_TYPE_PointerTott__PTZPresetTourPresetDetail (1304)
#endif

/* tt__PTZPresetTourExtension * has binding name 'PointerTott__PTZPresetTourExtension' for type 'tt:PTZPresetTourExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourExtension (1303)
#endif

/* tt__PTZPresetTourSpot * has binding name 'PointerTott__PTZPresetTourSpot' for type 'tt:PTZPresetTourSpot' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourSpot
#define SOAP_TYPE_PointerTott__PTZPresetTourSpot (1301)
#endif

/* tt__PTZPresetTourStartingCondition * has binding name 'PointerTott__PTZPresetTourStartingCondition' for type 'tt:PTZPresetTourStartingCondition' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourStartingCondition
#define SOAP_TYPE_PointerTott__PTZPresetTourStartingCondition (1300)
#endif

/* tt__PTZPresetTourStatus * has binding name 'PointerTott__PTZPresetTourStatus' for type 'tt:PTZPresetTourStatus' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourStatus
#define SOAP_TYPE_PointerTott__PTZPresetTourStatus (1299)
#endif

/* tt__PTZVector * has binding name 'PointerTott__PTZVector' for type 'tt:PTZVector' */
#ifndef SOAP_TYPE_PointerTott__PTZVector
#define SOAP_TYPE_PointerTott__PTZVector (1298)
#endif

/* std::string * has binding name 'PointerTott__Name' for type 'tt:Name' */
#ifndef SOAP_TYPE_PointerTott__Name
#define SOAP_TYPE_PointerTott__Name (1297)
#endif

/* tt__Vector1D * has binding name 'PointerTott__Vector1D' for type 'tt:Vector1D' */
#ifndef SOAP_TYPE_PointerTott__Vector1D
#define SOAP_TYPE_PointerTott__Vector1D (1296)
#endif

/* tt__Vector2D * has binding name 'PointerTott__Vector2D' for type 'tt:Vector2D' */
#ifndef SOAP_TYPE_PointerTott__Vector2D
#define SOAP_TYPE_PointerTott__Vector2D (1295)
#endif

/* tt__PTZSpacesExtension * has binding name 'PointerTott__PTZSpacesExtension' for type 'tt:PTZSpacesExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZSpacesExtension
#define SOAP_TYPE_PointerTott__PTZSpacesExtension (1294)
#endif

/* tt__Space1DDescription * has binding name 'PointerTott__Space1DDescription' for type 'tt:Space1DDescription' */
#ifndef SOAP_TYPE_PointerTott__Space1DDescription
#define SOAP_TYPE_PointerTott__Space1DDescription (1291)
#endif

/* tt__Space2DDescription * has binding name 'PointerTott__Space2DDescription' for type 'tt:Space2DDescription' */
#ifndef SOAP_TYPE_PointerTott__Space2DDescription
#define SOAP_TYPE_PointerTott__Space2DDescription (1290)
#endif

/* tt__ReverseOptionsExtension * has binding name 'PointerTott__ReverseOptionsExtension' for type 'tt:ReverseOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__ReverseOptionsExtension
#define SOAP_TYPE_PointerTott__ReverseOptionsExtension (1289)
#endif

/* tt__EFlipOptionsExtension * has binding name 'PointerTott__EFlipOptionsExtension' for type 'tt:EFlipOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__EFlipOptionsExtension
#define SOAP_TYPE_PointerTott__EFlipOptionsExtension (1287)
#endif

/* tt__PTControlDirectionOptionsExtension * has binding name 'PointerTott__PTControlDirectionOptionsExtension' for type 'tt:PTControlDirectionOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__PTControlDirectionOptionsExtension
#define SOAP_TYPE_PointerTott__PTControlDirectionOptionsExtension (1285)
#endif

/* tt__ReverseOptions * has binding name 'PointerTott__ReverseOptions' for type 'tt:ReverseOptions' */
#ifndef SOAP_TYPE_PointerTott__ReverseOptions
#define SOAP_TYPE_PointerTott__ReverseOptions (1284)
#endif

/* tt__EFlipOptions * has binding name 'PointerTott__EFlipOptions' for type 'tt:EFlipOptions' */
#ifndef SOAP_TYPE_PointerTott__EFlipOptions
#define SOAP_TYPE_PointerTott__EFlipOptions (1283)
#endif

/* tt__PTZConfigurationOptions2 * has binding name 'PointerTott__PTZConfigurationOptions2' for type 'tt:PTZConfigurationOptions2' */
#ifndef SOAP_TYPE_PointerTott__PTZConfigurationOptions2
#define SOAP_TYPE_PointerTott__PTZConfigurationOptions2 (1282)
#endif

/* tt__PTControlDirectionOptions * has binding name 'PointerTott__PTControlDirectionOptions' for type 'tt:PTControlDirectionOptions' */
#ifndef SOAP_TYPE_PointerTott__PTControlDirectionOptions
#define SOAP_TYPE_PointerTott__PTControlDirectionOptions (1281)
#endif

/* tt__DurationRange * has binding name 'PointerTott__DurationRange' for type 'tt:DurationRange' */
#ifndef SOAP_TYPE_PointerTott__DurationRange
#define SOAP_TYPE_PointerTott__DurationRange (1280)
#endif

/* tt__PTZSpaces * has binding name 'PointerTott__PTZSpaces' for type 'tt:PTZSpaces' */
#ifndef SOAP_TYPE_PointerTott__PTZSpaces
#define SOAP_TYPE_PointerTott__PTZSpaces (1279)
#endif

/* tt__PTControlDirectionExtension * has binding name 'PointerTott__PTControlDirectionExtension' for type 'tt:PTControlDirectionExtension' */
#ifndef SOAP_TYPE_PointerTott__PTControlDirectionExtension
#define SOAP_TYPE_PointerTott__PTControlDirectionExtension (1278)
#endif

/* tt__Reverse * has binding name 'PointerTott__Reverse' for type 'tt:Reverse' */
#ifndef SOAP_TYPE_PointerTott__Reverse
#define SOAP_TYPE_PointerTott__Reverse (1277)
#endif

/* tt__EFlip * has binding name 'PointerTott__EFlip' for type 'tt:EFlip' */
#ifndef SOAP_TYPE_PointerTott__EFlip
#define SOAP_TYPE_PointerTott__EFlip (1276)
#endif

/* tt__PTZConfigurationExtension2 * has binding name 'PointerTott__PTZConfigurationExtension2' for type 'tt:PTZConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTott__PTZConfigurationExtension2
#define SOAP_TYPE_PointerTott__PTZConfigurationExtension2 (1275)
#endif

/* tt__PTControlDirection * has binding name 'PointerTott__PTControlDirection' for type 'tt:PTControlDirection' */
#ifndef SOAP_TYPE_PointerTott__PTControlDirection
#define SOAP_TYPE_PointerTott__PTControlDirection (1274)
#endif

/* tt__PTZPresetTourSupportedExtension * has binding name 'PointerTott__PTZPresetTourSupportedExtension' for type 'tt:PTZPresetTourSupportedExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourSupportedExtension
#define SOAP_TYPE_PointerTott__PTZPresetTourSupportedExtension (1273)
#endif

/* tt__PTZNodeExtension2 * has binding name 'PointerTott__PTZNodeExtension2' for type 'tt:PTZNodeExtension2' */
#ifndef SOAP_TYPE_PointerTott__PTZNodeExtension2
#define SOAP_TYPE_PointerTott__PTZNodeExtension2 (1271)
#endif

/* tt__PTZPresetTourSupported * has binding name 'PointerTott__PTZPresetTourSupported' for type 'tt:PTZPresetTourSupported' */
#ifndef SOAP_TYPE_PointerTott__PTZPresetTourSupported
#define SOAP_TYPE_PointerTott__PTZPresetTourSupported (1270)
#endif

/* tt__EapMethodExtension * has binding name 'PointerTott__EapMethodExtension' for type 'tt:EapMethodExtension' */
#ifndef SOAP_TYPE_PointerTott__EapMethodExtension
#define SOAP_TYPE_PointerTott__EapMethodExtension (1269)
#endif

/* tt__TLSConfiguration * has binding name 'PointerTott__TLSConfiguration' for type 'tt:TLSConfiguration' */
#ifndef SOAP_TYPE_PointerTott__TLSConfiguration
#define SOAP_TYPE_PointerTott__TLSConfiguration (1268)
#endif

/* tt__Dot1XConfigurationExtension * has binding name 'PointerTott__Dot1XConfigurationExtension' for type 'tt:Dot1XConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__Dot1XConfigurationExtension
#define SOAP_TYPE_PointerTott__Dot1XConfigurationExtension (1267)
#endif

/* tt__EAPMethodConfiguration * has binding name 'PointerTott__EAPMethodConfiguration' for type 'tt:EAPMethodConfiguration' */
#ifndef SOAP_TYPE_PointerTott__EAPMethodConfiguration
#define SOAP_TYPE_PointerTott__EAPMethodConfiguration (1266)
#endif

/* tt__CertificateInformationExtension * has binding name 'PointerTott__CertificateInformationExtension' for type 'tt:CertificateInformationExtension' */
#ifndef SOAP_TYPE_PointerTott__CertificateInformationExtension
#define SOAP_TYPE_PointerTott__CertificateInformationExtension (1265)
#endif

/* tt__DateTimeRange * has binding name 'PointerTott__DateTimeRange' for type 'tt:DateTimeRange' */
#ifndef SOAP_TYPE_PointerTott__DateTimeRange
#define SOAP_TYPE_PointerTott__DateTimeRange (1264)
#endif

/* tt__CertificateUsage * has binding name 'PointerTott__CertificateUsage' for type 'tt:CertificateUsage' */
#ifndef SOAP_TYPE_PointerTott__CertificateUsage
#define SOAP_TYPE_PointerTott__CertificateUsage (1263)
#endif

/* tt__CertificateGenerationParametersExtension * has binding name 'PointerTott__CertificateGenerationParametersExtension' for type 'tt:CertificateGenerationParametersExtension' */
#ifndef SOAP_TYPE_PointerTott__CertificateGenerationParametersExtension
#define SOAP_TYPE_PointerTott__CertificateGenerationParametersExtension (1262)
#endif

/* tt__UserExtension * has binding name 'PointerTott__UserExtension' for type 'tt:UserExtension' */
#ifndef SOAP_TYPE_PointerTott__UserExtension
#define SOAP_TYPE_PointerTott__UserExtension (1261)
#endif

/* tt__Date * has binding name 'PointerTott__Date' for type 'tt:Date' */
#ifndef SOAP_TYPE_PointerTott__Date
#define SOAP_TYPE_PointerTott__Date (1260)
#endif

/* tt__Time * has binding name 'PointerTott__Time' for type 'tt:Time' */
#ifndef SOAP_TYPE_PointerTott__Time
#define SOAP_TYPE_PointerTott__Time (1259)
#endif

/* tt__SystemDateTimeExtension * has binding name 'PointerTott__SystemDateTimeExtension' for type 'tt:SystemDateTimeExtension' */
#ifndef SOAP_TYPE_PointerTott__SystemDateTimeExtension
#define SOAP_TYPE_PointerTott__SystemDateTimeExtension (1258)
#endif

/* tt__SystemLogUri * has binding name 'PointerTott__SystemLogUri' for type 'tt:SystemLogUri' */
#ifndef SOAP_TYPE_PointerTott__SystemLogUri
#define SOAP_TYPE_PointerTott__SystemLogUri (1256)
#endif

/* tt__AnalyticsDeviceExtension * has binding name 'PointerTott__AnalyticsDeviceExtension' for type 'tt:AnalyticsDeviceExtension' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsDeviceExtension
#define SOAP_TYPE_PointerTott__AnalyticsDeviceExtension (1255)
#endif

/* tt__SystemCapabilitiesExtension2 * has binding name 'PointerTott__SystemCapabilitiesExtension2' for type 'tt:SystemCapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTott__SystemCapabilitiesExtension2
#define SOAP_TYPE_PointerTott__SystemCapabilitiesExtension2 (1254)
#endif

/* tt__SystemCapabilitiesExtension * has binding name 'PointerTott__SystemCapabilitiesExtension' for type 'tt:SystemCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__SystemCapabilitiesExtension
#define SOAP_TYPE_PointerTott__SystemCapabilitiesExtension (1253)
#endif

/* tt__SecurityCapabilitiesExtension2 * has binding name 'PointerTott__SecurityCapabilitiesExtension2' for type 'tt:SecurityCapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension2
#define SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension2 (1251)
#endif

/* tt__SecurityCapabilitiesExtension * has binding name 'PointerTott__SecurityCapabilitiesExtension' for type 'tt:SecurityCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension
#define SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension (1250)
#endif

/* tt__NetworkCapabilitiesExtension2 * has binding name 'PointerTott__NetworkCapabilitiesExtension2' for type 'tt:NetworkCapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension2
#define SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension2 (1249)
#endif

/* tt__NetworkCapabilitiesExtension * has binding name 'PointerTott__NetworkCapabilitiesExtension' for type 'tt:NetworkCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension
#define SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension (1248)
#endif

/* tt__RealTimeStreamingCapabilitiesExtension * has binding name 'PointerTott__RealTimeStreamingCapabilitiesExtension' for type 'tt:RealTimeStreamingCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension (1247)
#endif

/* tt__ProfileCapabilities * has binding name 'PointerTott__ProfileCapabilities' for type 'tt:ProfileCapabilities' */
#ifndef SOAP_TYPE_PointerTott__ProfileCapabilities
#define SOAP_TYPE_PointerTott__ProfileCapabilities (1246)
#endif

/* tt__MediaCapabilitiesExtension * has binding name 'PointerTott__MediaCapabilitiesExtension' for type 'tt:MediaCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__MediaCapabilitiesExtension
#define SOAP_TYPE_PointerTott__MediaCapabilitiesExtension (1245)
#endif

/* tt__RealTimeStreamingCapabilities * has binding name 'PointerTott__RealTimeStreamingCapabilities' for type 'tt:RealTimeStreamingCapabilities' */
#ifndef SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities
#define SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities (1244)
#endif

/* tt__IOCapabilitiesExtension2 * has binding name 'PointerTott__IOCapabilitiesExtension2' for type 'tt:IOCapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTott__IOCapabilitiesExtension2
#define SOAP_TYPE_PointerTott__IOCapabilitiesExtension2 (1243)
#endif

/* tt__IOCapabilitiesExtension * has binding name 'PointerTott__IOCapabilitiesExtension' for type 'tt:IOCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__IOCapabilitiesExtension
#define SOAP_TYPE_PointerTott__IOCapabilitiesExtension (1241)
#endif

/* tt__DeviceCapabilitiesExtension * has binding name 'PointerTott__DeviceCapabilitiesExtension' for type 'tt:DeviceCapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension
#define SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension (1240)
#endif

/* tt__SecurityCapabilities * has binding name 'PointerTott__SecurityCapabilities' for type 'tt:SecurityCapabilities' */
#ifndef SOAP_TYPE_PointerTott__SecurityCapabilities
#define SOAP_TYPE_PointerTott__SecurityCapabilities (1239)
#endif

/* tt__IOCapabilities * has binding name 'PointerTott__IOCapabilities' for type 'tt:IOCapabilities' */
#ifndef SOAP_TYPE_PointerTott__IOCapabilities
#define SOAP_TYPE_PointerTott__IOCapabilities (1238)
#endif

/* tt__SystemCapabilities * has binding name 'PointerTott__SystemCapabilities' for type 'tt:SystemCapabilities' */
#ifndef SOAP_TYPE_PointerTott__SystemCapabilities
#define SOAP_TYPE_PointerTott__SystemCapabilities (1237)
#endif

/* tt__NetworkCapabilities * has binding name 'PointerTott__NetworkCapabilities' for type 'tt:NetworkCapabilities' */
#ifndef SOAP_TYPE_PointerTott__NetworkCapabilities
#define SOAP_TYPE_PointerTott__NetworkCapabilities (1236)
#endif

/* tt__CapabilitiesExtension2 * has binding name 'PointerTott__CapabilitiesExtension2' for type 'tt:CapabilitiesExtension2' */
#ifndef SOAP_TYPE_PointerTott__CapabilitiesExtension2
#define SOAP_TYPE_PointerTott__CapabilitiesExtension2 (1235)
#endif

/* tt__AnalyticsDeviceCapabilities * has binding name 'PointerTott__AnalyticsDeviceCapabilities' for type 'tt:AnalyticsDeviceCapabilities' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsDeviceCapabilities
#define SOAP_TYPE_PointerTott__AnalyticsDeviceCapabilities (1234)
#endif

/* tt__ReceiverCapabilities * has binding name 'PointerTott__ReceiverCapabilities' for type 'tt:ReceiverCapabilities' */
#ifndef SOAP_TYPE_PointerTott__ReceiverCapabilities
#define SOAP_TYPE_PointerTott__ReceiverCapabilities (1233)
#endif

/* tt__ReplayCapabilities * has binding name 'PointerTott__ReplayCapabilities' for type 'tt:ReplayCapabilities' */
#ifndef SOAP_TYPE_PointerTott__ReplayCapabilities
#define SOAP_TYPE_PointerTott__ReplayCapabilities (1232)
#endif

/* tt__SearchCapabilities * has binding name 'PointerTott__SearchCapabilities' for type 'tt:SearchCapabilities' */
#ifndef SOAP_TYPE_PointerTott__SearchCapabilities
#define SOAP_TYPE_PointerTott__SearchCapabilities (1231)
#endif

/* tt__RecordingCapabilities * has binding name 'PointerTott__RecordingCapabilities' for type 'tt:RecordingCapabilities' */
#ifndef SOAP_TYPE_PointerTott__RecordingCapabilities
#define SOAP_TYPE_PointerTott__RecordingCapabilities (1230)
#endif

/* tt__DisplayCapabilities * has binding name 'PointerTott__DisplayCapabilities' for type 'tt:DisplayCapabilities' */
#ifndef SOAP_TYPE_PointerTott__DisplayCapabilities
#define SOAP_TYPE_PointerTott__DisplayCapabilities (1229)
#endif

/* tt__DeviceIOCapabilities * has binding name 'PointerTott__DeviceIOCapabilities' for type 'tt:DeviceIOCapabilities' */
#ifndef SOAP_TYPE_PointerTott__DeviceIOCapabilities
#define SOAP_TYPE_PointerTott__DeviceIOCapabilities (1228)
#endif

/* tt__CapabilitiesExtension * has binding name 'PointerTott__CapabilitiesExtension' for type 'tt:CapabilitiesExtension' */
#ifndef SOAP_TYPE_PointerTott__CapabilitiesExtension
#define SOAP_TYPE_PointerTott__CapabilitiesExtension (1227)
#endif

/* tt__PTZCapabilities * has binding name 'PointerTott__PTZCapabilities' for type 'tt:PTZCapabilities' */
#ifndef SOAP_TYPE_PointerTott__PTZCapabilities
#define SOAP_TYPE_PointerTott__PTZCapabilities (1226)
#endif

/* tt__MediaCapabilities * has binding name 'PointerTott__MediaCapabilities' for type 'tt:MediaCapabilities' */
#ifndef SOAP_TYPE_PointerTott__MediaCapabilities
#define SOAP_TYPE_PointerTott__MediaCapabilities (1225)
#endif

/* tt__ImagingCapabilities * has binding name 'PointerTott__ImagingCapabilities' for type 'tt:ImagingCapabilities' */
#ifndef SOAP_TYPE_PointerTott__ImagingCapabilities
#define SOAP_TYPE_PointerTott__ImagingCapabilities (1224)
#endif

/* tt__EventCapabilities * has binding name 'PointerTott__EventCapabilities' for type 'tt:EventCapabilities' */
#ifndef SOAP_TYPE_PointerTott__EventCapabilities
#define SOAP_TYPE_PointerTott__EventCapabilities (1223)
#endif

/* tt__DeviceCapabilities * has binding name 'PointerTott__DeviceCapabilities' for type 'tt:DeviceCapabilities' */
#ifndef SOAP_TYPE_PointerTott__DeviceCapabilities
#define SOAP_TYPE_PointerTott__DeviceCapabilities (1222)
#endif

/* tt__AnalyticsCapabilities * has binding name 'PointerTott__AnalyticsCapabilities' for type 'tt:AnalyticsCapabilities' */
#ifndef SOAP_TYPE_PointerTott__AnalyticsCapabilities
#define SOAP_TYPE_PointerTott__AnalyticsCapabilities (1221)
#endif

/* tt__Dot11AvailableNetworksExtension * has binding name 'PointerTott__Dot11AvailableNetworksExtension' for type 'tt:Dot11AvailableNetworksExtension' */
#ifndef SOAP_TYPE_PointerTott__Dot11AvailableNetworksExtension
#define SOAP_TYPE_PointerTott__Dot11AvailableNetworksExtension (1220)
#endif

/* enum tt__Dot11SignalStrength * has binding name 'PointerTott__Dot11SignalStrength' for type 'tt:Dot11SignalStrength' */
#ifndef SOAP_TYPE_PointerTott__Dot11SignalStrength
#define SOAP_TYPE_PointerTott__Dot11SignalStrength (1217)
#endif

/* tt__Dot11PSKSetExtension * has binding name 'PointerTott__Dot11PSKSetExtension' for type 'tt:Dot11PSKSetExtension' */
#ifndef SOAP_TYPE_PointerTott__Dot11PSKSetExtension
#define SOAP_TYPE_PointerTott__Dot11PSKSetExtension (1216)
#endif

/* std::string * has binding name 'PointerTott__Dot11PSKPassphrase' for type 'tt:Dot11PSKPassphrase' */
#ifndef SOAP_TYPE_PointerTott__Dot11PSKPassphrase
#define SOAP_TYPE_PointerTott__Dot11PSKPassphrase (1215)
#endif

/* xsd__hexBinary * has binding name 'PointerTott__Dot11PSK' for type 'tt:Dot11PSK' */
#ifndef SOAP_TYPE_PointerTott__Dot11PSK
#define SOAP_TYPE_PointerTott__Dot11PSK (1214)
#endif

/* tt__Dot11SecurityConfigurationExtension * has binding name 'PointerTott__Dot11SecurityConfigurationExtension' for type 'tt:Dot11SecurityConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_PointerTott__Dot11SecurityConfigurationExtension (1213)
#endif

/* std::string * has binding name 'PointerTott__ReferenceToken' for type 'tt:ReferenceToken' */
#ifndef SOAP_TYPE_PointerTott__ReferenceToken
#define SOAP_TYPE_PointerTott__ReferenceToken (1212)
#endif

/* tt__Dot11PSKSet * has binding name 'PointerTott__Dot11PSKSet' for type 'tt:Dot11PSKSet' */
#ifndef SOAP_TYPE_PointerTott__Dot11PSKSet
#define SOAP_TYPE_PointerTott__Dot11PSKSet (1211)
#endif

/* enum tt__Dot11Cipher * has binding name 'PointerTott__Dot11Cipher' for type 'tt:Dot11Cipher' */
#ifndef SOAP_TYPE_PointerTott__Dot11Cipher
#define SOAP_TYPE_PointerTott__Dot11Cipher (1210)
#endif

/* tt__Dot11SecurityConfiguration * has binding name 'PointerTott__Dot11SecurityConfiguration' for type 'tt:Dot11SecurityConfiguration' */
#ifndef SOAP_TYPE_PointerTott__Dot11SecurityConfiguration
#define SOAP_TYPE_PointerTott__Dot11SecurityConfiguration (1209)
#endif

/* tt__IPAddressFilterExtension * has binding name 'PointerTott__IPAddressFilterExtension' for type 'tt:IPAddressFilterExtension' */
#ifndef SOAP_TYPE_PointerTott__IPAddressFilterExtension
#define SOAP_TYPE_PointerTott__IPAddressFilterExtension (1208)
#endif

/* tt__NetworkZeroConfigurationExtension2 * has binding name 'PointerTott__NetworkZeroConfigurationExtension2' for type 'tt:NetworkZeroConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension2 (1207)
#endif

/* tt__NetworkZeroConfigurationExtension * has binding name 'PointerTott__NetworkZeroConfigurationExtension' for type 'tt:NetworkZeroConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension
#define SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension (1205)
#endif

/* enum tt__IPv6DHCPConfiguration * has binding name 'PointerTott__IPv6DHCPConfiguration' for type 'tt:IPv6DHCPConfiguration' */
#ifndef SOAP_TYPE_PointerTott__IPv6DHCPConfiguration
#define SOAP_TYPE_PointerTott__IPv6DHCPConfiguration (1204)
#endif

/* tt__NetworkInterfaceSetConfigurationExtension2 * has binding name 'PointerTott__NetworkInterfaceSetConfigurationExtension2' for type 'tt:NetworkInterfaceSetConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension2 (1203)
#endif

/* tt__NetworkInterfaceSetConfigurationExtension * has binding name 'PointerTott__NetworkInterfaceSetConfigurationExtension' for type 'tt:NetworkInterfaceSetConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension (1202)
#endif

/* tt__IPv6NetworkInterfaceSetConfiguration * has binding name 'PointerTott__IPv6NetworkInterfaceSetConfiguration' for type 'tt:IPv6NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration (1201)
#endif

/* tt__IPv4NetworkInterfaceSetConfiguration * has binding name 'PointerTott__IPv4NetworkInterfaceSetConfiguration' for type 'tt:IPv4NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration (1200)
#endif

/* tt__DynamicDNSInformationExtension * has binding name 'PointerTott__DynamicDNSInformationExtension' for type 'tt:DynamicDNSInformationExtension' */
#ifndef SOAP_TYPE_PointerTott__DynamicDNSInformationExtension
#define SOAP_TYPE_PointerTott__DynamicDNSInformationExtension (1199)
#endif

/* tt__NTPInformationExtension * has binding name 'PointerTott__NTPInformationExtension' for type 'tt:NTPInformationExtension' */
#ifndef SOAP_TYPE_PointerTott__NTPInformationExtension
#define SOAP_TYPE_PointerTott__NTPInformationExtension (1198)
#endif

/* tt__DNSInformationExtension * has binding name 'PointerTott__DNSInformationExtension' for type 'tt:DNSInformationExtension' */
#ifndef SOAP_TYPE_PointerTott__DNSInformationExtension
#define SOAP_TYPE_PointerTott__DNSInformationExtension (1197)
#endif

/* tt__HostnameInformationExtension * has binding name 'PointerTott__HostnameInformationExtension' for type 'tt:HostnameInformationExtension' */
#ifndef SOAP_TYPE_PointerTott__HostnameInformationExtension
#define SOAP_TYPE_PointerTott__HostnameInformationExtension (1196)
#endif

/* tt__NetworkHostExtension * has binding name 'PointerTott__NetworkHostExtension' for type 'tt:NetworkHostExtension' */
#ifndef SOAP_TYPE_PointerTott__NetworkHostExtension
#define SOAP_TYPE_PointerTott__NetworkHostExtension (1195)
#endif

/* std::string * has binding name 'PointerTott__IPv6Address' for type 'tt:IPv6Address' */
#ifndef SOAP_TYPE_PointerTott__IPv6Address
#define SOAP_TYPE_PointerTott__IPv6Address (1194)
#endif

/* std::string * has binding name 'PointerTott__IPv4Address' for type 'tt:IPv4Address' */
#ifndef SOAP_TYPE_PointerTott__IPv4Address
#define SOAP_TYPE_PointerTott__IPv4Address (1193)
#endif

/* tt__NetworkProtocolExtension * has binding name 'PointerTott__NetworkProtocolExtension' for type 'tt:NetworkProtocolExtension' */
#ifndef SOAP_TYPE_PointerTott__NetworkProtocolExtension
#define SOAP_TYPE_PointerTott__NetworkProtocolExtension (1192)
#endif

/* tt__IPv6ConfigurationExtension * has binding name 'PointerTott__IPv6ConfigurationExtension' for type 'tt:IPv6ConfigurationExtension' */
#ifndef SOAP_TYPE_PointerTott__IPv6ConfigurationExtension
#define SOAP_TYPE_PointerTott__IPv6ConfigurationExtension (1191)
#endif

/* tt__PrefixedIPv6Address * has binding name 'PointerTott__PrefixedIPv6Address' for type 'tt:PrefixedIPv6Address' */
#ifndef SOAP_TYPE_PointerTott__PrefixedIPv6Address
#define SOAP_TYPE_PointerTott__PrefixedIPv6Address (1189)
#endif

/* tt__PrefixedIPv4Address * has binding name 'PointerTott__PrefixedIPv4Address' for type 'tt:PrefixedIPv4Address' */
#ifndef SOAP_TYPE_PointerTott__PrefixedIPv4Address
#define SOAP_TYPE_PointerTott__PrefixedIPv4Address (1187)
#endif

/* tt__IPv4Configuration * has binding name 'PointerTott__IPv4Configuration' for type 'tt:IPv4Configuration' */
#ifndef SOAP_TYPE_PointerTott__IPv4Configuration
#define SOAP_TYPE_PointerTott__IPv4Configuration (1186)
#endif

/* tt__IPv6Configuration * has binding name 'PointerTott__IPv6Configuration' for type 'tt:IPv6Configuration' */
#ifndef SOAP_TYPE_PointerTott__IPv6Configuration
#define SOAP_TYPE_PointerTott__IPv6Configuration (1185)
#endif

/* tt__NetworkInterfaceConnectionSetting * has binding name 'PointerTott__NetworkInterfaceConnectionSetting' for type 'tt:NetworkInterfaceConnectionSetting' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting (1184)
#endif

/* tt__NetworkInterfaceExtension2 * has binding name 'PointerTott__NetworkInterfaceExtension2' for type 'tt:NetworkInterfaceExtension2' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceExtension2
#define SOAP_TYPE_PointerTott__NetworkInterfaceExtension2 (1183)
#endif

/* tt__Dot11Configuration * has binding name 'PointerTott__Dot11Configuration' for type 'tt:Dot11Configuration' */
#ifndef SOAP_TYPE_PointerTott__Dot11Configuration
#define SOAP_TYPE_PointerTott__Dot11Configuration (1181)
#endif

/* tt__Dot3Configuration * has binding name 'PointerTott__Dot3Configuration' for type 'tt:Dot3Configuration' */
#ifndef SOAP_TYPE_PointerTott__Dot3Configuration
#define SOAP_TYPE_PointerTott__Dot3Configuration (1179)
#endif

/* tt__Transport * has binding name 'PointerTott__Transport' for type 'tt:Transport' */
#ifndef SOAP_TYPE_PointerTott__Transport
#define SOAP_TYPE_PointerTott__Transport (1178)
#endif

/* tt__AudioDecoderConfigurationOptionsExtension * has binding name 'PointerTott__AudioDecoderConfigurationOptionsExtension' for type 'tt:AudioDecoderConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_PointerTott__AudioDecoderConfigurationOptionsExtension (1177)
#endif

/* tt__G726DecOptions * has binding name 'PointerTott__G726DecOptions' for type 'tt:G726DecOptions' */
#ifndef SOAP_TYPE_PointerTott__G726DecOptions
#define SOAP_TYPE_PointerTott__G726DecOptions (1176)
#endif

/* tt__G711DecOptions * has binding name 'PointerTott__G711DecOptions' for type 'tt:G711DecOptions' */
#ifndef SOAP_TYPE_PointerTott__G711DecOptions
#define SOAP_TYPE_PointerTott__G711DecOptions (1175)
#endif

/* tt__AACDecOptions * has binding name 'PointerTott__AACDecOptions' for type 'tt:AACDecOptions' */
#ifndef SOAP_TYPE_PointerTott__AACDecOptions
#define SOAP_TYPE_PointerTott__AACDecOptions (1174)
#endif

/* tt__VideoDecoderConfigurationOptionsExtension * has binding name 'PointerTott__VideoDecoderConfigurationOptionsExtension' for type 'tt:VideoDecoderConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_PointerTott__VideoDecoderConfigurationOptionsExtension (1173)
#endif

/* tt__Mpeg4DecOptions * has binding name 'PointerTott__Mpeg4DecOptions' for type 'tt:Mpeg4DecOptions' */
#ifndef SOAP_TYPE_PointerTott__Mpeg4DecOptions
#define SOAP_TYPE_PointerTott__Mpeg4DecOptions (1172)
#endif

/* tt__H264DecOptions * has binding name 'PointerTott__H264DecOptions' for type 'tt:H264DecOptions' */
#ifndef SOAP_TYPE_PointerTott__H264DecOptions
#define SOAP_TYPE_PointerTott__H264DecOptions (1171)
#endif

/* tt__JpegDecOptions * has binding name 'PointerTott__JpegDecOptions' for type 'tt:JpegDecOptions' */
#ifndef SOAP_TYPE_PointerTott__JpegDecOptions
#define SOAP_TYPE_PointerTott__JpegDecOptions (1170)
#endif

/* tt__PTZStatusFilterOptionsExtension * has binding name 'PointerTott__PTZStatusFilterOptionsExtension' for type 'tt:PTZStatusFilterOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_PointerTott__PTZStatusFilterOptionsExtension (1169)
#endif

/* tt__MetadataConfigurationOptionsExtension2 * has binding name 'PointerTott__MetadataConfigurationOptionsExtension2' for type 'tt:MetadataConfigurationOptionsExtension2' */
#ifndef SOAP_TYPE_PointerTott__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_PointerTott__MetadataConfigurationOptionsExtension2 (1168)
#endif

/* tt__MetadataConfigurationOptionsExtension * has binding name 'PointerTott__MetadataConfigurationOptionsExtension' for type 'tt:MetadataConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_PointerTott__MetadataConfigurationOptionsExtension (1167)
#endif

/* tt__PTZStatusFilterOptions * has binding name 'PointerTott__PTZStatusFilterOptions' for type 'tt:PTZStatusFilterOptions' */
#ifndef SOAP_TYPE_PointerTott__PTZStatusFilterOptions
#define SOAP_TYPE_PointerTott__PTZStatusFilterOptions (1166)
#endif

/* _tt__EventSubscription_SubscriptionPolicy * has binding name 'PointerTo_tt__EventSubscription_SubscriptionPolicy' for type '' */
#ifndef SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy (1165)
#endif

/* wsnt__FilterType * has binding name 'PointerTowsnt__FilterType' for type 'wsnt:FilterType' */
#ifndef SOAP_TYPE_PointerTowsnt__FilterType
#define SOAP_TYPE_PointerTowsnt__FilterType (1163)
#endif

/* tt__AudioEncoderConfigurationOption * has binding name 'PointerTott__AudioEncoderConfigurationOption' for type 'tt:AudioEncoderConfigurationOption' */
#ifndef SOAP_TYPE_PointerTott__AudioEncoderConfigurationOption
#define SOAP_TYPE_PointerTott__AudioEncoderConfigurationOption (1161)
#endif

/* tt__AudioSourceOptionsExtension * has binding name 'PointerTott__AudioSourceOptionsExtension' for type 'tt:AudioSourceOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__AudioSourceOptionsExtension
#define SOAP_TYPE_PointerTott__AudioSourceOptionsExtension (1160)
#endif

/* std::string * has binding name 'PointerTott__FloatList' for type 'tt:FloatList' */
#ifndef SOAP_TYPE_PointerTott__FloatList
#define SOAP_TYPE_PointerTott__FloatList (1159)
#endif

/* tt__VideoResolution2 * has binding name 'PointerTott__VideoResolution2' for type 'tt:VideoResolution2' */
#ifndef SOAP_TYPE_PointerTott__VideoResolution2
#define SOAP_TYPE_PointerTott__VideoResolution2 (1157)
#endif

/* tt__FloatRange * has binding name 'PointerTott__FloatRange' for type 'tt:FloatRange' */
#ifndef SOAP_TYPE_PointerTott__FloatRange
#define SOAP_TYPE_PointerTott__FloatRange (1156)
#endif

/* tt__VideoResolution * has binding name 'PointerTott__VideoResolution' for type 'tt:VideoResolution' */
#ifndef SOAP_TYPE_PointerTott__VideoResolution
#define SOAP_TYPE_PointerTott__VideoResolution (1152)
#endif

/* tt__VideoEncoderOptionsExtension2 * has binding name 'PointerTott__VideoEncoderOptionsExtension2' for type 'tt:VideoEncoderOptionsExtension2' */
#ifndef SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension2
#define SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension2 (1151)
#endif

/* tt__H264Options2 * has binding name 'PointerTott__H264Options2' for type 'tt:H264Options2' */
#ifndef SOAP_TYPE_PointerTott__H264Options2
#define SOAP_TYPE_PointerTott__H264Options2 (1150)
#endif

/* tt__Mpeg4Options2 * has binding name 'PointerTott__Mpeg4Options2' for type 'tt:Mpeg4Options2' */
#ifndef SOAP_TYPE_PointerTott__Mpeg4Options2
#define SOAP_TYPE_PointerTott__Mpeg4Options2 (1149)
#endif

/* tt__JpegOptions2 * has binding name 'PointerTott__JpegOptions2' for type 'tt:JpegOptions2' */
#ifndef SOAP_TYPE_PointerTott__JpegOptions2
#define SOAP_TYPE_PointerTott__JpegOptions2 (1148)
#endif

/* tt__VideoEncoderOptionsExtension * has binding name 'PointerTott__VideoEncoderOptionsExtension' for type 'tt:VideoEncoderOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension
#define SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension (1147)
#endif

/* tt__H264Options * has binding name 'PointerTott__H264Options' for type 'tt:H264Options' */
#ifndef SOAP_TYPE_PointerTott__H264Options
#define SOAP_TYPE_PointerTott__H264Options (1146)
#endif

/* tt__Mpeg4Options * has binding name 'PointerTott__Mpeg4Options' for type 'tt:Mpeg4Options' */
#ifndef SOAP_TYPE_PointerTott__Mpeg4Options
#define SOAP_TYPE_PointerTott__Mpeg4Options (1145)
#endif

/* tt__JpegOptions * has binding name 'PointerTott__JpegOptions' for type 'tt:JpegOptions' */
#ifndef SOAP_TYPE_PointerTott__JpegOptions
#define SOAP_TYPE_PointerTott__JpegOptions (1144)
#endif

/* tt__RotateOptionsExtension * has binding name 'PointerTott__RotateOptionsExtension' for type 'tt:RotateOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__RotateOptionsExtension
#define SOAP_TYPE_PointerTott__RotateOptionsExtension (1143)
#endif

/* tt__IntItems * has binding name 'PointerTott__IntItems' for type 'tt:IntItems' */
#ifndef SOAP_TYPE_PointerTott__IntItems
#define SOAP_TYPE_PointerTott__IntItems (1142)
#endif

/* tt__VideoSourceConfigurationOptionsExtension2 * has binding name 'PointerTott__VideoSourceConfigurationOptionsExtension2' for type 'tt:VideoSourceConfigurationOptionsExtension2' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension2 (1139)
#endif

/* tt__RotateOptions * has binding name 'PointerTott__RotateOptions' for type 'tt:RotateOptions' */
#ifndef SOAP_TYPE_PointerTott__RotateOptions
#define SOAP_TYPE_PointerTott__RotateOptions (1138)
#endif

/* tt__VideoSourceConfigurationOptionsExtension * has binding name 'PointerTott__VideoSourceConfigurationOptionsExtension' for type 'tt:VideoSourceConfigurationOptionsExtension' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension (1137)
#endif

/* tt__IntRectangleRange * has binding name 'PointerTott__IntRectangleRange' for type 'tt:IntRectangleRange' */
#ifndef SOAP_TYPE_PointerTott__IntRectangleRange
#define SOAP_TYPE_PointerTott__IntRectangleRange (1136)
#endif

/* tt__LensProjection * has binding name 'PointerTott__LensProjection' for type 'tt:LensProjection' */
#ifndef SOAP_TYPE_PointerTott__LensProjection
#define SOAP_TYPE_PointerTott__LensProjection (1134)
#endif

/* tt__LensOffset * has binding name 'PointerTott__LensOffset' for type 'tt:LensOffset' */
#ifndef SOAP_TYPE_PointerTott__LensOffset
#define SOAP_TYPE_PointerTott__LensOffset (1133)
#endif

/* float * has binding name 'PointerTofloat' for type 'xsd:float' */
#ifndef SOAP_TYPE_PointerTofloat
#define SOAP_TYPE_PointerTofloat (1132)
#endif

/* tt__RotateExtension * has binding name 'PointerTott__RotateExtension' for type 'tt:RotateExtension' */
#ifndef SOAP_TYPE_PointerTott__RotateExtension
#define SOAP_TYPE_PointerTott__RotateExtension (1131)
#endif

/* tt__SceneOrientation * has binding name 'PointerTott__SceneOrientation' for type 'tt:SceneOrientation' */
#ifndef SOAP_TYPE_PointerTott__SceneOrientation
#define SOAP_TYPE_PointerTott__SceneOrientation (1130)
#endif

/* tt__LensDescription * has binding name 'PointerTott__LensDescription' for type 'tt:LensDescription' */
#ifndef SOAP_TYPE_PointerTott__LensDescription
#define SOAP_TYPE_PointerTott__LensDescription (1128)
#endif

/* tt__VideoSourceConfigurationExtension2 * has binding name 'PointerTott__VideoSourceConfigurationExtension2' for type 'tt:VideoSourceConfigurationExtension2' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension2
#define SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension2 (1127)
#endif

/* tt__Rotate * has binding name 'PointerTott__Rotate' for type 'tt:Rotate' */
#ifndef SOAP_TYPE_PointerTott__Rotate
#define SOAP_TYPE_PointerTott__Rotate (1126)
#endif

/* tt__ProfileExtension2 * has binding name 'PointerTott__ProfileExtension2' for type 'tt:ProfileExtension2' */
#ifndef SOAP_TYPE_PointerTott__ProfileExtension2
#define SOAP_TYPE_PointerTott__ProfileExtension2 (1125)
#endif

/* tt__AudioDecoderConfiguration * has binding name 'PointerTott__AudioDecoderConfiguration' for type 'tt:AudioDecoderConfiguration' */
#ifndef SOAP_TYPE_PointerTott__AudioDecoderConfiguration
#define SOAP_TYPE_PointerTott__AudioDecoderConfiguration (1124)
#endif

/* tt__AudioOutputConfiguration * has binding name 'PointerTott__AudioOutputConfiguration' for type 'tt:AudioOutputConfiguration' */
#ifndef SOAP_TYPE_PointerTott__AudioOutputConfiguration
#define SOAP_TYPE_PointerTott__AudioOutputConfiguration (1123)
#endif

/* tt__ProfileExtension * has binding name 'PointerTott__ProfileExtension' for type 'tt:ProfileExtension' */
#ifndef SOAP_TYPE_PointerTott__ProfileExtension
#define SOAP_TYPE_PointerTott__ProfileExtension (1122)
#endif

/* tt__MetadataConfiguration * has binding name 'PointerTott__MetadataConfiguration' for type 'tt:MetadataConfiguration' */
#ifndef SOAP_TYPE_PointerTott__MetadataConfiguration
#define SOAP_TYPE_PointerTott__MetadataConfiguration (1121)
#endif

/* tt__PTZConfiguration * has binding name 'PointerTott__PTZConfiguration' for type 'tt:PTZConfiguration' */
#ifndef SOAP_TYPE_PointerTott__PTZConfiguration
#define SOAP_TYPE_PointerTott__PTZConfiguration (1120)
#endif

/* tt__VideoAnalyticsConfiguration * has binding name 'PointerTott__VideoAnalyticsConfiguration' for type 'tt:VideoAnalyticsConfiguration' */
#ifndef SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration
#define SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration (1119)
#endif

/* tt__AudioEncoderConfiguration * has binding name 'PointerTott__AudioEncoderConfiguration' for type 'tt:AudioEncoderConfiguration' */
#ifndef SOAP_TYPE_PointerTott__AudioEncoderConfiguration
#define SOAP_TYPE_PointerTott__AudioEncoderConfiguration (1118)
#endif

/* tt__VideoEncoderConfiguration * has binding name 'PointerTott__VideoEncoderConfiguration' for type 'tt:VideoEncoderConfiguration' */
#ifndef SOAP_TYPE_PointerTott__VideoEncoderConfiguration
#define SOAP_TYPE_PointerTott__VideoEncoderConfiguration (1117)
#endif

/* tt__AudioSourceConfiguration * has binding name 'PointerTott__AudioSourceConfiguration' for type 'tt:AudioSourceConfiguration' */
#ifndef SOAP_TYPE_PointerTott__AudioSourceConfiguration
#define SOAP_TYPE_PointerTott__AudioSourceConfiguration (1116)
#endif

/* tt__VideoSourceConfiguration * has binding name 'PointerTott__VideoSourceConfiguration' for type 'tt:VideoSourceConfiguration' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceConfiguration
#define SOAP_TYPE_PointerTott__VideoSourceConfiguration (1115)
#endif

/* tt__VideoSourceExtension2 * has binding name 'PointerTott__VideoSourceExtension2' for type 'tt:VideoSourceExtension2' */
#ifndef SOAP_TYPE_PointerTott__VideoSourceExtension2
#define SOAP_TYPE_PointerTott__VideoSourceExtension2 (1114)
#endif

/* tt__ImagingSettings20 * has binding name 'PointerTott__ImagingSettings20' for type 'tt:ImagingSettings20' */
#ifndef SOAP_TYPE_PointerTott__ImagingSettings20
#define SOAP_TYPE_PointerTott__ImagingSettings20 (1113)
#endif

/* tt__LocationEntity * has binding name 'PointerTott__LocationEntity' for type 'tt:LocationEntity' */
#ifndef SOAP_TYPE_PointerTott__LocationEntity
#define SOAP_TYPE_PointerTott__LocationEntity (1109)
#endif

/* tds__StorageConfigurationData * has binding name 'PointerTotds__StorageConfigurationData' for type 'tds:StorageConfigurationData' */
#ifndef SOAP_TYPE_PointerTotds__StorageConfigurationData
#define SOAP_TYPE_PointerTotds__StorageConfigurationData (1108)
#endif

/* tds__StorageConfiguration * has binding name 'PointerTotds__StorageConfiguration' for type 'tds:StorageConfiguration' */
#ifndef SOAP_TYPE_PointerTotds__StorageConfiguration
#define SOAP_TYPE_PointerTotds__StorageConfiguration (1106)
#endif

/* _tds__GetSystemUrisResponse_Extension * has binding name 'PointerTo_tds__GetSystemUrisResponse_Extension' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__GetSystemUrisResponse_Extension
#define SOAP_TYPE_PointerTo_tds__GetSystemUrisResponse_Extension (1105)
#endif

/* tt__SystemLogUriList * has binding name 'PointerTott__SystemLogUriList' for type 'tt:SystemLogUriList' */
#ifndef SOAP_TYPE_PointerTott__SystemLogUriList
#define SOAP_TYPE_PointerTott__SystemLogUriList (1103)
#endif

/* tt__Dot11AvailableNetworks * has binding name 'PointerTott__Dot11AvailableNetworks' for type 'tt:Dot11AvailableNetworks' */
#ifndef SOAP_TYPE_PointerTott__Dot11AvailableNetworks
#define SOAP_TYPE_PointerTott__Dot11AvailableNetworks (1101)
#endif

/* tt__Dot11Status * has binding name 'PointerTott__Dot11Status' for type 'tt:Dot11Status' */
#ifndef SOAP_TYPE_PointerTott__Dot11Status
#define SOAP_TYPE_PointerTott__Dot11Status (1100)
#endif

/* tt__Dot11Capabilities * has binding name 'PointerTott__Dot11Capabilities' for type 'tt:Dot11Capabilities' */
#ifndef SOAP_TYPE_PointerTott__Dot11Capabilities
#define SOAP_TYPE_PointerTott__Dot11Capabilities (1099)
#endif

/* std::string * has binding name 'PointerTott__AuxiliaryData' for type 'tt:AuxiliaryData' */
#ifndef SOAP_TYPE_PointerTott__AuxiliaryData
#define SOAP_TYPE_PointerTott__AuxiliaryData (1098)
#endif

/* tt__RelayOutputSettings * has binding name 'PointerTott__RelayOutputSettings' for type 'tt:RelayOutputSettings' */
#ifndef SOAP_TYPE_PointerTott__RelayOutputSettings
#define SOAP_TYPE_PointerTott__RelayOutputSettings (1097)
#endif

/* tt__RelayOutput * has binding name 'PointerTott__RelayOutput' for type 'tt:RelayOutput' */
#ifndef SOAP_TYPE_PointerTott__RelayOutput
#define SOAP_TYPE_PointerTott__RelayOutput (1095)
#endif

/* tt__Dot1XConfiguration * has binding name 'PointerTott__Dot1XConfiguration' for type 'tt:Dot1XConfiguration' */
#ifndef SOAP_TYPE_PointerTott__Dot1XConfiguration
#define SOAP_TYPE_PointerTott__Dot1XConfiguration (1092)
#endif

/* tt__CertificateInformation * has binding name 'PointerTott__CertificateInformation' for type 'tt:CertificateInformation' */
#ifndef SOAP_TYPE_PointerTott__CertificateInformation
#define SOAP_TYPE_PointerTott__CertificateInformation (1091)
#endif

/* tt__CertificateWithPrivateKey * has binding name 'PointerTott__CertificateWithPrivateKey' for type 'tt:CertificateWithPrivateKey' */
#ifndef SOAP_TYPE_PointerTott__CertificateWithPrivateKey
#define SOAP_TYPE_PointerTott__CertificateWithPrivateKey (1089)
#endif

/* tt__CertificateStatus * has binding name 'PointerTott__CertificateStatus' for type 'tt:CertificateStatus' */
#ifndef SOAP_TYPE_PointerTott__CertificateStatus
#define SOAP_TYPE_PointerTott__CertificateStatus (1087)
#endif

/* tt__Certificate * has binding name 'PointerTott__Certificate' for type 'tt:Certificate' */
#ifndef SOAP_TYPE_PointerTott__Certificate
#define SOAP_TYPE_PointerTott__Certificate (1085)
#endif

/* time_t * has binding name 'PointerTodateTime' for type 'xsd:dateTime' */
#ifndef SOAP_TYPE_PointerTodateTime
#define SOAP_TYPE_PointerTodateTime (1084)
#endif

/* std::string * has binding name 'PointerToxsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_PointerToxsd__token
#define SOAP_TYPE_PointerToxsd__token (1083)
#endif

/* tt__BinaryData * has binding name 'PointerTott__BinaryData' for type 'tt:BinaryData' */
#ifndef SOAP_TYPE_PointerTott__BinaryData
#define SOAP_TYPE_PointerTott__BinaryData (1082)
#endif

/* tt__IPAddressFilter * has binding name 'PointerTott__IPAddressFilter' for type 'tt:IPAddressFilter' */
#ifndef SOAP_TYPE_PointerTott__IPAddressFilter
#define SOAP_TYPE_PointerTott__IPAddressFilter (1081)
#endif

/* tt__NetworkZeroConfiguration * has binding name 'PointerTott__NetworkZeroConfiguration' for type 'tt:NetworkZeroConfiguration' */
#ifndef SOAP_TYPE_PointerTott__NetworkZeroConfiguration
#define SOAP_TYPE_PointerTott__NetworkZeroConfiguration (1080)
#endif

/* tt__NetworkGateway * has binding name 'PointerTott__NetworkGateway' for type 'tt:NetworkGateway' */
#ifndef SOAP_TYPE_PointerTott__NetworkGateway
#define SOAP_TYPE_PointerTott__NetworkGateway (1077)
#endif

/* tt__NetworkProtocol * has binding name 'PointerTott__NetworkProtocol' for type 'tt:NetworkProtocol' */
#ifndef SOAP_TYPE_PointerTott__NetworkProtocol
#define SOAP_TYPE_PointerTott__NetworkProtocol (1075)
#endif

/* tt__NetworkInterfaceSetConfiguration * has binding name 'PointerTott__NetworkInterfaceSetConfiguration' for type 'tt:NetworkInterfaceSetConfiguration' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_PointerTott__NetworkInterfaceSetConfiguration (1074)
#endif

/* tt__NetworkInterface * has binding name 'PointerTott__NetworkInterface' for type 'tt:NetworkInterface' */
#ifndef SOAP_TYPE_PointerTott__NetworkInterface
#define SOAP_TYPE_PointerTott__NetworkInterface (1072)
#endif

/* std::string * has binding name 'PointerToxsd__duration' for type 'xsd:duration' */
#ifndef SOAP_TYPE_PointerToxsd__duration
#define SOAP_TYPE_PointerToxsd__duration (1071)
#endif

/* std::string * has binding name 'PointerTott__DNSName' for type 'tt:DNSName' */
#ifndef SOAP_TYPE_PointerTott__DNSName
#define SOAP_TYPE_PointerTott__DNSName (1070)
#endif

/* tt__DynamicDNSInformation * has binding name 'PointerTott__DynamicDNSInformation' for type 'tt:DynamicDNSInformation' */
#ifndef SOAP_TYPE_PointerTott__DynamicDNSInformation
#define SOAP_TYPE_PointerTott__DynamicDNSInformation (1069)
#endif

/* tt__NTPInformation * has binding name 'PointerTott__NTPInformation' for type 'tt:NTPInformation' */
#ifndef SOAP_TYPE_PointerTott__NTPInformation
#define SOAP_TYPE_PointerTott__NTPInformation (1068)
#endif

/* tt__IPAddress * has binding name 'PointerTott__IPAddress' for type 'tt:IPAddress' */
#ifndef SOAP_TYPE_PointerTott__IPAddress
#define SOAP_TYPE_PointerTott__IPAddress (1066)
#endif

/* tt__DNSInformation * has binding name 'PointerTott__DNSInformation' for type 'tt:DNSInformation' */
#ifndef SOAP_TYPE_PointerTott__DNSInformation
#define SOAP_TYPE_PointerTott__DNSInformation (1064)
#endif

/* tt__HostnameInformation * has binding name 'PointerTott__HostnameInformation' for type 'tt:HostnameInformation' */
#ifndef SOAP_TYPE_PointerTott__HostnameInformation
#define SOAP_TYPE_PointerTott__HostnameInformation (1063)
#endif

/* tt__Capabilities * has binding name 'PointerTott__Capabilities' for type 'tt:Capabilities' */
#ifndef SOAP_TYPE_PointerTott__Capabilities
#define SOAP_TYPE_PointerTott__Capabilities (1062)
#endif

/* tt__IntRange * has binding name 'PointerTott__IntRange' for type 'tt:IntRange' */
#ifndef SOAP_TYPE_PointerTott__IntRange
#define SOAP_TYPE_PointerTott__IntRange (1060)
#endif

/* tt__User * has binding name 'PointerTott__User' for type 'tt:User' */
#ifndef SOAP_TYPE_PointerTott__User
#define SOAP_TYPE_PointerTott__User (1057)
#endif

/* tt__RemoteUser * has binding name 'PointerTott__RemoteUser' for type 'tt:RemoteUser' */
#ifndef SOAP_TYPE_PointerTott__RemoteUser
#define SOAP_TYPE_PointerTott__RemoteUser (1056)
#endif

/* tt__NetworkHost * has binding name 'PointerTott__NetworkHost' for type 'tt:NetworkHost' */
#ifndef SOAP_TYPE_PointerTott__NetworkHost
#define SOAP_TYPE_PointerTott__NetworkHost (1054)
#endif

/* tt__Scope * has binding name 'PointerTott__Scope' for type 'tt:Scope' */
#ifndef SOAP_TYPE_PointerTott__Scope
#define SOAP_TYPE_PointerTott__Scope (1051)
#endif

/* tt__SystemLog * has binding name 'PointerTott__SystemLog' for type 'tt:SystemLog' */
#ifndef SOAP_TYPE_PointerTott__SystemLog
#define SOAP_TYPE_PointerTott__SystemLog (1050)
#endif

/* tt__SupportInformation * has binding name 'PointerTott__SupportInformation' for type 'tt:SupportInformation' */
#ifndef SOAP_TYPE_PointerTott__SupportInformation
#define SOAP_TYPE_PointerTott__SupportInformation (1049)
#endif

/* tt__BackupFile * has binding name 'PointerTott__BackupFile' for type 'tt:BackupFile' */
#ifndef SOAP_TYPE_PointerTott__BackupFile
#define SOAP_TYPE_PointerTott__BackupFile (1047)
#endif

/* tt__AttachmentData * has binding name 'PointerTott__AttachmentData' for type 'tt:AttachmentData' */
#ifndef SOAP_TYPE_PointerTott__AttachmentData
#define SOAP_TYPE_PointerTott__AttachmentData (1046)
#endif

/* tt__SystemDateTime * has binding name 'PointerTott__SystemDateTime' for type 'tt:SystemDateTime' */
#ifndef SOAP_TYPE_PointerTott__SystemDateTime
#define SOAP_TYPE_PointerTott__SystemDateTime (1045)
#endif

/* tt__DateTime * has binding name 'PointerTott__DateTime' for type 'tt:DateTime' */
#ifndef SOAP_TYPE_PointerTott__DateTime
#define SOAP_TYPE_PointerTott__DateTime (1044)
#endif

/* tt__TimeZone * has binding name 'PointerTott__TimeZone' for type 'tt:TimeZone' */
#ifndef SOAP_TYPE_PointerTott__TimeZone
#define SOAP_TYPE_PointerTott__TimeZone (1043)
#endif

/* tds__DeviceServiceCapabilities * has binding name 'PointerTotds__DeviceServiceCapabilities' for type 'tds:DeviceServiceCapabilities' */
#ifndef SOAP_TYPE_PointerTotds__DeviceServiceCapabilities
#define SOAP_TYPE_PointerTotds__DeviceServiceCapabilities (1042)
#endif

/* tds__Service * has binding name 'PointerTotds__Service' for type 'tds:Service' */
#ifndef SOAP_TYPE_PointerTotds__Service
#define SOAP_TYPE_PointerTotds__Service (1040)
#endif

/* _tds__StorageConfigurationData_Extension * has binding name 'PointerTo_tds__StorageConfigurationData_Extension' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__StorageConfigurationData_Extension
#define SOAP_TYPE_PointerTo_tds__StorageConfigurationData_Extension (1039)
#endif

/* tds__UserCredential * has binding name 'PointerTotds__UserCredential' for type 'tds:UserCredential' */
#ifndef SOAP_TYPE_PointerTotds__UserCredential
#define SOAP_TYPE_PointerTotds__UserCredential (1037)
#endif

/* std::string * has binding name 'PointerToxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_PointerToxsd__anyURI
#define SOAP_TYPE_PointerToxsd__anyURI (1036)
#endif

/* _tds__UserCredential_Extension * has binding name 'PointerTo_tds__UserCredential_Extension' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__UserCredential_Extension
#define SOAP_TYPE_PointerTo_tds__UserCredential_Extension (1035)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (1033)
#endif

/* std::string * has binding name 'PointerTott__StringAttrList' for type 'tt:StringAttrList' */
#ifndef SOAP_TYPE_PointerTott__StringAttrList
#define SOAP_TYPE_PointerTott__StringAttrList (1032)
#endif

/* std::string * has binding name 'PointerTott__StringList' for type 'tt:StringList' */
#ifndef SOAP_TYPE_PointerTott__StringList
#define SOAP_TYPE_PointerTott__StringList (1031)
#endif

/* std::string * has binding name 'PointerTott__IntList' for type 'tt:IntList' */
#ifndef SOAP_TYPE_PointerTott__IntList
#define SOAP_TYPE_PointerTott__IntList (1030)
#endif

/* bool * has binding name 'PointerTobool' for type 'xsd:boolean' */
#ifndef SOAP_TYPE_PointerTobool
#define SOAP_TYPE_PointerTobool (1029)
#endif

/* tds__MiscCapabilities * has binding name 'PointerTotds__MiscCapabilities' for type 'tds:MiscCapabilities' */
#ifndef SOAP_TYPE_PointerTotds__MiscCapabilities
#define SOAP_TYPE_PointerTotds__MiscCapabilities (1028)
#endif

/* tds__SystemCapabilities * has binding name 'PointerTotds__SystemCapabilities' for type 'tds:SystemCapabilities' */
#ifndef SOAP_TYPE_PointerTotds__SystemCapabilities
#define SOAP_TYPE_PointerTotds__SystemCapabilities (1027)
#endif

/* tds__SecurityCapabilities * has binding name 'PointerTotds__SecurityCapabilities' for type 'tds:SecurityCapabilities' */
#ifndef SOAP_TYPE_PointerTotds__SecurityCapabilities
#define SOAP_TYPE_PointerTotds__SecurityCapabilities (1026)
#endif

/* tds__NetworkCapabilities * has binding name 'PointerTotds__NetworkCapabilities' for type 'tds:NetworkCapabilities' */
#ifndef SOAP_TYPE_PointerTotds__NetworkCapabilities
#define SOAP_TYPE_PointerTotds__NetworkCapabilities (1025)
#endif

/* tt__OnvifVersion * has binding name 'PointerTott__OnvifVersion' for type 'tt:OnvifVersion' */
#ifndef SOAP_TYPE_PointerTott__OnvifVersion
#define SOAP_TYPE_PointerTott__OnvifVersion (1023)
#endif

/* _tds__Service_Capabilities * has binding name 'PointerTo_tds__Service_Capabilities' for type '' */
#ifndef SOAP_TYPE_PointerTo_tds__Service_Capabilities
#define SOAP_TYPE_PointerTo_tds__Service_Capabilities (1022)
#endif

/* struct SOAP_ENV__Header * has binding name 'PointerToSOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Header
#define SOAP_TYPE_PointerToSOAP_ENV__Header (60)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (53)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (51)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (49)
#endif

/* struct chan__ChannelInstanceType * has binding name 'PointerTochan__ChannelInstanceType' for type 'chan:ChannelInstanceType' */
#ifndef SOAP_TYPE_PointerTochan__ChannelInstanceType
#define SOAP_TYPE_PointerTochan__ChannelInstanceType (47)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__FaultTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__FaultTo
#define SOAP_TYPE_PointerTo_wsa5__FaultTo (46)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__ReplyTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__ReplyTo
#define SOAP_TYPE_PointerTo_wsa5__ReplyTo (45)
#endif

/* struct wsa5__EndpointReferenceType * has binding name 'PointerTo_wsa5__From' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__From
#define SOAP_TYPE_PointerTo_wsa5__From (44)
#endif

/* struct wsa5__RelatesToType * has binding name 'PointerTo_wsa5__RelatesTo' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsa5__RelatesTo
#define SOAP_TYPE_PointerTo_wsa5__RelatesTo (43)
#endif

/* _wsa5__ProblemIRI has binding name '_wsa5__ProblemIRI' for type '' */
#ifndef SOAP_TYPE__wsa5__ProblemIRI
#define SOAP_TYPE__wsa5__ProblemIRI (38)
#endif

/* _wsa5__ProblemHeaderQName has binding name '_wsa5__ProblemHeaderQName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__wsa5__ProblemHeaderQName
#define SOAP_TYPE__wsa5__ProblemHeaderQName (37)
#endif

/* _wsa5__Action has binding name '_wsa5__Action' for type '' */
#ifndef SOAP_TYPE__wsa5__Action
#define SOAP_TYPE__wsa5__Action (34)
#endif

/* _wsa5__To has binding name '_wsa5__To' for type '' */
#ifndef SOAP_TYPE__wsa5__To
#define SOAP_TYPE__wsa5__To (33)
#endif

/* _wsa5__MessageID has binding name '_wsa5__MessageID' for type '' */
#ifndef SOAP_TYPE__wsa5__MessageID
#define SOAP_TYPE__wsa5__MessageID (28)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (24)
#endif

/* char ** has binding name 'PointerTo_XML' for type '' */
#ifndef SOAP_TYPE_PointerTo_XML
#define SOAP_TYPE_PointerTo_XML (23)
#endif

/* struct wsa5__MetadataType * has binding name 'PointerTowsa5__MetadataType' for type 'wsa5:MetadataType' */
#ifndef SOAP_TYPE_PointerTowsa5__MetadataType
#define SOAP_TYPE_PointerTowsa5__MetadataType (22)
#endif

/* struct wsa5__ReferenceParametersType * has binding name 'PointerTowsa5__ReferenceParametersType' for type 'wsa5:ReferenceParametersType' */
#ifndef SOAP_TYPE_PointerTowsa5__ReferenceParametersType
#define SOAP_TYPE_PointerTowsa5__ReferenceParametersType (21)
#endif

/* wsa5__FaultCodesOpenEnumType has binding name 'wsa5__FaultCodesOpenEnumType' for type 'wsa5:FaultCodesOpenEnumType' */
#ifndef SOAP_TYPE_wsa5__FaultCodesOpenEnumType
#define SOAP_TYPE_wsa5__FaultCodesOpenEnumType (18)
#endif

/* wsa5__RelationshipTypeOpenEnum has binding name 'wsa5__RelationshipTypeOpenEnum' for type 'wsa5:RelationshipTypeOpenEnum' */
#ifndef SOAP_TYPE_wsa5__RelationshipTypeOpenEnum
#define SOAP_TYPE_wsa5__RelationshipTypeOpenEnum (17)
#endif

/* unsigned char * has binding name 'PointerTounsignedByte' for type 'xsd:unsignedByte' */
#ifndef SOAP_TYPE_PointerTounsignedByte
#define SOAP_TYPE_PointerTounsignedByte (11)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<_wstop__TopicNamespaceType_Topic>  has binding name 'std__vectorTemplateOf_wstop__TopicNamespaceType_Topic' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic
#define SOAP_TYPE_std__vectorTemplateOf_wstop__TopicNamespaceType_Topic (1596)
#endif

/* std::vector<wstop__TopicType *>  has binding name 'std__vectorTemplateOfPointerTowstop__TopicType' for type 'wstop:TopicType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowstop__TopicType (1593)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__QName
#define SOAP_TYPE_std__vectorTemplateOfxsd__QName (1589)
#endif

/* std::vector<_wsrfbf__BaseFaultType_Description>  has binding name 'std__vectorTemplateOf_wsrfbf__BaseFaultType_Description' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description
#define SOAP_TYPE_std__vectorTemplateOf_wsrfbf__BaseFaultType_Description (1551)
#endif

/* std::vector<wsnt__NotificationMessageHolderType *>  has binding name 'std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType' for type 'wsnt:NotificationMessageHolderType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__NotificationMessageHolderType (1542)
#endif

/* std::vector<wsnt__TopicExpressionType *>  has binding name 'std__vectorTemplateOfPointerTowsnt__TopicExpressionType' for type 'wsnt:TopicExpressionType' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType
#define SOAP_TYPE_std__vectorTemplateOfPointerTowsnt__TopicExpressionType (1539)
#endif

/* std::vector<_tt__ColorDescriptor_ColorCluster>  has binding name 'std__vectorTemplateOf_tt__ColorDescriptor_ColorCluster' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__ColorDescriptor_ColorCluster
#define SOAP_TYPE_std__vectorTemplateOf_tt__ColorDescriptor_ColorCluster (1526)
#endif

/* std::vector<tt__FileProgress *>  has binding name 'std__vectorTemplateOfPointerTott__FileProgress' for type 'tt:FileProgress' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__FileProgress
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__FileProgress (1519)
#endif

/* std::vector<enum tt__OSDType>  has binding name 'std__vectorTemplateOftt__OSDType' for type 'tt:OSDType' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__OSDType
#define SOAP_TYPE_std__vectorTemplateOftt__OSDType (1514)
#endif

/* std::vector<tt__ColorspaceRange *>  has binding name 'std__vectorTemplateOfPointerTott__ColorspaceRange' for type 'tt:ColorspaceRange' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__ColorspaceRange
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__ColorspaceRange (1506)
#endif

/* std::vector<tt__Color *>  has binding name 'std__vectorTemplateOfPointerTott__Color' for type 'tt:Color' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Color
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Color (1503)
#endif

/* std::vector<tt__ActiveConnection *>  has binding name 'std__vectorTemplateOfPointerTott__ActiveConnection' for type 'tt:ActiveConnection' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__ActiveConnection
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__ActiveConnection (1495)
#endif

/* std::vector<tt__AudioClassCandidate *>  has binding name 'std__vectorTemplateOfPointerTott__AudioClassCandidate' for type 'tt:AudioClassCandidate' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioClassCandidate
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioClassCandidate (1492)
#endif

/* std::vector<tt__EngineConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__EngineConfiguration' for type 'tt:EngineConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__EngineConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__EngineConfiguration (1481)
#endif

/* std::vector<tt__RecordingJobStateTrack *>  has binding name 'std__vectorTemplateOfPointerTott__RecordingJobStateTrack' for type 'tt:RecordingJobStateTrack' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobStateTrack
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobStateTrack (1478)
#endif

/* std::vector<tt__RecordingJobStateSource *>  has binding name 'std__vectorTemplateOfPointerTott__RecordingJobStateSource' for type 'tt:RecordingJobStateSource' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobStateSource
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobStateSource (1474)
#endif

/* std::vector<tt__RecordingJobTrack *>  has binding name 'std__vectorTemplateOfPointerTott__RecordingJobTrack' for type 'tt:RecordingJobTrack' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobTrack
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobTrack (1471)
#endif

/* std::vector<_tt__RecordingEventFilter_Filter>  has binding name 'std__vectorTemplateOf_tt__RecordingEventFilter_Filter' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__RecordingEventFilter_Filter
#define SOAP_TYPE_std__vectorTemplateOf_tt__RecordingEventFilter_Filter (1469)
#endif

/* std::vector<tt__RecordingJobSource *>  has binding name 'std__vectorTemplateOfPointerTott__RecordingJobSource' for type 'tt:RecordingJobSource' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobSource
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingJobSource (1465)
#endif

/* std::vector<tt__GetTracksResponseItem *>  has binding name 'std__vectorTemplateOfPointerTott__GetTracksResponseItem' for type 'tt:GetTracksResponseItem' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__GetTracksResponseItem
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__GetTracksResponseItem (1462)
#endif

/* std::vector<tt__TrackAttributes *>  has binding name 'std__vectorTemplateOfPointerTott__TrackAttributes' for type 'tt:TrackAttributes' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__TrackAttributes
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__TrackAttributes (1454)
#endif

/* std::vector<tt__TrackInformation *>  has binding name 'std__vectorTemplateOfPointerTott__TrackInformation' for type 'tt:TrackInformation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__TrackInformation
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__TrackInformation (1452)
#endif

/* std::vector<tt__FindMetadataResult *>  has binding name 'std__vectorTemplateOfPointerTott__FindMetadataResult' for type 'tt:FindMetadataResult' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__FindMetadataResult
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__FindMetadataResult (1449)
#endif

/* std::vector<tt__FindPTZPositionResult *>  has binding name 'std__vectorTemplateOfPointerTott__FindPTZPositionResult' for type 'tt:FindPTZPositionResult' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__FindPTZPositionResult
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__FindPTZPositionResult (1447)
#endif

/* std::vector<tt__FindEventResult *>  has binding name 'std__vectorTemplateOfPointerTott__FindEventResult' for type 'tt:FindEventResult' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__FindEventResult
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__FindEventResult (1444)
#endif

/* std::vector<tt__RecordingInformation *>  has binding name 'std__vectorTemplateOfPointerTott__RecordingInformation' for type 'tt:RecordingInformation' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingInformation
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__RecordingInformation (1442)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftt__RecordingReference' for type 'tt:RecordingReference' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__RecordingReference
#define SOAP_TYPE_std__vectorTemplateOftt__RecordingReference (1438)
#endif

/* std::vector<tt__SourceReference *>  has binding name 'std__vectorTemplateOfPointerTott__SourceReference' for type 'tt:SourceReference' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__SourceReference
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__SourceReference (1437)
#endif

/* std::vector<tt__Rectangle *>  has binding name 'std__vectorTemplateOfPointerTott__Rectangle' for type 'tt:Rectangle' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Rectangle
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Rectangle (1432)
#endif

/* std::vector<tt__PaneLayoutOptions *>  has binding name 'std__vectorTemplateOfPointerTott__PaneLayoutOptions' for type 'tt:PaneLayoutOptions' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayoutOptions
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayoutOptions (1430)
#endif

/* std::vector<tt__PaneLayout *>  has binding name 'std__vectorTemplateOfPointerTott__PaneLayout' for type 'tt:PaneLayout' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayout
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PaneLayout (1424)
#endif

/* std::vector<tt__Polyline *>  has binding name 'std__vectorTemplateOfPointerTott__Polyline' for type 'tt:Polyline' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Polyline
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Polyline (1418)
#endif

/* std::vector<tt__ConfigDescription *>  has binding name 'std__vectorTemplateOfPointerTott__ConfigDescription' for type 'tt:ConfigDescription' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__ConfigDescription
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__ConfigDescription (1414)
#endif

/* std::vector<_tt__ConfigDescription_Messages>  has binding name 'std__vectorTemplateOf_tt__ConfigDescription_Messages' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__ConfigDescription_Messages
#define SOAP_TYPE_std__vectorTemplateOf_tt__ConfigDescription_Messages (1410)
#endif

/* std::vector<tt__Config *>  has binding name 'std__vectorTemplateOfPointerTott__Config' for type 'tt:Config' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Config
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Config (1405)
#endif

/* std::vector<tt__Vector *>  has binding name 'std__vectorTemplateOfPointerTott__Vector' for type 'tt:Vector' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Vector (1403)
#endif

/* std::vector<_tt__ItemListDescription_ElementItemDescription>  has binding name 'std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription
#define SOAP_TYPE_std__vectorTemplateOf_tt__ItemListDescription_ElementItemDescription (1400)
#endif

/* std::vector<_tt__ItemListDescription_SimpleItemDescription>  has binding name 'std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE_std__vectorTemplateOf_tt__ItemListDescription_SimpleItemDescription (1398)
#endif

/* std::vector<_tt__ItemList_ElementItem>  has binding name 'std__vectorTemplateOf_tt__ItemList_ElementItem' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem
#define SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_ElementItem (1393)
#endif

/* std::vector<_tt__ItemList_SimpleItem>  has binding name 'std__vectorTemplateOf_tt__ItemList_SimpleItem' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem
#define SOAP_TYPE_std__vectorTemplateOf_tt__ItemList_SimpleItem (1391)
#endif

/* std::vector<enum tt__BacklightCompensationMode>  has binding name 'std__vectorTemplateOftt__BacklightCompensationMode' for type 'tt:BacklightCompensationMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode
#define SOAP_TYPE_std__vectorTemplateOftt__BacklightCompensationMode (1384)
#endif

/* std::vector<enum tt__ImageStabilizationMode>  has binding name 'std__vectorTemplateOftt__ImageStabilizationMode' for type 'tt:ImageStabilizationMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode
#define SOAP_TYPE_std__vectorTemplateOftt__ImageStabilizationMode (1381)
#endif

/* std::vector<tt__IrCutFilterAutoAdjustment *>  has binding name 'std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment' for type 'tt:IrCutFilterAutoAdjustment' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__IrCutFilterAutoAdjustment (1356)
#endif

/* std::vector<enum tt__WhiteBalanceMode>  has binding name 'std__vectorTemplateOftt__WhiteBalanceMode' for type 'tt:WhiteBalanceMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode
#define SOAP_TYPE_std__vectorTemplateOftt__WhiteBalanceMode (1337)
#endif

/* std::vector<enum tt__ExposurePriority>  has binding name 'std__vectorTemplateOftt__ExposurePriority' for type 'tt:ExposurePriority' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority
#define SOAP_TYPE_std__vectorTemplateOftt__ExposurePriority (1336)
#endif

/* std::vector<enum tt__ExposureMode>  has binding name 'std__vectorTemplateOftt__ExposureMode' for type 'tt:ExposureMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ExposureMode
#define SOAP_TYPE_std__vectorTemplateOftt__ExposureMode (1335)
#endif

/* std::vector<enum tt__AutoFocusMode>  has binding name 'std__vectorTemplateOftt__AutoFocusMode' for type 'tt:AutoFocusMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode
#define SOAP_TYPE_std__vectorTemplateOftt__AutoFocusMode (1334)
#endif

/* std::vector<enum tt__WideDynamicMode>  has binding name 'std__vectorTemplateOftt__WideDynamicMode' for type 'tt:WideDynamicMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode
#define SOAP_TYPE_std__vectorTemplateOftt__WideDynamicMode (1333)
#endif

/* std::vector<enum tt__IrCutFilterMode>  has binding name 'std__vectorTemplateOftt__IrCutFilterMode' for type 'tt:IrCutFilterMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode
#define SOAP_TYPE_std__vectorTemplateOftt__IrCutFilterMode (1330)
#endif

/* std::vector<enum tt__PTZPresetTourDirection>  has binding name 'std__vectorTemplateOftt__PTZPresetTourDirection' for type 'tt:PTZPresetTourDirection' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection
#define SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection (1316)
#endif

/* std::vector<tt__PTZPresetTourSpot *>  has binding name 'std__vectorTemplateOfPointerTott__PTZPresetTourSpot' for type 'tt:PTZPresetTourSpot' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot (1302)
#endif

/* std::vector<tt__Space1DDescription *>  has binding name 'std__vectorTemplateOfPointerTott__Space1DDescription' for type 'tt:Space1DDescription' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription (1293)
#endif

/* std::vector<tt__Space2DDescription *>  has binding name 'std__vectorTemplateOfPointerTott__Space2DDescription' for type 'tt:Space2DDescription' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription (1292)
#endif

/* std::vector<enum tt__ReverseMode>  has binding name 'std__vectorTemplateOftt__ReverseMode' for type 'tt:ReverseMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ReverseMode
#define SOAP_TYPE_std__vectorTemplateOftt__ReverseMode (1288)
#endif

/* std::vector<enum tt__EFlipMode>  has binding name 'std__vectorTemplateOftt__EFlipMode' for type 'tt:EFlipMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__EFlipMode
#define SOAP_TYPE_std__vectorTemplateOftt__EFlipMode (1286)
#endif

/* std::vector<enum tt__PTZPresetTourOperation>  has binding name 'std__vectorTemplateOftt__PTZPresetTourOperation' for type 'tt:PTZPresetTourOperation' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation
#define SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation (1272)
#endif

/* std::vector<tt__SystemLogUri *>  has binding name 'std__vectorTemplateOfPointerTott__SystemLogUri' for type 'tt:SystemLogUri' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__SystemLogUri (1257)
#endif

/* std::vector<tt__OnvifVersion *>  has binding name 'std__vectorTemplateOfPointerTott__OnvifVersion' for type 'tt:OnvifVersion' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__OnvifVersion (1252)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftt__AuxiliaryData' for type 'tt:AuxiliaryData' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData
#define SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData (1242)
#endif

/* std::vector<enum tt__Dot11Cipher>  has binding name 'std__vectorTemplateOftt__Dot11Cipher' for type 'tt:Dot11Cipher' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher
#define SOAP_TYPE_std__vectorTemplateOftt__Dot11Cipher (1219)
#endif

/* std::vector<enum tt__Dot11AuthAndMangementSuite>  has binding name 'std__vectorTemplateOftt__Dot11AuthAndMangementSuite' for type 'tt:Dot11AuthAndMangementSuite' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite
#define SOAP_TYPE_std__vectorTemplateOftt__Dot11AuthAndMangementSuite (1218)
#endif

/* std::vector<tt__NetworkZeroConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__NetworkZeroConfiguration' for type 'tt:NetworkZeroConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkZeroConfiguration (1206)
#endif

/* std::vector<tt__PrefixedIPv6Address *>  has binding name 'std__vectorTemplateOfPointerTott__PrefixedIPv6Address' for type 'tt:PrefixedIPv6Address' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv6Address (1190)
#endif

/* std::vector<tt__PrefixedIPv4Address *>  has binding name 'std__vectorTemplateOfPointerTott__PrefixedIPv4Address' for type 'tt:PrefixedIPv4Address' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__PrefixedIPv4Address (1188)
#endif

/* std::vector<tt__Dot11Configuration *>  has binding name 'std__vectorTemplateOfPointerTott__Dot11Configuration' for type 'tt:Dot11Configuration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11Configuration (1182)
#endif

/* std::vector<tt__Dot3Configuration *>  has binding name 'std__vectorTemplateOfPointerTott__Dot3Configuration' for type 'tt:Dot3Configuration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot3Configuration (1180)
#endif

/* std::vector<tt__AudioEncoderConfigurationOption *>  has binding name 'std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption' for type 'tt:AudioEncoderConfigurationOption' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__AudioEncoderConfigurationOption (1162)
#endif

/* std::vector<tt__VideoResolution2 *>  has binding name 'std__vectorTemplateOfPointerTott__VideoResolution2' for type 'tt:VideoResolution2' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution2
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution2 (1158)
#endif

/* std::vector<enum tt__H264Profile>  has binding name 'std__vectorTemplateOftt__H264Profile' for type 'tt:H264Profile' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__H264Profile
#define SOAP_TYPE_std__vectorTemplateOftt__H264Profile (1155)
#endif

/* std::vector<enum tt__Mpeg4Profile>  has binding name 'std__vectorTemplateOftt__Mpeg4Profile' for type 'tt:Mpeg4Profile' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile
#define SOAP_TYPE_std__vectorTemplateOftt__Mpeg4Profile (1154)
#endif

/* std::vector<tt__VideoResolution *>  has binding name 'std__vectorTemplateOfPointerTott__VideoResolution' for type 'tt:VideoResolution' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__VideoResolution (1153)
#endif

/* std::vector<enum tt__RotateMode>  has binding name 'std__vectorTemplateOftt__RotateMode' for type 'tt:RotateMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__RotateMode
#define SOAP_TYPE_std__vectorTemplateOftt__RotateMode (1141)
#endif

/* std::vector<enum tt__SceneOrientationMode>  has binding name 'std__vectorTemplateOftt__SceneOrientationMode' for type 'tt:SceneOrientationMode' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__SceneOrientationMode
#define SOAP_TYPE_std__vectorTemplateOftt__SceneOrientationMode (1140)
#endif

/* std::vector<tt__LensProjection *>  has binding name 'std__vectorTemplateOfPointerTott__LensProjection' for type 'tt:LensProjection' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__LensProjection (1135)
#endif

/* std::vector<tt__LensDescription *>  has binding name 'std__vectorTemplateOfPointerTott__LensDescription' for type 'tt:LensDescription' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__LensDescription (1129)
#endif

/* std::vector<float>  has binding name 'std__vectorTemplateOffloat' for type 'xsd:float' */
#ifndef SOAP_TYPE_std__vectorTemplateOffloat
#define SOAP_TYPE_std__vectorTemplateOffloat (1112)
#endif

/* std::vector<int>  has binding name 'std__vectorTemplateOfint' for type 'xsd:int' */
#ifndef SOAP_TYPE_std__vectorTemplateOfint
#define SOAP_TYPE_std__vectorTemplateOfint (1111)
#endif

/* std::vector<tt__LocationEntity *>  has binding name 'std__vectorTemplateOfPointerTott__LocationEntity' for type 'tt:LocationEntity' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__LocationEntity (1110)
#endif

/* std::vector<tds__StorageConfiguration *>  has binding name 'std__vectorTemplateOfPointerTotds__StorageConfiguration' for type 'tds:StorageConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTotds__StorageConfiguration (1107)
#endif

/* std::vector<tt__Dot11AvailableNetworks *>  has binding name 'std__vectorTemplateOfPointerTott__Dot11AvailableNetworks' for type 'tt:Dot11AvailableNetworks' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot11AvailableNetworks (1102)
#endif

/* std::vector<tt__RelayOutput *>  has binding name 'std__vectorTemplateOfPointerTott__RelayOutput' for type 'tt:RelayOutput' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__RelayOutput (1096)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftt__ReferenceToken' for type 'tt:ReferenceToken' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken
#define SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken (1094)
#endif

/* std::vector<tt__Dot1XConfiguration *>  has binding name 'std__vectorTemplateOfPointerTott__Dot1XConfiguration' for type 'tt:Dot1XConfiguration' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Dot1XConfiguration (1093)
#endif

/* std::vector<tt__CertificateWithPrivateKey *>  has binding name 'std__vectorTemplateOfPointerTott__CertificateWithPrivateKey' for type 'tt:CertificateWithPrivateKey' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateWithPrivateKey (1090)
#endif

/* std::vector<tt__CertificateStatus *>  has binding name 'std__vectorTemplateOfPointerTott__CertificateStatus' for type 'tt:CertificateStatus' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__CertificateStatus (1088)
#endif

/* std::vector<tt__Certificate *>  has binding name 'std__vectorTemplateOfPointerTott__Certificate' for type 'tt:Certificate' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Certificate (1086)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftt__IPv6Address' for type 'tt:IPv6Address' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__IPv6Address
#define SOAP_TYPE_std__vectorTemplateOftt__IPv6Address (1079)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOftt__IPv4Address' for type 'tt:IPv4Address' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__IPv4Address
#define SOAP_TYPE_std__vectorTemplateOftt__IPv4Address (1078)
#endif

/* std::vector<tt__NetworkProtocol *>  has binding name 'std__vectorTemplateOfPointerTott__NetworkProtocol' for type 'tt:NetworkProtocol' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkProtocol (1076)
#endif

/* std::vector<tt__NetworkInterface *>  has binding name 'std__vectorTemplateOfPointerTott__NetworkInterface' for type 'tt:NetworkInterface' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkInterface (1073)
#endif

/* std::vector<tt__IPAddress *>  has binding name 'std__vectorTemplateOfPointerTott__IPAddress' for type 'tt:IPAddress' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__IPAddress (1067)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__token' for type 'xsd:token' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__token
#define SOAP_TYPE_std__vectorTemplateOfxsd__token (1065)
#endif

/* std::vector<enum tt__CapabilityCategory>  has binding name 'std__vectorTemplateOftt__CapabilityCategory' for type 'tt:CapabilityCategory' */
#ifndef SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory
#define SOAP_TYPE_std__vectorTemplateOftt__CapabilityCategory (1061)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (1059)
#endif

/* std::vector<tt__User *>  has binding name 'std__vectorTemplateOfPointerTott__User' for type 'tt:User' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__User
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__User (1058)
#endif

/* std::vector<tt__NetworkHost *>  has binding name 'std__vectorTemplateOfPointerTott__NetworkHost' for type 'tt:NetworkHost' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__NetworkHost (1055)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfxsd__anyURI' for type 'xsd:anyURI' */
#ifndef SOAP_TYPE_std__vectorTemplateOfxsd__anyURI
#define SOAP_TYPE_std__vectorTemplateOfxsd__anyURI (1053)
#endif

/* std::vector<tt__Scope *>  has binding name 'std__vectorTemplateOfPointerTott__Scope' for type 'tt:Scope' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__Scope (1052)
#endif

/* std::vector<tt__BackupFile *>  has binding name 'std__vectorTemplateOfPointerTott__BackupFile' for type 'tt:BackupFile' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile
#define SOAP_TYPE_std__vectorTemplateOfPointerTott__BackupFile (1048)
#endif

/* std::vector<tds__Service *>  has binding name 'std__vectorTemplateOfPointerTotds__Service' for type 'tds:Service' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service
#define SOAP_TYPE_std__vectorTemplateOfPointerTotds__Service (1041)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_XML
#define SOAP_TYPE_std__vectorTemplateOf_XML (1024)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
